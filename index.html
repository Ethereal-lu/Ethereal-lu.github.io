<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.140.1"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>lu</title>
<meta name=description content><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity="sha256-1yREUm1+y9sAFUOKf6iQVKZYv3WdBULi5d+BzpS0k+4=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://ethereal-lu.github.io/index.xml><link rel=alternate type=application/json href=https://ethereal-lu.github.io/index.json><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/"><meta property="og:site_name" content="lu"><meta property="og:title" content="lu"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="lu"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"lu","url":"https://ethereal-lu.github.io/","description":"","logo":"https://ethereal-lu.github.io/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="lu (Alt + H)">lu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class="first-entry home-info"><header class=entry-header><h1>Hi there 👋</h1></header><div class=entry-content>Welcome to my blog</div><footer class=entry-footer><div class=social-icons></div></footer></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>常见面试问题</h2></header><div class=entry-content><p>1、为什么应聘我们单位？ 考核维度：是否了解本银行，是否真正想要进入银行工作
回答方向：本人专业对口情况、对该银行的了解、与其他银行相比该银行有哪些优势、选择该银行对本人今后发展的正面影响，表达想要进入该银行的强烈意愿
2、你对银行未来发展趋势有什么看法？ 考核维度：了解应聘者对银行发展的认识
回答方向：银行发展现状与未来如何做 –> 机遇与挑战并存
示例回答：近年来，随着金融市场竞争加剧，以及新冠肺炎疫情常态化防控形势，银行的发展挑战越来越大，而且很多政策都是主张向实体经济让利，所以未来银行的发展趋势是危与机并存的，但是挑战越大，机遇也就越大，疫情加速了银行业的数字化转型，所以未来银行在发展方面可以借力大数据、云计算、人工智能等新技术不断提升服务效率、优化客户体验，同时全面整合线上线下资源，降低各类运营成本，扩大盈利空间。
3、如何适应轮岗？ 考核维度：了解应聘者是否吃苦耐劳，是否能长期在银行发展
回答方向：柜面岗位是为自己将来的发展打基础，在柜员工作中夯实自己，提升服务意识，不能好高骛远，要脚踏实地地服从安排
4、如何看待小微企业融资难的问题？对银行普惠工作有何看法？（无领导面试题） 考核维度：了解应聘者是否关注市场的发展现状，是否对政策有基本的了解
回答方向：阐述小微企业融资难的主观因素和客观因素，谈谈政策让利实体经济的原因，银行普惠工作的重要意义
示例回答：小微企业融资难是有主观因素和客观因素的，客观上小微企业没有大型企业良好的组织架构和制度体系，人员素质水平参差不齐，信息不对称等，常常面临需求不足的经营困境，而且自疫情以来，更让原本就经营困难的小微企业雪上加霜，现金流短缺成为主要经营困境。主观上，可能存在小微企业管理者管理不善的问题，而且融资渠道比较单一，小微企业常因缺乏担保而得不到银行贷款的支持，这些都是导致小微企业融资难的问题。作为经济的毛细血管，为保市场主体进而保就业保民生，金融机构也在不断加大对中小微企业的支持力度，比如推进普惠型的小微企业贷款，给予利率优惠等，力所能及地疏通毛细血管。所以银行的普惠工作有重要意义，不仅是社会责任的体现，也可以树立银行正面形象，得到各界支持。
5、在完成某项工作时，你认为领导的方式不是最好，你有更好的方法，你怎么办？ 考核维度：了解应聘者的执行力以及沟通能力
回答方向：有原则有底线，尊重领导。如果领导的方式符合原则，则私下委婉提出自己的想法，如果领导同意最好，不同意则按照领导要求进行。如果领导要求不符合原则，则坚决提出自己的质疑，并与领导分析对公司的利与弊。总之必须为公司大局着想。</p></div><footer class=entry-footer><span title='2022-11-04 21:12:41 +0000 UTC'>2022-11-04</span>&nbsp;·&nbsp;19 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 常见面试问题" href=https://ethereal-lu.github.io/posts/%E9%93%B6%E8%A1%8C/%E9%9D%A2%E8%AF%95/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>EPI</h2></header><div class=entry-content><p>1、入门 1、时间型问题 题型特征：题干只有时间，没有效率、效率比
解题步骤：
设工作总量 W 为题干所给时间的最小公倍数 用公倍数 W 和所给时间 t 算出效率 P 用 W 的所需的 P 算出结果 2、平均速度 定义： 平均速度 = 总路程 / 总时间
等距离平均公式：v = 2 * v1 * v2 / (v1 + v2)
3、时针分针重合规律 一天中第一次重合一定是 0 点 0 分 每个小时内最多重合一次 公式：时针分针在 n 时重合的时刻为：n 时 60/11 * n 分(0 &lt;= n &lt;= 11) 将 11 代入公式可知，11 时重合时刻为 0 时 0 分，故一天 24 小时内，时针分针重合次数为 22 次。 当题目为 24 小时制时将其化为 12 小时，即让求 18 时的重合时刻，将 6 带入公式，即 18 时 60/11 * 6 分 除了 0 和 11，其余数代入公式都不可能整除，故正确选项的分母一定是 11，可直接排除分母为其他数字的选项 4、三元容斥问题 题型特征：喜欢 A 的有几人，喜欢 B 的有几人，喜欢 C 的有几人，都喜欢的有几人。。。。
...</p></div><footer class=entry-footer><span title='2022-10-02 00:00:00 +0000 UTC'>2022-10-02</span>&nbsp;·&nbsp;399 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to EPI" href=https://ethereal-lu.github.io/posts/%E9%93%B6%E8%A1%8C/%E7%AC%94%E8%AF%95/epi/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>慢查询优化</h2></header><div class=entry-content><p>1、开启慢查询 慢查询的时间定义：可设置为超过 1 秒就是慢查询（MySql 默认是 10 秒）
mysql> show variables like 'long_query_time'; 设置方法一：全局变量设置
mysql> set global slow_query_log='ON'; mysql> set global slow_query_log_file='/usr/local/mysql/data/slow.log'; mysql> set global long_query_time=1; 设置方法二：配置文件设置
slow_query_log = ON slow_query_log_file = /usr/local/mysql/data/slow.log long_query_time = 1 2、分析慢查询日志 explain 关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句
EXPLAIN SELECT * FROM `user`; table type possible_keys key key_len ref rows Extra 表名 const、eq_reg、ref、range、index、all 可选择的索引 实际使用的索引 需要扫描的行数 3、常见的慢查询优化 没建索引或索引没起作用 模糊查询以 % 开头 未遵守最左匹配 索引列进行计算 … 优化数据库结构 分库分表：字段很多时垂直分表；数据很多时水平分表 增加中间表： 对于需要经常联合查询的表，可将需要联合的字段合成一张中间表，这样每次只需要查询中间表一张表即可 分解复杂查询： 将一个大的查询分解为多个小查询，在应用层进行逻辑处理 优化LIMIT分页：select id,title from collect limit 10000,20;这样的查询，需要查询10020条然后只返回最后20条。 为 id,title建立组合索引，用于覆盖索引查询 用主键索引过滤掉前 10000 行无效的查询 子查询select id,title from collect where id>=(select id from collect limit 10000,1) limit 10; 关联查询select id,title from collect inner join (select id from collect limit 10000,20) as midTable using(id);</p></div><footer class=entry-footer><span title='2022-09-24 23:39:41 +0000 UTC'>2022-09-24</span>&nbsp;·&nbsp;109 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 慢查询优化" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Mysql同步ElasticSearch</h2></header><div class=entry-content><p>Mysql 同步 ElasticSearch 采用 Canal 监听 binlog，然后将数据发送到 MQ 的 topic 中，ElasticSearch 作为 MQ 的消费者进行处理。
1 Canal Canal是阿里开源的一款基于Mysql数据库binlog的增量订阅和消费组件，通过它可以订阅数据库的binlog日志，然后进行一些数据消费，相对于消息队列，通过这种机制可以实现数据的有序化和一致性。
Canal 工作原理如下：
Canal模拟MySQL slave的交互协议，伪装自己为MySQL slave，向MySQL master发送dump请求 MySQL master收到dump请求，开始推送binary log给slave（也就是canal） Canal解析binary log对象（原始为byte流） 简而言之，Canal是通过模拟成为MySQL的slave，监听MySQL的binlog日志来获取数据。当把MySQL的binlog设置为row模式以后，可以获取到执行的每一个Insert/Update/Delete的脚本，以及修改前和修改后的数据，基于这个特性，Canal就能高效的获取到MySQL数据的变更。
Canal 组件如下：
canal-server：服务端，从mysql读取binlog日志获取增量日志，可以通过tcp、kafka、RocketMQ等方式与客户端通信；通过zookeeper搭建集群。 canal-adapter：客户端，根据canal-server获取的增量日志执行适配到其他诸如elasticsearch、redis、mysql等端，实现数据同步。 Canal 使用示例如下：
Mysql 开启 binlog，并设置为 row 模式，然后指定需要同步的数据库 新建一个用户供 Canal 连接 Mysql 在 Canal 服务端中配置 Mysql 的地址和用户名密码以及与客户端的通信方式 在 Canal 客户端中配置 ElasticSearch 的地址等信息以及索引库名称等信息 2 同步流程 由 Canal 订阅 binlog，得到 Canal 解析的好 Json 字符串后进行一些业务逻辑处理，比如新增一条 order 数据时需要同时获取到相关的用户信息、申请审批信息等，将这些信息封装为一个文档，使用 binlog 主键作为文档 id，与封装好的文档一起发送到 MQ 中。由消费者组消费 MQ 中的消息，并根据相应操作写入到 ES 中。注：binlog 会记录当前事务的操作类型（Insert/Update/Delete），故 ES 也做相应操作即可。
...</p></div><footer class=entry-footer><span title='2022-08-22 17:39:41 +0000 UTC'>2022-08-22</span>&nbsp;·&nbsp;140 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Mysql同步ElasticSearch" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/mysql%E5%90%8C%E6%AD%A5elasticsearch/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Dubbo</h2></header><div class=entry-content><p>1 RPC RPC 即进程A中的方法A通过网络调用进程B中的方法B，是一种进程间通信方式。
为了实现RPC远程调用，请求时在网络中传输的数据应该包括类名、方法名、参数类型列表、参数值列表，前三项可以唯一确定一个方法。除了上述4项，企业内部使用时还可以自定义需要传输的数据以便于业务开发。确定好要传什么数据后还需要确定怎么传数据，如 Tomcat + HttpClient 、 Netty 、Socket等都可以选择。
2 Dubbo 优势 分布式系统中，Dubbo 相较于 HTTP 的优势：
负载均衡 服务调用链路生成：服务间依赖关系错踪复杂，Dubbo 可以解决服务之间互相是如何调用的。 资源调度：基于访问压力实时管理集群容量，提高集群利用率。 3 Dubbo 架构 Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。
Monitor： 统计服务的调用次数和调用时间的监控中心 Container： 运行服务的容器 调用关系说明：
服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 重要知识点总结：
注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小 监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示 注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外 注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者 注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表 注册中心和监控中心都是可选的，服务消费者可以直连服务提供者 服务提供者无状态，任意一台宕掉后，不影响使用 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复 4 核心要点 Dubbo作为一个分布式服务框架，主要具有如下几个核心的要点：
服务定义：服务提供方实现服务，而服务消费方调用服务。 服务注册：随着系统扩展，提供者需要暴露的服务和消费者需要调用的服务都不断膨胀，而一个服务既可以是提供者又可以是调用者，会使服务任务繁重，且管理混乱。将服务管理抽离进行统一管理可以进行优化。Dubbo提供多种注册中心以选择，包括Redis和Zookeeper。 服务监控：无论是服务提供方，还是服务消费方，他们都需要对服务调用的实际状态进行有效的监控，从而改进服务质量。 远程通信与信息交换：支持Triple 协议和 Netty 框架 服务调用：下图展示 RPC 层的服务调用 详细调用流程如下图
服务提供者启动，开启Netty服务，创建Zookeeper客户端，向注册中心注册服务。 服务消费者启动，从Zookeeper注册中心获取服务提供者列表，与服务提供者通过Netty建立长连接。 服务消费者通过接口开始远程调用服务，ProxyFactory初始化Proxy对象，Proxy创建动态代理对象。 动态代理对象调用invoke方法，层层包装生成一个Invoker对象，该对象包含了代理对象。 Invoker通过负载均衡选择一个合适的服务提供者，再加入各种过滤器，协议层包装成一个新的DubboInvoker对象。 交换层将DubboInvoker对象包装成一个Reuqest对象，该对象序列化后通过NettyClient传输到服务提供者的NettyServer端。 到了服务提供者这边，再通过反序列化、协议解密等操作生成一个DubboExporter对象,再层层传递处理,会生成一个服务提供端的Invoker对象. 这个Invoker对象会调用本地服务，获得结果再通过层层回调返回到服务消费者，服务消费者拿到结果后，再解析获得最终结果。 5 负载均衡 Dubbo 提供了多种均衡策略，默认为 random 随机负载均衡。
...</p></div><footer class=entry-footer><span title='2022-08-17 23:42:15 +0000 UTC'>2022-08-17</span>&nbsp;·&nbsp;249 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Dubbo" href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/dubbo/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Raft算法</h2></header><div class=entry-content><p>一、 概述 分布式一致性算法Raft将一致性分解为多个子问题：Leader选举、日志同步、安全性、日志压缩、成员变更等。
Raft将系统中的角色分为领导者（Leader）、跟从者（Follower）和候选人（Candidate）：
Leader：接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志。 Follower：接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。 Candidate：Leader选举过程中的临时角色。 Raft要求系统在任意时刻最多只有一个Leader，正常工作期间只有Leader和Followers。
只有 Leader 节点能够处理客户端的一切请求（如果客户端的请求发到了 Follower，Follower 将会把请求重定向到 Leader）。Raft算法将时间分为一个个的任期（term），每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束。
二、Leader选举 Raft 使用心跳（heartbeat）触发Leader选举。Leader向所有Followers周期性发送heartbeat。如果Follower在超时时间内没有收到Leader的heartbeat（也许此时还没有选出Leader，大家都在等；也许Leader挂了；也许只是Leader与该Follower之间网络故障），就会随机睡眠一段时间后发起Leader选举。
当服务器启动时，初始化为Follower，此时可能是集群刚启动，那么所有节点全部等待leader的心跳，当某个或某些节点超时后变为Candidate发起选举；也可能是新节点加入集群，那它会直接收到leader的心跳。
不论外部环境如何，只要一个节点在超时时间内没有收到Leader的心跳，那它就会发起选举。也即选举时只有一个或几个节点会成为Candidate，并不是所有节点都成为Candidate。
Follower按如下规则投票：
每个 term 只能投一票 只能给 term 和 logindex 不低于自己的 Candidate 投票 注意：只有Candidate会给自己投票，Follower不能给自己投票，Follower按上方规则给自己收到的第一个投票请求投票。醒的最早的Candidate最有可能成为Leader。
Follower将其当前term加一然后转换为Candidate。它首先给自己投票并且给集群中的其他服务器发送 RequestVote RPC。结果有以下三种情况：
赢得了多数的选票，成功选举为Leader； 收到了Leader的消息，表示有其它服务器已经抢先当选了Leader； 没有服务器赢得多数的选票，Leader选举失败，等待选举时间超时后发起下一次选举。 选举出Leader后，Leader通过定期向所有Followers发送心跳信息维持其统治。若Follower一段时间未收到Leader的心跳则认为Leader可能已经挂了，再次发起Leader选举过程。
Raft保证选举出的Leader上一定具有最新的已提交的日志，这一点将在四、安全性中说明。
三、日志同步 Leader选出后，就开始接收客户端的请求。Leader把请求作为日志条目（Log entries）加入到它的日志中，然后并行的向其他服务器发起 AppendEntries RPC 复制日志条目。当这条日志被复制到大多数服务器上，Leader将这条日志应用到它的状态机并向客户端返回执行结果。
某些Followers可能没有成功的复制日志，Leader会无限的重试 AppendEntries RPC直到所有的Followers最终存储了所有的日志条目。
日志由有序编号（log index，索引）的日志条目组成。每个日志条目包含它被创建时的任期号（term），和用于状态机执行的命令。如果一个日志条目被复制到大多数服务器上，就被认为可以提交（commit）了。log index 与 term 无关，Leader 每生成一条日志条目都会消耗一个 log index ，log index 只会一直递增。
Raft日志同步保证如下两点：
如果不同日志中的两个条目有着相同的索引和任期号，则它们所存储的命令是相同的。 如果不同日志中的两个条目有着相同的索引和任期号，则它们之前的所有条目都是完全一样的。 第一条特性源于Leader在一个term内在给定的一个log index最多创建一条日志条目，同时该条目在日志中的位置也从来不会改变。
第二条特性源于 AppendEntries 的一个简单的一致性检查。当发送一个 AppendEntries RPC 时，Leader会把新日志条目紧接着之前的条目的log index和term都包含在里面。如果Follower没有在它的日志中找到log index和term都相同的日志，它就会拒绝新的日志条目。
...</p></div><footer class=entry-footer><span title='2022-08-11 13:42:15 +0000 UTC'>2022-08-11</span>&nbsp;·&nbsp;190 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Raft算法" href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/raft%E7%AE%97%E6%B3%95/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ElasticSearch集群</h2></header><div class=entry-content><p>1 节点自动发现 Zen Discovery是Elasticsearch内置的默认发现模块，支持多播模式和单播模式。发现模块用于发现集群中的节点 及选举主节点。多播模式已经不被大多数操作系统所支持，Elasticsearch的发现机制默认为单播模式，以防止节点无意中加入集群。
在同一台机器上运行的Elasticsearch节点会自动组成集群，当集群的节点运行在不同的机器上时，需要在每个节点的配置文件elasticsearch.yml中配置节点列表，即其他节点的IP和端口。集群建立后，每个节点都会每隔一定时间对节点列表中的所有节点发送心跳检测，心跳响应包中包含响应者所认可的master节点。
2 Bully算法 选举原则：在所有活着的节点中，选取节点ID最大或者最小的节点为主节点。
节点角色：主节点和普通节点
消息类型：
Election 消息，向节点发起选举的消息 Alive 消息，节点对 Election 消息的应答 Victory 消息，竞选成功的主节点向普通节点发送竞选成功的消息 选举过程：
集群中每个活着的节点查找比自己ID大的节点，如果不存在则向其他节点发送Victory消息，表明自己为主节点。 如果存在比自己ID大的节点，则向这些节点发送Election消息，并等待响应。 若在给定的时间内没有收到这些节点回复的消息，则自己成为主节点，并向比自己ID小的节点发送Victory消息。 节点收到比自己ID小的节点发送的Election消息，则回复Alive消息。
假设有三个节点，选举过程如下图：
3 选举流程 3.1 选举时机 当一个节点发现包括自己在内的多数派的master-eligible节点认为集群没有master时，就可以发起master选举。
3.2 选举流程 Elasticsearch节点向节点列表中的所有节点发送ping消息 对收到的响应包进行过滤，筛选出activeMasters列表和masterCandidates列表。activeMasters列表是其它节点认为的当前集群的Master节点，masterCandidates列表是当前集群有资格成为Master的节点（即配置文件中 node.master:true的节点） 如果activeMasters列表不为空，elasticsearch会优先从activeMasters列表中选举，选举的算法是Bully算法，选择ID最小的节点(理论上activeMaster中的节点一定有master资格) 如果activeMaster列表为空，那么会在masterCandidates中选举，选举同样涉及到优先级比较，首先会判断masterCandidates列表成员数目是否达到了最小数目（即超过半数）。如果达到的情况下先比较节点的集群状态版本编号，版本号越大优先级越高，然后再比较id，id越小优先级越高，这一流程的目的是让拥有最新集群状态的节点成为master 经过上述选举之后，会选举出一个临时master节点， 临时master节点会等待其它节点的投票，如果有discovery.zen.minimum_master_nodes - 1个节点投票认为当前节点是master，那么选举就成功，临时master会等待一定时间，如果超时投票数仍不够，那么就失败，需要重新选举。临时master 收到投票会给 Follwer 一个响应，表明 Follwer 已经加入自己的集群。 注意：上述的2、3、4步都是单个节点内部的操作，所选出的临时master节点是当前节点自己认为的master，即每个节点所选出的临时master可能不同，所以才需要在第5步对临时master进行投票，超过一半票数的临时master才会成为真正master。
Master节点会开启错误检测机制，它会定期扫描集群所有的成员，将失活的成员移除集群，同时将最新的集群状态发布到集群中，集群成员收到最新的集群状态后会进行相应的调整，比如重新选择主分片，进行数据复制等操作。
4 脑裂问题 ElasticSearch 保证不脑裂的基本原则还是多数派的策略，如果必须得到多数派的认可才能成为Master。3.2 的流程在绝大部份场景下没问题，但还是有 bug，因为上述流程并没有限制在选举过程中，一个Node只能投一票。比如NodeB投NodeA一票，但是NodeA迟迟不成为Master，NodeB等不及了发起了下一轮选主，这时候发现集群里多了个Node0，Node0优先级比NodeA还高，那NodeB肯定就改投Node0了。假设Node0和NodeA都处在等选票的环节，那显然这时候NodeB其实发挥了两票的作用，而且投给了不同的人。如果最后NodeA和Node0都得到超过半数的投票，就会发生脑裂。Raft算法为了解决此问题引入了 term 的概念，即使产生双主也一定在不同的 term ，当 term 小的收到 term 大的节点消息时会自动变为 Follwer。ElasticSearch 没有 term 概念所以一个集群会有双主，但也不会产生问题，因为旧的master 很快会发现自己集群的节点数不过半而降级为 candidate。
...</p></div><footer class=entry-footer><span title='2022-08-10 21:39:41 +0000 UTC'>2022-08-10</span>&nbsp;·&nbsp;102 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to ElasticSearch集群" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/elasticsearch%E9%9B%86%E7%BE%A4/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>需求实现</h2></header><div class=entry-content><p>1 对接千帆客服系统-CPO进线数据 1.1 需求 客户对异常判定结果不满意投诉至滴滴客服，但客服无法看到该订单的异常详情，需要将异常数据展示给千帆客服系统，供客服查看。
1.2 实现 第一个需求，对业务还不熟悉，查看了大量代码，以及翻看数据库中各表以及表内字段的作用，梳理表之间以及代码模块之间的关系。
现有的日志实现只有审批日志，但是我不知道，从 crius 和 zeus 代码以及wiki中查找了大量问询和支付相关代码和文档并企图找出相关日志，显然没有找到，但是这也不算无用功，起码对项目更加熟悉。
经过两天的查找，终于确定了需要展示的数据的来源并定义好了接口，接下来开始实现接口。
现有 model 中的reasonListV2函数无法满足本次接口调用的需求，故重新写了一个函数。 接口实现完成，学习了如何部署到预发布环境，如何测试接口，如何查看日志。 接口返回错误码-6，向子健请教，是postman入参不全，补全参数 接口不返回任何东西，经过一行一行的排错，找到是 php 的 substr 函数是以字节截断而不是字符 接口返回依然错误，查看错误日志，找到是日志函数 getAfterApprovalFlow的参数有问题，从其他接口得到的该参数在这个函数中少一个字段，于是继续调用其他接口补齐这个字段 返回依然错误，找到getAfterApprovalFlow函数的返回值是二维数组，之前以一维数组处理 至此，接口总算正常运行。 通过该需求的实现，熟悉了部分业务逻辑，学习了接口部署与测试以及查看日志。
2 审批详情页
3 申请详情页
4 日志获取（按申请单类型）
5 在处置入口处增加判断，仅高级版和专业版拥有清风处置能力（这里新创建了远程调用接口）</p></div><footer class=entry-footer><span title='2022-08-06 13:39:41 +0000 UTC'>2022-08-06</span>&nbsp;·&nbsp;37 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 需求实现" href=https://ethereal-lu.github.io/posts/%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/%E9%9C%80%E6%B1%82%E5%AE%9E%E7%8E%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ElasticSearch基础</h2></header><div class=entry-content><p>Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎
1 基础 9300 端口为 Elasticsearch 集群间组件的通信端口， 9200 端口为浏览器访问的 http协议 RESTful端口。
ElasticSearch8.x版本默认开启密码验证功能，可在 elasticsearch.yml末尾添加 xpack.security.enabled: false取消密码验证
1.1 倒排索引 正排索引（传统）
id content 1001 my name is zhang san 1002 my name is li si 倒排索引
keyword id name 1001, 1002 zhang 1001 1.2 数据库结构 Elasticsearch 是面向文档型数据库，一条数据在这里就是一个文档。 Elasticsearch 里存储文档数据和关系型数据库 MySQL 存储数据的概念进行一个类比
ES 里的 Index 可以看做一个库，而 Types 相当于表， Documents 则相当于表的行，Fields相当于表中的字段。这里 Types 的概念已经被逐渐弱化， Elasticsearch 6.X 中，一个 index 下已经只能包含一个type， Elasticsearch 7.X 中, Type 的概念已经被删除了。
...</p></div><footer class=entry-footer><span title='2022-07-24 17:39:41 +0000 UTC'>2022-07-24</span>&nbsp;·&nbsp;813 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to ElasticSearch基础" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/elasticsearch%E5%9F%BA%E7%A1%80/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>山西建行暑期实习面经</h2></header><div class=entry-content><p>1、工作中遇到问题时，如何将损失降到最低
2、未来在你的专业上如何发展
3、你擅长的研究领域是哪些</p></div><footer class=entry-footer><span title='2022-07-11 11:12:41 +0000 UTC'>2022-07-11</span>&nbsp;·&nbsp;3 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 山西建行暑期实习面经" href=https://ethereal-lu.github.io/posts/%E9%9D%A2%E7%BB%8F/%E5%B1%B1%E8%A5%BF%E5%BB%BA%E8%A1%8C%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://ethereal-lu.github.io/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>