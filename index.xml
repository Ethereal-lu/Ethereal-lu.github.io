<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>lu</title>
    <link>https://ethereal-lu.github.io/</link>
    <description>Recent content on lu</description>
    <generator>Hugo -- 0.140.1</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 09 Jan 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://ethereal-lu.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Hugo &#43; GithubPages 实现博客自动部署</title>
      <link>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/hugo-&#43;-githubpages-%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Thu, 09 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/hugo-&#43;-githubpages-%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</guid>
      <description>&lt;h3 id=&#34;1--安装hugo&#34;&gt;1  安装Hugo&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;下载 Hugo 最新版本并安装&lt;/li&gt;
&lt;li&gt;将 Hugo 安装目录添加到环境变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hugo version&lt;/code&gt;查看安装情况&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-安装git&#34;&gt;2 安装Git&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在安装过程中选择下方图片红框中的选项。在 windows 上安装 git 都推荐选择该选项。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;git安装指引&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/hugo-+-githubpages-%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/gitinst.jpg&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果已经安装完成，执行&lt;code&gt;git config --global core.autocrlf false&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为Windows和Linux的回车符不一样，在&lt;code&gt;git add&lt;/code&gt;时，回车符会进行转换，导致网站发布后文件的一致性检查不通过，进而致使网站的 css 文件无法加载，显示为网站无样式。&lt;/p&gt;
&lt;h3 id=&#34;3-创建网站&#34;&gt;3 创建网站&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在任意位置通过&lt;code&gt;hugo new site my-site&lt;/code&gt;创建名称为&lt;code&gt;my-site&lt;/code&gt;的博客根目录&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;my-site/
├── archetypes/      &amp;lt;-- 模板
│   └── default.md
├── assets/
├── content/         &amp;lt;-- 存放 笔记.md
├── data/
├── i18n/
├── layouts/
├── static/
├── themes/           &amp;lt;-- 主题
└── hugo.toml         &amp;lt;-- site configuration
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;进入 content 文件夹，创建 post 目录，并把所有笔记拷贝到该目录下。&lt;/p&gt;</description>
    </item>
    <item>
      <title>慢查询优化</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</link>
      <pubDate>Sat, 24 Sep 2022 23:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</guid>
      <description>&lt;h2 id=&#34;1开启慢查询&#34;&gt;1、开启慢查询&lt;/h2&gt;
&lt;p&gt;慢查询的时间定义：可设置为超过 1 秒就是慢查询（MySql 默认是 10 秒）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mysql&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;show&lt;/span&gt; variables &lt;span style=&#34;color:#66d9ef&#34;&gt;like&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;long_query_time&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;设置方法一：全局变量设置&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mysql&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt; global slow_query_log&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ON&amp;#39;&lt;/span&gt;; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mysql&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt; global slow_query_log_file&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/usr/local/mysql/data/slow.log&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mysql&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt; global long_query_time&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置方法二：配置文件设置&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-properties&#34; data-lang=&#34;properties&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;slow_query_log&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;ON&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;slow_query_log_file&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;/usr/local/mysql/data/slow.log&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;long_query_time&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2分析慢查询日志&#34;&gt;2、分析慢查询日志&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;explain&lt;/code&gt; 关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;EXPLAIN&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;user&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;table&lt;/th&gt;
          &lt;th&gt;type&lt;/th&gt;
          &lt;th&gt;possible_keys&lt;/th&gt;
          &lt;th&gt;key&lt;/th&gt;
          &lt;th&gt;key_len&lt;/th&gt;
          &lt;th&gt;ref&lt;/th&gt;
          &lt;th&gt;rows&lt;/th&gt;
          &lt;th&gt;Extra&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;表名&lt;/td&gt;
          &lt;td&gt;const、eq_reg、ref、range、index、all&lt;/td&gt;
          &lt;td&gt;可选择的索引&lt;/td&gt;
          &lt;td&gt;实际使用的索引&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;需要扫描的行数&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;3常见的慢查询优化&#34;&gt;3、常见的慢查询优化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没建索引或索引没起作用
&lt;ul&gt;
&lt;li&gt;模糊查询以 % 开头&lt;/li&gt;
&lt;li&gt;未遵守最左匹配&lt;/li&gt;
&lt;li&gt;索引列进行计算&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优化数据库结构
&lt;ul&gt;
&lt;li&gt;分库分表：字段很多时垂直分表；数据很多时水平分表&lt;/li&gt;
&lt;li&gt;增加中间表： 对于需要经常联合查询的表，可将需要联合的字段合成一张中间表，这样每次只需要查询中间表一张表即可&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分解复杂查询： 将一个大的查询分解为多个小查询，在应用层进行逻辑处理&lt;/li&gt;
&lt;li&gt;优化LIMIT分页：&lt;code&gt;select id,title from collect limit 10000,20;&lt;/code&gt;这样的查询，需要查询10020条然后只返回最后20条。
&lt;ul&gt;
&lt;li&gt;为 &lt;code&gt;id,title&lt;/code&gt;建立组合索引，用于覆盖索引查询&lt;/li&gt;
&lt;li&gt;用主键索引过滤掉前 10000 行无效的查询
&lt;ul&gt;
&lt;li&gt;子查询&lt;code&gt;select id,title from collect where id&amp;gt;=(select id from collect limit 10000,1) limit 10;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;关联查询&lt;code&gt;select id,title from collect inner join (select id from collect limit 10000,20) as midTable using(id);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Mysql同步ElasticSearch</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/mysql%E5%90%8C%E6%AD%A5elasticsearch/</link>
      <pubDate>Mon, 22 Aug 2022 17:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/mysql%E5%90%8C%E6%AD%A5elasticsearch/</guid>
      <description>&lt;p&gt;Mysql 同步 ElasticSearch 采用 Canal 监听 binlog，然后将数据发送到 MQ 的 topic 中，ElasticSearch 作为 MQ 的消费者进行处理。&lt;/p&gt;
&lt;h2 id=&#34;1-canal&#34;&gt;1 Canal&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Canal&lt;/code&gt;是阿里开源的一款基于Mysql数据库binlog的增量订阅和消费组件，通过它可以订阅数据库的binlog日志，然后进行一些数据消费，相对于消息队列，通过这种机制可以实现数据的有序化和一致性。&lt;/p&gt;
&lt;p&gt;Canal 工作原理如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Canal模拟MySQL slave的交互协议，伪装自己为MySQL slave，向MySQL master发送dump请求&lt;/li&gt;
&lt;li&gt;MySQL master收到dump请求，开始推送binary log给slave（也就是canal）&lt;/li&gt;
&lt;li&gt;Canal解析binary log对象（原始为byte流）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简而言之，Canal是通过模拟成为MySQL的slave，监听MySQL的binlog日志来获取数据。当把MySQL的binlog设置为row模式以后，可以获取到执行的每一个Insert/Update/Delete的脚本，以及修改前和修改后的数据，基于这个特性，Canal就能高效的获取到MySQL数据的变更。&lt;/p&gt;
&lt;p&gt;Canal 组件如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;canal-server：服务端，从mysql读取binlog日志获取增量日志，可以通过tcp、kafka、RocketMQ等方式与客户端通信；通过zookeeper搭建集群。&lt;/li&gt;
&lt;li&gt;canal-adapter：客户端，根据canal-server获取的增量日志执行适配到其他诸如elasticsearch、redis、mysql等端，实现数据同步。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Canal 使用示例如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Mysql 开启 binlog，并设置为 row 模式，然后指定需要同步的数据库&lt;/li&gt;
&lt;li&gt;新建一个用户供 Canal 连接 Mysql&lt;/li&gt;
&lt;li&gt;在 Canal 服务端中配置 Mysql 的地址和用户名密码以及与客户端的通信方式&lt;/li&gt;
&lt;li&gt;在 Canal 客户端中配置 ElasticSearch 的地址等信息以及索引库名称等信息&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-同步流程&#34;&gt;2 同步流程&lt;/h2&gt;
&lt;p&gt;由 Canal 订阅 binlog，得到 Canal 解析的好 Json 字符串后进行一些业务逻辑处理，比如新增一条 order 数据时需要同时获取到相关的用户信息、申请审批信息等，将这些信息封装为一个文档，使用 binlog 主键作为文档 id，与封装好的文档一起发送到 MQ 中。由消费者组消费 MQ 中的消息，并根据相应操作写入到 ES 中。注：binlog 会记录当前事务的操作类型（Insert/Update/Delete），故 ES 也做相应操作即可。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Dubbo</title>
      <link>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/dubbo/</link>
      <pubDate>Wed, 17 Aug 2022 23:42:15 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/dubbo/</guid>
      <description>&lt;h2 id=&#34;1-rpc&#34;&gt;1 RPC&lt;/h2&gt;
&lt;p&gt;RPC 即进程A中的方法A通过网络调用进程B中的方法B，是一种进程间通信方式。&lt;/p&gt;
&lt;p&gt;为了实现RPC远程调用，请求时在网络中传输的数据应该包括&lt;code&gt;类名&lt;/code&gt;、&lt;code&gt;方法名&lt;/code&gt;、&lt;code&gt;参数类型列表&lt;/code&gt;、&lt;code&gt;参数值列表&lt;/code&gt;，前三项可以唯一确定一个方法。除了上述4项，企业内部使用时还可以自定义需要传输的数据以便于业务开发。确定好要传什么数据后还需要确定怎么传数据，如 &lt;code&gt;Tomcat + HttpClient&lt;/code&gt; 、 &lt;code&gt;Netty&lt;/code&gt; 、&lt;code&gt;Socket&lt;/code&gt;等都可以选择。&lt;/p&gt;
&lt;h2 id=&#34;2-dubbo-优势&#34;&gt;2 Dubbo 优势&lt;/h2&gt;
&lt;p&gt;分布式系统中，Dubbo 相较于 HTTP 的优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;服务调用链路生成：服务间依赖关系错踪复杂，Dubbo 可以解决服务之间互相是如何调用的。&lt;/li&gt;
&lt;li&gt;资源调度：基于访问压力实时管理集群容量，提高集群利用率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-dubbo-架构&#34;&gt;3 Dubbo 架构&lt;/h2&gt;
&lt;p&gt;Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;Dubbo架构&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/dubbo/Dubbo%E6%9E%B6%E6%9E%84.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Monitor： 统计服务的调用次数和调用时间的监控中心&lt;/li&gt;
&lt;li&gt;Container： 运行服务的容器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;调用关系说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务容器负责启动，加载，运行服务提供者。&lt;/li&gt;
&lt;li&gt;服务提供者在启动时，向注册中心注册自己提供的服务。&lt;/li&gt;
&lt;li&gt;服务消费者在启动时，向注册中心订阅自己所需的服务。&lt;/li&gt;
&lt;li&gt;注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。&lt;/li&gt;
&lt;li&gt;服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。&lt;/li&gt;
&lt;li&gt;服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;重要知识点总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小&lt;/li&gt;
&lt;li&gt;监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示&lt;/li&gt;
&lt;li&gt;注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外&lt;/li&gt;
&lt;li&gt;注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者&lt;/li&gt;
&lt;li&gt;注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表&lt;/li&gt;
&lt;li&gt;注册中心和监控中心都是可选的，服务消费者可以直连服务提供者&lt;/li&gt;
&lt;li&gt;服务提供者无状态，任意一台宕掉后，不影响使用&lt;/li&gt;
&lt;li&gt;服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-核心要点&#34;&gt;4 核心要点&lt;/h2&gt;
&lt;p&gt;Dubbo作为一个分布式服务框架，主要具有如下几个核心的要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;服务定义&lt;/strong&gt;：服务提供方实现服务，而服务消费方调用服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务注册&lt;/strong&gt;：随着系统扩展，提供者需要暴露的服务和消费者需要调用的服务都不断膨胀，而一个服务既可以是提供者又可以是调用者，会使服务任务繁重，且管理混乱。将服务管理抽离进行统一管理可以进行优化。Dubbo提供多种注册中心以选择，包括Redis和Zookeeper。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务监控&lt;/strong&gt;：无论是服务提供方，还是服务消费方，他们都需要对服务调用的实际状态进行有效的监控，从而改进服务质量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;远程通信与信息交换&lt;/strong&gt;：支持Triple 协议和 Netty 框架&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务调用&lt;/strong&gt;：下图展示 RPC 层的服务调用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;服务调用&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/dubbo/%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;详细调用流程如下图&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;详细调用&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/dubbo/%E8%AF%A6%E7%BB%86%E8%B0%83%E7%94%A8.jpg&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务提供者启动，开启Netty服务，创建Zookeeper客户端，向注册中心注册服务。&lt;/li&gt;
&lt;li&gt;服务消费者启动，从Zookeeper注册中心获取服务提供者列表，与服务提供者通过Netty建立长连接。&lt;/li&gt;
&lt;li&gt;服务消费者通过接口开始远程调用服务，ProxyFactory初始化Proxy对象，Proxy创建动态代理对象。&lt;/li&gt;
&lt;li&gt;动态代理对象调用invoke方法，层层包装生成一个Invoker对象，该对象包含了代理对象。&lt;/li&gt;
&lt;li&gt;Invoker通过负载均衡选择一个合适的服务提供者，再加入各种过滤器，协议层包装成一个新的DubboInvoker对象。&lt;/li&gt;
&lt;li&gt;交换层将DubboInvoker对象包装成一个Reuqest对象，该对象序列化后通过NettyClient传输到服务提供者的NettyServer端。&lt;/li&gt;
&lt;li&gt;到了服务提供者这边，再通过反序列化、协议解密等操作生成一个DubboExporter对象,再层层传递处理,会生成一个服务提供端的Invoker对象.&lt;/li&gt;
&lt;li&gt;这个Invoker对象会调用本地服务，获得结果再通过层层回调返回到服务消费者，服务消费者拿到结果后，再解析获得最终结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-负载均衡&#34;&gt;5 负载均衡&lt;/h2&gt;
&lt;p&gt;Dubbo 提供了多种均衡策略，默认为 &lt;code&gt;random&lt;/code&gt; 随机负载均衡。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Raft算法</title>
      <link>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/raft%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 11 Aug 2022 13:42:15 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/raft%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h2 id=&#34;一-概述&#34;&gt;一、 概述&lt;/h2&gt;
&lt;p&gt;分布式一致性算法Raft将一致性分解为多个子问题：Leader选举、日志同步、安全性、日志压缩、成员变更等。&lt;/p&gt;
&lt;p&gt;Raft将系统中的角色分为领导者（Leader）、跟从者（Follower）和候选人（Candidate）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Leader&lt;/strong&gt;：接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Follower&lt;/strong&gt;：接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Candidate&lt;/strong&gt;：Leader选举过程中的临时角色。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Raft要求系统在任意时刻最多只有一个Leader，正常工作期间只有Leader和Followers。&lt;/p&gt;
&lt;p&gt;只有 Leader 节点能够处理客户端的一切请求（如果客户端的请求发到了 Follower，Follower 将会把请求重定向到 Leader）。Raft算法将时间分为一个个的任期（term），每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;term&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/raft%E7%AE%97%E6%B3%95/term.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;二leader选举&#34;&gt;二、Leader选举&lt;/h2&gt;
&lt;p&gt;Raft 使用心跳（heartbeat）触发Leader选举。Leader向所有Followers周期性发送heartbeat。如果Follower在超时时间内没有收到Leader的heartbeat（也许此时还没有选出Leader，大家都在等；也许Leader挂了；也许只是Leader与该Follower之间网络故障），就会随机睡眠一段时间后发起Leader选举。&lt;/p&gt;
&lt;p&gt;当服务器启动时，初始化为Follower，此时可能是集群刚启动，那么所有节点全部等待leader的心跳，当某个或某些节点超时后变为Candidate发起选举；也可能是新节点加入集群，那它会直接收到leader的心跳。&lt;/p&gt;
&lt;p&gt;不论外部环境如何，只要一个节点在超时时间内没有收到Leader的心跳，那它就会发起选举。也即选举时只有一个或几个节点会成为Candidate，并不是所有节点都成为Candidate。&lt;/p&gt;
&lt;p&gt;Follower按如下规则投票：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个 term 只能投一票&lt;/li&gt;
&lt;li&gt;只能给 term 和 logindex 不低于自己的 Candidate 投票&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：只有Candidate会给自己投票，Follower不能给自己投票，Follower按上方规则给自己收到的第一个投票请求投票。醒的最早的Candidate最有可能成为Leader。&lt;/p&gt;
&lt;p&gt;Follower将其当前term加一然后转换为Candidate。它首先给自己投票并且给集群中的其他服务器发送 RequestVote RPC。结果有以下三种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;赢得了多数的选票，成功选举为Leader；&lt;/li&gt;
&lt;li&gt;收到了Leader的消息，表示有其它服务器已经抢先当选了Leader；&lt;/li&gt;
&lt;li&gt;没有服务器赢得多数的选票，Leader选举失败，等待选举时间超时后发起下一次选举。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;选举出Leader后，Leader通过定期向所有Followers发送心跳信息维持其统治。若Follower一段时间未收到Leader的心跳则认为Leader可能已经挂了，再次发起Leader选举过程。&lt;/p&gt;
&lt;p&gt;Raft保证选举出的Leader上一定具有最新的已提交的日志，这一点将在四、安全性中说明。&lt;/p&gt;
&lt;h2 id=&#34;三日志同步&#34;&gt;三、日志同步&lt;/h2&gt;
&lt;p&gt;Leader选出后，就开始接收客户端的请求。Leader把请求作为日志条目（Log entries）加入到它的日志中，然后并行的向其他服务器发起 AppendEntries RPC 复制日志条目。当这条日志被复制到大多数服务器上，Leader将这条日志应用到它的状态机并向客户端返回执行结果。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;日志同步&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/raft%E7%AE%97%E6%B3%95/%E6%97%A5%E5%BF%97%E5%90%8C%E6%AD%A5.jpeg&#34;&gt;&lt;/p&gt;
&lt;p&gt;某些Followers可能没有成功的复制日志，Leader会无限的重试 AppendEntries RPC直到所有的Followers最终存储了所有的日志条目。&lt;/p&gt;
&lt;p&gt;日志由有序编号（log index，索引）的日志条目组成。每个日志条目包含它被创建时的任期号（term），和用于状态机执行的命令。如果一个日志条目被复制到大多数服务器上，就被认为可以提交（commit）了。log index 与 term 无关，Leader 每生成一条日志条目都会消耗一个 log index ，log index 只会一直递增。&lt;/p&gt;
&lt;p&gt;Raft日志同步保证如下两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果不同日志中的两个条目有着相同的索引和任期号，则它们所存储的命令是相同的。&lt;/li&gt;
&lt;li&gt;如果不同日志中的两个条目有着相同的索引和任期号，则它们之前的所有条目都是完全一样的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一条特性源于Leader在一个term内在给定的一个log index最多创建一条日志条目，同时该条目在日志中的位置也从来不会改变。&lt;/p&gt;
&lt;p&gt;第二条特性源于 AppendEntries 的一个简单的一致性检查。当发送一个 AppendEntries RPC 时，Leader会把新日志条目紧接着之前的条目的log index和term都包含在里面。如果Follower没有在它的日志中找到log index和term都相同的日志，它就会拒绝新的日志条目。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ElasticSearch集群</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/elasticsearch%E9%9B%86%E7%BE%A4/</link>
      <pubDate>Wed, 10 Aug 2022 21:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/elasticsearch%E9%9B%86%E7%BE%A4/</guid>
      <description>&lt;h2 id=&#34;1-节点自动发现&#34;&gt;1 节点自动发现&lt;/h2&gt;
&lt;p&gt;Zen Discovery是Elasticsearch内置的默认发现模块，支持多播模式和单播模式。发现模块用于发现集群中的节点 及选举主节点。多播模式已经不被大多数操作系统所支持，Elasticsearch的发现机制默认为单播模式，以防止节点无意中加入集群。&lt;/p&gt;
&lt;p&gt;在同一台机器上运行的Elasticsearch节点会自动组成集群，当集群的节点运行在不同的机器上时，需要在每个节点的配置文件&lt;code&gt;elasticsearch.yml&lt;/code&gt;中配置节点列表，即其他节点的IP和端口。集群建立后，每个节点都会每隔一定时间对节点列表中的所有节点发送心跳检测，心跳响应包中包含响应者所认可的master节点。&lt;/p&gt;
&lt;h2 id=&#34;2-bully算法&#34;&gt;2 Bully算法&lt;/h2&gt;
&lt;p&gt;选举原则：在所有活着的节点中，选取节点ID最大或者最小的节点为主节点。&lt;/p&gt;
&lt;p&gt;节点角色：主节点和普通节点&lt;/p&gt;
&lt;p&gt;消息类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Election 消息，向节点发起选举的消息&lt;/li&gt;
&lt;li&gt;Alive 消息，节点对 Election 消息的应答&lt;/li&gt;
&lt;li&gt;Victory 消息，竞选成功的主节点向普通节点发送竞选成功的消息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;选举过程：&lt;/p&gt;
&lt;p&gt;集群中每个活着的节点查找比自己ID大的节点，如果不存在则向其他节点发送Victory消息，表明自己为主节点。
如果存在比自己ID大的节点，则向这些节点发送Election消息，并等待响应。
若在给定的时间内没有收到这些节点回复的消息，则自己成为主节点，并向比自己ID小的节点发送Victory消息。
节点收到比自己ID小的节点发送的Election消息，则回复Alive消息。&lt;/p&gt;
&lt;p&gt;假设有三个节点，选举过程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;Bully算法&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/elasticsearch%E9%9B%86%E7%BE%A4/Bully%E7%AE%97%E6%B3%95.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-选举流程&#34;&gt;3 选举流程&lt;/h2&gt;
&lt;h3 id=&#34;31-选举时机&#34;&gt;3.1 选举时机&lt;/h3&gt;
&lt;p&gt;当一个节点发现包括自己在内的多数派的master-eligible节点认为集群没有master时，就可以发起master选举。&lt;/p&gt;
&lt;h3 id=&#34;32-选举流程&#34;&gt;3.2 选举流程&lt;/h3&gt;
&lt;p&gt;&lt;img alt=&#34;选举流程&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/elasticsearch%E9%9B%86%E7%BE%A4/%E9%80%89%E4%B8%BE%E6%B5%81%E7%A8%8B.jpg&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Elasticsearch节点向节点列表中的所有节点发送ping消息&lt;/li&gt;
&lt;li&gt;对收到的响应包进行过滤，筛选出activeMasters列表和masterCandidates列表。activeMasters列表是其它节点认为的当前集群的Master节点，masterCandidates列表是当前集群有资格成为Master的节点（即配置文件中 &lt;code&gt;node.master:true&lt;/code&gt;的节点）&lt;/li&gt;
&lt;li&gt;如果activeMasters列表不为空，elasticsearch会优先从activeMasters列表中选举，选举的算法是Bully算法，选择ID最小的节点(理论上activeMaster中的节点一定有master资格)&lt;/li&gt;
&lt;li&gt;如果activeMaster列表为空，那么会在masterCandidates中选举，选举同样涉及到优先级比较，首先会判断masterCandidates列表成员数目是否达到了最小数目（即超过半数）。如果达到的情况下先比较节点的集群状态版本编号，版本号越大优先级越高，然后再比较id，id越小优先级越高，这一流程的目的是让拥有最新集群状态的节点成为master&lt;/li&gt;
&lt;li&gt;经过上述选举之后，会选举出一个临时master节点，  临时master节点会等待其它节点的投票，如果有&lt;code&gt;discovery.zen.minimum_master_nodes - 1&lt;/code&gt;个节点投票认为当前节点是master，那么选举就成功，临时master会等待一定时间，如果超时投票数仍不够，那么就失败，需要重新选举。临时master 收到投票会给 Follwer 一个响应，表明 Follwer 已经加入自己的集群。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：上述的2、3、4步都是单个节点内部的操作，所选出的临时master节点是当前节点自己认为的master，即每个节点所选出的临时master可能不同，所以才需要在第5步对临时master进行投票，超过一半票数的临时master才会成为真正master。&lt;/p&gt;
&lt;p&gt;Master节点会开启错误检测机制，它会定期扫描集群所有的成员，将失活的成员移除集群，同时将最新的集群状态发布到集群中，集群成员收到最新的集群状态后会进行相应的调整，比如重新选择主分片，进行数据复制等操作。&lt;/p&gt;
&lt;h2 id=&#34;4-脑裂问题&#34;&gt;4 脑裂问题&lt;/h2&gt;
&lt;p&gt;ElasticSearch 保证不脑裂的基本原则还是多数派的策略，如果必须得到多数派的认可才能成为Master。3.2 的流程在绝大部份场景下没问题，但还是有 bug，因为上述流程并没有限制在选举过程中，一个Node只能投一票。比如NodeB投NodeA一票，但是NodeA迟迟不成为Master，NodeB等不及了发起了下一轮选主，这时候发现集群里多了个Node0，Node0优先级比NodeA还高，那NodeB肯定就改投Node0了。假设Node0和NodeA都处在等选票的环节，那显然这时候NodeB其实发挥了两票的作用，而且投给了不同的人。如果最后NodeA和Node0都得到超过半数的投票，就会发生脑裂。Raft算法为了解决此问题引入了 term 的概念，即使产生双主也一定在不同的 term ，当 term 小的收到 term 大的节点消息时会自动变为 Follwer。ElasticSearch 没有 term 概念所以一个集群会有双主，但也不会产生问题，因为旧的master 很快会发现自己集群的节点数不过半而降级为 candidate。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ElasticSearch基础</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/elasticsearch%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 24 Jul 2022 17:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/elasticsearch%E5%9F%BA%E7%A1%80/</guid>
      <description>&lt;p&gt;Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎&lt;/p&gt;
&lt;h2 id=&#34;1-基础&#34;&gt;1 基础&lt;/h2&gt;
&lt;p&gt;9300 端口为 Elasticsearch 集群间组件的通信端口， 9200 端口为浏览器访问的 http协议 RESTful端口。&lt;/p&gt;
&lt;p&gt;ElasticSearch8.x版本默认开启密码验证功能，可在 &lt;code&gt;elasticsearch.yml&lt;/code&gt;末尾添加 &lt;code&gt;xpack.security.enabled: false&lt;/code&gt;取消密码验证&lt;/p&gt;
&lt;h3 id=&#34;11-倒排索引&#34;&gt;1.1 倒排索引&lt;/h3&gt;
&lt;p&gt;正排索引（传统）&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;id&lt;/th&gt;
          &lt;th&gt;content&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1001&lt;/td&gt;
          &lt;td&gt;my name is zhang san&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;1002&lt;/td&gt;
          &lt;td&gt;my name is li si&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;倒排索引&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;keyword&lt;/th&gt;
          &lt;th&gt;id&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;name&lt;/td&gt;
          &lt;td&gt;1001, 1002&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;zhang&lt;/td&gt;
          &lt;td&gt;1001&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;12-数据库结构&#34;&gt;1.2 数据库结构&lt;/h3&gt;
&lt;p&gt;Elasticsearch 是面向文档型数据库，一条数据在这里就是一个文档。 Elasticsearch 里存储文档数据和关系型数据库 MySQL 存储数据的概念进行一个类比&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;数据库结构类比&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/elasticsearch%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E7%B1%BB%E6%AF%94.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;ES 里的 Index 可以看做一个库，而 Types 相当于表， Documents 则相当于表的行，Fields相当于表中的字段。这里 Types 的概念已经被逐渐弱化， Elasticsearch 6.X 中，一个 index 下已经只能包含一个type， Elasticsearch 7.X 中, Type 的概念已经被删除了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Netty</title>
      <link>https://ethereal-lu.github.io/posts/java/netty/</link>
      <pubDate>Sat, 09 Jul 2022 19:12:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/java/netty/</guid>
      <description>&lt;h2 id=&#34;1-nio基础&#34;&gt;1 NIO基础&lt;/h2&gt;
&lt;p&gt;non-blocking io 非阻塞IO&lt;/p&gt;
&lt;h3 id=&#34;11-三大组件&#34;&gt;1.1 三大组件&lt;/h3&gt;
&lt;h4 id=&#34;111-channel--buffer&#34;&gt;1.1.1 Channel &amp;amp; Buffer&lt;/h4&gt;
&lt;p&gt;Buffer是内存中的数据缓冲区，Channel 是内存与磁盘之间的数据通道。不同于InputStream、OutputStream等BIO中的流都是单向数据通道，Channel 是双向数据通道，可以从 Channel 将数据读入 Buffer，也可以将Buffer 中的数据写入Channel 。&lt;/p&gt;
&lt;p&gt;常见的 Channel 有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FileChannel ：文件通道&lt;/li&gt;
&lt;li&gt;DatagramChannel ：udp&lt;/li&gt;
&lt;li&gt;SocketChannel ：tcp；客户端服务端都可以&lt;/li&gt;
&lt;li&gt;ServerSocketChannel ：tcp；专用于服务端&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Buffer 使用最多的就是 ByteBuffer，其他的也是每种基础数据类型有一个对应的Buffer，但用的不多。&lt;/p&gt;
&lt;h4 id=&#34;112-selector&#34;&gt;1.1.2 Selector&lt;/h4&gt;
&lt;p&gt;在使用传统BIO开发时，要么对每个连接都新建一个线程处理（线程太多撑爆内存、线程切换成本高），要么使用线程池（阻塞IO，同时只能处理一个连接，线程利用率不高）&amp;mdash;&amp;gt; 正因为此，原始的HTTP1.0才使用短连接，一个请求处理完立刻释放连接，让线程可以处理其他请求。&lt;/p&gt;
&lt;p&gt;Selector 的作用就是配合一个线程来管理多个Channel ，获取这些Channel 上发生的事件，将有事件发生的Channel 交给线程处理。适合连接数多但流量低的场景，流量大意味着一个Channel 要处理大量数据，会使其他Channel 饥饿。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;selector&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/java/netty/selector.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;12-bytebuffer&#34;&gt;1.2 ByteBuffer&lt;/h3&gt;
&lt;h4 id=&#34;121-基本使用&#34;&gt;1.2.1 基本使用&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TestByteBuffer&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 获取 FileChannel&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; (FileChannel channel &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; FileInputStream(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;data.txt&amp;#34;&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;getChannel&lt;/span&gt;()) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 申请 10 个字节的缓冲区&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ByteBuffer buffer &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ByteBuffer.&lt;span style=&#34;color:#a6e22e&#34;&gt;allocate&lt;/span&gt;(10);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 读取channel中的数据到buffer。read 方法返回读取到的字节数，-1表示读完了&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (channel.&lt;span style=&#34;color:#a6e22e&#34;&gt;read&lt;/span&gt;(buffer) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                buffer.&lt;span style=&#34;color:#a6e22e&#34;&gt;flip&lt;/span&gt;();  &lt;span style=&#34;color:#75715e&#34;&gt;// 切换为读模式&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (buffer.&lt;span style=&#34;color:#a6e22e&#34;&gt;hasRemaining&lt;/span&gt;()) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(buffer.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;());  &lt;span style=&#34;color:#75715e&#34;&gt;// get 每次读一个字节&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                buffer.&lt;span style=&#34;color:#a6e22e&#34;&gt;clear&lt;/span&gt;();  &lt;span style=&#34;color:#75715e&#34;&gt;// 切换为写模式&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; (IOException e) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            e.&lt;span style=&#34;color:#a6e22e&#34;&gt;printStackTrace&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;122-内部结构&#34;&gt;1.2.2 内部结构&lt;/h4&gt;
&lt;p&gt;ByteBuffer有以下几个重要属性&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kuberbetes基础</title>
      <link>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8/kuberbetes/kuberbetes%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 06 Jun 2022 17:12:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8/kuberbetes/kuberbetes%E5%9F%BA%E7%A1%80/</guid>
      <description>&lt;p&gt;Kubernetes 是 Google 开源的一个容器编排引擎，用于自动化容器化应用程序的部署和管理。&lt;/p&gt;
&lt;h2 id=&#34;1kubernetes整体架构&#34;&gt;1、Kubernetes整体架构&lt;/h2&gt;
&lt;p&gt;&lt;img alt=&#34;Kubernetes整体架构&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8/kuberbetes/kuberbetes%E5%9F%BA%E7%A1%80/Kubernetes%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Master&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;k8s集群控制节点，对集群进行调度管理，接受集群外用户去集群操作请求；&lt;/p&gt;
&lt;p&gt;Master Node 由 API Server、Scheduler、ClusterState Store（ETCD 数据库）和 Controller MangerServer 所组成；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Nodes&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;集群工作节点，运行用户业务应用容器；&lt;/p&gt;
&lt;p&gt;Nodes节点也叫Worker Node，包含kubelet、kube proxy 和 Pod（Container Runtime）；&lt;/p&gt;
&lt;h2 id=&#34;2kubernetes环境搭建&#34;&gt;2、Kubernetes环境搭建&lt;/h2&gt;
&lt;p&gt;kubeadm是官方社区推出的一个用于快速部署 kubernetes 集群的工具。两个指令即可完成集群搭建：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个Master节点：kubeadm init&lt;/li&gt;
&lt;li&gt;将Node节点加入到Master集群中：kubeadm join &amp;lt;Master节点的IP和端口&amp;gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;21初始环境准备&#34;&gt;2.1、初始环境准备&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;硬件：内存2G+，CPU 2核+；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭防火墙：&lt;code&gt;ufw disable&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭selinux：&lt;code&gt;sed -i &#39;s/enforcing/disabled/&#39; /etc/selinux/config #永久&lt;/code&gt; ；&lt;code&gt;setenforce 0 #临时&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭swap：&lt;code&gt;sed -ri &#39;s/.*swap.*/#&amp;amp;/&#39; /etc/fstab #永久&lt;/code&gt; ；&lt;code&gt;swapoff -a #临时&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置网桥参数&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cat &amp;gt; /etc/sysctl.d/k8s.conf &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;lt;&amp;lt; EOF
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;net.bridge.bridge-nf-call-ip6tables = 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;net.bridge.bridge-nf-call-iptables = 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;EOF&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sysctl --system  &lt;span style=&#34;color:#75715e&#34;&gt;#生效&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在master添加hosts&lt;/p&gt;</description>
    </item>
    <item>
      <title>分布式基础</title>
      <link>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Thu, 02 Jun 2022 19:42:15 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/</guid>
      <description>&lt;h2 id=&#34;1分布式session&#34;&gt;1、分布式Session&lt;/h2&gt;
&lt;p&gt;解决分布式Session有两种方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将所有Session存放在Redis服务器中，所有请求过来后先到Redis服务器中获取Session&lt;/li&gt;
&lt;li&gt;token：用户首次登录后，将用户信息加密为token下发给客户端，之后每次请求都携带该token，token验证通过即承认其合法身份。多个服务器都使用相同的密钥和算法对 token 进行验证。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    <item>
      <title>HTTP</title>
      <link>https://ethereal-lu.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http/</link>
      <pubDate>Wed, 01 Jun 2022 12:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http/</guid>
      <description>&lt;h2 id=&#34;1http请求方法&#34;&gt;1、HTTP请求方法&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;index&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;method&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;description&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;GET&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;请求指定页面信息，并返回实体主体&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;HEAD&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;3&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;POST&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;4&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;PUT&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;从客户端向服务器传送的数据取代指定的文档的内容。（全部取代）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;5&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;PATCH&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;从客户端向服务器传送的数据取代指定的文档的内容。（部分取代）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;6&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;DELETE&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;请求服务器删除指定的页面。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;7&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;CONNECT&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;8&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;OPTIONS&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;允许客户端查看服务器的性能。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;9&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;TRACE&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;回显服务器收到的请求，主要用于测试或诊断。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;2http队头阻塞&#34;&gt;2、HTTP队头阻塞&lt;/h2&gt;
&lt;p&gt;在HTTP1.0中不使用TCP长连接，每次收到响应后才能发起下一个请求。每个请求都需要 3 + 4.&lt;/p&gt;
&lt;p&gt;在HTTP1.1中使用TCP长连接，一个TCP连接中可以处理多个请求，但是如果前面的请求没有收到响应就会阻塞后续的请求。因此引入管道来提高效率。但是管道的引入带来了对头阻塞，管道特性允许客户端在已发送的请求收到服务端的响应之前发送下一个请求，但是由于HTTP请求和响应并没有序号标识，无法将乱序的响应与请求关联起来，因此响应顺序必须与请求顺序一致。如果某个响应由于一些原因延迟了，那么后面的响应就都会被阻塞，这就是队头阻塞。&lt;/p&gt;
&lt;p&gt;由于队头阻塞和幂等性问题，现代浏览器默认都关闭了管道化，并且大部分服务器也是默认不支持管道化的。&lt;/p&gt;
&lt;p&gt;解决队头阻塞问题可以采用并发TCP连接，即每个浏览器可以对同一个域名发起多个TCP连接，如谷歌浏览器默认最大可以同时发起6个TCP连接，此时不同TCP连接中的请求便不存在队头阻塞问题。但是连接数量有限且需要额外的资源，因此只能做有效缓解。&lt;/p&gt;
&lt;h2 id=&#34;3http幂等性&#34;&gt;3、HTTP幂等性&lt;/h2&gt;
&lt;p&gt;当客户端在支持管道化时需要保持未收到响应的请求，当连接意外中断时，需要重新发送这部分请求。因此客户端在使用管道化的时候请求方式必须是幂等请求。&lt;/p&gt;
&lt;p&gt;HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。这里的副作用是指对于资源造成的改变，而不是响应结果必须一样。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GET&lt;/strong&gt; 操作是幂等的，原因是 GET 操作根本不会对服务器产生任何修改。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PUT&lt;/strong&gt; 方法通常是对已经存在的资源进行修改，也是幂等的。如将数字 1 改为 2，执行一次成功后，后续的操作都应该找不到数字 1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DELETE&lt;/strong&gt; 方法也是幂等的，例如我们连续发起多个对 A 的删除请求，如果第一个成功的话，后面的请求都应返回资源找不到的错误&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;POST&lt;/strong&gt; 一般是指新增资源，不是幂等的。如果连续发起三个 A 资源的增加，最终的结果会是三个 A 资源，而不是一个&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，POST方法不能使用 Pipeline。&lt;/p&gt;
&lt;h2 id=&#34;4http2-和http11-区别&#34;&gt;4、http2 和http1.1 区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;新的二进制格式&lt;/strong&gt;（Binary  Format），http1.1和2.0 最大的区别是二进制框架层。与 http1.1把所有请求和响应作为纯文本不同，http2 使用二进制框架层把所有消息封装成二进制。二进制协议解析起来更高效且错误更少。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多路复用&lt;/strong&gt;（MultiPlexing），客户端与服务端只建立一个TCP连接，所有的请求都共享这个连接。一个request对应一个id，再将一个请求切割成多个帧，同一个请求的多个帧都携带同一个请求id，这样一个连接上可以有多个request，每个请求的帧可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;header压缩&lt;/strong&gt;，HTTP报文的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务端推送&lt;/strong&gt;（server push），实现复杂。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5tsl&#34;&gt;5、TSL&lt;/h2&gt;
&lt;p&gt;TLS（传输层安全）是更为安全的升级版 SSL。该协议由两层组成： TLS 记录协议和 TLS 握手协议。记录协议主要负责使用对称密码对消息进行加密。握手协议负责在客户端和服务器端商定密码算法和共享密钥，以及证书认证。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Nginx基础</title>
      <link>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 30 May 2022 22:42:15 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx%E5%9F%BA%E7%A1%80/</guid>
      <description>&lt;p&gt;Tomcat 稳定但不支持高并发，因此支持高并发的 Nginx 诞生了。Nginx使用基于事件驱动架构，使其可以支持数以百万级别的TCP连接。&lt;/p&gt;
&lt;h2 id=&#34;1nginx-应用场景&#34;&gt;1、Nginx 应用场景&lt;/h2&gt;
&lt;p&gt;Nginx是一款高性能的HTTP服务器和反向代理服务器。Nginx 最常用的应用场景就是这两个。&lt;/p&gt;
&lt;h3 id=&#34;11反向代理&#34;&gt;1.1、反向代理&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;正向代理&lt;/strong&gt;，&amp;ldquo;它代理的是客户端，代客户端发出请求&amp;rdquo;，是一个位于客户端和原始服务器之间的中间服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;反向代理&lt;/strong&gt;，&amp;ldquo;它代理的是服务端，代服务端接收请求&amp;rdquo;，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息。Nginx 作为服务端暴露的地址，所有客户端的请求都会进入 Nginx 服务器，然后由 Nginx 按照一定的规则将请求分发给具体的业务处理服务器，客户端并不知道是哪台服务器为自己服务，这里Nginx 扮演的就是反向代理服务器。&lt;/p&gt;
&lt;p&gt;反向代理的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证内网的安全，通常将反向代理作为公网访问地址，Web服务器是内网&lt;/li&gt;
&lt;li&gt;负载均衡，通过反向代理服务器来优化网站的负载&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上方提到的请求分发就是依据这里的负载均衡策略分发的。&lt;/p&gt;
&lt;p&gt;负载均衡分为硬件负载均衡和软件负载均衡两种，硬件如F5负载均衡，相对造价昂贵成本较高，但是数据的稳定性安全性高；除了移动联通等运营商使用的都是软件负载均衡，软件负载均衡是利用现有的技术结合主机硬件实现的一种消息队列分发机制。&lt;/p&gt;
&lt;p&gt;Nginx支持的负载均衡调度算法如下：&lt;strong&gt;重点掌握权重轮询即可，其余的基本不用。但作为面试还是要能说出来。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;权重轮询(默认）：接收到的请求按照权重分配到不同的后端服务器，可以根据服务器的硬件性能配置不同的权重，权重越大被分配到请求的几率越大。&lt;/li&gt;
&lt;li&gt;ip_hash：每个请求按照发起客户端的ip的hash结果进行匹配，对于一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。但是移动端的ip可能一直变化，所以较为鸡肋。&lt;/li&gt;
&lt;li&gt;fair：智能调整调度算法，动态的根据后端服务器的响应时长进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高。Nginx默认不支持fair算法，需要安装upstream_fair模块。可能造成流量倾斜，大量请求进入响应时长短的服务器导致崩溃。&lt;/li&gt;
&lt;li&gt;url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在Nginx作为静态服务器的情况下提高缓存效率。同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装Nginx的hash软件包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12web-服务器&#34;&gt;1.2、web 服务器&lt;/h3&gt;
&lt;p&gt;可以先通过动态/静态内容分离，而后为静态内容（html/css/js/图片等）提供HTTP访问功能；而动态内容可以整合代理模块，代理给上游服务器，来支持对外部程序的直接调用或者解析。&lt;/p&gt;
&lt;h2 id=&#34;2nginx-基本架构&#34;&gt;2、Nginx 基本架构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一个master进程生成多个worker子进程（每个进程只有一个线程），一个worker进程可以响应多个用户请求；&lt;/li&gt;
&lt;li&gt;非阻塞、IO复用、事件驱动：select，poll， epoll， kqueue，/dev/poll；&lt;/li&gt;
&lt;li&gt;支持sendfile，sendfile64；&lt;/li&gt;
&lt;li&gt;支持文件AIO（异步I/O）；&lt;/li&gt;
&lt;li&gt;支持mmap；&lt;/li&gt;
&lt;li&gt;灵活的文件配置；&lt;/li&gt;
&lt;li&gt;占用内存小：10,000个非活动HTTP保持连接占用大约2.5M内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3nginx-并发模型&#34;&gt;3、Nginx 并发模型&lt;/h2&gt;
&lt;p&gt;一个master进程生成多个worker子进程（每个进程只有一个线程），一个worker响应多个用户请求。如果单进程启动：仅有一个进程，既充当master进程的角色，也充当worker进程的角色。&lt;/p&gt;
&lt;h3 id=&#34;31master进程&#34;&gt;3.1、master进程&lt;/h3&gt;
&lt;p&gt;充当整个进程组与用户的交互接口（接收来自外界的信号，向各worker进程发送信号），同时监控worker进程的运行状态。&lt;/p&gt;
&lt;p&gt;它不需要处理网络事件，不负责业务的执行，只会通过管理worker进程来实现重启服务、平滑升级、更换日志文件、配置文件实时生效等功能。&lt;/p&gt;
&lt;h3 id=&#34;32worker进程&#34;&gt;3.2、worker进程&lt;/h3&gt;
&lt;p&gt;主要任务是处理基本的网络事件，完成具体的任务逻辑。多个worker进程之间是对等的，互相独立的。&lt;/p&gt;
&lt;p&gt;worker进程主要关注点是与客户端或后端服务器（此时nginx作为中间代理）之间的数据可读/可写等I/O交互事件，所以工作进程的阻塞点是在像select()、epoll_wait()等这样的I/O多路复用函数调用处，以等待发生数据可读/写事件。当然也可能被新收到的进程信号中断。&lt;/p&gt;
&lt;p&gt;worker进程个数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果负载以CPU密集型应用为主，一般会设置与机器cpu核数一致或少一个（用来处理用户等其他任务）；&lt;/li&gt;
&lt;li&gt;如果负载以IO密集型为主，如响应大量内容给客户端，则worker数应该为CPU个数的1.5或2倍。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为更多的worker数，只会导致进程来竞争cpu资源了，从而带来不必要的上下文切换。而且，nginx为了更好的利用多核特性，具有cpu绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来cache的失效。&lt;/p&gt;
&lt;h3 id=&#34;33并发处理&#34;&gt;3.3、并发处理&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在master进程里面，先创建socket，并bind、listen在80端口（所以master进程需要root权限）；&lt;/li&gt;
&lt;li&gt;然后再fork出多个worker进程，这样每个worker进程都可以去accept这个socket（会产生惊群问题）， 或者使用锁机制，让抢到锁的一个worker进程去accept这个socket，注意这里一般使用select/poll/epoll机制来解决accept阻塞问题；&lt;/li&gt;
&lt;li&gt;当一个新连接进来后，而只有抢到锁的一个进程可以accept这个连接进行处理（也是放入epoll中）；&lt;/li&gt;
&lt;li&gt;抢到锁的worker进程accept到新连接后，会立即释放锁；然后所有worker进程再次参与抢锁，这样就回到了第二步，进行循环处理并发连接；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;34惊群问题&#34;&gt;3.4、惊群问题&lt;/h3&gt;
&lt;p&gt;产生原因：像上面第二步，多个worker进程等待同一个socket的连接事件，当这个事件发生时，这些进程被同时唤醒，就是惊群。&lt;/p&gt;
&lt;p&gt;注意，在linux2.6内核上，accept系统调用已经不存在惊群，但用epoll机制来解决accept阻塞问题，epoll_wait会有惊群问题（新增 EPOLLEXCLUSIVE 选项解决了）。&lt;/p&gt;
&lt;p&gt;导致后果：许多worker进程被内核重新调度唤醒，只有一个进程可以accept这个连接进行处理，其他余者皆失败，导致性能浪费。&lt;/p&gt;
&lt;p&gt;nginx解决方案：使用锁机制，让抢到锁的一个worker进程去accept（epoll_wait）这个socket；如果操作系统支持原子整型，才会使用共享内存实现原子上锁，否则使用文件上锁。&lt;/p&gt;
&lt;h2 id=&#34;4nginx-配置&#34;&gt;4、Nginx 配置&lt;/h2&gt;
&lt;h3 id=&#34;41默认配置文件&#34;&gt;4.1、默认配置文件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;/etc/nginx/nginx.conf&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>分布式锁</title>
      <link>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link>
      <pubDate>Mon, 30 May 2022 10:42:15 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid>
      <description>&lt;h2 id=&#34;1前言&#34;&gt;1、前言&lt;/h2&gt;
&lt;p&gt;单纯的Java Api并不能提供分布式锁的能力。目前比较常用的分布式锁的实现方案有如下三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于数据库实现分布式锁&lt;/li&gt;
&lt;li&gt;基于缓存实现分布式锁&lt;/li&gt;
&lt;li&gt;基于Zookeeper实现分布式锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分布式锁应该实现如下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥性：在任何时刻，对于同一条数据，只有一台应用可以获取到分布式锁；&lt;/li&gt;
&lt;li&gt;高可用性：在分布式场景下，一小部分服务器宕机不影响正常使用，这种情况就需要将提供分布式锁的服务以集群的方式部署；&lt;/li&gt;
&lt;li&gt;防止锁超时：如果客户端没有主动释放锁，服务器会在一段时间之后自动释放锁，防止客户端宕机或者网络不可达时产生死锁；&lt;/li&gt;
&lt;li&gt;独占性：加锁解锁必须由同一台服务器进行，也就是锁的持有者才可以释放锁，不能出现你加的锁，别人给你解锁了；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2基于数据库实现分布式锁&#34;&gt;2、基于数据库实现分布式锁&lt;/h2&gt;
&lt;h3 id=&#34;21实现方式&#34;&gt;2.1、实现方式&lt;/h3&gt;
&lt;p&gt;在数据库中存储方法名，将数据库的自动提交关闭，然后在查询语句后面增加&lt;code&gt;for update&lt;/code&gt;来查询需要上锁的方法名，数据库会在查询过程中给数据库表增加排他锁。值得注意的是：只有通过索引进行检索的时候才会使用行级锁，所以应该给方法名加上唯一锁，同时为了避免重载方法也被锁住，应该在方法名上将参数类型也加上。等临界资源使用完毕后再手动提交事务。&lt;/p&gt;
&lt;h3 id=&#34;22缺点&#34;&gt;2.2、缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据在磁盘中，查询开销很大&lt;/li&gt;
&lt;li&gt;事务提交之前客户端失联，会导致死锁&lt;/li&gt;
&lt;li&gt;如果表中数据量不大，查询优化器可能会通过全表扫描执行，此时会使用表锁，而非行锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3基于缓存实现分布式锁&#34;&gt;3、基于缓存实现分布式锁&lt;/h2&gt;
&lt;h3 id=&#34;31实现方式&#34;&gt;3.1、实现方式&lt;/h3&gt;
&lt;p&gt;以 redis 为例来说明基于缓存实现分布式锁。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Redis&lt;/code&gt;分布式锁主要是通过在 set 命令中添加 nx 和 ex 这两个参数实现的。&lt;/p&gt;
&lt;p&gt;核心思想就是每次想要获取锁的时候，就对一个固定的 key 值以 &lt;code&gt;SET  NX  EX&lt;/code&gt;的方式存放，如果成功，就说明获取锁成功，否则以自旋的方式持续获取锁，直到超时获取失败。解锁通过 LUA 代码实现，LUA是原子性的。&lt;/p&gt;
&lt;h3 id=&#34;32优缺点&#34;&gt;3.2、优缺点&lt;/h3&gt;
&lt;p&gt;优点：性能好，redis 是 NoSQL，数据在内存中，支持高性能，高并发。&lt;/p&gt;
&lt;p&gt;缺点：过期时间需要手动提前设置，若设置太长当线程阻塞后需要较长时间才锁过期，会影响性能，若设置太短会导致提前释放产生并发问题。所以可靠性稍低。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ethereal-lu.github.io/2022/04/12/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/&#34;&gt;关于 redis 实现分布式锁更多内容查看 redis 目录中的分布式锁篇章&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;4基于zookeeper实现分布式锁&#34;&gt;4、基于Zookeeper实现分布式锁&lt;/h2&gt;
&lt;h3 id=&#34;41实现方式&#34;&gt;4.1、实现方式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在与方法对应的永久节点下创建一个临时序号节点&lt;/li&gt;
&lt;li&gt;获取当前永久节点下的所有子节点&lt;/li&gt;
&lt;li&gt;判断自己是否是最小节点
&lt;ul&gt;
&lt;li&gt;如果是，上锁成功&lt;/li&gt;
&lt;li&gt;如果不是，说明前面还有锁，上锁失败，监听比自己小的节点，形成链式监听，当触发监听时，再次执行步骤 2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;惊群效应&lt;/strong&gt;（羊群效应）：如果在上锁时，每个节点监听的是最小的节点，那么每次最小节点发生改变都会触发大量的监听事件，对于 zk 压力非常大，这就是惊群效应。故应该使用上述的链式监听，因为如果前一个结点没有获取到锁，自然也轮不到自己获取。这样只能实现公平锁。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端突然失联，会自动释放锁&lt;/li&gt;
&lt;li&gt;可以在临时序号节点的值中保存当前主机和线程的信息，实现可重入锁&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;42优缺点&#34;&gt;4.2、优缺点&lt;/h3&gt;
&lt;p&gt;优点：可靠性高；断开连接自动释放锁，无需手动设置过期时间&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能没有 reids 高。因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同不到所有的Follower机器上。&lt;/li&gt;
&lt;li&gt;可能产生并发问题：如果由于网络抖动，服务端没有收到客户端的心跳包，服务端就会删除临时节点让其他节点获取锁，从而使多个客户端获取到锁。但是 zk 有重试机制，如果检测不到客户端的心跳，就会重试连接，所以这种情况并不常见。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>零碎算法</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9B%B6%E7%A2%8E%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 22 May 2022 11:12:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9B%B6%E7%A2%8E%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h2 id=&#34;不大于-num-的最大值&#34;&gt;不大于 num 的最大值&lt;/h2&gt;
&lt;p&gt;给定整数 num，使用数组 arr 中的元素组成不大于 num 的最大数；1 &amp;lt;= arr[i] &amp;lt;= 9。例如 arr = {1, 2, 4, 9}，num = 2533，则返回 2499。&lt;/p&gt;
&lt;p&gt;**整体思路：**每次都选择恰好等于当前值的元素，若顺利遍历完则所选元素组成的数等于给定值；若遍历到某个值时数组中的所有元素都大于该值，则需要回溯，将前一个元素减小；若遍历到某个值时数组中不存在等于当前值的元素，则选择较小的元素，并将之后所有元素全部置为数组中的最大值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.util.Arrays;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;findMax&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; arr, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; num) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Arrays.&lt;span style=&#34;color:#a6e22e&#34;&gt;sort&lt;/span&gt;(arr);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; String.&lt;span style=&#34;color:#a6e22e&#34;&gt;valueOf&lt;/span&gt;(num).&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dfs(arr, num, 0, 0, n);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 这里 ret &amp;lt; 0 是递归的最外层返回 -1，说明数位相同没有答案，必须少一位。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (ret &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 0) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (ret &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; num) ret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ret &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; 10 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; arr&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;arr.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ret &lt;span style=&#34;color:#f92672&#34;&gt;/=&lt;/span&gt; 10;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 这里 ret 如果为 0，说明数组中的数不可能组成答案。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ret &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1 : ret;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ret;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 只负责处理第一个数位相同的情况，因为数位不相同的情况只有一种，很简单，交给主函数处理即可。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dfs&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; arr, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; num, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; target, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; index, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; n) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (target &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; num) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; target;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; curr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Integer.&lt;span style=&#34;color:#a6e22e&#34;&gt;parseInt&lt;/span&gt;(String.&lt;span style=&#34;color:#a6e22e&#34;&gt;valueOf&lt;/span&gt;(num).&lt;span style=&#34;color:#a6e22e&#34;&gt;charAt&lt;/span&gt;(index) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// arr[i] 为不大于 curr 的最大值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arr.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; arr&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; curr; i&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// i &amp;lt; 0 表示所有值都大于 curr。不正确，回退。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 0) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// arr[i] == curr, 继续往后走。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (arr&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; curr) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dfs(arr, num, target &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; 10 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; arr&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;, index &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1, n);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (ret &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; 0) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ret;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// arr[i] &amp;lt; curr，则后续所有值直接取最大值即可。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (arr&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; curr &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; 0) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 如果 arr[i] == curr 且走到这里，说明当前选择 arr[i] 走不通，选择更小的 arr[i - 1];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (arr&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; curr) i&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            target &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; target &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; 10 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; arr&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (target &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; num) target &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; target &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; 10 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; arr&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;arr.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; target &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; 10;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ret;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Solution solution &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Solution();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(solution.&lt;span style=&#34;color:#a6e22e&#34;&gt;findMax&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt;{1, 2, 4, 9}, 2533));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;右侧小于当前元素的个数&#34;&gt;右侧小于当前元素的个数&lt;/h2&gt;
&lt;p&gt;给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。如：nums = [5,2,6,1]，返回 [2,1,1,0]&lt;/p&gt;</description>
    </item>
    <item>
      <title>分布式事务</title>
      <link>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Thu, 19 May 2022 17:42:15 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</guid>
      <description>&lt;h2 id=&#34;1-事务&#34;&gt;1 事务&lt;/h2&gt;
&lt;p&gt;事务可以看做是一次大的活动，它由不同的小活动组成，这些活动要么全部成功，要么全部失败。&lt;/p&gt;
&lt;h3 id=&#34;11-本地事务&#34;&gt;1.1 本地事务&lt;/h3&gt;
&lt;p&gt;在计算机系统中，更多的是通过关系型数据库来控制事务，这是利用数据库本身的事务特性来实现的，因此叫数据库事务，由于应用主要靠关系数据库来控制事务，而数据库通常和应用在同一个服务器，所以基于关系型数据库的事务又被称为本地事务。&lt;/p&gt;
&lt;h3 id=&#34;12-分布式事务&#34;&gt;1.2 分布式事务&lt;/h3&gt;
&lt;p&gt;随着互联网的快速发展，软件系统由原来的单体应用转变为分布式应用。分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操作，这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为&lt;strong&gt;分布式事务&lt;/strong&gt;，例如用户注册送积分事务、创建订单减库存事务，银行转账事务等都是分布式事务。&lt;/p&gt;
&lt;h3 id=&#34;13-base-理论&#34;&gt;1.3 BASE 理论&lt;/h3&gt;
&lt;p&gt;由于 CAP 理论，大型互联网应用为达到良好的响应性能来提高用户体验，一般会保证 P 和 A ，舍弃 C 强一致，保证最终一致性。&lt;/p&gt;
&lt;p&gt;BASE 是 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent （最终一致性）三个短语的缩写。BASE 理论通过牺牲强一致性来获得可用性，当出现故障允许部分不可用但要保证核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。满足BASE理论的事务，我们称之为“&lt;strong&gt;柔性事务&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;基本可用：分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。如电商网站交易付款出现问题了，商品依然可以正常浏览。&lt;/p&gt;
&lt;p&gt;软状态：由于不要求强一致性，所以BASE允许系统中存在中间状态（也叫软状态），这个状态不影响系统可用性，如订单的&amp;quot;支付中&amp;quot;、“数据同步中”等状态，待数据最终一致后状态改为“成功”状态。&lt;/p&gt;
&lt;p&gt;最终一致：最终一致是指经过一段时间后，所有节点数据都将会达到一致。如订单的&amp;quot;支付中&amp;quot;状态，最终会变 为“支付成功”或者&amp;quot;支付失败&amp;quot;，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待。&lt;/p&gt;
&lt;h2 id=&#34;2-分布式事务解决方案&#34;&gt;2 分布式事务解决方案&lt;/h2&gt;
&lt;h3 id=&#34;21-2pc&#34;&gt;2.1 2PC&lt;/h3&gt;
&lt;p&gt;2PC 即两阶段提交协议，是将整个事务流程分为两个阶段，准备阶段（Prepare phase）、提交阶段（commit phase），2 是指两个阶段，P 是指准备阶段，C 是指提交阶段。&lt;/p&gt;
&lt;p&gt;整个事务过程由事务管理器和参与者组成，事务管理器负责决策整个分布式事务的提交和回滚，事务参与者负责自己本地事务的提交和回滚。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在&lt;strong&gt;准备阶段&lt;/strong&gt; 事务管理器给每个参与者发送 Prepare 消息，每个数据库参与者在本地执行事务（此时本地事务不提交），并将自己的执行结果发送给事务管理器。&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;提交阶段&lt;/strong&gt; 事务管理器只要发现有任意一个数据库参与者执行失败，就会直接给每个参与者发送回滚（Rollback）消息；否则，发送提交（Commit）消息；参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的锁资源。注意：&lt;strong&gt;必须在最后阶段释放锁资源&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;tips：Mysql 中，事务执行是指在内存中修改值；事务提交是指将 undolog 和  redolog 存储在磁盘中。事务已经提交，仍然可以回滚。&lt;/p&gt;
&lt;h3 id=&#34;22-tcc&#34;&gt;2.2 TCC&lt;/h3&gt;
&lt;p&gt;TCC 是 Try、Conﬁrm、Cancel 三个词语的缩写，TCC 要求每个分支事务实现三个操作：预处理、确认 、撤销 。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Try&lt;/strong&gt; 阶段是做完业务检查（一致性）及资源预留（隔离），此阶段仅是一个初步操作，它和后续的  Conﬁrm 一起才能真正构成一个完整的业务逻辑。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Confirm&lt;/strong&gt; 阶段是做确认提交，Try 阶段所有分支事务执行成功后开始执行 Conﬁrm。通常情况下，采用 TCC 则认为 Conﬁrm 阶段是不会出错的。即：只要 Try 成功，Conﬁrm 一定成功。若 Conﬁrm 阶段真的出错了，需引入重试机制或人工处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cancel&lt;/strong&gt; 阶段是在业务执行错误需要回滚的状态下执行分支事务的业务取消，预留资源释放。通常情况下，采用 TCC 则认为 Cancel 阶段也是一定成功的。若 Cancel 阶段真的出错了，需引入重试机制或人工处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;事务管理器首先发起所有的分支事务的 Try 操作，任何一个分支事务的Try操作执行失败，事务管理器将会发起所有分支事务的 Cancel 操作，若 Try 操作全部成功，事务管理器将会发起所有分支事务的 Conﬁrm 操作，其中 Conﬁrm/Cancel 操作若执行失败，事务管理器会进行重试。&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL默认数据库</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Tue, 17 May 2022 17:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>&lt;h2 id=&#34;mysql系统默认数据库&#34;&gt;Mysql系统默认数据库&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;information_schema&lt;/li&gt;
&lt;li&gt;performance_schema&lt;/li&gt;
&lt;li&gt;mysql&lt;/li&gt;
&lt;li&gt;sys&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;一information_schema信息概要&#34;&gt;一、information_schema（信息概要）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;保存了MySQl服务所有数据库的信息。&lt;/li&gt;
&lt;li&gt;具体MySQL服务有多少个数据库，各个数据库有哪些表，各个表中的字段是什么数据类型，各个表中有哪些索引，各个数据库要什么权限才能访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二performance_schema性能概要&#34;&gt;二、performance_schema（性能概要）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;主要用于收集数据库服务器性能参数。5.7后默认开启。&lt;/li&gt;
&lt;li&gt;提供进程等待的详细信息，包括锁、互斥变量、文件信息；&lt;/li&gt;
&lt;li&gt;保存历史的事件汇总信息，为提供MySQL服务器性能做出详细的判断；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三mysql核心数据库&#34;&gt;三、mysql（核心数据库）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;保存MySQL的用户、权限设置、关键字等&lt;/li&gt;
&lt;li&gt;如哪些user可以访问这个数据、DB参数、插件、主从&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;四sys系统表&#34;&gt;四、Sys（系统表）&lt;/h3&gt;
&lt;p&gt;Sys库所有的数据源来自：performance_schema。目标是把performance_schema的把复杂度降低，让DBA能更好的阅读这个库里的内容。让DBA更快的了解DB的运行情况。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ZAB协议</title>
      <link>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zab%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Sun, 08 May 2022 19:42:15 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zab%E5%8D%8F%E8%AE%AE/</guid>
      <description>&lt;h1 id=&#34;1zab协议介绍&#34;&gt;1、ZAB协议介绍&lt;/h1&gt;
&lt;p&gt;Zookeeper Atomic Broadcast，是 Zookeeper 专门设计的一种支持崩溃恢复的原子广播协议。用来实现分布式数据一致性。包含两种基本模式，分别是 崩溃恢复、原子广播。&lt;/p&gt;
&lt;p&gt;当整个集群在启动时，或当leader 节点崩溃时，ZAB协议就会进入恢复模式并选举产生新的leader，当leader选举出来后，并且集群中有过半机器和该leader节点完成数据同步后，ZAB协议就会退出恢复模式进入消息广播模式。&lt;/p&gt;
&lt;h1 id=&#34;2崩溃恢复&#34;&gt;2、崩溃恢复&lt;/h1&gt;
&lt;p&gt;崩溃恢复阶段的任务主要为 Leader 选举和数据同步。&lt;/p&gt;
&lt;h2 id=&#34;1选举基本原则&#34;&gt;1、选举基本原则&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;选举投票必须在同一轮次中进行&lt;/li&gt;
&lt;li&gt;事务ID 大的节点优先成为 Leader&lt;/li&gt;
&lt;li&gt;服务器ID大的节点优先成为 Leader&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2相关参数&#34;&gt;2、相关参数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;SID：服务器ID&lt;/li&gt;
&lt;li&gt;ZXID：事务ID。在集群范围内全局唯一单调递增，是一个64位的数字，高 32 位是Epoch，低 32 位是单调递增的计数器。每次选举会使 Epoch 加 1，每个写操作会使计数器加1，由于写操作全部由Leader执行，故Leader 节点总是保持着最大的事务 ID，然后根据一致性协议向 Flower 同步数据。由于各 Flower 与 Leader 通信的时差，可能某些 Flower 中保存的数据不是最新的，即各 Flower 的事务 ID 可能不同。事务ID越大说明其保存的数据越新。&lt;/li&gt;
&lt;li&gt;Epoch：选举轮次。每个服务器都会维护一个名为&lt;code&gt;logicClock&lt;/code&gt;的变量，用于标识当前选举的轮次。每开始一次Leader选举，服务器都会将自己存储的&lt;code&gt;logicClock&lt;/code&gt;执行加一操作，并且投票时会附带上这个&lt;code&gt;logicClock&lt;/code&gt;。如果其他服务器收到了一个带有旧的&lt;code&gt;logicClock&lt;/code&gt;的投票，则会直接忽略这个投票。若一个节点中途宕机之后又连接上，由于其保存的是旧的&lt;code&gt;logicClock&lt;/code&gt;，则其不能参与本次选举。&lt;strong&gt;&lt;code&gt;logicClock&lt;/code&gt;变量只在一次Leader选举开始时执行一次递增操作，一次选举中的多轮投票并不会改变&lt;code&gt;logicClock&lt;/code&gt;变量的值。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3节点状态&#34;&gt;3、节点状态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;LOOKING：正在选举。在选举阶段集群不能对外提供服务。&lt;/li&gt;
&lt;li&gt;FOLLOWING：跟随者状态。&lt;/li&gt;
&lt;li&gt;LEADING：领导者状态。&lt;/li&gt;
&lt;li&gt;OBSERVING：观察者状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4选举流程&#34;&gt;4、选举流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;自增选举轮次：每开始一次新的选举，节点先将自己的&lt;code&gt;logicClock&lt;/code&gt;加 1，并且投票时会附带上这个&lt;code&gt;logicClock&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;初始化选票：每个服务器在广播自己的选票前，会将自己的投票箱清空。投票箱记录了所收到的选票。票箱中只会记录每一个投票者的最新的选票。实际上投票箱是一个 Map，节点 id 为键，选票为值，如果收到某个节点的新选票，更新该 Map 即可。&lt;/li&gt;
&lt;li&gt;发送选票：节点给自己投票，将投给自己的选票放入投票箱，然后广播该选票，用于与其它节点交换选票信息。&lt;/li&gt;
&lt;li&gt;接收其他节点广播的选票：对于接收到的其他节点的选票进行&lt;code&gt;logicClock&lt;/code&gt;的校验
&lt;ul&gt;
&lt;li&gt;如果收到的选票中的&lt;code&gt;logicClock&lt;/code&gt;大于自己的&lt;code&gt;logicClock&lt;/code&gt;，则清空自己的投票箱，并更新自己的&lt;code&gt;logicClock&lt;/code&gt;，然后进行步骤5&lt;/li&gt;
&lt;li&gt;如果收到的选票中的&lt;code&gt;logicClock&lt;/code&gt;小于自己的&lt;code&gt;logicClock&lt;/code&gt;，直接丢弃&lt;/li&gt;
&lt;li&gt;如果收到的选票中的&lt;code&gt;logicClock&lt;/code&gt;等于自己的&lt;code&gt;logicClock&lt;/code&gt;，进行步骤5&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;选票比较：首先比较 ZXID，如果收到的选票中的 ZXID 较大，则更新自己的选票。如果 ZXID 一致，则比较 SID，如果收到的选票中的 SID较大，则更新自己的选票。将收到的选票存入投票箱。&lt;/li&gt;
&lt;li&gt;再次发送选票：进过步骤 5 的选票比较，如果自己的选票需要改变，则修改自己的选票并更新到投票箱，然后再次广播出去。&lt;/li&gt;
&lt;li&gt;统计选票：统计自己的投票箱，如果超过半数的节点投票一致，则终止投票。否则继续接收其他节点的投票。&lt;/li&gt;
&lt;li&gt;更新节点状态：若过半的票投给了自己，则将自己的服务器状态更新为LEADING，否则将自己的状态更新为FOLLOWING。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;6选举时机&#34;&gt;6、选举时机&lt;/h2&gt;
&lt;p&gt;当集群第一次启动时会发起一次选举；当 Leader 崩溃后会发起一次选举。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kafka基础</title>
      <link>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/kafka/kafka%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 08 May 2022 17:42:15 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/kafka/kafka%E5%9F%BA%E7%A1%80/</guid>
      <description>&lt;h2 id=&#34;1概述&#34;&gt;1、概述&lt;/h2&gt;
&lt;p&gt;定义：Kafka 是分布式的基于发布订阅的消息队列，主要应用于大数据实时处理领域。&lt;/p&gt;
&lt;p&gt;Kafka基础架构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为方便扩展，并提高吞吐量，一个topic分为多个partition&lt;/li&gt;
&lt;li&gt;写数据通过分区提高效率，为不拖后腿，读数据也采用多个消费者合为一组并发读数据，每个分区只能被一个消费者消费。&lt;/li&gt;
&lt;li&gt;为提高可用性，为每个分区增加副本，分为 leader 和 follower，读写只与 leader 有关，follower 仅仅用作备份与故障选举。&lt;/li&gt;
&lt;li&gt;Kafka 需配合 Zookeeper 使用，Zookeeper 中存储了哪些分区已经上线，以及每个分区的 leader 是谁。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt=&#34;Kafka基础架构&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/kafka/kafka%E5%9F%BA%E7%A1%80/Kafka%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84.png&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Zookeeper基础</title>
      <link>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 08 May 2022 17:42:15 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper%E5%9F%BA%E7%A1%80/</guid>
      <description>&lt;h2 id=&#34;1概述&#34;&gt;1、概述&lt;/h2&gt;
&lt;p&gt;Zookeeper 是一个分布式程序协调服务，提供的主要功能包括：配置管理、名字服务、分布式锁、集群管理。 由 java 编写。&lt;/p&gt;
&lt;h3 id=&#34;11特点&#34;&gt;1.1、特点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一主多从：一个 Leader 负责写数据，多个 Follower 负责读数据。&lt;/li&gt;
&lt;li&gt;集群中只要有半数&lt;strong&gt;以上&lt;/strong&gt;节点存活，Zookeeper 集群就能正常服务，因此 Zookeeper 适合安装奇数台服务器。&lt;/li&gt;
&lt;li&gt;所有节点数据一致&lt;/li&gt;
&lt;li&gt;来自同一个客户端的多个请求按顺序执行&lt;/li&gt;
&lt;li&gt;每个写操作都是事务，具有原子性。&lt;/li&gt;
&lt;li&gt;在一定时间范围内，Client 能读到最新的数据。最终一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12应用场景&#34;&gt;1.2、应用场景&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;分布式协调：客户端先后对不同节点的同一个变量设置不同的值，此时数据不一致。通过 Zookeeper 监听该变量，当变量改变时通知其他节点修改该值。&lt;/li&gt;
&lt;li&gt;分布式锁&lt;/li&gt;
&lt;li&gt;无状态化实现：在分布式登陆场景中，若将用户的登录信息放在某一个节点中，则下一次登录到其他节点就无法获取登录信息。可以将登录信息放在 Zookeeper 中，每个节点都到 Zookeeper 查询登录信息。这样对于每个节点而言就实现了无状态登录。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2数据结构&#34;&gt;2、数据结构&lt;/h2&gt;
&lt;p&gt;Zookeeper 的数据结构类似于 Unix 文件系统，可以看作一棵树，每个节点称为一个 ZNode ，每个 ZNode 都可以通过其路径唯一标识。为了保证高吞吐和低延迟，znode只适合存储非常小的数据，不能超过1M。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;数据结构&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;21节点结构&#34;&gt;2.1、节点结构&lt;/h3&gt;
&lt;p&gt;每个 ZNode 包含四部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;data：保存数据&lt;/li&gt;
&lt;li&gt;acl：权限。 c：创建权限；w：更新权限；r：读权限；d：删除权限；a：管理员权限，允许设置该节点的权限。&lt;/li&gt;
&lt;li&gt;stat：元数据&lt;/li&gt;
&lt;li&gt;child：子节点&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22节点类型&#34;&gt;2.2、节点类型&lt;/h3&gt;
&lt;p&gt;&lt;img alt=&#34;节点类型&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper%E5%9F%BA%E7%A1%80/%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;临时节点&lt;strong&gt;实现原理&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;客户端与服务端之间的连接是基于 TCP 长连接，client 端连接 server 端默认的 2181 端口，也就是 session 会话。&lt;/p&gt;
&lt;p&gt;客户端与服务端建立连接后，服务端会给客户端分配一个全局唯一的  session id。这个  session id 是有期限的，会话期间客户端会定时向服务端发送一个 ping 请求（心跳），服务端每次收到 ping 请求都会给  session id 续约。只要  session id 不过期，临时节点就一直存在。会话断开后，客户端便不再发送 ping 信号，session id 就会过期。服务端会定时查看 session id 是否过期，如果过期就将与之绑定的临时节点删除。&lt;/p&gt;</description>
    </item>
    <item>
      <title>swap</title>
      <link>https://ethereal-lu.github.io/posts/linux/swap/</link>
      <pubDate>Sat, 07 May 2022 10:42:15 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/linux/swap/</guid>
      <description>&lt;p&gt;swap 分区又叫交换分区，这是一块特殊的硬盘空间，即当实际内存不够用的时候，操作系统会从内存中取出一部分暂时不用的数据，放在交换分区中，从而为当前运行的程序腾出足够的内存空间。&lt;/p&gt;
&lt;p&gt;操作系统为每个线程都在内存中分配一定的页框，当属于该进程的页框用完时，就会根据页面置换算法将一部分页面替换到交换分区中。&lt;/p&gt;
&lt;p&gt;磁盘被分为两部分，一部分是存储文件的文件分区，一部分是交换分区。文件分区散列存储，交换分区顺序存储，因此交换分区的读写速度快于文件分区。&lt;/p&gt;
&lt;p&gt;当文件第一次加载到内存时，从文件分区加载，之后置换到交换分区再次被加载时直接从交换分区加载。&lt;/p&gt;</description>
    </item>
    <item>
      <title>进程状态</title>
      <link>https://ethereal-lu.github.io/posts/linux/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/</link>
      <pubDate>Sat, 07 May 2022 10:42:15 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/linux/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/</guid>
      <description>&lt;p&gt;操作系统为每个线程都在内存中分配一定的页框&lt;/p&gt;
&lt;h3 id=&#34;1可运行状态&#34;&gt;1、可运行状态&lt;/h3&gt;
&lt;p&gt;处于运行状态或就绪状态&lt;/p&gt;
&lt;h3 id=&#34;2可中断的阻塞状态&#34;&gt;2、可中断的阻塞状态&lt;/h3&gt;
&lt;p&gt;处于阻塞状态，等待条件满足即可唤醒。同时该状态的进程也会由于接收到信号而提前唤醒。&lt;/p&gt;
&lt;h3 id=&#34;3不可中断的阻塞状态&#34;&gt;3、不可中断的阻塞状态&lt;/h3&gt;
&lt;p&gt;处于阻塞状态，等待条件满足即可唤醒。但该状态的进程对于信号不做任何回应。&lt;/p&gt;
&lt;h3 id=&#34;4暂停状态&#34;&gt;4、暂停状态&lt;/h3&gt;
&lt;p&gt;进程暂时停止，来接收某种特殊处理。&lt;/p&gt;
&lt;h3 id=&#34;5退出状态&#34;&gt;5、退出状态&lt;/h3&gt;
&lt;p&gt;进程退出时会释放掉所有资源，只保留一个&lt;code&gt;task_struct&lt;/code&gt;结构，该结构中保存了进程的&lt;code&gt;pid&lt;/code&gt;和退出码等信息供父进程调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;僵尸进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正常情况下，子进程退出后，父进程会通过调用 wait 或 waitpid 获取子进程的状态信息，并将子进程释放掉。但是如果父进程没有调用，则子进程的&lt;code&gt;task_struct&lt;/code&gt;就会一直保留在系统中，并占用一个 &lt;code&gt;pid&lt;/code&gt;，此时子进程就是一个僵尸进程。&lt;/p&gt;
&lt;p&gt;僵尸进程过多会导致系统中的 &lt;code&gt;pid&lt;/code&gt;不够用，此时可以杀死父进程，使子进程过继给 &lt;code&gt;init&lt;/code&gt;进程来释放子进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;孤儿进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;父进程退出，但是子进程仍然运行，那么这些子进程就是孤儿进程，孤儿进程会被 &lt;code&gt;init&lt;/code&gt;进程收养。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;init 进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;pid为1的进程，又称init进程。 linux系统启动后，第一个被创建的用户态进程就是init进程。它有两项使命：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行系统初始化脚本，创建一系列的进程（它们都是init进程的子孙）；&lt;/li&gt;
&lt;li&gt;在一个死循环中等待其子进程的退出事件，并调用waitid系统调用来完成“收尸”工作；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;init进程不会被暂停、也不会被杀死（这是由内核来保证的）。它在等待子进程退出的过程中处于TASK_INTERRUPTIBLE状态，“收尸”过程中则处于TASK_RUNNING状态。&lt;/p&gt;</description>
    </item>
    <item>
      <title>分库分表</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</link>
      <pubDate>Fri, 06 May 2022 17:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</guid>
      <description>&lt;p&gt;当一张表的字段数过多或数据量过大时，即使添加从库、优化索引，做很多操作时性能仍下降严重。此时就要考虑对其进行切分了，切分的目的就在于减少数据库的负担，缩短查询时间。&lt;/p&gt;
&lt;p&gt;数据库分布式核心内容就是数据切分（Sharding），以及切分后对数据的定位、整合。数据切分就是将数据分散存储到多个数据库中，使得单一数据库中的数据量变小，通过扩充主机的数量缓解单一数据库的性能问题，从而达到提升数据库操作性能的目的。&lt;/p&gt;
&lt;p&gt;数据切分根据其切分类型，可以分为两种方式：垂直（纵向）切分和水平（横向）切分&lt;/p&gt;
&lt;h2 id=&#34;1垂直分库&#34;&gt;1、垂直分库&lt;/h2&gt;
&lt;p&gt;垂直分库就是根据业务耦合性，将关联度低的不同表存储在不同的数据库。减轻数据库的压力。&lt;/p&gt;
&lt;h2 id=&#34;2垂直分表&#34;&gt;2、垂直分表&lt;/h2&gt;
&lt;p&gt;垂直分表是基于数据库中的&amp;quot;列&amp;quot;进行，某个表字段较多，可以新建一张扩展表，将不经常用或字段长度较大的字段拆分出去到扩展表中。在字段很多的情况下（例如一个大表有100多个字段），通过&amp;quot;大表拆小表&amp;quot;，更便于开发与维护，也能避免跨页问题，&lt;a href=&#34;https://jhrtech.cn/sql/135779.html&#34;&gt;MySQL&lt;/a&gt;底层是通过数据页存储的，一条记录占用空间过大会导致跨页，造成额外的性能开销。另外数据库以行为单位将数据加载到内存中，这样表中字段长度较短且访问频率较高，内存能加载更多的数据，命中率更高，减少了磁盘IO，从而提升了数据库性能。&lt;/p&gt;
&lt;p&gt;垂直分表虽然使表的复杂度降低了，但是数据量大的问题依然存在；另外，只有部分字段的表无法 join ，只能通过接口聚合方式解决，提升了开发的复杂度&lt;/p&gt;
&lt;h2 id=&#34;3水平分表&#34;&gt;3、水平分表&lt;/h2&gt;
&lt;p&gt;将一个表中的数据按照一定的规则划分到同一个库中的不同表中，每张表存储一部分数据。库内分表只解决了单一表数据量过大的问题，但没有减轻MySQL数据库的压力，大家还是竞争同一个物理机的硬件资源。&lt;/p&gt;
&lt;h2 id=&#34;4分库分表&#34;&gt;4、分库分表&lt;/h2&gt;
&lt;p&gt;将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。&lt;/p&gt;
&lt;h2 id=&#34;5数据分片规则&#34;&gt;5、数据分片规则&lt;/h2&gt;
&lt;p&gt;数据分片规则指的是水平分表时的规则&lt;/p&gt;
&lt;p&gt;1、&lt;strong&gt;根据数值范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按照时间区间或ID区间来切分。例如：按日期将不同月甚至是日的数据分散到不同的库中；将userId为1&lt;del&gt;9999的记录分到第一个库，10000&lt;/del&gt;20000的分到第二个库，以此类推。某种意义上，某些系统中使用的&amp;quot;冷热数据分离&amp;quot;，将一些使用较少的历史数据迁移到其他库中，业务功能上只提供热点数据的查询，也是类似的实践。&lt;/p&gt;
&lt;p&gt;优点：1、易于扩展；2、若查询条件是时间或id则可以很快地知道在哪个表&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;哈希&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将 id 或某个字段根据哈希函数划分数据&lt;/p&gt;
&lt;p&gt;3、&lt;strong&gt;使用单独的一个数据库来存储映射关系&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL数据类型</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Wed, 04 May 2022 12:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>&lt;h3 id=&#34;1整型&#34;&gt;1、整型&lt;/h3&gt;
&lt;p&gt;&lt;img alt=&#34;int类型&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/int%E7%B1%BB%E5%9E%8B.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int(11)&lt;/strong&gt;：括号中的 11 表示&lt;em&gt;字符的显示宽度&lt;/em&gt;，它不影响存储，即它所能存储的数据还是在上图 int 的范围内。&lt;/p&gt;
&lt;p&gt;那它什么时候起作用：&lt;/p&gt;
&lt;p&gt;只有 int 字段类型设置为无符号且填充零（UNSIGNED  ZEROFILL）时，当数值位数未达到设置的显示宽度时，会在数值前面补充零直到满足设定的显示宽度，为什么会有无符号的限制呢，是因为  ZEROFILL 属性会隐式地将数值转为无符号型，因此不能存储负的数值。&lt;/p&gt;
&lt;p&gt;详见https://www.cnblogs.com/chenmingjun/p/10556206.html&lt;/p&gt;
&lt;h3 id=&#34;2浮点类型&#34;&gt;2、浮点类型&lt;/h3&gt;
&lt;p&gt;MySQL中使用浮点数和定点数来表示小数。&lt;/p&gt;
&lt;p&gt;浮点类型有两种，分别是单精度浮点数（&lt;strong&gt;FLOAT&lt;/strong&gt;）和双精度浮点数（&lt;strong&gt;DOUBLE&lt;/strong&gt;）；定点类型只有一种，就是 &lt;strong&gt;DECIMAL&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;浮点类型和定点类型都可以用&lt;code&gt;(M, D)&lt;/code&gt;来表示，其中&lt;code&gt;M&lt;/code&gt;称为精度，表示总共的位数；&lt;code&gt;D&lt;/code&gt;称为标度，表示小数的位数。&lt;/p&gt;
&lt;p&gt;CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。&lt;/p&gt;
&lt;h3 id=&#34;3字符串&#34;&gt;3、字符串&lt;/h3&gt;
&lt;p&gt;主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。因此，当char类型的长度不够时，会以空格填充。当插入的字符串长度超过括号中设置的长度时报错。&lt;/p&gt;
&lt;h4 id=&#34;31varcharn&#34;&gt;3.1、varchar(n)&lt;/h4&gt;
&lt;p&gt;varchar是动态字符串（跟上面的int不一样）长度是在括号里面指定的，即只能存储小于等于指定长度的字符串，以 varchar(255)举例，该字段最多只能存储255个字符。&lt;/p&gt;
&lt;h4 id=&#34;32varchar255&#34;&gt;3.2、varchar(255)&lt;/h4&gt;
&lt;p&gt;那为什么会经常性设置成varchar(255)呢？&lt;/p&gt;
&lt;p&gt;首先我们要知道一个概念：InnoDB存储引擎的表索引的前缀长度最长是767字节(bytes)，前缀长度意思就是索引中数据的长度，即若给一个varchar类型的字段建索引，则该varchar中最长的字符长度不能超过767字节。&lt;/p&gt;
&lt;p&gt;utf8编码时 255*3=765bytes ,恰恰是能建索引情况下的最大值。（255是字符的长度，3是utf8一个字符占用3个字节）&lt;/p&gt;
&lt;p&gt;如果使用的是utf8mb4编码，默认字符长度则应该是 767除以4向下取整，也就是191。&lt;/p&gt;
&lt;h4 id=&#34;33字符集&#34;&gt;3.3、字符集&lt;/h4&gt;
&lt;p&gt;varchar(n)占用几个字节跟字符集有关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符类型若为gbk，每个字符占用2个字节，&lt;/li&gt;
&lt;li&gt;字符类型若为utf8，每个字符最多占用3个字节&lt;/li&gt;
&lt;li&gt;字符类型若为utf8mb4，每个字符最多占用4个字节&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;34前缀索引&#34;&gt;3.4、前缀索引&lt;/h4&gt;
&lt;p&gt;如果要为三个 varchar 字段建立联合索引，但是三个字段的长度之和加起来超过了767字节，该怎么办？&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UNIQUE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;uniq_code&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;nick_name&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;),&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;account&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;),&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;city&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每个字段取前20字符建立索引，这样的话就是长度就不会超出，这个就是&lt;code&gt;前缀索引&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;35varchar20-和varchar255的开销&#34;&gt;3.5、varchar（20） 和varchar（255）的开销&lt;/h4&gt;
&lt;p&gt;如果要存储&lt;code&gt;&#39;hello12345&#39;&lt;/code&gt;这个字符串，使用&lt;code&gt;varchar(10)&lt;/code&gt;和&lt;code&gt;varchar(100)&lt;/code&gt;存储，占用的磁盘空间是一样的，但是内存消耗不一样。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySQL建立索引时如果没有限制索引的大小，索引长度会默认采用的该字段的长度。因此，加载索引信息时用varchar(255)类型会占用更多的内存。&lt;/li&gt;
&lt;li&gt;由于MySQL通常会分配固定大小的内存块来保存内部值，因此当使用临时表进行排序等操作时会消耗更多的内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;36varchar-与-char&#34;&gt;3.6、varchar 与 char&lt;/h4&gt;
&lt;p&gt;VARCHAR 会保留字符串末尾的空格，而 CHAR 会删除。即对于 &lt;code&gt;“a    ”&lt;/code&gt;，varchar 存储的是 &lt;code&gt;“a    ”&lt;/code&gt;，而char存储的是&lt;code&gt;“a”&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>基础网络攻击</title>
      <link>https://ethereal-lu.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/</link>
      <pubDate>Tue, 03 May 2022 22:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/</guid>
      <description>&lt;h2 id=&#34;1syn洪泛攻击&#34;&gt;1、SYN洪泛攻击&lt;/h2&gt;
&lt;h3 id=&#34;11产生原理&#34;&gt;1.1、产生原理&lt;/h3&gt;
&lt;p&gt;服务器在收到连接请求报文段后，如同意建立连接，就向客户机发回确认，并在OS内核中为该TCP连接分配TCP缓存和变量。除此之外标识该tcp连接的tcb也会占用内存资源。&lt;/p&gt;
&lt;h3 id=&#34;12防御手段&#34;&gt;1.2、防御手段&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;SYN cookie 方法&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在服务器收到客户端的第一次请求之后，不立马分配资源，而是将&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SYN报文的源和目的IP与端口号&lt;/li&gt;
&lt;li&gt;仅仅有服务器知道的密钥&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;塞入一个哈希函数，生成一个认证码；这个认证码也叫cookie；将cookie作为初始序列号，发送给客户端。如果客户端真实存在，则客户端将会带着cookie+1作为ack响应。而服务器可以再次执行上述过程，比较与ack-1是否相同。如果相同，则建立连接。如果客户端不存在，则服务器没有为其消耗任何资源。&lt;/p&gt;
&lt;h3 id=&#34;13tcp的相关细节&#34;&gt;1.3、TCP的相关细节&lt;/h3&gt;
&lt;p&gt;TCB：包含 socket 、指向收发缓冲区的指针、数据包序列号等。&lt;/p&gt;
&lt;p&gt;客户端的TCB在发起连接之前就创建并赋好值；服务端的TCB也在收到连接之前就创建好，但是由于不知道谁会连接自己，故将TCB都初始化为0，当接收到第一次握手的连接请求后，为该tcp分配缓存等资源，并赋值给TCB。因此，在第二次握手时，服务端已经为该tcp连接分配了一部分资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;若第三次握手的ack包丢失会怎样？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;或许由于第二次握手的包丢失，客户端不会发起第三次握手；或者客户端的第三次握手的包丢失。总之，服务端在接收不到第三次握手包时会执行如下操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有收到来自客户端的任何包：根据 TCP的超时重传机制，重新发送第二次握手包，若重发指定次数之后，仍然未收到响应，就会发送reset包，关闭连接，释放资源。&lt;/li&gt;
&lt;li&gt;收到了后续的数据包：由于第三次握手的关键就是其ack，而数据包中也有ack，故连接正常建立并进行通信。如果第三次握手包中不包含数据则不消耗序号。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2dns-劫持&#34;&gt;2、DNS 劫持&lt;/h2&gt;
&lt;p&gt;某些网络运营商为了某些目的，对DNS进行了某些操作，导致用户无法通过域名取得正确的IP地址。&lt;/p&gt;
&lt;p&gt;运营商会利用 DNS 劫持 投放小广告等。DNS污染则让域名直接无法访问了。&lt;/p&gt;
&lt;p&gt;遇到DNS污染只能更换域名服务器或使用第三方域名解析服务。&lt;/p&gt;
&lt;h2 id=&#34;3中间人攻击&#34;&gt;3、中间人攻击&lt;/h2&gt;
&lt;p&gt;前置知识：机器对于 ARP 包是信任的，不做任何安全校验。此方式需要和受害人在同一局域网。&lt;/p&gt;
&lt;p&gt;当客户端发起连接请求时，攻击者向客户端发送大量 ARP 包谎称自己是网关，然后客户端就会将所有请求都发送给攻击者。攻击者收到请求后返回自己的数字证书，并向服务端发送真实的请求。如果客户端不对证书校验，则客户端就会向攻击者发送对称加密密钥并进行后续的加密通信，而攻击者和服务器建立的是正规的安全连接。如此，中间人攻击就成功了，后续攻击者可以对请求和响应进行转发，并动一些手脚。&lt;/p&gt;
&lt;p&gt;也可以利用DNS 劫持发起中间人攻击。&lt;/p&gt;
&lt;p&gt;使用 SSL 身份认证即可防御中间人攻击。&lt;/p&gt;
&lt;h2 id=&#34;4缓冲区溢出攻击&#34;&gt;4、缓冲区溢出攻击&lt;/h2&gt;
&lt;p&gt;通过往程序的缓冲区写超出其长度的内容，造成缓冲区的溢出，使程序转而执行其它指令，以达到攻击的目的。如strcpy()函数，不会对字符串边界进行检查就直接复制，当参数长度大于缓冲区长度时就会造成缓冲区溢出。&lt;/p&gt;
&lt;p&gt;可以通过制造缓冲区溢出使程序运行一个用户shell，再通过shell执行其它命令。如果该程序有root权限的话，攻击者就获得了一个有root权限的shell，可以对系统进行任意操作了。&lt;/p&gt;
&lt;h2 id=&#34;5跨站请求伪造-csrf&#34;&gt;5、跨站请求伪造 CSRF&lt;/h2&gt;
&lt;h3 id=&#34;51同源策略&#34;&gt;5.1、同源策略&lt;/h3&gt;
&lt;p&gt;源由[协议、域名、端口]三元组组成，三元组都一样时称为同源。&lt;/p&gt;
&lt;p&gt;同源策略限制了其他源的脚本对当前页面资源的读写。&lt;/p&gt;
&lt;p&gt;同源策略不会限制发起跨域请求，而是限制 Javascript 对于响应结果的读写。&lt;/p&gt;
&lt;h3 id=&#34;52csrf-原理&#34;&gt;5.2、CSRF 原理&lt;/h3&gt;
&lt;p&gt;用户在登录网站 A 后，在本地浏览器中存储了网站 A 的 Cookie 。之后没有结束与 A 的会话就去访问恶意网站 B ，网站 B 可以通过 img 的 src 向网站 A 发起 GET 请求，或通过表单向网站 A 发起 POST请求。这些请求会自动携带上之前还没有删除的 Cookie ，网站 A 就会认为这是来自用户的一个合法请求并执行它。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis集群</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E9%9B%86%E7%BE%A4/</link>
      <pubDate>Mon, 02 May 2022 21:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E9%9B%86%E7%BE%A4/</guid>
      <description>&lt;p&gt;主从复制和哨兵机制保障了高可用，就读写分离而言虽然slave节点扩展了主从的读并发能力，但是&lt;strong&gt;写能力&lt;/strong&gt;和&lt;strong&gt;存储能力&lt;/strong&gt;是无法进行扩展，就只能是master节点能够承载的上限。如果面对海量数据那么必然需要构建master之间的集群，同时必然需要吸收高可用（主从复制和哨兵机制）能力，即每个master分片节点还需要有slave节点。这就是为社么要使用Redis集群。&lt;/p&gt;
&lt;h2 id=&#34;1概述&#34;&gt;1、概述&lt;/h2&gt;
&lt;p&gt;Redis集群可以理解为n个主从架构组合在一起对外服务。Redis Cluster要求至少需要3个master才能组成一个集群，同时每个master至少需要有一个slave节点。&lt;/p&gt;
&lt;p&gt;如此，Redis集群的写能力和存储能力就是所有master之和了。&lt;/p&gt;
&lt;p&gt;虽然每个master下都挂载了一个slave节点，但是在Redis Cluster中的读、写请求其实都是在&lt;strong&gt;master&lt;/strong&gt;上完成的。slave节点只是充当了一个数据备份的角色，当master发生了宕机，就会将对应的slave节点提拔为master，来重新对外提供服务。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;redis-cluster&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E9%9B%86%E7%BE%A4/redis-cluster.jpg&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-主要模块介绍&#34;&gt;2、 主要模块介绍&lt;/h2&gt;
&lt;h3 id=&#34;21-哈希槽hash-slot&#34;&gt;2.1、 哈希槽(Hash Slot)&lt;/h3&gt;
&lt;p&gt;Redis-cluster没有使用&lt;a href=&#34;https://zhuanlan.zhihu.com/p/129049724&#34;&gt;一致性hash&lt;/a&gt;，而是引入了&lt;strong&gt;哈希槽&lt;/strong&gt;的概念。Redis-cluster中有16384(即2的14次方）个哈希槽，每个key通过CRC16校验后对16383取模来决定放置哪个槽。Cluster中的每个节点负责一部分hash槽（hash slot）。&lt;/p&gt;
&lt;p&gt;一个键的对应的哈希槽通过计算键的CRC16 哈希值，然后对16384进行取模得到：&lt;code&gt;HASH_SLOT=CRC16(key) modulo 16383&lt;/code&gt;。读写操作都是先计算出键的哈希槽，再在负责该哈希槽的 master 上进行相应操作。&lt;/p&gt;
&lt;h3 id=&#34;22cluster总线&#34;&gt;2.2、Cluster总线&lt;/h3&gt;
&lt;p&gt;每个Redis Cluster节点有一个额外的TCP端口用来接受其他节点的连接。这个端口为普通 client 端口 + 10000。如普通 client 端口为6379，则总线端口为 16379。节点到节点的通讯只使用集群总线。&lt;/p&gt;
&lt;h3 id=&#34;23集群拓扑&#34;&gt;2.3、集群拓扑&lt;/h3&gt;
&lt;p&gt;Redis Cluster是一张全网拓扑，节点与其他每个节点之间都保持着TCP连接。&lt;/p&gt;
&lt;h3 id=&#34;24节点握手&#34;&gt;2.4、节点握手&lt;/h3&gt;
&lt;p&gt;节点认定其他节点是当前集群的一部分有两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果一个节点出现在了一条MEET消息中。meet消息会强制接收者接受一个节点作为集群的一部分。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从某个已信任的节点处获知某节点是集群的一部分，则当前节点也会将该节点当成集群的一部分。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3状态检测及维护&#34;&gt;3、状态检测及维护&lt;/h2&gt;
&lt;p&gt;在集群模式下，所有的publish命令都会向所有节点（包括从节点）进行广播，加重了带宽负担，对于在有大量节点的集群中频繁使用pub，会严重消耗带宽，不建议使用。&lt;/p&gt;
&lt;h3 id=&#34;31gossip协议&#34;&gt;3.1、Gossip协议&lt;/h3&gt;
&lt;p&gt;gossip 协议是基于流行病传播方式的节点或者进程之间信息交换的协议。Gossip协议的最大的好处是，即使集群节点的数量增加，每个节点的负载也不会增加很多，几乎是恒定的。&lt;/p&gt;
&lt;p&gt;Gossip的特点：在一个有界网络中，每个节点都随机地与其他节点通信，经过一番杂乱无章的通信，最终所有节点的状态都会达成一致。每个节点可能知道所有其他节点，也可能仅知道几个邻居节点，只要这些节可以通过网络连通，最终他们的状态都是一致的。即Gossip协议是最终一致性，不是强一致性。&lt;/p&gt;
&lt;h3 id=&#34;32基于gossip协议的故障检测&#34;&gt;3.2、基于Gossip协议的故障检测&lt;/h3&gt;
&lt;p&gt;集群中的每个节点都会不定时地向集群中的其他节点发送PING消息，以此交换各个节点状态信息。&lt;/p&gt;
&lt;p&gt;当节点 1 向节点 3 发送PING消息后未在规定时间内收到节点 3 的PONG响应，则节点 1 认为节点 3 PFAIL（主观下线）。当节点1标记节点3为PFAIL后，节点1会通过Gossip消息把这个信息发送给其他节点，接收到信息的节点会进行节点3客观下线状态判定。当节点2接收到来自节点1关于节点3的状态判定信息之后，节点2首先会把节点1加入到节点3的下线报告列表(Fail Report)中。每个节点都会维护一个下线报告列表，主要维护一个节点被哪些节点报告处于下线状态。&lt;/p&gt;
&lt;p&gt;只有同样认为节点3处于PFAIL状态的节点才会去做客观下线状态判定，即只有节点2也曾向节点3发送ping且没有得到响应，节点2才会去做客观下线状态判定：如果自己维护的节点3的下线报告列表中包含&lt;strong&gt;一半以上的主节点&lt;/strong&gt;（即超过半数的主节点认为节点3主观下线），则认为节点3 FAIL（客观下线）。&lt;/p&gt;
&lt;p&gt;一旦节点2认为节点3客观下线，就向集群广播节点3的FAIL消息，所有收到FAIL消息的节点都会立即将节点3的状态标记为已下线。&lt;/p&gt;
&lt;p&gt;疑问：节点2是否可以是从节点？即从节点是否参与故障检测，是否拥有下线报告列表，是否做客观下线判断，是否能发广播？&lt;/p&gt;
&lt;h2 id=&#34;4-故障恢复failover&#34;&gt;4、 故障恢复（Failover）&lt;/h2&gt;
&lt;p&gt;当slave发现自己的master变为FAIL状态时，便尝试进行Failover，以期成为新的master。由于挂掉的master可能会有多个slave。Failover的过程需要经过类Raft协议的过程在整个集群内达到一致， 其过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;slave发现自己的master变为FAIL&lt;/li&gt;
&lt;li&gt;长时间不与主节点通信的从节点不具备竞选资格&lt;/li&gt;
&lt;li&gt;所有竞选者随即休眠，唤醒后立即通过广播向所有节点拉票&lt;/li&gt;
&lt;li&gt;其他节点收到拉票请求，只有master响应，若本轮竞选中自己没投过票就投，否则不投票，即每个主节点只有一次投票机会&lt;/li&gt;
&lt;li&gt;从节点发现超过半数的主节点为自己投票就变成新Master：接替旧master 的slot，并让旧master与其他从节点成为自己的从节点&lt;/li&gt;
&lt;li&gt;广播Pong通知其他集群节点自己成为新的主节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;易知，休眠时间最短的节点容易获得大部分投票。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis主从复制</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Mon, 02 May 2022 15:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</guid>
      <description>&lt;h1 id=&#34;1概述&#34;&gt;1、概述&lt;/h1&gt;
&lt;p&gt;主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。主从节点建立连接后会保持心跳检测。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主从复制的作用&lt;/strong&gt;主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据冗余&lt;/strong&gt;：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;故障恢复&lt;/strong&gt;：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务。尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高可用基石&lt;/strong&gt;：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主从库之间采用的是&lt;strong&gt;读写分离&lt;/strong&gt;的方式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读操作：主库、从库都可以接收；&lt;/li&gt;
&lt;li&gt;写操作：首先到主库执行，然后，主库将写操作同步给从库。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于 Redis 的主从复制是通过异步实现的，在主从复制期间任然可以对外提供服务，因此属于 AP 模型，实现的是最终一致性。&lt;/p&gt;
&lt;h1 id=&#34;2原理&#34;&gt;2、原理&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;全量（同步）复制&lt;/code&gt;：主库的全部数据同步给从库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;增量（同步）复制&lt;/code&gt;：只会把主从库网络断连期间主库收到的命令，同步给从库&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;21全量复制&#34;&gt;2.1、全量复制&lt;/h2&gt;
&lt;p&gt;当我们启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;replicaof &lt;span style=&#34;color:#ae81ff&#34;&gt;172.16.19.3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;6379&lt;/span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// 当前实例作为 172.16.19.3 6379 的从库
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;全量复制的三个阶段&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一阶段是主从库间建立连接、协商同步的过程：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 从库发出如下命令请求数据同步
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;psync &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;？&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 第一个参数为 runID ,唯一标识一个实例。由于第一次请求不知道主库的 runID ，故使用 ？
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 第二个参数为数据同步的偏移量 offset ，-1 表示从头开始同步。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;主库收到请求后返回自己的 runID 和当前同步进度 offset，从库记录下来用于后续同步操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二阶段，主库将所有数据同步给从库：主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。数据同步的过程中主库新接收的写操作记录在 replication buffer 中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库：主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis哨兵机制</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 02 May 2022 15:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;p&gt;由于主从模式是读写分离的，如果主节点故障，那么将没有主节点来执行写操作，也没有主节点给从节点进行数据同步了。若是每次主节点故障都需要人工切换主从节点太繁琐，于是哨兵机制出现了。哨兵的核心功能是主节点的自动故障转移。&lt;/p&gt;
&lt;h2 id=&#34;1哨兵集群的组建&#34;&gt;1、哨兵集群的组建&lt;/h2&gt;
&lt;p&gt;哨兵实例之间可以相互发现，要归功于 Redis 提供的发布 / 订阅机制。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先主节点的信息配置在哨兵(Sentinel)的配置文件中&lt;/li&gt;
&lt;li&gt;哨兵节点会和配置的主节点建立起连接&lt;/li&gt;
&lt;li&gt;哨兵每10秒会向主节点发送info命令，主节点会返回自己的run_id和自己的从节点信息。&lt;/li&gt;
&lt;li&gt;哨兵会对这些从节点也建立连接。之后&lt;strong&gt;每10秒会向主节点和从节点都发送info命令&lt;/strong&gt;以获取最新的拓扑结构。&lt;/li&gt;
&lt;li&gt;每个哨兵都订阅主节点的&lt;code&gt;_sentinel:hello&lt;/code&gt;频道，且&lt;strong&gt;每2秒向该频道发布自己的信息&lt;/strong&gt;，各哨兵由此与其他哨兵建立连接。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;每隔1秒每个哨兵会向主节点、从节点、其他哨兵发送ping命令，做心跳检测。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述 6 点中，加粗部分为每个哨兵的三个定时任务。&lt;/p&gt;
&lt;h2 id=&#34;2主库下线的判定&#34;&gt;2、主库下线的判定&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主观下线&lt;/strong&gt;：哨兵节点每隔1秒向各节点发送PING命令，如果在规定时间内没有收到有效响应，哨兵就会将该节点标记为主观下线。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客观下线&lt;/strong&gt;：当某个哨兵判断主库主观下线后，就会给其他哨兵发起询问，其他哨兵会根据自己和主库的连接情况，做出赞成或反对的响应。如果赞成票数大于等于哨兵配置文件中的配置项 &lt;code&gt;quorum&lt;/code&gt; 的值, 则判定主库客观下线。&lt;code&gt;quorum&lt;/code&gt; 的值一般为哨兵个数 / 2 + 1。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3新主库选取&#34;&gt;3、新主库选取&lt;/h2&gt;
&lt;p&gt;根据以下规则选取新主库：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;过滤掉网络状态不好的：redis 有一个参数用于表示主从节点的通信超时时间，如果从节点的超时次数超过10次，说明这个从节点的网络状况不好，不适合作为新主节点。&lt;/li&gt;
&lt;li&gt;选择从节点优先级最高的（redis.conf 中有一个配置项&lt;code&gt;salve-priority&lt;/code&gt;表示从节点优先级）&lt;/li&gt;
&lt;li&gt;优先级相同时选择复制偏移量最大的&lt;/li&gt;
&lt;li&gt;若优先级和偏移量都相同，则选择 id 号小的&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4选举leader哨兵&#34;&gt;4、选举Leader哨兵&lt;/h2&gt;
&lt;p&gt;新主库选取选举之后需要进行故障转移，但是哨兵节点有多个，需要选举一个 leader 哨兵来负责进行主从切换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选举算法&lt;/strong&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/32052223&#34;&gt;Raft选举算法&lt;/a&gt;：哪个哨兵节点判断主节点为「客观下线」，这个哨兵节点就是候选者。候选者会向其他哨兵发送命令，表明希望成为 Leader 来执行主从切换，并让所有其他哨兵对它进行投票。每个哨兵只有一次投票机会，如果用完后就不能参与投票了，可以投给自己或投给别人，但是只有候选者才能把票投给自己。若只有一个候选者，则其他哨兵会将票投给它，若有多个候选者，即多个哨兵同时判断主节点为「客观下线」，此时其他非候选者哨兵会对它收到的第一个拉票候选者投票，对后续收到的其他拉票请求给予拒绝。&lt;/p&gt;
&lt;p&gt;一个候选者若能成为 Leader ，那它获得的赞成票必须既大于哨兵节点的一半又大于&lt;code&gt;quorum&lt;/code&gt;的值。如果所有候选者都不满足，则发起下一轮选举。&lt;/p&gt;
&lt;p&gt;若有超过一半的哨兵宕机，则无法完成Leader哨兵的选举。&lt;/p&gt;
&lt;h2 id=&#34;5故障转移&#34;&gt;5、故障转移&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;通过 &lt;code&gt;slave of no one&lt;/code&gt; 命令将 4 中选举的从节点变为主节点。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;replicaof&lt;/code&gt;命令将其他从节点和旧的主节点都成为新主节点的从节点。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    <item>
      <title>Redis底层数据结构</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 01 May 2022 17:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>&lt;h2 id=&#34;1压缩列表---ziplist&#34;&gt;1、压缩列表 - ZipList&lt;/h2&gt;
&lt;p&gt;Redis是基于内存的nosql，有些场景下为了节省内存redis会用“时间”换“空间”。ziplist就是很典型的例子。&lt;/p&gt;
&lt;h3 id=&#34;11整体布局&#34;&gt;1.1、整体布局&lt;/h3&gt;
&lt;p&gt;ziplist是为了&lt;strong&gt;节省内存空间&lt;/strong&gt;而设计的由一系列特殊编码的&lt;strong&gt;连续内存块&lt;/strong&gt;组成的&lt;strong&gt;顺序存储&lt;/strong&gt;结构，类似于数组，ziplist在内存中是连续存储的，但是不同于数组，为了节省内存 ziplist的每个元素所占的内存大小可以不同（数组中叫元素，ziplist叫节点&lt;strong&gt;entry&lt;/strong&gt;），每个节点可以用来存储一个整数或者一个字符串。存储整数时是采用整数的二进制而不是字符串形式存储。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;ziplist内存布局&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ziplist%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;zlbytes: ziplist的长度（单位: 字节)，是一个32位无符号整数&lt;/li&gt;
&lt;li&gt;zltail: ziplist最后一个节点的偏移量，反向遍历ziplist或者pop尾部节点的时候有用。&lt;/li&gt;
&lt;li&gt;zllen: ziplist的节点（entry）个数&lt;/li&gt;
&lt;li&gt;entry: 节点&lt;/li&gt;
&lt;li&gt;zlend: 值为0xFF，用于标记ziplist的结尾&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12节点的布局entry&#34;&gt;1.2、节点的布局(entry)&lt;/h3&gt;
&lt;p&gt;每个节点由三部分组成：prevlength、encoding、data&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;prevlengh: 记录上一个节点的长度，为了方便反向遍历ziplist&lt;/li&gt;
&lt;li&gt;encoding: 当前节点的编码规则&lt;/li&gt;
&lt;li&gt;data: 当前节点的值，可以是数字或字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了节省内存，根据上一个节点的长度prevlength 可以将ziplist节点分为两类：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;entry布局&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/entry%E5%B8%83%E5%B1%80.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;entry的前8位小于254，则这8位就表示上一个节点的长度&lt;/li&gt;
&lt;li&gt;entry的前8位等于254，则意味着上一个节点的长度无法用8位表示，后面32位才是真实的prevlength。用254 不用255(11111111)作为分界是因为255是zlend的值，它用于判断ziplist是否到达尾部。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据当前节点存储的数据类型及长度，可以将ziplist节点分为9类：&lt;/p&gt;
&lt;p&gt;当 encoding 的高两位为 11 时表明是整数节点，否则表明是字符串节点。其中整数节点共有 6 中类型（int16、int32、int64等），字符串节点共有3中类型（3种类型的字符串长度不同）。&lt;/p&gt;
&lt;h3 id=&#34;13复杂度&#34;&gt;1.3、复杂度&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;新建 ZipList：O(1)&lt;/li&gt;
&lt;li&gt;查找：O(n)&lt;/li&gt;
&lt;li&gt;插入：O(n)&lt;/li&gt;
&lt;li&gt;删除：O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;14总结&#34;&gt;1.4、总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ziplist是为节省内存空间而生的。让每个元素按照实际的内容大小存储，不浪费空间。&lt;/li&gt;
&lt;li&gt;ziplist是一个为Redis专门提供的底层数据结构之一，本身可以有序也可以无序。当作为&lt;strong&gt;list&lt;/strong&gt;和&lt;strong&gt;hash&lt;/strong&gt;的底层实现时，节点之间没有顺序；当作为&lt;strong&gt;zset&lt;/strong&gt;的底层实现时，节点之间会按照大小顺序排列。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2快表---quicklist&#34;&gt;2、快表 - QuickList&lt;/h2&gt;
&lt;p&gt;在Redis的早期版本中，存储list列表结构时，如果元素少则使用压缩列表ziplist，否则使用双向链表linkedlist。&lt;/p&gt;
&lt;p&gt;但是考虑到链表的每个节点都要有两个指针，prev 和 next 指针要占去 16 个字节 (64bit 系统的指针是 8 个字节)。因此Redis3.2版本开始使用 quicklist 代替了 ziplist 和 linkedlist。&lt;/p&gt;
&lt;p&gt;quicklist 实际上是 zipList 和 linkedList 的混合体，它将 linkedList 中的多个节点并为一个 quicklistNode，使用 zipList 来紧凑存储，多个 zipList 之间使用双向指针串接起来。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux基础</title>
      <link>https://ethereal-lu.github.io/posts/linux/linux%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Thu, 28 Apr 2022 14:42:15 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/linux/linux%E5%9F%BA%E7%A1%80/</guid>
      <description>&lt;h3 id=&#34;1binbash&#34;&gt;1、#!/bin/bash&lt;/h3&gt;
&lt;p&gt;shell 脚本第一行的 &lt;code&gt;#!/bin/bash&lt;/code&gt; 用于指定执行该文件的解释器路径，不写默认是 &lt;code&gt;/bin/bash&lt;/code&gt;；也可以执行时手动指定解释器路径，如：&lt;code&gt;/usr/bin/python3 test_py&lt;/code&gt;，手动指定优先级高于文件内第一行指定的优先级。&lt;/p&gt;
&lt;h3 id=&#34;2-binsbinusrsbinusrbin&#34;&gt;2、 /bin；/sbin；/usr/sbin；/usr/bin&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;/bin&lt;/strong&gt; 存放系统的一些指令。如：ls、chmod、rm、cp、mkdir、su等等&lt;/li&gt;
&lt;li&gt;**/sbin **存放超级用户指令。如：shutdown、halt、init、ifconfig、fdisk等等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/usr/bin&lt;/strong&gt; 存放用户后期安装的一些软件的运行脚本。如：awk、man、python3、c++、less等等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/usr/sbin&lt;/strong&gt;  存放一些用户安装的系统命令：如：httpd、netconfig、swap等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3软硬链接&#34;&gt;3、软硬链接&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;硬链接是指针，所有的硬链接都是指向同一个磁盘块。 删除一个指针不会真正删除文件，只有把所有的指针都删除才会真正删除文件。&lt;/li&gt;
&lt;li&gt;软链接是另外一种类型的文件，保存的是它指向文件的全路径，访问时会替换成绝对路径。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4查看-cpumem-信息&#34;&gt;4、查看 cpu、mem 信息&lt;/h3&gt;
&lt;p&gt;查看 cpu 信息： &lt;code&gt;cat /proc/cpuinfo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看内存信息：&lt;code&gt;cat /proc/meminfo&lt;/code&gt;；&lt;code&gt;free&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此外：&lt;code&gt;top&lt;/code&gt;命令动态显示进程信息，其中也包含 cpu 和 mem 的使用情况。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis缓存一致性</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</link>
      <pubDate>Mon, 25 Apr 2022 22:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</guid>
      <description>&lt;h3 id=&#34;1先更新缓存再更新db&#34;&gt;1、先更新缓存再更新DB&lt;/h3&gt;
&lt;p&gt;缓存更新后 DB 更新失败回滚，此时缓存与 DB 数据不一致。因此不推荐&lt;/p&gt;
&lt;h3 id=&#34;2先删除缓存再更新db&#34;&gt;2、先删除缓存再更新DB&lt;/h3&gt;
&lt;p&gt;删除缓存后立即来一条线程查询，此时 DB 可能还未更新完成，读取到了旧值，这相当于白删了，做了无用功。不推荐。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因此最好先操作 DB 再操作缓存&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;3先更新db再更新缓存&#34;&gt;3、先更新DB再更新缓存&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;更新操作远多于查询操作时，对于缓存的更新完全是没必要的，浪费。&lt;/li&gt;
&lt;li&gt;并发修改问题：若线程A、B同时修改数据，A先修改DB，释放锁后B再修改；但是有可能 B 先于 A 修改缓存（STW），此时 A 覆盖了缓存中 B 的修改，导致不一致问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;因此最好删除缓存而不是更新缓存&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;4先更新db再删除缓存&#34;&gt;4、先更新DB再删除缓存&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;延迟双删&lt;/strong&gt;：更新期间读取的是旧值；第一次删除后，读取线程可能因操作缓慢将读到旧值写回缓存中，为了避免缓存中一直是旧值，需要在一定时间后再次删除缓存，保证之后的读取线程写回缓存的值为更新后的值。这段时间应该大于线程读数据 + 写缓存的时间。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;putValue&lt;/span&gt;(key, value){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    putToDB(key, value);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    deleteFromRedis(key);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 5秒之后再次进行删除&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    deleteFromRedisDelay(key, 5second);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;5其他策略&#34;&gt;5、其他策略&lt;/h3&gt;
&lt;p&gt;如果对于一致性要求不高，可以将缓存中数据的过期时间设置的短一些（如 5 秒），这样每过  5 秒，缓存就会从 DB 中取一次最新值。&lt;/p&gt;</description>
    </item>
    <item>
      <title>缓存穿透、击穿、雪崩</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E9%9B%AA%E5%B4%A9/</link>
      <pubDate>Sat, 16 Apr 2022 22:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E9%9B%AA%E5%B4%A9/</guid>
      <description>&lt;h2 id=&#34;1缓存穿透&#34;&gt;1、缓存穿透&lt;/h2&gt;
&lt;h3 id=&#34;11问题描述&#34;&gt;1.1、问题描述&lt;/h3&gt;
&lt;p&gt;如果在请求数据时，在缓存层和数据库层都没有命中，这种情况就叫作缓存穿透。&lt;/p&gt;
&lt;p&gt;造成缓存穿透的主要原因就是：查询某个 Key 对应的数据，Redis 缓存中没有相应的数据，则直接到数据库中查询。数据库中也不存在要查询的数据，则数据库会返回空，而 Redis 也不会缓存这个空结果。这就造成每次通过这样的 Key 去查询数据都会直接到数据库中查询，Redis 不会缓存空结果。这就造成了缓存穿透的问题。&lt;/p&gt;
&lt;h3 id=&#34;12解决办法&#34;&gt;1.2、解决办法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;将空对象也缓存起来。即如果某个 key 在缓存和数据库都没有命中，就将该 key 的值置为空对象缓存到 redis。&lt;/li&gt;
&lt;li&gt;布隆过滤器。将所有的 key 都存放在足够大的布隆过滤器中，每次查询先由其对 key 过滤，若布隆过滤器命中，则该 key 有可能存在，若布隆过滤器未命中，则该 key 一定不存在。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13布隆过滤器&#34;&gt;1.3、布隆过滤器&lt;/h3&gt;
&lt;p&gt;布隆过滤器由一个 bit 数组和若干哈希函数组成。&lt;/p&gt;
&lt;p&gt;初始时将 bit 数组所有位置置 0。&lt;/p&gt;
&lt;p&gt;对任意一个 key，通过哈希函数得到哈希值，将该哈希值对 bit 数组的长度取余就得到一个确定的位置，将该位置置为 1。对所有的哈希函数都执行上述操作，则一个 key 会对应多个位置。&lt;/p&gt;
&lt;p&gt;查询时，对 key 进行同样的操作，若得到的所有位置都为 1，则该 key 有很大的可能存在；若有任意一个位置不为 1，则该值一定不存在。&lt;/p&gt;
&lt;p&gt;之所以命中时是很有可能存在，根本问题是哈希的碰撞，可能其他一个或多个值的哈希映射与该值的所有映射碰撞，则无法判断该值是否存在。&lt;/p&gt;
&lt;p&gt;布隆过滤器无法删除元素，一是无法精确判断该值是否存在，二是删除后会使得其他值在该点的碰撞映射删除导致误判。&lt;/p&gt;
&lt;p&gt;应用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;redis 缓存穿透&lt;/li&gt;
&lt;li&gt;爬虫或其他业务中判断是否访问过某 url&lt;/li&gt;
&lt;li&gt;web 拦截器，拦截重复请求，防止重复攻击&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2缓存击穿&#34;&gt;2、缓存击穿&lt;/h2&gt;
&lt;h3 id=&#34;21问题描述&#34;&gt;2.1、问题描述&lt;/h3&gt;
&lt;p&gt;缓存数据都设置有过期时间，当高峰期对于某个热点数据有大量访问，若此时该数据正好过期，则大量的访问就直接落到数据库中，导致数据库崩溃。&lt;/p&gt;
&lt;h3 id=&#34;22解决办法&#34;&gt;2.2、解决办法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;对于热点数据不设置过期时间&lt;/li&gt;
&lt;li&gt;使用分布式锁。只有第一个到达的访问获取锁去数据库读取数据并写回缓存，其他的访问竞争锁失败陷入等待并循环查询缓存。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3缓存雪崩&#34;&gt;3、缓存雪崩&lt;/h2&gt;
&lt;h3 id=&#34;31问题描述&#34;&gt;3.1、问题描述&lt;/h3&gt;
&lt;p&gt;若缓存服务器突然故障宕机，则大量请求就会直接淹没数据库，此时若不采取其他措施就直接重启数据库，它又会立刻被淹没，这就是缓存雪崩。&lt;/p&gt;
&lt;h3 id=&#34;32解决办法&#34;&gt;3.2、解决办法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;redis 集群，保证高可用&lt;/li&gt;
&lt;li&gt;限流，通过分布式锁限制访问数据库的线程数量&lt;/li&gt;
&lt;li&gt;数据预热 ，可能产生大量访问之前，手动将数据加载到缓存，对数据设置不同的过期时间，使其均匀过期。（感觉像是缓存击穿的解决方法呢？）&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Redis分布式锁</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link>
      <pubDate>Tue, 12 Apr 2022 22:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid>
      <description>&lt;h2 id=&#34;1什么是分布式锁&#34;&gt;1、什么是分布式锁&lt;/h2&gt;
&lt;p&gt;分布式锁，顾名思义，就是分布式项目开发中用到的锁，可以用来控制分布式系统之间同步访问共享资源，一般来说，分布式锁需要满足的特性有这么几点：&lt;/p&gt;
&lt;p&gt;1、互斥性：在任何时刻，对于同一条数据，只有一台应用可以获取到分布式锁；&lt;/p&gt;
&lt;p&gt;2、高可用性：在分布式场景下，一小部分服务器宕机不影响正常使用，这种情况就需要将提供分布式锁的服务以集群的方式部署；&lt;/p&gt;
&lt;p&gt;3、防止锁超时：如果客户端没有主动释放锁，服务器会在一段时间之后自动释放锁，防止客户端宕机或者网络不可达时产生死锁；&lt;/p&gt;
&lt;p&gt;4、独占性：加锁解锁必须由同一台服务器进行，也就是锁的持有者才可以释放锁，不能出现你加的锁，别人给你解锁了；&lt;/p&gt;
&lt;h2 id=&#34;2实现分布式锁&#34;&gt;2、实现分布式锁&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Redis&lt;/code&gt;分布式锁主要是通过&lt;code&gt;SETNX&lt;/code&gt;和&lt;code&gt;SETEX&lt;/code&gt;这两个命令实现的。这两个命令都是原子操作。&lt;/p&gt;
&lt;p&gt;核心思想就是每次想要获取锁的时候，就对一个固定的 key 值以 &lt;code&gt;SETNX&lt;/code&gt;的方式存放，如果成功，就说明获取锁成功，否则以自旋的方式持续获取锁，直到超时获取失败。&lt;/p&gt;
&lt;p&gt;解锁通过 LUA 代码实现，LUA是原子性的。&lt;/p&gt;
&lt;p&gt;注：下方代码只体现实现锁的思想，不能实际使用。实际开发中使用 Redisson 。&lt;/p&gt;
&lt;h2 id=&#34;3分布式锁的缺陷&#34;&gt;3、分布式锁的缺陷&lt;/h2&gt;
&lt;p&gt;一、客户端长时间阻塞导致锁失效问题&lt;/p&gt;
&lt;p&gt;客户端1得到了锁，因为网络问题或者GC等原因导致长时间阻塞，然后业务程序还没执行完锁就过期了，这时候客户端2也能正常拿到锁，可能会导致线程安全的问题。&lt;/p&gt;
&lt;p&gt;二、redis服务器时钟漂移问题&lt;/p&gt;
&lt;p&gt;如果redis服务器的机器时钟发生了向前跳跃，就会导致这个key过早超时失效，比如说客户端1拿到锁后，key的过期时间是12:02分，但redis服务器本身的时钟比客户端快了2分钟，导致key在12:00的时候就失效了，这时候，如果客户端1还没有释放锁的话，就可能导致多个客户端同时持有同一把锁的问题。&lt;/p&gt;
&lt;p&gt;三、单点实例安全问题&lt;/p&gt;
&lt;p&gt;如果redis是单master模式的，当这台机宕机的时候，那么所有的客户端都获取不到锁了，为了提高可用性，可能就会给这个master加一个slave，但是因为redis的主从同步是异步进行的，可能会出现客户端1设置完锁后，master挂掉，但此时数据还没有同步给slave 节点，当slave提升为master后，客户端1设置的锁丢失了，这时候客户端2设置锁也能够成功，导致客户端1和客户端2同时拥有锁。因此 reids 实现的分布式锁是 AP 模型。&lt;/p&gt;
&lt;h2 id=&#34;4redlock&#34;&gt;4、RedLock&lt;/h2&gt;
&lt;p&gt;针对上述问题，官方推出了 RedLock 算法，RedLock 算法用于解决 Redis 集群中向一个 master 节点设置锁后该节点挂了，这时向其他 master 节点设置锁一定成功的问题。获取锁时在超过半数的实例中设置了锁就认为获取到了锁，解锁时将所有实例解锁。&lt;/p&gt;
&lt;p&gt;RedLock 不足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;宕机重启之后，2个客户端拿到同一把锁：假设5个节点是A, B, C, D, E，客户端1在A, B, C上面拿到锁，D, E没有拿到锁，客户端1拿锁成功。 此时，C挂了重启，C上面锁的数据丢失（假设机器断电，数据还没来得及刷盘；或者C上面的主节点挂了，从节点未同步）。客户端2去取锁，从C, D, E 3个节点拿到锁，A, B没有拿到（还被客户端1持有），客户端2也超过多数派，也会拿到锁。&lt;/li&gt;
&lt;li&gt;多个客户端同时竞争同一把锁，全部失败：比如有节点1、2、3、4、5，A、B、C同时竞争锁，A获得1、2,B获得3、4,C获得5,最后ABC都没有成功获得锁，没有获得半数以上的锁。需要强调，当客户端从大多数Redis实例获取锁失败时，应该尽快地释放（部分）已经成功取到的锁，方便别的客户端去获取锁，假如释放锁失败了，就只能等待锁超时释放了&lt;/li&gt;
&lt;li&gt;效率低：需要顺序向所有 master 节点设置锁，master 节点越多，效率越低&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5redisson&#34;&gt;5、Redisson&lt;/h2&gt;
&lt;p&gt;Redisson 分布式锁通过 hash 实现，hash 名作为锁，hash 中的键为 线程ID，值为 重入次数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加锁时设置了过期时间&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis持久化</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/</link>
      <pubDate>Sat, 09 Apr 2022 23:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/</guid>
      <description>&lt;h2 id=&#34;1redis-核心主流程&#34;&gt;1、Redis 核心主流程&lt;/h2&gt;
&lt;p&gt;AOF 和 RDB 的持久化过程中，有不少操作是在时间事件 serverCron 中被触发的。所以，这边有必要先了解下 Redis 中的事件核心流程。&lt;/p&gt;
&lt;p&gt;Redis 的服务器进程就是一个事件循环，最重要的有两个事件：文件事件和时间事件。Redis 在服务器初始化后，会无限循环，处理产生的文件事件和时间事件。&lt;/p&gt;
&lt;p&gt;文件事件常见的有：接受连接（accept）、读取（read）、写入（write）、关闭连接（close）等。使用 IO 多路复用处理。&lt;/p&gt;
&lt;p&gt;时间事件中常见的就是 serverCron，redis 核心流程中通常也只有这个时间事件。serverCron 默认配置下每100ms会被触发一次，在该时间事件中，会执行很多操作：清理过期键、AOF 后台重写、RDB 的 save point 的检查、将 aof_buf 内容写到磁盘上（flushAppendOnlyFile 函数）等等。&lt;/p&gt;
&lt;h2 id=&#34;2redis持久化&#34;&gt;2、Redis持久化&lt;/h2&gt;
&lt;p&gt;Redis是内存数据库，若不持久化到磁盘中，则redis进程一旦退出，数据就会丢失，因此需要持久化。&lt;/p&gt;
&lt;p&gt;Redis 的持久化机制有以下三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RDB&lt;/li&gt;
&lt;li&gt;AOF&lt;/li&gt;
&lt;li&gt;混合持久化（redis4.0引入）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;21rdbredis-database&#34;&gt;2.1、RDB(Redis DataBase)&lt;/h3&gt;
&lt;p&gt;描述：类似于快照。在某个时间点，将 Redis 在内存中的数据保存到磁盘里面。RDB 持久化功能生成的 RDB 文件是经过压缩的二进制文件。恢复时将快照文件直接读入内存。&lt;/p&gt;
&lt;p&gt;rdb保存的文件是dump.rdb。同样可以在redis.conf中修改&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;在redis.conf中对自动保存的间隔进行设置
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# save 3600 1        After 3600 seconds (an hour) if at least 1 key changed&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# save 300 100       After 300 seconds (5 minutes) if at least 100 keys changed&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# save 60 10000      After 60 seconds if at least 10000 keys changed&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;211触发条件&#34;&gt;2.1.1、触发条件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;自动触发&lt;/strong&gt;（全部是BGSAVE）&lt;/p&gt;</description>
    </item>
    <item>
      <title>IO 多路复用</title>
      <link>https://ethereal-lu.github.io/posts/linux/io/</link>
      <pubDate>Sat, 09 Apr 2022 19:42:15 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/linux/io/</guid>
      <description>&lt;h2 id=&#34;1概念&#34;&gt;1、概念&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;IO多路复用&lt;/strong&gt;是一种同步IO模型，实现一个线程可以监视多个文件描述符；一旦某个文件描述符就绪，就能够通知应用程序进行相应的读写操作；没有文件描述符就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/143847169&#34;&gt;文件描述符&lt;/a&gt;&lt;/strong&gt;：Linux 中一切都可以看作文件，包括普通文件、链接文件、Socket  以及设备驱动等，对其进行相关操作时，都可能会创建对应的文件描述符。文件描述符（file  descriptor）是内核为了高效管理已被打开的文件所创建的索引，用于指代被打开的文件，对文件所有 I/O  操作相关的系统调用都需要通过文件描述符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/234806787&#34;&gt;Socket&lt;/a&gt;&lt;/strong&gt;：在Linux 中，Socket 也是文件，发送端将数据写进发送方的 Socket ，再通过网卡、路由到接收方的 Socket ，接收方程序将数据从接收方 Socket 中读出来使用。一个 Socket 由&amp;lt;协议、发送方 IP、发送方 Port、接收方 IP、接收方 Port&amp;gt; 五元组描述。总之，Socket 就是一个文件，同样可以进行读写。&lt;/p&gt;
&lt;h2 id=&#34;2linux-io模型&#34;&gt;2、Linux IO模型&lt;/h2&gt;
&lt;p&gt;目前Linux系统中提供了5种IO处理模型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;阻塞IO&lt;/li&gt;
&lt;li&gt;非阻塞IO&lt;/li&gt;
&lt;li&gt;IO多路复用&lt;/li&gt;
&lt;li&gt;信号驱动IO&lt;/li&gt;
&lt;li&gt;异步IO&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;阻塞io&#34;&gt;阻塞IO&lt;/h4&gt;
&lt;p&gt;阻塞IO意味着当我们发起一次IO操作后一直等待成功或失败之后才返回，在这期间程序不能做其它的事情。阻塞IO操作只能对单个文件描述符进行操作，如果文件描述符不就绪就阻塞。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务端采用单线程，当accept一个请求后，在recv或send调用阻塞时，将无法accept其他请求（必须等上一个请求处recv或send完），无法处理并发。&lt;/li&gt;
&lt;li&gt;服务器端采用多线程，当accept一个请求后，开启线程进行recv，可以完成并发处理，但随着请求数增加需要增加系统线程，大量的线程占用很大的内存空间，并且线程切换会带来很大的开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;非阻塞io&#34;&gt;非阻塞IO&lt;/h4&gt;
&lt;p&gt;服务器端当accept一个请求后，加入fds集合，每次轮询一遍fds，若IO失败则返回错误，每次轮询所有fd（包括没有发生读写事件的fd）会很浪费cpu&lt;/p&gt;
&lt;h4 id=&#34;io多路复用&#34;&gt;IO多路复用&lt;/h4&gt;
&lt;p&gt;个人认为IO多路复用是吸收了阻塞IO和非阻塞IO的优点的一种IO方式，即同时可以对多个请求进行处理，但当所有请求不就绪时会阻塞，不占用CPU资源。&lt;/p&gt;
&lt;p&gt;服务器端采用单线程通过select/epoll等系统调用获取fd列表，遍历活跃（即有读写事件）的fd进行accept/recv/send，使其能支持更多的并发连接请求。&lt;/p&gt;
&lt;h2 id=&#34;3io多路复用的实现&#34;&gt;3、IO多路复用的实现&lt;/h2&gt;
&lt;h3 id=&#34;31select&#34;&gt;3.1、select&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;select 每个进程可同时监听的文件描述符数量最大为 1024，虽然可以设置，但是会降低网络效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对socket扫描时是线性扫描，采用轮询的方法，效率较低（高并发时）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后面的不重要&lt;/p&gt;
&lt;p&gt;数据结构：&lt;code&gt;fd_set&lt;/code&gt;简单地理解为一个长度是1024的比特位，每个比特位表示一个需要处理的FD，如果是1，那么表示这个FD有需要处理的I/O事件，否则没有。&lt;/p&gt;
&lt;p&gt;select 在调用期间会一直阻塞。&lt;/p&gt;
&lt;p&gt;select将监听的文件描述符分为三组，分别是：read_fds是需要进行读操作的文件描述符，write_fds是需要进行写操作的文件描述符，except_fds是需要进行异常事件处理的文件描述符。&lt;/p&gt;
&lt;h3 id=&#34;32poll&#34;&gt;3.2、poll&lt;/h3&gt;
&lt;p&gt;poll 仅仅时取消了 1024 的限制，其他和 select 一样，不分为三组。poll 是 fd 数组。&lt;/p&gt;
&lt;h3 id=&#34;33epoll&#34;&gt;3.3、epoll&lt;/h3&gt;
&lt;p&gt;epoll 底层是红黑树 + 链表。红黑树存储所有需要监听的 fd（文件描述符），链表存储活跃（有读写事件）的fd。&lt;/p&gt;</description>
    </item>
    <item>
      <title>linux创建子进程--fork()方法</title>
      <link>https://ethereal-lu.github.io/posts/linux/linux%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B--fork%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 09 Apr 2022 19:42:15 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/linux/linux%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B--fork%E6%96%B9%E6%B3%95/</guid>
      <description>&lt;h3 id=&#34;1fork的定义&#34;&gt;1、fork()的定义&lt;/h3&gt;
&lt;p&gt;fork()函数是Unix中派生新进程的唯一方法，子进程和父进程独立运行互不干扰。&lt;/p&gt;
&lt;p&gt;声明如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;unistd.h&amp;gt; &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pid_t&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fork&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;调用一次fork()方法，该方法会返回两次。一次是在父进程中返回一次，返回值是新派生的进程的进程ID。一次是在子进程中返回，返回值是0，代表当前进程为子进程。如果返回值为-1的话，则代表在派生新进程的过程中出错。&lt;/p&gt;
&lt;p&gt;那么在程序中，我们就可以根据此返回值来判断当前进程是父进程还是子进程，来实现一些具体的操作。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;()  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;pid_t&lt;/span&gt; pid;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;((pid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fork&lt;/span&gt;()) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// TODO: 在子进程中实现具体操作  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// ...  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;exit&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 结束子进程  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// TODO: 在调用进程(父进程)实现具体操作  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;} 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;2getpid和getppid函数&#34;&gt;2、getpid和getppid函数&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   pid_t &lt;span style=&#34;color:#a6e22e&#34;&gt;getpid&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 获取当前进程的pid
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   pid_t &lt;span style=&#34;color:#a6e22e&#34;&gt;getppid&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 获取当前进程父进程的pid
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;3fork-原理&#34;&gt;3、fork() 原理&lt;/h3&gt;
&lt;p&gt;父进程中在调用fork()派生新进程，实际上相当于创建了进程的一个拷贝；即在fork()之前的进程拥有的资源会被复制到新的进程中去。&lt;/p&gt;
&lt;p&gt;​		（1）进程不同于程序是动态运行在内存中的实体，占用系统资源（CPU、内存等），而程序则是存放在磁盘中的静态的资源，占用磁盘空间而不占用系统资源。进程在内存中运行，由CPU分配资源。&lt;/p&gt;
&lt;p&gt;　　（2）与进程相关的两个内存：虚拟内存和物理内存。所谓虚拟内存就是我们程序员视角下的内存，比如int a = 10; &amp;amp;a 所得的值就是虚拟内存，是给我们程序员看的连续的地址空间。（当我们在代码中连续定义几个local object时，通过&amp;amp;可以观察到它们的地址是连续的）相对的，物理内存才是实实在在的存在于计算机硬件中的内存（比如买内存条时我们可以参考的4G、8G等容量参数），当执行 a = 20这条语句时，操作系统就会将 a 的虚拟地址送入 CPU的地址转换单元（MMU），如果a还没有实际的物理单元，则为a分配物理内存，写入20，反之直接将20写入a物理内存单元。&lt;/p&gt;
&lt;p&gt;　　（3）为什么会有虚拟内存？ 虚拟内存的产生源自物理内存的稀缺，买过SSD或者内存条的伙伴都知道，250G的SSD也就是250块左右，而仅仅8G的内存条就要250块，内存的小容量与高价格的反差促使猿们必须节省内存的开销。由此产生了虚拟内存技术，32位系统下，CPU会为每个进程分配4G的虚拟地址单元（地址编号为0-4G），分为用户空间（通常为0-3G）和内核（kernel）空间（3-4G），用户空间存放该进程的堆栈变量、全局变量等，kernel里存放该进程的进程控制块（&lt;strong&gt;PCB，唯一区分每一个进程&lt;/strong&gt;）。虚拟内存单元只有在被进程访问后才会映射为物理内存单元（见（2）a=20的执行过程）。&lt;/p&gt;
&lt;p&gt;　　（4）内存使用的一大机制（虚拟内存能实现的原因）：缺页中断（见文章最后）。&lt;/p&gt;
&lt;p&gt;　　3. fork()是如何产生子进程的？ 上面说了每一个进程都有自己0-4G的虚拟地址空间，因此，fork所做的动作就是在当前进程的基础上产生一个新进程：&lt;strong&gt;（1）复制父进程的0-3G的用户空间（2）创建新进程（子进程）的PCB&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看一个例子吧：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//global variable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; globalVar &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;78&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pid_t pid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getpid();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        pid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; fork();   &lt;span style=&#34;color:#75715e&#34;&gt;// 循环生成5个子进程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; pid){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            perror(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;FORK&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            exit(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 由于fork()返回两个值，该分支一定会被子进程执行，即每子进程都会跳出循环去执行下方代码，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 而父进程一直执行到循环结束，故每个子进程都会执行下方的if(i &amp;lt; 5)，而父进程执行else
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 所以下方图片输出可表明每个子进程写时都复制父进程的变量再修改，且不影响其他进程。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; pid){  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sleep(i); &lt;span style=&#34;color:#75715e&#34;&gt;// 保证父进程最后退出
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;k;  &lt;span style=&#34;color:#75715e&#34;&gt;// 写时复制
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;globalVar; &lt;span style=&#34;color:#75715e&#34;&gt;//写时复制
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;I&amp;#39;m %dth child, pid = %d, parent is %d, k = %d, globalVar = %d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, i, getpid(), getppid(), k, globalVar);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;k;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;globalVar;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;I&amp;#39;m parent, pid = %d, k = %d, globalVar = %d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, getpid(), k, globalVar);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;https://img2020.cnblogs.com/blog/1696980/202007/1696980-20200715102950625-1441570329.png&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>编码</title>
      <link>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A0%81/</link>
      <pubDate>Fri, 08 Apr 2022 23:08:18 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A0%81/</guid>
      <description>&lt;h2 id=&#34;1为什么使用编码&#34;&gt;1、为什么使用编码&lt;/h2&gt;
&lt;p&gt;人类的语言并不适合计算机使用，所以就需要发明一种适合计算机的语言，这就是二进制。电脑读不懂人类语言，所以需要将人类语言转换为二进制语言，这就是编码；人类读不懂电脑的二进制语言，所以需要转换为人类语言，这就是解码。&lt;/p&gt;
&lt;h2 id=&#34;2为什么会乱码&#34;&gt;2、为什么会乱码&lt;/h2&gt;
&lt;p&gt;编码与解码使用的规则不一样，就会乱码。即解码的时候，解码器不知道如何将当前的二进制转换为人类语言，就会乱码。&lt;/p&gt;
&lt;h2 id=&#34;3字符集的历史&#34;&gt;3、字符集的历史&lt;/h2&gt;
&lt;h3 id=&#34;31百花齐放&#34;&gt;3.1、百花齐放&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ASCII&lt;/code&gt; 码占用了 0~127，即一个字节中的后 7 位。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IOS-8859-n&lt;/code&gt; 编码家族占用了 128~255，即利用了 &lt;code&gt;ASCII&lt;/code&gt; 码未使用的第 1 位，因此&lt;code&gt;IOS-8859-n&lt;/code&gt; 编码家族兼容&lt;code&gt;ASCII&lt;/code&gt; 码。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;至此一个字节的 8 位已全部占用，后来的编码必须使用多个字节。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;GB2312&lt;/code&gt;：&lt;code&gt;GB2312&lt;/code&gt; 并不兼容 &lt;code&gt;ISO-8859-n&lt;/code&gt; 编码集，但是兼容 &lt;code&gt;ASCII&lt;/code&gt; 编码。因为 &lt;code&gt;ASCII&lt;/code&gt; 编码中的单字节字符一定是小于 &lt;code&gt;128&lt;/code&gt; 的，所以最后我们就决定，中文的双字节字符都从 &lt;code&gt;128&lt;/code&gt; 之后开始，也就是当发现字符连续两位都大于 &lt;code&gt;128&lt;/code&gt; 时，就说明这是一个中文，指定了之后我们就把这种编码方式称之为 &lt;code&gt;GB2312&lt;/code&gt; 编码。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GB2312&lt;/code&gt; 中收录的中文汉字都是简体字和常用字，对于一些生僻字以及繁体字没有收录，于是乎 &lt;code&gt;GBK&lt;/code&gt; 出现了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GBK&lt;/code&gt;： &lt;code&gt;GBK&lt;/code&gt; 只要求第一位是大于 &lt;code&gt;128&lt;/code&gt;，第二位可以小于 &lt;code&gt;128&lt;/code&gt;，只要发现一个字节大于 &lt;code&gt;128&lt;/code&gt;，那么紧随其后的一个字节就是和其作为一个整体作为中文字符。&lt;code&gt;GBK&lt;/code&gt;兼容&lt;code&gt;GB2312&lt;/code&gt;、&lt;code&gt;ASCII&lt;/code&gt;，不兼容&lt;code&gt;IOS-8859-n&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;32unicode&#34;&gt;3.2、Unicode&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Unicode&lt;/code&gt; 不兼容以上任何编码。&lt;code&gt;Unicode&lt;/code&gt; 字符最开始采用的是 &lt;code&gt;UCS-2&lt;/code&gt; 标准，&lt;code&gt;UCS-2&lt;/code&gt; 标准规定一个字符至少使用 &lt;code&gt;2&lt;/code&gt; 个字节来表示。由于无法攘括全世界所有字符，后来又有了 &lt;code&gt;UCS-4&lt;/code&gt; 标准，可以用 &lt;code&gt;4&lt;/code&gt; 个字节来存储一个字符。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Unicode&lt;/code&gt; 编码只是定义了字符集，对于字符集具体应该如何存储并没有做要求。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;UTF&lt;/code&gt; 系列编码就是对 &lt;code&gt;Unicode&lt;/code&gt; 字符集的实现，只不过实现的方式有所区别，其中主要有：&lt;code&gt;UTF-8&lt;/code&gt;，&lt;code&gt;UTF-16&lt;/code&gt;，&lt;code&gt;UTF-32&lt;/code&gt; 等类型。&lt;/p&gt;
&lt;h4 id=&#34;321utf-32-编码&#34;&gt;3.2.1、UTF-32 编码&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;UTF-32&lt;/code&gt; 编码基本按照 &lt;code&gt;Unicode&lt;/code&gt;字符集标准来实现，任何一个符号都占用 &lt;code&gt;4&lt;/code&gt; 个字节。浪费严重。&lt;/p&gt;</description>
    </item>
    <item>
      <title>RabbitMQ基础</title>
      <link>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/rabbitmq/rabbitmq/</link>
      <pubDate>Thu, 07 Apr 2022 14:42:15 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/rabbitmq/rabbitmq/</guid>
      <description>&lt;h2 id=&#34;一概述&#34;&gt;一、概述&lt;/h2&gt;
&lt;h3 id=&#34;11什么是消息队列&#34;&gt;1.1、什么是消息队列&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;消息&lt;/strong&gt;：指的是两个应用间传递的数据。数据的类型有很多种形式，可能只包含文本字符串，也可能包含嵌入对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消息协议&lt;/strong&gt;：为了让消息发送者和消息接收者都能够明白消息所承载的信息，它们就需要按照一种统一的格式描述消息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消息队列&lt;/strong&gt;：（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message。&lt;/p&gt;
&lt;p&gt;消息从发送者到接收者的方式也有两种。
一种为即时消息通讯，也就是说消息从一端发出后（消息发送者）立即就可以达到另一端（消息接收者），这种方式的具体实现就是RPC（当然单纯的http通讯也满足这个定义）；
另一种为延迟消息通讯，即消息从某一端发出后，首先进入一个容器进行临时存储，当达到某种条件后，再由这个容器发送给另一端。 这个容器的一种具体实现就是消息队列，如RabbitMQ。&lt;/p&gt;
&lt;h3 id=&#34;12为什么使用消息队列&#34;&gt;1.2、为什么使用消息队列&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;应用解耦：不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个；&lt;/li&gt;
&lt;li&gt;流量削峰：如数据库只能同时处理一万条请求，如果来了两万条请求就执行一万条，将剩余一万条放在消息队列顺序执行。&lt;/li&gt;
&lt;li&gt;异步处理：A 调用 B 处理数据，但 B 处理时间很长；A可以不用等，当B执行完将结果放在消息队列，再由消息队列将结果给A，这样就不用轮询或提供回调函数了。&lt;/li&gt;
&lt;li&gt;广播&lt;/li&gt;
&lt;li&gt;最终一致性&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13mqtt-与-mq-的区别&#34;&gt;1.3、mqtt 与 MQ 的区别&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;mqtt&lt;/strong&gt;：一种通信协议，类似人类交谈中的汉语、英语、俄语中的一种语言规范
&lt;strong&gt;MQ&lt;/strong&gt;：一种通信通道，也叫消息队列，类似人类交谈中的用电话、email、微信的一种通信方式
&lt;strong&gt;json&lt;/strong&gt;：一种内容格式，类似人类交谈中的排比句等方式&lt;/p&gt;
&lt;h3 id=&#34;14rpc-执行流程&#34;&gt;1.4、RPC 执行流程&lt;/h3&gt;
&lt;p&gt;RPC（Remote Procedure Call）远程过程调用协议，一种通过网络从远程计算机上请求服务，而不需要了解底层网络技术的协议。其主要目的是做到不同服务间调用方法像同一服务间调用本地方法一样。&lt;/p&gt;
&lt;p&gt;当业务需要强一致性，关注业务逻辑的处理结果，则 RPC 比消息队列更合适。&lt;/p&gt;
&lt;p&gt;强一致性指不论在任何时候读取的都是最新的数据，最终一致性是允许可以在一段时间内每个结点的数据不一致，但是经过一段时间每个结点的数据必须一致，它强调的是最终数据的一致性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端处理过程中调用client sub，就像调用本地方法一样，传入参数&lt;/li&gt;
&lt;li&gt;client sub将参数编组为消息，然后通过系统调用向服务端发送消息&lt;/li&gt;
&lt;li&gt;服务端将接收到的数据包传递给server sub&lt;/li&gt;
&lt;li&gt;server sub将接收到的数据解组为参数&lt;/li&gt;
&lt;li&gt;server sub再调用服务端的过程，过程执行的结果以反方向的相同步骤响应给客户端&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以 Google 的 grpc 为例：先在 proto 文件中声明接口，包括方法名、参数和返回值，然后使用工具生成 go 可以用的库；服务端创建 grpc 服务实例并将本地实现的服务注册进该实例中，然后监听本地端口，收到请求后就执行本地方法并将结果返回；客户端创建 grpc 客户端实例，然后调用 proto 中声明的方法即可获得结果。&lt;/p&gt;
&lt;h3 id=&#34;15mq-分类&#34;&gt;1.5、MQ 分类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ActiveMQ：老、较少使用&lt;/li&gt;
&lt;li&gt;Kafka：大数据实时计算和日志采集方面卓越&lt;/li&gt;
&lt;li&gt;RocketMQ：阿里开源产品&lt;/li&gt;
&lt;li&gt;RabbitMQ：主流&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二rabbitmq介绍&#34;&gt;二、RabbitMQ介绍&lt;/h2&gt;
&lt;h3 id=&#34;21rabbitmq-简介&#34;&gt;2.1、RabbitMQ 简介&lt;/h3&gt;
&lt;p&gt;RabbitMQ是一个在AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ubuntu的ufw与iptables</title>
      <link>https://ethereal-lu.github.io/posts/linux/ubuntu%E7%9A%84ufw%E4%B8%8Eiptables/</link>
      <pubDate>Thu, 07 Apr 2022 14:42:15 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/linux/ubuntu%E7%9A%84ufw%E4%B8%8Eiptables/</guid>
      <description>&lt;h2 id=&#34;1概述&#34;&gt;1、概述&lt;/h2&gt;
&lt;p&gt;进出计算机的流量通过“端口”进行过滤，“端口”是附加到特定应用程序使用的流量数据包的相对任意名称。&lt;/p&gt;
&lt;p&gt;按照惯例，某些端口通常用于特定类型的应用程序。例如，端口 80 通常用于不安全的 Web 浏览，端口 443 用于安全的 Web 浏览。&lt;/p&gt;
&lt;p&gt;可以通过“打开”或“关闭”（即过滤）为特定类型的流量指定的端口来允许或阻止到特定应用程序的流量。例如，如果端口 80 “关闭”，则无法进行（不安全的）网页浏览。&lt;/p&gt;
&lt;p&gt;Linux 内核包括 netfilter 子系统，用于操纵或决定进入或通过计算机的网络流量的命运。所有现代 Linux 防火墙解决方案都使用该系统进行数据包过滤。&lt;/p&gt;
&lt;p&gt;如果没有用户界面来管理内核的数据包过滤系统，那么用户或管理员几乎没有什么用处。这就是 iptables 的目的。当一个数据包到达您的计算机时，它会根据通过 iptables 提供给它的规则传递给 netfilter 子系统接受、处理或拒绝。因此，iptables 是您管理防火墙所需的一切（如果您熟悉它）。然而，许多前端可用于简化任务。&lt;/p&gt;
&lt;p&gt;因此，用户可以配置防火墙以允许某些类型的网络流量进出系统（例如 SSH 或 Web 服务器流量）。这是通过在防火墙中打开和关闭 TCP 和 UDP“端口”来完成的。此外，防火墙可以配置为允许或限制对特定 IP 地址（或 IP 地址范围）的访问。&lt;/p&gt;
&lt;h2 id=&#34;2端口映射与端口转发&#34;&gt;2、端口映射与端口转发&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;端口映射&lt;/strong&gt;：端口映射就是将内网中的主机的一个端口映射到外网主机的一个端口，提供相应的服务。当用户访问外网IP的这个端口时，服务器自动将请求映射到对应局域网内部的机器上。&lt;/p&gt;
&lt;p&gt;我们在内网中有一台Web服务器，但是外网中的用户是没有办法直接访问该服务器的。于是我们可以在路由器上设置一个端口映射，只要外网用户访问路由器ip的80端口，那么路由器会把自动把流量转到内网Web服务器的80端口上。并且，在路由器上还存在一个Session，当内网服务器返回数据给路由器时，路由器能准确的将消息发送给外网请求用户的主机。在这过程中，路由器充当了一个反向代理的作用，他保护了内网中主机的安全。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;端口转发&lt;/strong&gt;：端口转发（Port forwarding），有时被叫做隧道，是安全壳（SSH） 为网络安全通信使用的一种方法。&lt;/p&gt;
&lt;p&gt;比如，我们现在在内网中，是没有办法直接访问外网的。但是我们可以通过路由器的NAT方式访问外网。假如我们内网现在有100台主机，那么我们现在都是通过路由器的这一个公网IP和外网通信的。那么，当互联网上的消息发送回来时，路由器是怎么知道这个消息是给他的，而另外消息是给你的呢？这就要我们的ip地址和路由器的端口进行绑定了，这时，在路由器中就会有一个内网ip和路由器端口对应的一张表。当路由器的10000端口收到消息时，就知道把消息发送给他，而当20000端口收到消息时，就知道把消息发送给你。这就是端口转发，其转发一个端口收到的流量，给另一个主机。&lt;/p&gt;
&lt;p&gt;端口转发：转发的重点在“转”上面。送快递的过来，把所有快递都交给门口保安，保安再根据每件快递上的收件人来分发。&lt;/p&gt;
&lt;p&gt;端口映射：就是在大门口给每个人装个柜子，送快递的直接按收件人名字，把快递放到对应的柜子里面。&lt;/p&gt;
&lt;h2 id=&#34;3ufw与iptables&#34;&gt;3、ufw与iptables&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;iptables&lt;/strong&gt; 是防火墙规则的数据库，是 Linux 系统中实际使用的防火墙。 Linux系统中配置iptables的传统界面是命令行界面终端。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UFW&lt;/strong&gt;（简单防火墙）是 iptables 的前端，是Ubuntu系统上配置iptables防火墙的工具，特别适合基于主机的防火墙。 UFW 是专门为 Ubuntu 开发的（但在其他发行版中可用），也可以从终端进行配置。&lt;/p&gt;</description>
    </item>
    <item>
      <title>AQS</title>
      <link>https://ethereal-lu.github.io/posts/java/java-%E8%BF%9B%E9%98%B6/aqs/</link>
      <pubDate>Wed, 06 Apr 2022 21:12:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/java/java-%E8%BF%9B%E9%98%B6/aqs/</guid>
      <description>&lt;p&gt;&lt;strong&gt;AQS的核心思想&lt;/strong&gt;是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就通过cas 的方式将当前线程添加到等待队列的尾部，直到它的前继节点释放锁并唤醒它。&lt;/p&gt;
&lt;p&gt;在 AQS 中用变量 state 代表共享资源，通过 cas 改变 state 的值来竞争锁。&lt;/p&gt;
&lt;p&gt;ReentrantLock 实现了公平锁和非公平锁，他们都继承了 AQS，公平锁和非公平锁的最大区别就是在获取锁的时候，非公平锁直接和等待队列的头节点竞争锁，而非公平锁只有在自己是队列头结点时才去获取锁。&lt;/p&gt;
&lt;p&gt;ReentrantLock 中，若 state 的值为0，说明当前共享资源是空闲的，可以获取。若获取到锁的线程再次获取锁时，state 的值加 1，这就是可重入锁。同时这样会避免多余的 cas 开销。&lt;/p&gt;</description>
    </item>
    <item>
      <title>BIO,NIO,AIO</title>
      <link>https://ethereal-lu.github.io/posts/java/java-%E8%BF%9B%E9%98%B6/bionioaio/</link>
      <pubDate>Wed, 06 Apr 2022 21:12:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/java/java-%E8%BF%9B%E9%98%B6/bionioaio/</guid>
      <description>&lt;p&gt;本文摘自&lt;a href=&#34;https://blog.csdn.net/m0_38109046/article/details/89449305&#34;&gt;(31条消息) Java面试常考的 BIO，NIO，AIO 总结_有梦想的小树的博客-CSDN博客_bio nio&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Java 中的 BIO、NIO和 AIO 理解为是 Java 语言对操作系统的各种 IO 模型的封装。程序员在使用这些 API 的时候，不需要关心操作系统层面的知识，也不需要根据不同操作系统编写不同的代码。只需要使用Java的API就可以了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步与异步&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;同步：&lt;/strong&gt; 同步就是发起一个调用后，需要等待被调用者返回结果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步：&lt;/strong&gt; 异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同步和异步的区别最大在于异步的话调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阻塞和非阻塞&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;阻塞：&lt;/strong&gt; 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非阻塞：&lt;/strong&gt; 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同步和阻塞最大的区别就是线程是否会被挂起。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么同步阻塞、同步非阻塞和异步非阻塞又代表什么意思呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在等待返回结果前如果什么也不干就是同步阻塞；如果可以做一些其他的事只需要以轮询的方式查看结果是否返回就是同步非阻塞；如果不需要等待返回结果就是异步非阻塞。&lt;/p&gt;
&lt;p&gt;举个生活中简单的例子，你妈妈让你烧水，小时候你比较笨啊，在哪里傻等着水开（&lt;strong&gt;同步阻塞&lt;/strong&gt;）。等你稍微再长大一点，你知道每次烧水的空隙可以去干点其他事，然后只需要时不时来看看水开了没有（&lt;strong&gt;同步非阻塞&lt;/strong&gt;）。后来，你们家用上了水开了会发出声音的壶，这样你就只需要听到响声后就知道水开了，在这期间你可以随便干自己的事情，你需要去倒水了（&lt;strong&gt;异步非阻塞&lt;/strong&gt;）。&lt;/p&gt;
&lt;h2 id=&#34;1-bio-blocking-io&#34;&gt;1. BIO (Blocking I/O)&lt;/h2&gt;
&lt;p&gt;最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。
  当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。
  典型的阻塞IO模型的例子为 &lt;code&gt;data = socket.read(); &lt;/code&gt;如果数据没有就绪，就会一直阻塞在read方法。&lt;/p&gt;
&lt;h3 id=&#34;11-传统-bio&#34;&gt;1.1 传统 BIO&lt;/h3&gt;
&lt;p&gt;BIO通信（一请求一应答）模型图如下(图源网络，原出处不明)：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;https://img-blog.csdnimg.cn/2019042212100021.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MTA5MDQ2,size_16,color_FFFFFF,t_70&#34;&gt;&lt;/p&gt;
&lt;p&gt;采用 &lt;strong&gt;BIO 通信模型&lt;/strong&gt; 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。我们一般通过在 &lt;code&gt;while(true)&lt;/code&gt; 循环中服务端会调用 &lt;code&gt;accept()&lt;/code&gt; 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接，如上图所示。&lt;/p&gt;
&lt;p&gt;如果要让 &lt;strong&gt;BIO 通信模型&lt;/strong&gt; 能够同时处理多个客户端请求，就必须使用多线程（主要原因是 &lt;code&gt;socket.accept()&lt;/code&gt;、 &lt;code&gt;socket.read()&lt;/code&gt;、 &lt;code&gt;socket.write()&lt;/code&gt; 涉及的三个主要函数都是同步阻塞的），也就是说它在接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的 &lt;strong&gt;一请求一应答通信模型&lt;/strong&gt; 。我们可以设想一下如果这个连接不做任何事情的话就会造成不必要的线程开销，不过可以通过 &lt;strong&gt;线程池机制&lt;/strong&gt; 改善，线程池还可以让线程的创建和回收成本相对较低。使用&lt;code&gt;FixedThreadPool&lt;/code&gt; 可以有效的控制了线程的最大数量，保证了系统有限的资源的控制，实现了N(客户端请求数量):M(处理客户端请求的线程数量)的伪异步I/O模型（N 可以远远大于 M），下面一节&amp;quot;伪异步 BIO&amp;quot;中会详细介绍到。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis基础</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 01 Apr 2022 17:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h3 id=&#34;概述&#34;&gt;概述&lt;/h3&gt;
&lt;p&gt;Redis是什么？&lt;/p&gt;
&lt;p&gt;Redis（Remote Dictionary Server )，即远程字典服务！&lt;/p&gt;
&lt;p&gt;Redis能干吗？  &amp;mdash;》 数据库、缓存、中间件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内存存储、持久化（rdb、aof）&lt;/li&gt;
&lt;li&gt;效率高，可用于缓存&lt;/li&gt;
&lt;li&gt;发布订阅系统&lt;/li&gt;
&lt;li&gt;地图信息分析&lt;/li&gt;
&lt;li&gt;计时器、计数器 。。。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Redis 通过“Redis序列化协议”（简称“RESP”），实现客户端与服务端之间的连接通信，其底层是通过TCP来完成的。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;linux安装配置redis&#34;&gt;Linux安装配置redis&lt;/h3&gt;
&lt;p&gt;下载并解压redis后，将解压好的包移动到&lt;code&gt;/usr/local/redis&lt;/code&gt;中，然后&lt;code&gt;cd /usr/local/redis&lt;/code&gt;，依次在该目录下执行&lt;code&gt;make&lt;/code&gt;，&lt;code&gt;make test&lt;/code&gt;（也可以不执行）和&lt;code&gt;make install&lt;/code&gt;。之后将该目录下的&lt;code&gt;redis.conf&lt;/code&gt;备份，再&lt;code&gt;vim redis.conf&lt;/code&gt;，将&lt;code&gt;daemonize&lt;/code&gt;的值从no改为yes。&lt;code&gt;cd /usr/local/bin&lt;/code&gt;，执行&lt;code&gt;redis-server ../redis/redis.conf&lt;/code&gt;。配置完成。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;redis-是单线程&#34;&gt;redis 是单线程&lt;/h3&gt;
&lt;p&gt;对Redis来说，执行get、set以及eval等API，都是一个一个的任务，这些任务都会由Redis的线程（单线程）去负责执行，任务要么执行成功，要么执行失败，这就是Redis的命令是原子性的原因。&lt;/p&gt;
&lt;h5 id=&#34;redis-6-引入了多线程&#34;&gt;redis 6 引入了多线程&lt;/h5&gt;
&lt;p&gt;redis 5 及之前的版本一直使用的是单线程，多线程是 Redis6.0 推出的一个新特性。 Redis 的核心线程负责网络 IO ，命令处理以及写数据到缓冲，而随着网络硬件的性能提升，单个主线程处理⽹络请求的速度跟不上底层⽹络硬件的速度，导致网络 IO 的处理成为了 Redis 的性能瓶颈。&lt;/p&gt;
&lt;p&gt;而 Redis6.0 就是从单线程处理网络请求到多线程处理，通过多个 IO 线程并⾏处理网络操作提升实例的整体处理性能。需要注意的是对于读写命令，Redis 仍然使⽤单线程来处理，这是因为继续使⽤单线程执行命令操作，就不⽤为了保证 Lua 脚本、事务的原⼦性，额外开发多线程互斥机制了。&lt;/p&gt;
&lt;p&gt;redis 将所有的数据都放在内存中。单线程避免切换上下文，所以快。&lt;/p&gt;
&lt;p&gt;多线程开发中并发访问控制是⼀个难点，需要精细的设计才能处理。如果只是简单地处理，比如简单地采⽤⼀个粗粒度互斥锁，只会出现不理想的结果。即便增加了线程，系统吞吐率也不会随着线程的增加而增加，因为大部分线程还在等待获取访问共享资源的互斥锁。而且，大部分采用多线程开发引入的同步原语保护共享资源的并发访问，也会降低系统代码的易调试性和可维护性。而正是以上这些问题，才让 Redis 采⽤了单线程模式。&lt;/p&gt;
&lt;p&gt;官方解释：因为Redis是基于内存的操作，CPU不是Redis的瓶颈，&lt;strong&gt;Redis的瓶颈最有可能是机器内存的大小或者网络带宽&lt;/strong&gt;。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦)。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;基础知识&#34;&gt;基础知识&lt;/h3&gt;
&lt;p&gt;redis所有命令不区分大小写&lt;/p&gt;
&lt;h5 id=&#34;数据库基本命令&#34;&gt;数据库基本命令&lt;/h5&gt;
&lt;p&gt;redis默认有16个数据库（0~15），默认使用第0个数据库。数据库之间数据相互隔离&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; SELECT &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;# 切换数据库&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OK
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;3&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&amp;gt; DBSIZE     &lt;span style=&#34;color:#75715e&#34;&gt;# 查看当前数据库大小&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; FLUSHDB       &lt;span style=&#34;color:#75715e&#34;&gt;# 清空当前数据库&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OK
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; FLUSHALL      &lt;span style=&#34;color:#75715e&#34;&gt;# 清空所有数据库&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OK
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; SHUTDOWN      &lt;span style=&#34;color:#75715e&#34;&gt;# 关闭redis服务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;redis-key基本命令&#34;&gt;Redis-key基本命令&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; set age &lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# 添加键值对&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OK
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; get name              &lt;span style=&#34;color:#75715e&#34;&gt;# 通过key获取value&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;xunlu&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; KEYS *                &lt;span style=&#34;color:#75715e&#34;&gt;# KEYS + 正则表达式。返回所有符合正则表达式的键&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;age&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; EXISTS name           &lt;span style=&#34;color:#75715e&#34;&gt;# 判断是否存在指定的key&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;                           &lt;span style=&#34;color:#75715e&#34;&gt;# 返回1则存在，0则不存在&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; EXPIRE name &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 设置键name的有效期为10秒&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; ttl name              &lt;span style=&#34;color:#75715e&#34;&gt;# 查看键name的有效时间还剩下多少&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; MOVE name &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;           &lt;span style=&#34;color:#75715e&#34;&gt;# 将键值对移动到指定的数据库中&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; DEL name              &lt;span style=&#34;color:#75715e&#34;&gt;# 删除键值对&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; TYPE age              &lt;span style=&#34;color:#75715e&#34;&gt;# 获取当前键对应值的类型&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;string
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h3 id=&#34;数据类型&#34;&gt;数据类型&lt;/h3&gt;
&lt;h5 id=&#34;五种基本数据类型&#34;&gt;五种基本数据类型&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;String  &amp;mdash;&amp;gt;  应用：计数器（如访问量，点赞数等）&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; set name xunlu
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OK
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; APPEND name feilu              &lt;span style=&#34;color:#75715e&#34;&gt;# 追加字符串，类似StringBuilder的append&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;                                   &lt;span style=&#34;color:#75715e&#34;&gt;# 若追加的键不存在，则新建键值对&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; get name
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;xunlufeilu&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-----------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; STRLEN name					 &lt;span style=&#34;color:#75715e&#34;&gt;# 返回值的长度&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-----------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; set views &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OK
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; INCR views                     &lt;span style=&#34;color:#75715e&#34;&gt;# 每执行一次，值就会加1.（只能作用于integer类型）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; INCR views
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; DECR views                     &lt;span style=&#34;color:#75715e&#34;&gt;# 每执行一次，值就会减1.（只能作用于integer类型）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; INCRBY views &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# 指定增加的步长&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; DECRBY views &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# 指定减少的步长&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-----------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; set name xunlu
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OK
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; GETRANGE name &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;              &lt;span style=&#34;color:#75715e&#34;&gt;# 截取部分值（start和end都包括在内）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;xun&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; GETRANGE name &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; -1             &lt;span style=&#34;color:#75715e&#34;&gt;# == get name&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;xunlu&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; SETRANGE name &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; gao            &lt;span style=&#34;color:#75715e&#34;&gt;# 替换部分字符，起始替换位置 + 替换的值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; get name
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;gaolu&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-----------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# setex(set with expire)   【原子性操作】&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# setnx(set if not exist)  【原子性操作】&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; setex name &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt; xunlu            &lt;span style=&#34;color:#75715e&#34;&gt;# 新建键值对，并设置有效期为30秒&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OK   &lt;span style=&#34;color:#75715e&#34;&gt;# 等同于 set name xunlu ex 30&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; setnx gender male              &lt;span style=&#34;color:#75715e&#34;&gt;# nx表示键不存在时才能正确执行，即只能新建&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OK   &lt;span style=&#34;color:#75715e&#34;&gt;# 等同于 set gender male nx               # 常用于分布式锁&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; get gender
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;male&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; set gender female nx           &lt;span style=&#34;color:#75715e&#34;&gt;# 此时键gender已经存在，执行失败&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;nil&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-----------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; MSET k1 v1 k2 v1 k3 v1         &lt;span style=&#34;color:#75715e&#34;&gt;# 批量创建键值对&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OK
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; KEYS *
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;k1&amp;#34;&lt;/span&gt;                                        &lt;span style=&#34;color:#75715e&#34;&gt;# msetnx 【原子性操作】&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;k3&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;3&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;k2&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; MGET k1 k2 k3                  &lt;span style=&#34;color:#75715e&#34;&gt;# 批量获取 &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;v1&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;v1&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;3&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;v1&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; set user &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;id:1,name:xunlu,age:3&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 可以将值设为json字符串，然后通过json解析&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OK
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; mset user:name xunlu user:age &lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# redis支持键中存在`:`冒号，亦可用于解析&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OK
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; getset db redis                  &lt;span style=&#34;color:#75715e&#34;&gt;# 先get再set。没有返回nil，再设新值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;nil&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; getset db redis                  &lt;span style=&#34;color:#75715e&#34;&gt;# 有则返回旧值，再设新值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;redis&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;List（双向链表）
&lt;ul&gt;
&lt;li&gt;绝大部分的list命令都以l开头，list的名字也可作为key，故有些redis-key的命令也可用&lt;/li&gt;
&lt;li&gt;应用：消息队列、栈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 添加、范围读取&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;LPUSH key element &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;element ...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;                   &lt;span style=&#34;color:#75715e&#34;&gt;# key为列表的名字，添加到列表的头部&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;RPUSH key element &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;element ...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;                   &lt;span style=&#34;color:#75715e&#34;&gt;# 添加到列表的尾部                 &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; LPUSH list mid                    &lt;span style=&#34;color:#75715e&#34;&gt;# 列表名为list，head、mid、tail为元素&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; LPUSH list head
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; RPUSH list tail
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; LRANGE list &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; -1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;head&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;mid&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;3&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tail&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; LRANGE list &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;                   &lt;span style=&#34;color:#75715e&#34;&gt;# 从头向尾读，没有RRANGE这个命令&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;head&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;mid&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 删除、改变list&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;LPOP key &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;count&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;                                  &lt;span style=&#34;color:#75715e&#34;&gt;# 从头部弹出元素&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;RPOP key &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;count&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;                                  &lt;span style=&#34;color:#75715e&#34;&gt;# 从尾部弹出元素&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;LREM key count element                            &lt;span style=&#34;color:#75715e&#34;&gt;# 根据值移除元素，count表示从多个相同的值中移除的个数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;LTRIM key start stop                              &lt;span style=&#34;color:#75715e&#34;&gt;# 将列表截断，只保留[start ~ stop]的值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 按下标索引&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; LINDEX list &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;                     &lt;span style=&#34;color:#75715e&#34;&gt;# 获取list的第i个值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;head&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; LINDEX list &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;mid&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 长度&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; LLEN list                         &lt;span style=&#34;color:#75715e&#34;&gt;# 获取list的长度&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 组合命令&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;RPOPLPUSH source destination                     &lt;span style=&#34;color:#75715e&#34;&gt;# 从容器source的尾部弹出并添加到容器destination的头部&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tail&amp;#34;&lt;/span&gt;                                           &lt;span style=&#34;color:#75715e&#34;&gt;# source和destination自然可以是同一个列表&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 修改列表中的值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;LSET key index element                           &lt;span style=&#34;color:#75715e&#34;&gt;# 修改列表指定下标处的值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; LSET list &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; prehead
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OK
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 插值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;LINSERT key BEFORE|AFTER pivot element          &lt;span style=&#34;color:#75715e&#34;&gt;# pivot为列表中已有的元素，往列表中元素的前或后插入元素&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Set（无序不重复）（命令都以s打头）&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 添加、查看&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SADD key member &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;member ...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;                    &lt;span style=&#34;color:#75715e&#34;&gt;# 添加元素（可以批量）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; SADD set first second third
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; SMEMBERS set                    &lt;span style=&#34;color:#75715e&#34;&gt;# 查看所有元素&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;second&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;third&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;3&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;first&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; SISMEMBER set first             &lt;span style=&#34;color:#75715e&#34;&gt;# 判断是否包含指定元素&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; SISMEMBER set fifth
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; SCARD set				       &lt;span style=&#34;color:#75715e&#34;&gt;# 集合的长度&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 移除&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SREM key member &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;member ...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;                    &lt;span style=&#34;color:#75715e&#34;&gt;# 删除指定元素（可以批量）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SPOP key &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;count&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;                                &lt;span style=&#34;color:#75715e&#34;&gt;# 随机删除元素（可以指定个数）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SMOVE source destination member                 &lt;span style=&#34;color:#75715e&#34;&gt;# 将指定元素从集合source移动到集合destination&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SRANDMEMBER key &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;count&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;                         &lt;span style=&#34;color:#75715e&#34;&gt;# 随机返回元素（可以指定个数）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 集合计算&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 差集     &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SDIFF set1 set2                                 &lt;span style=&#34;color:#75715e&#34;&gt;# 集合set1中有但set2中没有的元素&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 交集&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SINTER set1 set2                                &lt;span style=&#34;color:#75715e&#34;&gt;# 交&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 并集&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SUNION set1 set2                                &lt;span style=&#34;color:#75715e&#34;&gt;# 并&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Hash（命令都以h打头）
&lt;ul&gt;
&lt;li&gt;相当于map，则变为key-(key-value)，故（更适合对象的存储）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 添加&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;HSET key field value &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;field value ...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;           &lt;span style=&#34;color:#75715e&#34;&gt;# 存值，key为hash容器的名字&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;HMSET key field value &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;field value ...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;          &lt;span style=&#34;color:#75715e&#34;&gt;# 批量存值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; HSET hash name xunlu
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; HSET hash age &lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 查看&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;HGET key field                                   &lt;span style=&#34;color:#75715e&#34;&gt;# 指定字段的取值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;HMGET key field &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;field ...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;                      &lt;span style=&#34;color:#75715e&#34;&gt;# 批量取值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; HGET hash name
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;xunlu&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; HGETALL hash                     &lt;span style=&#34;color:#75715e&#34;&gt;# 查看全部内容&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;xunlu&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;3&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;age&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;4&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;18&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 删除&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;HDEL key field &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;field ...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;                       &lt;span style=&#34;color:#75715e&#34;&gt;# 删除指定元素（可批量）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 长度&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; HLEN hash
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 是否存在&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;HEXISTS key field                                &lt;span style=&#34;color:#75715e&#34;&gt;# 判断指定字段是否存在&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; HKEYS hash                       &lt;span style=&#34;color:#75715e&#34;&gt;# 取全部字段名&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;age&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; HVALS hash                       &lt;span style=&#34;color:#75715e&#34;&gt;# 取全部字段的值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;xunlu&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;18&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 自增、自减&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;HINCRBY key field increment                      &lt;span style=&#34;color:#75715e&#34;&gt;# field = field + increment （increment为负数即为减）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;HSETNX key field value                           &lt;span style=&#34;color:#75715e&#34;&gt;# 和setnx作用类似&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Zset（有序集合）【底层为跳表】&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 添加、查看&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ZADD key score member &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;score member ...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;          &lt;span style=&#34;color:#75715e&#34;&gt;# score用于排序&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; ZADD salary &lt;span style=&#34;color:#ae81ff&#34;&gt;2500&lt;/span&gt; mary &lt;span style=&#34;color:#ae81ff&#34;&gt;3000&lt;/span&gt; alice &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt; lisa
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ZRANGE salary &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; -1                                &lt;span style=&#34;color:#75715e&#34;&gt;# 返回所有数据&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 排序&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ZRANGE salary &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; byscore rev withscores        &lt;span style=&#34;color:#75715e&#34;&gt;# ZRANGE 后可跟上多个参数来约束比较，如通过score、降序、带上score&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ZRANGEBYSCORE key min max &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;WITHSCORES&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;LIMIT offset count&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;# 小到大&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ZREVRANGEBYSCORE key max min &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;WITHSCORES&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;LIMIT offset count&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;# 大到小&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; ZRANGEBYSCORE salary -inf +inf    &lt;span style=&#34;color:#75715e&#34;&gt;# 返回score在-inf +inf之间元素的排序，小到大&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;lisa&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;mary&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;3&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;alice&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 移除&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ZREM key member &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;member ...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 长度&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; ZCARD salary                      &lt;span style=&#34;color:#75715e&#34;&gt;# 总个数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; zcount salary &lt;span style=&#34;color:#ae81ff&#34;&gt;2000&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3000&lt;/span&gt;           &lt;span style=&#34;color:#75715e&#34;&gt;# 指定区间个数（score的区间）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;三种特殊数据类型&#34;&gt;三种特殊数据类型&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Geospatial 地理位置 【底层由Zset实现、因此可以使用zset的命令，如ZREM等】&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 添加城市及经纬度信息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;GEOADD key &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;NX|XX&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;CH&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; longitude latitude member &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;longitude latitude member ...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; GEOADD china:city 116.40 39.90 beijing     &lt;span style=&#34;color:#75715e&#34;&gt;# 经度、纬度&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; GEOADD china:city 121.47 31.23 shanghai
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; type china:city                            &lt;span style=&#34;color:#75715e&#34;&gt;# 底层由Zset实现&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;zset
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;------------------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 获取指定城市的经纬度信息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;GEOPOS key member &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;member ...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; GEOPOS china:city beijing
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;116.39999896287918091&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   2&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;39.90000009167092543&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-------------------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 获取两地的距离（直线距离）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;GEODIST key member1 member2 &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;m|km|ft|mi&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;                     &lt;span style=&#34;color:#75715e&#34;&gt;# 可指定单位，默认为米&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; GEODIST china:city beijing shanghai km
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1067.3788&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-------------------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 获取范围内的元素&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;GEORADIUS key longitude latitude radius m|km|ft|mi          &lt;span style=&#34;color:#75715e&#34;&gt;# 根据指定经纬度和半径获取范围内的元素&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; GEORADIUS china:city &lt;span style=&#34;color:#ae81ff&#34;&gt;120&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;500&lt;/span&gt; km          &lt;span style=&#34;color:#75715e&#34;&gt;# 经度、维度、半径&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hangzhou&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;shanghai&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;GEORADIUSBYMEMBER key member radius m|km|ft|mi              &lt;span style=&#34;color:#75715e&#34;&gt;# 根据元素名和半径获取范围内的元素&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Hypeloglog（基数统计、即去重后计数）【占用内存很小，最大只需要12KB】（有0.81%错误率）&amp;mdash; 使用伯努利概率分布，根据第一个 1 出现的位置推测有多少基数。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;PFADD key element &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;element ...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;                  &lt;span style=&#34;color:#75715e&#34;&gt;# 添加&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;PFCOUNT key &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;key ...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;                            &lt;span style=&#34;color:#75715e&#34;&gt;# 基数统计&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; pfadd key a a a a l k j h j k l d
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;127.0.0.1:6379&amp;gt; PFCOUNT key
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;integer&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;PFMERGE destkey sourcekey &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;sourcekey ...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 合并&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Bitmaps（位图）
&lt;ul&gt;
&lt;li&gt;位存储、只有两种状态的都可以用它存储&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SETBIT key offset value                          &lt;span style=&#34;color:#75715e&#34;&gt;# 添加，其中value的值只能是 0 或 1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;GETBIT key offset                                &lt;span style=&#34;color:#75715e&#34;&gt;# 查看&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BITCOUNT key &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;start end&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;                         &lt;span style=&#34;color:#75715e&#34;&gt;# 统计value为 1 的个数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h3 id=&#34;发布订阅&#34;&gt;发布订阅&lt;/h3&gt;
&lt;h4 id=&#34;基于频道&#34;&gt;基于频道&lt;/h4&gt;
&lt;p&gt;基于频道(Channel)的发布/订阅有两个命令分别是 publish 和 subscribe 。&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL主从复制</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Sun, 27 Mar 2022 21:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</guid>
      <description>&lt;h3 id=&#34;复制原理&#34;&gt;复制原理&lt;/h3&gt;
&lt;p&gt;主从复制的原理其实就是把主服务器上的 binlog 日志复制到从服务器上执行一遍，这样从服务器上的数据就和主服务器上的数据相同了。&lt;/p&gt;
&lt;h3 id=&#34;复制过程&#34;&gt;复制过程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;主节点开启bin-log功能，记录任何修改了数据库数据的事件。&lt;/li&gt;
&lt;li&gt;从节点每隔一定时间探测 master 的 binlog 是否发生改变，如果发生改变，则开启一个线程（I/O Thread)把自己扮演成 mysql 的客户端，请求主节点的binlog，请求时携带参数 position 表示请求该位置之后的内容；如果不携带表示从头开始复制（用于首次复制）。&lt;/li&gt;
&lt;li&gt;主节点启动一个线程（dump Thread）与从节点的 I/O Thread建立连接，将 binlog 中 position 之后的内容返回给从节点 IO 线程。&lt;/li&gt;
&lt;li&gt;从节点接收到主节点发送过来的数据把它放置到中继日志（Relay log）文件中。&lt;/li&gt;
&lt;li&gt;从节点启动另外一个线程（sql Thread ），把 Relay log 中的事件读取出来，并在本地再执行一次。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;复制策略&#34;&gt;复制策略&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;「同步策略」&lt;/strong&gt;：Master会等待所有的Slave都回应后才会提交，用于强一致性场景但会严重影响性能&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;「半同步策略」&lt;/strong&gt;：Master至少会等待一个Slave回应后提交。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;「异步策略」&lt;/strong&gt;：Master不用等待Slave回应就可以提交。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;「延迟策略」&lt;/strong&gt;：Slave要落后于Master指定的时间。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;binlog-格式&#34;&gt;Binlog 格式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;statement：记录的是修改SQL语句&lt;/li&gt;
&lt;li&gt;row：记录的是每行实际数据的变更&lt;/li&gt;
&lt;li&gt;mixed：statement和row模式的混合&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;面试题&#34;&gt;面试题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;主从复制功能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负载均衡、读写分离&lt;/li&gt;
&lt;li&gt;备份容灾&lt;/li&gt;
&lt;li&gt;高可用和故障切换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;主从复制，达到了写性能的瓶颈如何解决&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分库分表&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主从复制的过程有数据延迟怎么办&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据延迟会导致Slave被读取到的数据并不是最新数据。&lt;/p&gt;
&lt;p&gt;如果业务场景需要强一致性，使用复制策略中的同步策略。&lt;/p&gt;</description>
    </item>
    <item>
      <title>InnoDB锁</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/innodb%E9%94%81/</link>
      <pubDate>Sun, 27 Mar 2022 17:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/innodb%E9%94%81/</guid>
      <description>&lt;p&gt;锁机制用于管理对共享资源的并发访问。&lt;/p&gt;
&lt;h2 id=&#34;1锁粒度&#34;&gt;1、锁粒度&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;表锁&lt;/strong&gt;是MySQL中最大粒度的锁定机制，会锁定整张表，可以很好的避免死锁，是 MySQL 中最大颗粒度的锁定机制。表锁由 MySQL Server 实现，一般在执行 DDL 语句时会对整个表进行加锁，比如说&lt;code&gt;ALTER TABLE&lt;/code&gt;等操作。在执行 DML 语句时，也可以通过&lt;code&gt;LOCK TABLES&lt;/code&gt;显式指定对某个表进行加锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;页级锁&lt;/strong&gt;锁定一页，主要应用于 BDB 存储引擎。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;行级锁&lt;/strong&gt;的锁定颗粒度在 MySQL 中是最小的，只针对操作的当前行进行加锁，所以行级锁发生锁定资源争用的概率也最小。只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。InnoDB 默认使用行级锁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2行锁详解&#34;&gt;2、行锁详解&lt;/h2&gt;
&lt;p&gt;InnoDB默认使用行锁，实现了两种标准的行锁——共享锁与排他锁；&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;共享锁与排他锁&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/innodb%E9%94%81/%E5%85%B1%E4%BA%AB%E9%94%81%E4%B8%8E%E6%8E%92%E4%BB%96%E9%94%81.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;1、除了显式加锁的情况，其他情况下的加锁与解锁都无需人工干预。
2、InnoDB所有的行锁算法都是基于索引实现的，锁定的也都是索引或索引区间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;lock in share mode&lt;/strong&gt;与&lt;strong&gt;for update&lt;/strong&gt;的区别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;lock in share mode 是共享锁；for update 是排他锁&lt;/li&gt;
&lt;li&gt;没有覆盖索引时，两种锁都需要即锁辅助索引又锁主键索引；当有覆盖索引时，lock in share mode 只锁辅助索引，而 for update 即锁辅助索引又锁主键索引。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3当前读与快照读&#34;&gt;3、当前读与快照读&lt;/h2&gt;
&lt;p&gt;**1、当前读：**即加锁读，读取记录的最新版本，会加锁保证其他并发事务不能修改当前记录，直至获取锁的事务释放锁；使用当前读的操作主要包括：显式加锁的读操作与插入/更新/删除等写操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、快照读&lt;/strong&gt;：即不加锁读，读取记录的快照版本而非最新版本，通过MVCC实现；&lt;/p&gt;
&lt;p&gt;InnoDB默认的RR事务隔离级别下，不显式加『lock in share mode』与『for update』的『select』操作都属于快照读，保证事务执行过程中只有第一次读之前提交的修改和自己的修改可见，其他的均不可见；&lt;/p&gt;
&lt;h2 id=&#34;4mvcc&#34;&gt;4、MVCC&lt;/h2&gt;
&lt;p&gt;MVCC『多版本并发控制』，与之对应的是『基于锁的并发控制』；&lt;/p&gt;
&lt;p&gt;MVCC的最大好处：读不加任何锁，读写不冲突，对于读操作多于写操作的应用，极大的增加了系统的并发性能；&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;mvcc&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/innodb%E9%94%81/mvcc.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;5锁算法&#34;&gt;5、锁算法&lt;/h2&gt;
&lt;p&gt;InnoDB主要实现了三种行锁算法：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;三种行锁算法&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/innodb%E9%94%81/%E4%B8%89%E7%A7%8D%E8%A1%8C%E9%94%81%E7%AE%97%E6%B3%95.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;51记录锁&#34;&gt;5.1、记录锁&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;记录锁(Record Locks)&lt;/code&gt;也称为行锁，顾名思义，表示对某一行记录加锁。&lt;/p&gt;
&lt;h3 id=&#34;52间隙锁&#34;&gt;5.2、间隙锁&lt;/h3&gt;
&lt;p&gt;Gap锁，锁定的是索引记录之间的间隙，是防止幻读的关键；并发事务插入新数据前会先检测间隙中是否已被加锁，防止幻读的出现；间隙锁与间隙锁不互斥。&lt;/p&gt;
&lt;p&gt;注意！间隙锁锁住的是一个区间，而不仅仅是这个区间中目前仅存在的数据行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;插入意向锁&lt;/code&gt;名字里虽然有意向锁这三个字，但是它并不是意向锁，它属于行级锁，是一种特殊的间隙锁，该锁只用于并发插入操作。是在插入一条记录行前，由 &lt;code&gt;INSERT&lt;/code&gt; 操作产生的一种&lt;code&gt;间隙锁&lt;/code&gt;。该锁用以表示插入意向，由于插入意向锁只是锁住一个点，当多个事务在同一区间插入位置不同的多条数据时，事务之间不需要互相等待。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;间隙锁的意义只在于阻止区间被插入&lt;/strong&gt;，因此是可以共存的。&lt;strong&gt;一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁&lt;/strong&gt;，共享和排他的间隙锁是没有区别的，他们相互不冲突，且功能相同。&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL小知识</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%B0%8F%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Sun, 27 Mar 2022 17:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%B0%8F%E7%9F%A5%E8%AF%86/</guid>
      <description>&lt;h3 id=&#34;1or和union的区别&#34;&gt;1、or和union的区别&lt;/h3&gt;
&lt;p&gt;对于单列来说，用or是没有任何问题的，但是or涉及到多个列的时候，每次select只能选取一个index，另一列需要进行table-scan，即全部扫描一遍，但是使用union就可以解决这个问题，分别使用各自列的index进行查询。 但是这里还会有一个问题就是，UNION会对结果进行排序去重，可能会降低一些performance。&lt;/p&gt;
&lt;h3 id=&#34;2having和where的区别&#34;&gt;2、having和where的区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;where是在分组前对数据进行过滤；where后面不可以使用聚合函数&lt;/li&gt;
&lt;li&gt;having是在分组后对数据进行过滤；having后面可以使用聚合函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;having 的作用就是弥补 where 的粗粒度，实现在组内更细粒度的筛选。&lt;/p&gt;
&lt;p&gt;在查询过程中执行顺序：from&amp;gt;where&amp;gt;group（含聚合）&amp;gt;having&amp;gt;order&amp;gt;select。&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL索引</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Sun, 27 Mar 2022 17:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E7%B4%A2%E5%BC%95/</guid>
      <description>&lt;p&gt;索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组。&lt;/p&gt;
&lt;h2 id=&#34;1索引类型&#34;&gt;1、索引类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;普通索引：最基本的索引，可以在任意一列或多列的组合上加普通索引。允许存在重复值以及空值。&lt;/li&gt;
&lt;li&gt;唯一索引：与普通索引不同的是，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。&lt;/li&gt;
&lt;li&gt;主键索引：与唯一索引不同的是，不允许有空值。&lt;/li&gt;
&lt;li&gt;组合索引：组合索引与单列索引相对应，只包含一个字段的索引叫做单列索引，包含两个或以上字段的索引叫做复合索引（或组合索引）。上述三种索引既可以是单列索引也可以是组合索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2聚集索引&#34;&gt;2、聚集索引&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;聚簇索引&lt;/strong&gt;的叶子节点就是数据节点，而&lt;strong&gt;非聚簇索引&lt;/strong&gt;的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。&lt;/p&gt;
&lt;p&gt;怎么理解呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;聚簇索引的顺序，就是数据在硬盘上的物理顺序。一般情况下主键就是默认的聚簇索引。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一张表&lt;strong&gt;只允许存在一个&lt;/strong&gt;聚簇索引，因为真实数据的物理顺序只能有一种。如果一张表上还没有聚簇索引，为它新创建聚簇索引时，就需要对已有数据重新进行排序，所以对表进行修改速度较慢是聚簇索引的缺点，对于&lt;strong&gt;经常更新的列不宜建立聚簇索引&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;聚簇索引性能最好，因为一旦具有第一个索引值的记录被找到，具有连续索引值的记录也一定物理地紧跟其后。一张表只能有一个聚簇索引，所以非常珍贵，必须慎重设置，一般要根据这个表最常用的SQL查询方式选择某个（或多个）字段作为聚簇索引（&lt;strong&gt;或复合聚簇索引&lt;/strong&gt;）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;InnoDB对主键建立聚簇索引。&lt;/li&gt;
&lt;li&gt;如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。&lt;/li&gt;
&lt;li&gt;如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3索引的最左匹配&#34;&gt;3、索引的最左匹配&lt;/h2&gt;
&lt;p&gt;最左前缀匹配原则，非常重要的原则，建立一个索引，对于索引中的字段，mysql会一直向右匹配直到遇到范围查询(&amp;gt;、&amp;lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &amp;gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。&lt;/p&gt;
&lt;p&gt;mysql创建复合索引的规则是首先会对复合索引的最左边的，也就是第一个name字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的cid字段进行排序。其实就相当于实现了类似 order by name cid这样一种排序规则。
所以：第一个name字段是绝对有序的，而第二字段就是无序的了。所以通常情况下，直接使用第二个cid字段进行条件判断是用不到索引的。&lt;/p&gt;
&lt;p&gt;在第一个值等值匹配的前提下，第二个值是有序的，因此mysql索引规则中要求复合索引要想使用第二个索引，必须先使用第一个索引的原因。（而且第一个索引必须是&lt;strong&gt;等值匹配&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;order by&lt;/code&gt;也会用到索引，但前提是 &lt;code&gt;where&lt;/code&gt;子句必须用到索引；如果 &lt;code&gt;where&lt;/code&gt;子句的字段没有索引，即使&lt;code&gt;order by&lt;/code&gt;的字段有索引也不会用到。&lt;code&gt;where&lt;/code&gt;和&lt;code&gt;order by&lt;/code&gt;使用的索引可以是同一个组合索引，同样符合最左匹配原则，比如 &lt;code&gt;select * from tb_user where name = &amp;quot;lu&amp;quot; and age &amp;lt; 21 order by score&lt;/code&gt;，如果有 &lt;code&gt;(name, age, score)&lt;/code&gt; 的组合索引，由于 &lt;code&gt;age&lt;/code&gt; 使用了范围搜索，&lt;code&gt;score&lt;/code&gt; 索引就会失效。&lt;/p&gt;</description>
    </item>
    <item>
      <title>事务实现原理</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sun, 27 Mar 2022 17:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>&lt;p&gt;MySQL 默认开启事务自动提交模式，即除非显式的开启事务（BEGIN 或 START TRANSACTION），否则每条 SOL 语句都会被当做一个单独的事务自动执行。&lt;/p&gt;
&lt;p&gt;在 MySQL 中，可以使用 SET autocommit 语句设置事务的自动提交模式，语法格式如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SET&lt;/span&gt; autocommit &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ON&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;OFF&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对取值的说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;值为 0 和值为 OFF：关闭事务自动提交。如果关闭自动提交，用户将会一直处于某个事务中，只有提交或回滚后才会结束当前事务，重新开始一个新事务。&lt;/li&gt;
&lt;li&gt;值为 1 和值为 ON：开启事务自动提交。如果开启自动提交，则每执行一条 SQL 语句，事务都会提交一次。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事务想要做到可靠性以及并发处理。&lt;/p&gt;
&lt;h2 id=&#34;1redo-log-与-undo-log&#34;&gt;1、redo log 与 undo log&lt;/h2&gt;
&lt;h3 id=&#34;11redo-log&#34;&gt;1.1、redo log&lt;/h3&gt;
&lt;p&gt;mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Boffer Pool(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做&lt;strong&gt;缓冲池和磁盘之间的同步&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么问题来了，如果还没来的同步的时候宕机或断电了怎么办？还没来得及执行上面图中红色的操作。这样会导致丢部分已提交事务的修改信息！&lt;/p&gt;
&lt;p&gt;所以引入了redo log来记录已成功提交事务的修改信息，并且会把redo log持久化到磁盘，系统重启之后在读取redo log恢复最新数据。&lt;/p&gt;
&lt;p&gt;redo log在事务提交时就写入磁盘，不会等待后台程序执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt; redo log是用来恢复数据的 用于保障，已提交事务的持久化特性。&lt;/p&gt;
&lt;p&gt;既然redo log也需要存储，也涉及磁盘IO为啥还用它？&lt;/p&gt;
&lt;p&gt;（1）redo log 的存储是顺序存储，而缓存同步是随机操作。&lt;/p&gt;
&lt;p&gt;（2）缓存同步是以数据页为单位的，每次传输的数据大小大于redo log。&lt;/p&gt;
&lt;h3 id=&#34;12undo-log&#34;&gt;1.2、undo log&lt;/h3&gt;
&lt;p&gt;undo log 叫做回滚日志，用于记录数据&lt;strong&gt;被修改前&lt;/strong&gt;的信息。会记录执行的操作以及修改前的信息，这样根据操作记录做相反的操作即可恢复到事务执行前的状态。&lt;/p&gt;
&lt;p&gt;undo log 记录事务修改之前版本的数据信息，因此假如由于系统错误或者rollback操作而回滚的话可以根据undo log的信息来进行回滚到没被修改前的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt; undo log是用来回滚数据的用于保障 未提交事务的原子性&lt;/p&gt;
&lt;h2 id=&#34;2事务的实现&#34;&gt;2、事务的实现&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;事务的原子性是通过 undo log 来实现的&lt;/li&gt;
&lt;li&gt;事务的持久性性是通过 redo log 来实现的&lt;/li&gt;
&lt;li&gt;事务的隔离性是通过 (读写锁+MVCC)来实现的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性&lt;/strong&gt;是通过原子性，持久性，隔离性来实现的！！&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;21原子性的实现&#34;&gt;2.1、原子性的实现&lt;/h3&gt;
&lt;p&gt;一个事务必须被视为不可分割的最小工作单位，一个事务中的所有操作要么全部成功提交，要么全部失败回滚，对于一个事务来说不可能只执行其中的部分操作，这就是事务的原子性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ConcurrentHashMap</title>
      <link>https://ethereal-lu.github.io/posts/java/java-%E8%BF%9B%E9%98%B6/concurrenthashmap/</link>
      <pubDate>Sat, 26 Mar 2022 11:12:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/java/java-%E8%BF%9B%E9%98%B6/concurrenthashmap/</guid>
      <description>&lt;h3 id=&#34;1concurrenthashmap-如何保证线程安全&#34;&gt;1、ConcurrentHashMap 如何保证线程安全&lt;/h3&gt;
&lt;p&gt;ConcurrentHashMap 是由 Node 数组构成，这里先将 Node 数组的每个下标对应的空间称为一个桶，以方便叙述。ConcurrentHashMap 的 get 操作不需要加锁，只有 put 和 remove 需要加锁。当执行 put\remove 操作时，会先定位到桶，然后将桶中的链表头节点或树的根节点锁住，因为必须要获取到链表头节点或树的根节点才能对整个链表或树操作，所以可以保证线程安全。&lt;/p&gt;
&lt;p&gt;当 put 操作发现桶中没有数据时，会通过 cas 操作赋值，而不是上锁。&lt;/p&gt;
&lt;h3 id=&#34;2concurrenthashmap-扩容&#34;&gt;2、ConcurrentHashMap 扩容&lt;/h3&gt;
&lt;p&gt;ConcurrentHashMap 中有一个 sizeCtl 变量，它类似于 HashMap 中的 threshold ，通过比较元素数量与 sizeCtl 的大小判断是否需要扩容。扩容时，先创建一个2倍大小的新数组并初始化一个forwardNode实例fwd，然后遍历每一个桶，若桶中元素为 null 时，直接将其赋值为fwd，否则将桶中的元素转移到新数组，再将其赋值为fwd。在扩容的过程中若进来其他的读线程，若读线程发现桶中的元素是 fwd，就会帮助进行转移，否则进行正常的读操作。若进来写线程，若写线程发现桶中的元素是 fwd，就会帮助进行转移，否则阻塞，直到扩容完成。&lt;/p&gt;</description>
    </item>
    <item>
      <title>基础数据结构</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sat, 26 Mar 2022 11:12:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>&lt;h2 id=&#34;1总体注意事项&#34;&gt;1、总体注意事项&lt;/h2&gt;
&lt;h3 id=&#34;11输入方式&#34;&gt;1.1、输入方式&lt;/h3&gt;
&lt;p&gt;两种输入方式，对于绝大多数时候，均选择&lt;code&gt;Scanner&lt;/code&gt;作为输入。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.util.Scanner;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Scanner sc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Scanner(System.&lt;span style=&#34;color:#a6e22e&#34;&gt;in&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当输入数据很大时，选择 &lt;code&gt;BufferedReader&lt;/code&gt;，但其只能以行作为单位读取，需要分割为字符串数组，再解析为其他类型。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.io.BufferedReader;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.io.InputStreamReader;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BufferedReader br &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; BufferedReader(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; InputStreamReader(System.&lt;span style=&#34;color:#a6e22e&#34;&gt;in&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;12读取&#34;&gt;1.2、读取&lt;/h3&gt;
&lt;p&gt;有些题目会有共包含 T 组案例，每组案例内 *** 操作，这种只需按 T 建循环即可。但有些题目没有指明共有 T 组案例，却在案例中包含了多组案例，此使必须在所有代码的外面包裹一层 &lt;code&gt;while (sc.hasNext()) {...}&lt;/code&gt;，否则会出现虽然自测通过，但提交时却通过 0 组。&lt;/p&gt;
&lt;h3 id=&#34;13审题&#34;&gt;1.3、审题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;当感觉找到一个比题目复杂度要求还低的方法时，一定要慎重考虑，这个方法真的对吗，能否覆盖所有情况，尽早换思路。&lt;/li&gt;
&lt;li&gt;遇到与数字相关的题目，先看能不能找规律或化简，将题目转化为简单的模型再做。&lt;/li&gt;
&lt;li&gt;与数字相关的题目，一定看是否为越界，注意用 long 和 double。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2链表&#34;&gt;2、链表&lt;/h2&gt;
&lt;h3 id=&#34;21链表反转&#34;&gt;2.1、链表反转&lt;/h3&gt;
&lt;p&gt;可以使用的方法有 栈、三指针法、头插法&lt;/p&gt;
&lt;p&gt;使用&lt;strong&gt;头插法&lt;/strong&gt;，因为对于一个区间的反转或者 k 个一组反转，使用头插法非常方便。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; ListNode &lt;span style=&#34;color:#a6e22e&#34;&gt;reverseKGroup&lt;/span&gt; (ListNode head, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; k) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ListNode pre &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ListNode(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pre.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; head;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ListNode ret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pre, p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; head;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    tag: &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (p &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 如果最后不够 k 个，则不反转&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; k; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (p &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt; tag;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; p.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pre.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 使用头插法，注意：循环 k - 1 次。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ListNode temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; p.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            p.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; temp.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            temp.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pre.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            pre.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; temp;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        pre &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; p;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; p.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ret.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;22lru缓存&#34;&gt;2.2、LRU缓存&lt;/h3&gt;
&lt;p&gt;方法一：LinkedHashMap。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Docker基础</title>
      <link>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8/docker/docker%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 17 Mar 2022 17:12:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8/docker/docker%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;1概述&#34;&gt;1、概述&lt;/h2&gt;
&lt;p&gt;Docker 基于 Go 语言实现。一次镜像，处处运行。&lt;/p&gt;
&lt;p&gt;Go文件编译后是平台级别的机器码，因此Docker 不需要 Go 环境支撑。由于 Docker 容器模型是基于 linux 内核的，因此 Docker 必须安装在 linux 环境上。&lt;/p&gt;
&lt;p&gt;Docker for Windows 中负责运行环境配置的工具是 Docker Machine。它会在 Windows 上创建一个 Linux 虚拟机，用于运行 Docker 引擎。&lt;/p&gt;
&lt;p&gt;Docker 相关的本地资源都存放在&lt;code&gt;/var/lib/docker/&lt;/code&gt;目录下&lt;/p&gt;
&lt;p&gt;docker 的配置文件路劲：&lt;code&gt;/etc/default/docker&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;11lcx&#34;&gt;1.1、LCX&lt;/h3&gt;
&lt;p&gt;Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。&lt;/p&gt;
&lt;p&gt;LXC与docker的关系&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker并不是LXC的替代品，Docker的底层就是使用了LXC来实现的。LXC将Linux进程沙盒化，使得进程之间相互隔离，并且能够控制各进程的资源分配。&lt;/li&gt;
&lt;li&gt;在LXC的基础之上，Docker提供了一系列更强的功能。
&lt;ul&gt;
&lt;li&gt;移植性：通过抽象容器配置，容器可以实现一个平台移植到另一个平台；&lt;/li&gt;
&lt;li&gt;镜像系统：基于 AUFS 的镜像系统为容器的分发带来了很多的便利，同时共同的 镜像层只需要存储一份，实现高效率的存储；&lt;/li&gt;
&lt;li&gt;版本管理：类似于 GIT 的版本管理理念，用户可以更方面的创建、管理镜像文件；&lt;/li&gt;
&lt;li&gt;仓库系统：仓库系统大大降低了镜像的分发和管理的成本；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12docker-启动为什么比虚拟机快&#34;&gt;1.2、docker 启动为什么比虚拟机快&lt;/h3&gt;
&lt;p&gt;1.Docker有着比虚拟机更少的抽象层，由于Docker不需要Hypervisor实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在Cpu、内存利用率上Docker将会在效率上有明显优势。&lt;/p&gt;
&lt;p&gt;2.Docker利用的是宿主机的内核，而不需要Guest OS，因此，当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统，避免了引导、加载操作系统内核这个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载Guest OS，这个新建过程是分钟级别的，而Docker由于直接利用宿主机的操作系统则省略了这个过程，因此新建一个Docker容器只需要几秒钟。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;/th&gt;
          &lt;th&gt;Docker容器&lt;/th&gt;
          &lt;th&gt;虚拟机（VM）&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;操作系统&lt;/td&gt;
          &lt;td&gt;与宿主机共享OS&lt;/td&gt;
          &lt;td&gt;宿主机OS上运行宿主机OS&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;存储大小&lt;/td&gt;
          &lt;td&gt;镜像小，便于存储与传输&lt;/td&gt;
          &lt;td&gt;镜像庞大（vmdk等）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;运行性能&lt;/td&gt;
          &lt;td&gt;几乎无额外性能损失&lt;/td&gt;
          &lt;td&gt;操作系统额外的cpu、内存消耗&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;移植性&lt;/td&gt;
          &lt;td&gt;轻便、灵活、适用于Linux&lt;/td&gt;
          &lt;td&gt;笨重、与虚拟化技术耦合度高&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;硬件亲和性&lt;/td&gt;
          &lt;td&gt;面向软件开发者&lt;/td&gt;
          &lt;td&gt;面向硬件运维者&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;2基本组成&#34;&gt;2、基本组成&lt;/h2&gt;
&lt;p&gt;docker 的三要素是：镜像、容器、仓库。&lt;/p&gt;</description>
    </item>
    <item>
      <title>C# 学习笔记</title>
      <link>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/c%23-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 01 Dec 2021 21:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/c%23-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;1基础概念&#34;&gt;1、基础概念&lt;/h2&gt;
&lt;h3 id=&#34;11net--概念&#34;&gt;1.1、.Net  概念&lt;/h3&gt;
&lt;p&gt;通常所说的 .Net 包括 .Net 平台和 .Net FrameWork 框架。它们两者的关系即 jvm 和 jre 的关系。&lt;/p&gt;
&lt;p&gt;.Net FrameWork 框架由两部分组成，分别是 .Net 类库和 CLR（公共语言运行时）。&lt;/p&gt;
&lt;h3 id=&#34;12c-语言&#34;&gt;1.2、C# 语言&lt;/h3&gt;
&lt;p&gt;C# 是一种编程语言，可以开发基于  .Net 平台 的应用。&lt;/p&gt;
&lt;h3 id=&#34;13net-作用&#34;&gt;1.3、.Net 作用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Winform 开发桌面应用程序&lt;/li&gt;
&lt;li&gt;ASP.NET 开发 web 网站&lt;/li&gt;
&lt;li&gt;Unity3D 开发游戏和虚拟现实&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;14net-两种交互模式&#34;&gt;1.4、.Net 两种交互模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C/S：客户机（Client）/服务器模式。客户端需要安装专用的客户端软件，如 微信。&lt;/li&gt;
&lt;li&gt;B/S：浏览器（Browser）/服务器模式。客户端只需要安装浏览器即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2语法规则&#34;&gt;2、语法规则&lt;/h2&gt;
&lt;p&gt;C# 的基础语法规则几乎与 java 一样。&lt;/p&gt;
&lt;h3 id=&#34;21基本类型&#34;&gt;2.1、基本类型&lt;/h3&gt;
&lt;p&gt;与 java 一样，包括 byte、short、int、long、float、double、bool等，u开头表示无符号。&lt;/p&gt;
&lt;p&gt;如果一个小数是浮点类型，则其后需加个 f ，否则默认为 double 型。&lt;/p&gt;
&lt;h3 id=&#34;22字符串&#34;&gt;2.2、字符串&lt;/h3&gt;
&lt;p&gt;类名为 string ，小写。它的使用和 java 几乎一样，注意方法名为大写开头。&lt;/p&gt;
&lt;p&gt;字符串格式化：&lt;code&gt;string str = $&amp;quot;{name}的年龄为{age}&amp;quot;&lt;/code&gt;，其中name和age为之前声明的变量。&lt;/p&gt;
&lt;h3 id=&#34;23函数&#34;&gt;2.3、函数&lt;/h3&gt;
&lt;p&gt;C# 的函数名要大写开头。&lt;/p&gt;</description>
    </item>
    <item>
      <title>VMware &#43; Ubuntu18.04设置静态 IP</title>
      <link>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81-ip/</link>
      <pubDate>Sun, 14 Nov 2021 22:08:18 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81-ip/</guid>
      <description>&lt;p&gt;进入VMware 的虚拟网络编辑器；&lt;/p&gt;
&lt;p&gt;选择 VMnet8，点击 DHCP 设置，记住子网 IP，子网掩码和起始终止 IP，关闭。&lt;/p&gt;
&lt;p&gt;点击右下方的更改设置，取消勾选 DHCP 分配 IP。再输入刚才记住的子网 IP 和子网掩码。&lt;/p&gt;
&lt;p&gt;点击 NET 设置，记住网关并点击左下方的 DNS 设置，取消勾选自动检测并设置首选DNS为 8.8.8.8，备用为 114.114.114.114。确定、确定、应用。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;打开主机的网络适配器中的 VMnet8 ，进入它的 IPV4 设置，将 IP 设置为之前记住的起始终止 IP 之间的任意一个，子网掩码和 DNS 都与之前设置的VMware一致。&lt;/p&gt;
&lt;p&gt;一路确定并禁用再启用 VMnet8。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;打开虚拟机，bash 输入 &lt;code&gt;vim /etc/network/interfaces&lt;/code&gt;，内容如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;source /etc/network/interfaces.d/*
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;auto lo
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;iface lo inet loopback
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;auto ens32
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;iface ens32 inet static          &lt;span style=&#34;color:#75715e&#34;&gt;# 下方设置与之前步骤设置的一致&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        address 192.168.40.130   &lt;span style=&#34;color:#75715e&#34;&gt;# 主机中设置的 IP，以后虚拟机 IP 固定为它&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        netmask 255.255.255.0    &lt;span style=&#34;color:#75715e&#34;&gt;# 子网掩码&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        gateway 192.168.40.2     &lt;span style=&#34;color:#75715e&#34;&gt;# 网关&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        dns-nameservers 8.8.8.8  &lt;span style=&#34;color:#75715e&#34;&gt;# dns&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输入&lt;code&gt;vim /etc/systemd/resolved.conf&lt;/code&gt;，使其内容如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>feign发起https请求</title>
      <link>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/feign%E5%8F%91%E8%B5%B7https%E8%AF%B7%E6%B1%82/</link>
      <pubDate>Tue, 02 Nov 2021 11:08:18 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/feign%E5%8F%91%E8%B5%B7https%E8%AF%B7%E6%B1%82/</guid>
      <description>&lt;h3 id=&#34;1安装-openssl&#34;&gt;1、安装 openssl&lt;/h3&gt;
&lt;p&gt;2、bash 进入任意目录执行以下命令&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mkdir certs                              &lt;span style=&#34;color:#75715e&#34;&gt;# 证书目录&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mkdir private                            &lt;span style=&#34;color:#75715e&#34;&gt;# 密钥目录&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;openssl rand -out private/.rand &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;     &lt;span style=&#34;color:#75715e&#34;&gt;# 在构建根证书之前需要构建随机数文件(.rand)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;openssl genrsa -aes256 -out private/ca.key.pem &lt;span style=&#34;color:#ae81ff&#34;&gt;2048&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;# 构建根证书私钥&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;openssl req -new -key private/ca.key.pem -out private/ca.csr -subj &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/C=CN/ST=BJ/L=BJ/O=FATE/OU=fate/CN=*.FATE.ORG&amp;#34;&lt;/span&gt;       &lt;span style=&#34;color:#75715e&#34;&gt;# 生成根证书签发申请&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;openssl x509 -req -days &lt;span style=&#34;color:#ae81ff&#34;&gt;10000&lt;/span&gt; -sha1 -extensions v3_ca -signkey private/ca.key.pem -in private/ca.csr -out certs/ca.cer         &lt;span style=&#34;color:#75715e&#34;&gt;# 签发根证书&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;openssl  pkcs12 -export -cacerts -inkey private/ca.key.pem -in certs/ca.cer -out certs/ca.p12  &lt;span style=&#34;color:#75715e&#34;&gt;# 根证书转换为PKCS12格式密钥库&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;openssl genrsa -aes256 -out private/server.key.pem &lt;span style=&#34;color:#ae81ff&#34;&gt;2048&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;# 构建服务器证书私钥&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;openssl req -new -key private/server.key.pem -out private/server.csr -subj &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/C=CN/ST=BJ/L=BJ/0=fate/OU=fate/CN=www.fate.org&amp;#34;&lt;/span&gt;         &lt;span style=&#34;color:#75715e&#34;&gt;# 生成服务器证书签发申请&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;openssl x509 -req -days &lt;span style=&#34;color:#ae81ff&#34;&gt;3650&lt;/span&gt; -sha1 -extensions v3_req  -CA  certs/ca.cer -CAkey private/ca.key.pem  -CAserial ca.srl  -CAcreateserial -in private/server.csr -out certs/server.cer                         &lt;span style=&#34;color:#75715e&#34;&gt;# 签发服务器证书&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;openssl pkcs12 -export -clcerts -inkey private/server.key.pem  -in certs/server.cer -out certs/server.p12                         &lt;span style=&#34;color:#75715e&#34;&gt;# 服务器证书转换为PKCS12格式密钥库&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;3、将 server.p12 复制到微服务端的 resources 目录下&lt;/p&gt;</description>
    </item>
    <item>
      <title>微服务学习笔记</title>
      <link>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 25 Oct 2021 17:42:15 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;1微服务架构介绍httpsmartinfowlercomarticlesmicroserviceshtml&#34;&gt;1、&lt;a href=&#34;https://martinfowler.com/articles/microservices.html&#34;&gt;微服务架构介绍&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&#34;11微服务概念&#34;&gt;1.1、微服务概念&lt;/h3&gt;
&lt;p&gt;微服务就是将一个单体架构的应用按业务划分为一个个独立运行的程序即服务，他们之间通过 HTTP 协议进行通信（也可以采用消息队列来通信，如 RabbotMQ、Kafaka 等），可以采用不同的编程语言，使用不同的存储技术，自动化部署（如Jenkins）减少人为控制，降低出错概率。服务数量越多，管理起来越复杂，因此采用集中化管理。例如 Eureka，Zookeeper 等都是比较常见的服务集中化管理框架。&lt;/p&gt;
&lt;p&gt;微服务是一种架构风格。有两个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;职责单一：一个微服务解决一个业务问题（注意是一个业务问题而不是一个接口）。&lt;/li&gt;
&lt;li&gt;面向服务：将自己的业务能力封装并对外提供服务，这是继承SOA的核心思想，一个微服务本身也可能调用其它的微服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12微服务设计原则&#34;&gt;1.2、微服务设计原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AKF 拆分原则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前后端分离原则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无状态服务&lt;/p&gt;
&lt;p&gt;状态：如果一个数据需要被多个服务共享，才能完成一笔交易，那么这个数据被称为状态。进而依赖这个状态数据的服务被称为有状态服务，反之称为无状态服务。&lt;/p&gt;
&lt;p&gt;例如对空调的设置：1、若空调遥控器发送加一或减一的指令，空调根据现在的温度计算并调整温度，则空调提供的是有状态服务，状态是空调当前温度。2、若空调遥控器发送的是加一或减一之后的温度数值，空调根据接收到的温度数值设置温度，则空调提供的是无状态服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Restful 通信风格&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2eureka-注册中心&#34;&gt;2、Eureka 注册中心&lt;/h2&gt;
&lt;p&gt;应用微服务化之后，首先遇到的第一个问题就是服务发现问题，一个微服务如何发现其他微服务呢？最简单的方式就是每个微服务里面配置其他微服务的地址，但是当微服务数量众多的时候，这样做明显不现实。所以需要使用到微服务架构中的一个最重要的组件：&lt;strong&gt;服务注册中心&lt;/strong&gt;，所有服务都注册到服务注册中心，同时也可以从服务注册中心获取当前可用的服务清单。&lt;/p&gt;
&lt;h3 id=&#34;21注册中心概念&#34;&gt;2.1、注册中心概念&lt;/h3&gt;
&lt;p&gt;注册中心可以理解为微服务架构中的“通讯录”。它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其他服务时，就到这里找到服务的地址，进行调用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;张三办了张新的电话卡并将号码告诉我，我将其名字和号码的映射保存进通讯录。              -- 服务注册&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;我想给张三打电话，于是在通讯录中根据其名字找到张三，然后根据映射到的电话号码拨打       -- 服务发现&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;---------------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;上例中我和张三分别代表一个微服务，通讯录是独立于我和张三的服务注册中心&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;总结：服务注册中心的作用就是&lt;strong&gt;服务的注册&lt;/strong&gt;和&lt;strong&gt;服务的发现&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;22eureka-入门案例&#34;&gt;2.2、Eureka 入门案例&lt;/h3&gt;
&lt;p&gt;1、创建一个 SpringBoot 项目并引入web、test和下方两个依赖 。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-cloud-dependencies&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;2020.0.4&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;type&amp;gt;&lt;/span&gt;pom&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/type&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;runtime&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-eureka-server&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.0.4&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2、application.yaml 如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;server&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;port&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;8761&lt;/span&gt;               &lt;span style=&#34;color:#75715e&#34;&gt;# 官方文档使用的端口&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;spring&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;application&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;eureka-server   &lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 应用名称&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 配置 eureka-server 注册中心&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;eureka&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;instance&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;hostname&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;localhost             &lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 主机名，默认根据操作系统的主机名获取&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;client&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 下方值为 false 的两项，只有当自身为单节点的注册中心时才需要设置为 false 。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 单节点指的是只有一个注册中心，不是只有一个微服务。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 当自身是微服务或者是集群中的注册中心之一时无需设置，使用默认 true。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;register-with-eureka&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;# 是否将自己注册到注册中心，默认为 true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;fetch-registry&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# 是否从注册中心获取服务注册信息，默认 true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;service-url&lt;/span&gt;:                     &lt;span style=&#34;color:#75715e&#34;&gt;# 注册中心对外暴露的注册地址&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;defaultZone&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;http://${eureka.instance.hostname}:${server.port}/eureka/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;3、启动类前添加 @EnableEurekaServer 注解&lt;/p&gt;</description>
    </item>
    <item>
      <title>设计模式</title>
      <link>https://ethereal-lu.github.io/posts/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 25 Sep 2021 17:12:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;1设计模式分类&#34;&gt;1、设计模式分类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;创建型模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;结构型模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;行为型模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2uml图&#34;&gt;2、UML图&lt;/h2&gt;
&lt;p&gt;统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。&lt;/p&gt;
&lt;h3 id=&#34;21类的表示方式&#34;&gt;2.1、类的表示方式&lt;/h3&gt;
&lt;p&gt;在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/Employee.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;+：表示public&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-：表示private&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;#：表示protected&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;属性的完整表示方式是： &lt;strong&gt;可见性  名称 ：类型 [ = 缺省值]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法的完整表示方式是： &lt;strong&gt;可见性  名称(参数列表) [ ： 返回类型]&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;22类与类之间关系的表示方式&#34;&gt;2.2、类与类之间关系的表示方式&lt;/h3&gt;
&lt;p&gt;感觉没必要记，用到时再查吧。&lt;/p&gt;
&lt;h2 id=&#34;3软件设计原则&#34;&gt;3、软件设计原则&lt;/h2&gt;
&lt;p&gt;在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。&lt;/p&gt;
&lt;h3 id=&#34;31-开闭原则&#34;&gt;3.1 开闭原则&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;对扩展开放，对修改关闭&lt;/strong&gt;。即使用接口和抽象类，扩展时实现新的派生类而不修改子类。增加新功能时添加新的代码，而不要修改原有代码。&lt;/p&gt;
&lt;h3 id=&#34;32-里氏代换原则&#34;&gt;3.2 里氏代换原则&lt;/h3&gt;
&lt;p&gt;里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。&lt;/p&gt;
&lt;h3 id=&#34;33-依赖倒转原则&#34;&gt;3.3 依赖倒转原则&lt;/h3&gt;
&lt;p&gt;高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。&lt;/p&gt;
&lt;p&gt;简单说就是尽量让接口作为成员变量，而不要让实现类作为成员变量。&lt;/p&gt;
&lt;h3 id=&#34;34-接口隔离原则&#34;&gt;3.4 接口隔离原则&lt;/h3&gt;
&lt;p&gt;客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。&lt;/p&gt;
&lt;p&gt;被迫依赖：类 B 为了定义一个已经在类 A 中定义了的方法而去继承类 A，此时类 B 被迫依赖于类 A 中其他它并不需要的方法。&lt;/p&gt;
&lt;p&gt;应该将该方法单独抽象为接口，若所有实现类的方法体都一样，可以用 default 修饰并实现。&lt;/p&gt;
&lt;p&gt;继承接口时也一样，不要使类被迫依赖于接口中其他不适用的方法。应该将接口拆分为多个接口。&lt;/p&gt;</description>
    </item>
    <item>
      <title>指令重排与内存屏障</title>
      <link>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E4%B8%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/</link>
      <pubDate>Thu, 26 Aug 2021 23:08:18 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E4%B8%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/</guid>
      <description>&lt;h2 id=&#34;指令重排&#34;&gt;指令重排&lt;/h2&gt;
&lt;p&gt;有两种发生指令重排的情况：一个是编译的时候，由编译原理的知识知道，编译器会对代码进行优化，这一步就涉及到指令重排，当然，编译完成之后的目标代码中指令的顺序就是确定的，不同线程执行该代码的顺序是一样的；另一个就是CPU在执行具体的指令的时候，也会因为计算机当前的状态（比如寄存器的占用情况、ALU的使用情况，cup缓存层的存在等原因）的不同导致指令最终的执行顺序发生变化(实际上，cpu本身并不会对指令进行重排，它本身是按照编译后的顺序来执行指令的，只是由于执行不同的指令需要的时间长短不同，以及缓存层的存在，再加上CPU执行指令的流水线并不是串行化等因素，那么就有可能出现排在靠前位置的指令还没执行完，而排在靠后的指令已经执行完了的情况，这一情况就是所谓的CPU执行指令的乱序）&lt;/p&gt;
&lt;h4 id=&#34;编译器指令重排&#34;&gt;编译器指令重排&lt;/h4&gt;
&lt;p&gt;如果两条有依赖关系 (像 a++; b=f(a); ) 的指令挨得很近，后一条指令必定会因为等待前一条执行的结果，而在流水线中阻塞很久(这个“很久”是对计算机而言哈)。而编译器的乱序，作为编译优化的一种手段，则试图通过指令重排，在这两条指令之间插入其他指令，将这两条指令拉开一定的距离，以保证后一条指令执行的时候前一条指令结果已经得到了，那么也就不需要阻塞等待了。所以相比于CPU的乱序，编译器的乱序才是真正对指令顺序做了调整，但是编译器所进行的调整也必须保证上下文的依赖逻辑，即存在依赖关系的指令顺序不能调整。&lt;/p&gt;
&lt;h4 id=&#34;cpu-指令重排&#34;&gt;CPU 指令重排&lt;/h4&gt;
&lt;p&gt;现在的CPU一般采用流水线来执行指令。一个指令的执行被分成：取址，译码，访存，执行，写回等若干个阶段。流水线中的多个指令是可以同时处于同一个阶段的，只要CPU内部相应的处理部件未被占满。这样一来，乱序就可能产生了。比如一条加法指令出现在一条除法指令的后面，但由于除法的执行时间很长，在它执行完之前，加法可能就先执行完了。再比如两条访存指令，可能由于第二条指令中了cache(或其它原因)而导致它先于第一条指令完成。指令流水线除了在资源不足的情况下会卡住之外(如一个加法器应付两条加法指令)，指令之间存在的相互依赖才是导致流水线阻塞的主要原因。当然，CPU的乱序执行并不是任意地乱序，而必须保证上下文依赖逻辑的正确性。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;内存屏障&#34;&gt;内存屏障&lt;/h2&gt;
&lt;p&gt;不存在依赖关系的内存操作会被按随机顺序有效得到执行，但这在CPU与CPU(多核)交互时或CPU与IO设备交互(一般IO比较耗时)时，这可能成为问题。我们需要一些手段来干预编译器和CPU对指令顺序的影响，而内存屏障就是这样的干预手段。它们能保证处于屏障两边的内存操作满足部分有序(“部分有序”的意思是，内存屏障之前的操作必须都先于屏障之后的操作，但是如果几个操作出现在屏障的一边，则不保证它们有序)。这样的强制措施是非常重要的，因为系统中的CPU和其它设备可以使用各种各样的策略来提高性能，包括对内存操作的乱序、延迟和合并执行、预取、投机性的分支预测和各种缓存……内存屏障就是用于禁用或者抑制这些策略，使代码能够清楚地控制多个CPU和/或设备的交互。操心系统中存在各式各样的内存屏障，不同的内存屏障涉及到了各种复杂的实现，这里不过多地讲了，但关于内存屏障还要记住的一点就是：在内存屏障之前出现的内存访问不保证在内存屏障指令完成之前完成，内存屏障相当于在该CPU的访问队列中画了一条线，使得相关访存类型的请求不能相互跨越(用于实现内存屏障的指令，其本身并不作为参考对象，其两边的访存操作才被当作参考对象，所以屏障指令执行完成并不表示出现在屏障之前的所有访存操作都已经完成，但如果屏障之后的某一个访存操作已经完成，则屏障指令之前的所有访存操作必定都已经完成了)。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;要想并发程序正确地执行，必须要保证程序的原子性、可见性以及有序性。只要有一个没有被保证，就可能会导致程序运行不正确。&lt;/p&gt;</description>
    </item>
    <item>
      <title>lambda 表达式中使用的变量为什么必须是 final</title>
      <link>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/lambda/</link>
      <pubDate>Wed, 18 Aug 2021 23:08:18 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/lambda/</guid>
      <description>&lt;p&gt;Java 规范中规定：Lambda 表达式中要用到的，但又未在 Lambda 表达式中声明的变量，必须声明为 final 或者是 effectively final，否则就会出现编译错误。&lt;/p&gt;
&lt;p&gt;有效 final 即不用显示声明为 final，由 JVM 添加 final。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;个人理解&#34;&gt;个人理解&lt;/h4&gt;
&lt;p&gt;由于 lambda 表达式相当于生成一个对象，存储在堆中（生命周期长），而方法的局部变量存储在栈中（生命周期短）。如果 lambda 表达式在使用了外部方法中的局部变量后，该局部变量又发生变化，且方法执行完毕内存被释放，此 lambda 表达式生成的对象可能依然存活（未被GC回收），但是却无法得知局部变量改变后的值，造成数据一致性破坏。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 报错&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Test&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 5;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Runnable runnable &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; () &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            a&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上方在方法中报错而下方在类中不报错，因此推断与栈和堆的生存周期有关系。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 不报错&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Test&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 3;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Runnable runnable &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; () &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        a&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;**存在问题：**作为方法中的内部类，既然方法被释放后，该类绝不可能再被使用，矛盾！&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;其他理解&#34;&gt;其他理解&lt;/h4&gt;
&lt;p&gt;lambda是对接口中的方法的一种简写方式，当方法想要使用外部的变量的时候，需要把值给传过去，但是方法中无论怎么改变量的值，都不会改变这个变量在外部的值（值传递和引用传递的区别），所以加上final就是为了方便开发者，以免误以为可以更改这个变量的值。final的目的就是告诉开发人员不能改变外面的变量值。&lt;/p&gt;
&lt;p&gt;**存在问题：**外部变量什么时候传递给 lambda 的。难道隐式的传了？&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;悬而未决，先睡觉&lt;/p&gt;</description>
    </item>
    <item>
      <title>文件的 MD5 值</title>
      <link>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E6%96%87%E4%BB%B6md5/</link>
      <pubDate>Wed, 18 Aug 2021 23:08:18 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E6%96%87%E4%BB%B6md5/</guid>
      <description>&lt;h3 id=&#34;是什么&#34;&gt;是什么&lt;/h3&gt;
&lt;p&gt;文件的 MD5 值不是文件的属性也不是文件存储的内容，而是由分析程序根据文件的信息分析得到的一串独一无二的字符值。当两个文件的 MD5 值相同时说明这两个文件的内容完全一样。任何数据计算得到的 MD5 值长度都相等。&lt;/p&gt;
&lt;h3 id=&#34;作用&#34;&gt;作用&lt;/h3&gt;
&lt;p&gt;由于同一个分析程序对于内容一样的文件分析得到的 MD5 值始终是一样的，因此可以通过对传输前后的文件进行 MD5 值的对比来检验传输途中文件是否被他人篡改。&lt;/p&gt;
&lt;h3 id=&#34;md5-值何时改变&#34;&gt;MD5 值何时改变&lt;/h3&gt;
&lt;p&gt;1、不同的分析程序对同一份文件分析得到的 MD5 值可能不同。&lt;/p&gt;
&lt;p&gt;2、对文件的内容进行增删改后，文件的 MD5 值会发生改变。&lt;/p&gt;
&lt;p&gt;3、修改文件的名称和后缀都不会改变文件的 MD5 值。&lt;/p&gt;
&lt;h3 id=&#34;查看文件-md5-值的方法&#34;&gt;查看文件 MD5 值的方法&lt;/h3&gt;
&lt;p&gt;1、Windows&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;certutil -hashfile 文件路径 md5
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 示例&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;certutil -hashfile E:&lt;span style=&#34;color:#ae81ff&#34;&gt;\资&lt;/span&gt;料&lt;span style=&#34;color:#ae81ff&#34;&gt;\作&lt;/span&gt;业资料&lt;span style=&#34;color:#ae81ff&#34;&gt;\a&lt;/span&gt;bc.py md5
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2、Linux&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;md5sum 文件路径
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>JUC 并发编程</title>
      <link>https://ethereal-lu.github.io/posts/java/juc%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 16 Aug 2021 17:12:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/java/juc%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;线程基础知识&#34;&gt;线程基础知识&lt;/h2&gt;
&lt;h3 id=&#34;概述&#34;&gt;概述&lt;/h3&gt;
&lt;p&gt;每个线程拥有一个自己独立的栈，但是共享进程的堆空间。&lt;/p&gt;
&lt;p&gt;Thread 中的 run 方法是一个回调函数，与普通函数没什么区别，所以以如下方式调用run时，就是一个普通的方法执行。而 start 方法会在本地创建一个线程，然后在本地代码中通过 jvm 回调 run 方法来执行任务。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Thread thread &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Thread(() &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; {...});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;thread.&lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;线程实现方法&#34;&gt;线程实现方法&lt;/h3&gt;
&lt;p&gt;Thread类是描述线程的类，要实现多线程，必须继承Thread类&lt;/p&gt;
&lt;h5 id=&#34;方法一创建thread类的子类&#34;&gt;方法一、创建Thread类的子类&lt;/h5&gt;
&lt;p&gt;1、创建Thread类的子类，并重写run方法，其中设置线程的任务&lt;/p&gt;
&lt;p&gt;2、创建子类对象，并执行start方法&lt;/p&gt;
&lt;p&gt;​	（执行start方法会创建一个新的栈空间，并在该栈空间中执行run方法。每执行一次步骤2，就开启一个新的线程）&lt;/p&gt;
&lt;h5 id=&#34;方法二实现runnable接口&#34;&gt;方法二、实现Runnable接口&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;推荐使用这种&lt;/strong&gt;   &amp;mdash;&amp;gt;  使用该方法时，Thread 类是咱们自定义类的静态代理类&lt;/p&gt;
&lt;p&gt;1、创建一个Runnable接口的实现类，并重写run方法，其中设置线程的任务&lt;/p&gt;
&lt;p&gt;2、创建对象，并将其作为参数传递给Thread类的构造方法，再调用start方法。&lt;/p&gt;
&lt;p&gt;​     new Thread(new MyRunnable()).start();
​     匿名内部类实现： new Thread(new Runnable(){重写run方法}).start();&lt;/p&gt;
&lt;h5 id=&#34;方法三实现callablev接口&#34;&gt;方法三、实现Callable&lt;V&gt;接口&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;Callable接口类似于Runnable，但Runnable不会返回结果，也不会抛出检查异常，Callable可以&lt;/strong&gt;，Runnable 效率比 Callable 低。&lt;/p&gt;
&lt;p&gt;1、创建一个Callable&lt;V&gt;接口的实现类，并重写call方法，其中设置线程的任务
2、在使用的地方创建该类对象 obj 。
3、ExecutorService executorService = Executors.newFixedThreadPool(5);  // 创建执行服务
4、Future&lt;V&gt; future = executorService.submit(obj);                                       // 提交执行
5、V result = future.get();                                                                                 // 获取结果
6、executorService.shutdownNow();                                                               // 关闭服务&lt;/p&gt;</description>
    </item>
    <item>
      <title>Enum 向注解赋值问题</title>
      <link>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/enum%E8%B5%8B%E5%80%BC/</link>
      <pubDate>Wed, 11 Aug 2021 16:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/enum%E8%B5%8B%E5%80%BC/</guid>
      <description>&lt;h3 id=&#34;问题&#34;&gt;问题&lt;/h3&gt;
&lt;p&gt;Enum 如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Getter&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@AllArgsConstructor&lt;/span&gt;(access &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; AccessLevel.&lt;span style=&#34;color:#a6e22e&#34;&gt;PRIVATE&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; RoleEnum {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ADMIN       (0, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;admin&amp;#34;&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ANALYST     (1, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;analyst&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; Integer intValue;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; String strValue;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将该 enum 对象的属性赋值给注解时报错：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@RequiresRoles&lt;/span&gt;(RoleEnum.&lt;span style=&#34;color:#a6e22e&#34;&gt;ADMIN&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getStrValue&lt;/span&gt;())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// error: &amp;#34;attribute value must be constant&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;报错显示注解所需值必须是常量&lt;/p&gt;
&lt;p&gt;这是因为 ADMIN 作为 RoleEnum 的对象，只有当 RoleEnum 被类加载器所加载之后才会生成，而在编译期 strValue 属性还是变量，所以会报错。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;解决&#34;&gt;解决&lt;/h3&gt;
&lt;p&gt;在 enum 中添加内部类存储常量&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Getter&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@AllArgsConstructor&lt;/span&gt;(access &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; AccessLevel.&lt;span style=&#34;color:#a6e22e&#34;&gt;PRIVATE&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; RoleEnum {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ADMIN       (0, Names.&lt;span style=&#34;color:#a6e22e&#34;&gt;ADMIN&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ANALYST     (1, Names.&lt;span style=&#34;color:#a6e22e&#34;&gt;ANALYST&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Names&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; String ADMIN   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;admin&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; String ANALYST &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;analyst&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; Integer intValue;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; String strValue;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;向注解中赋值时使用内部类的常量&lt;/p&gt;</description>
    </item>
    <item>
      <title>Shrio学习笔记</title>
      <link>https://ethereal-lu.github.io/posts/java/shiro%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 27 Jul 2021 18:48:13 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/java/shiro%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;作者  小陈&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微信 chenxu521600&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;B站 编程不良人  |  百知教育&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;资料 &lt;a href=&#34;http://www.baizhiedu.xin&#34;&gt;http://www.baizhiedu.xin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20200520220106539&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/java/shiro%E7%AC%94%E8%AE%B0/image-20200520220106539.png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1权限的管理&#34;&gt;1.权限的管理&lt;/h2&gt;
&lt;h3 id=&#34;11-什么是权限管理&#34;&gt;1.1 什么是权限管理&lt;/h3&gt;
&lt;p&gt;基本上涉及到用户参与的系统都要进行权限管理，权限管理属于系统安全的范畴，权限管理实现&lt;code&gt;对用户访问系统的控制&lt;/code&gt;，按照安全规则或者&lt;a href=&#34;http://baike.baidu.com/view/160028.htm&#34;&gt;安全策略&lt;/a&gt;控制用户可以访问而且只能访问自己被授权的资源。&lt;/p&gt;
&lt;p&gt;权限管理包括用户&lt;code&gt;身份认证&lt;/code&gt;和&lt;code&gt;授权&lt;/code&gt;两部分，简称&lt;code&gt;认证授权&lt;/code&gt;。对于需要访问控制的资源用户首先经过身份认证，认证通过后用户具有该资源的访问权限方可访问。&lt;/p&gt;
&lt;h3 id=&#34;12-什么是身份认证&#34;&gt;1.2 什么是身份认证&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;身份认证&lt;/code&gt;，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确。对于采用&lt;a href=&#34;http://baike.baidu.com/view/5628.htm&#34;&gt;指纹&lt;/a&gt;等系统，则出示指纹；对于硬件Key等刷卡系统，则需要刷卡。&lt;/p&gt;
&lt;h3 id=&#34;13-什么是授权&#34;&gt;1.3 什么是授权&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;授权，即访问控制&lt;/code&gt;，控制谁能访问哪些资源。主体进行身份认证后需要分配权限方可访问系统的资源，对于某些资源没有权限是无法访问的&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2什么是shiro&#34;&gt;2.什么是shiro&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Apache Shiro™&lt;/strong&gt; is a powerful and easy-to-use Java security framework that performs authentication, authorization, cryptography, and session management. With Shiro’s easy-to-understand API, you can quickly and easily secure any application – from the smallest mobile applications to the largest web and enterprise applications.&lt;/p&gt;
&lt;p&gt;Shiro 是一个功能强大且易于使用的Java安全框架，它执行身份验证、授权、加密和会话管理。使用Shiro易于理解的API，您可以快速轻松地保护任何应用程序—从最小的移动应用程序到最大的web和企业应用程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Shiro是apache旗下一个开源框架，它将软件系统的安全认证相关的功能抽取出来，实现用户身份认证，权限授权、加密、会话管理等功能，组成了一个通用的安全认证框架。&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;3shiro的核心架构&#34;&gt;3.shiro的核心架构&lt;/h2&gt;
&lt;p&gt;&lt;img alt=&#34;image-20200520220413190&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/java/shiro%E7%AC%94%E8%AE%B0/image-20200520220413190.png&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>MyBatisPlus学习笔记</title>
      <link>https://ethereal-lu.github.io/posts/java/mybatisplus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 18 Jul 2021 19:42:15 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/java/mybatisplus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;1快速开始&#34;&gt;1、快速开始&lt;/h2&gt;
&lt;h3 id=&#34;11导入依赖&#34;&gt;1.1、导入依赖&lt;/h3&gt;
&lt;p&gt;mybatis 和 mybatis-plus 的依赖不要同时导入。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;mysql&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;runtime&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.baomidou&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;mybatis-plus-boot-starter&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.4.3&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.baomidou&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;mybatis-plus-core&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.4.3&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.projectlombok&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;lombok&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;optional&amp;gt;&lt;/span&gt;true&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/optional&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;test&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;12配置&#34;&gt;1.2、配置&lt;/h3&gt;
&lt;p&gt;在主yaml中配置和 mybatis 的完全一样，没其他配置。&lt;/p&gt;
&lt;h3 id=&#34;13使用&#34;&gt;1.3、使用&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Repository&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;UserMapper&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; BaseMapper&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;User&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;UserMapper 接口只需继承 BaseMapper ，其中泛型填入被操作的实体类。BaseMapper 中已经实现许多的方法，直接使用即可。&lt;/p&gt;
&lt;h2 id=&#34;2配置日志&#34;&gt;2、配置日志&lt;/h2&gt;
&lt;p&gt;使用 mybatis-plus 的方法时，具体 sql 代码是不可见的，我们希望知道它是怎么执行的，就需要看日志。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 配置日志&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;mybatis-plus&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;configuration&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;log-impl&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;org.apache.ibatis.logging.stdout.StdOutImpl &lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# 这里使用 mybatis 自带的控制台输出&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;3crud扩展&#34;&gt;3、CRUD扩展&lt;/h2&gt;
&lt;p&gt;数据库的 user 表如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>JVM学习笔记</title>
      <link>https://ethereal-lu.github.io/posts/java/jvm%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 10 Jul 2021 19:42:15 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/java/jvm%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;p&gt;&lt;strong&gt;JVM有几大模块组成：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;类加载的子系统&lt;/li&gt;
&lt;li&gt;内存模型&lt;/li&gt;
&lt;li&gt;执行引擎&lt;/li&gt;
&lt;li&gt;垃圾收集器（GC）&lt;/li&gt;
&lt;li&gt;JIT(热点代码缓存)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;自动内存管理&#34;&gt;自动内存管理&lt;/h2&gt;
&lt;h3 id=&#34;1内存区域划分&#34;&gt;1、内存区域划分&lt;/h3&gt;
&lt;p&gt;Java虚拟机所管理的内存包括方法区、虚拟机栈、本地方法栈、堆、程序计数器。&lt;/p&gt;
&lt;h4 id=&#34;11程序计数器&#34;&gt;1.1、程序计数器&lt;/h4&gt;
&lt;p&gt;字节码解释器工作时就是通过改变这个计数器 的值来选取下一条需要执行的字节码指令，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。&lt;/p&gt;
&lt;p&gt;如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地 址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。&lt;/p&gt;
&lt;h4 id=&#34;12虚拟机栈&#34;&gt;1.2、虚拟机栈&lt;/h4&gt;
&lt;p&gt;Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。&lt;/p&gt;
&lt;p&gt;局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、 float、long、double）、对象引用和returnAddress 类型。操作数栈主要用于保存方法执行过程中变量的临时结果，方法执行过程中会根据字节码指令向操作数栈压入和弹出数据，返回值也是存储在操作数栈中。&lt;/p&gt;
&lt;h4 id=&#34;13本地方法栈&#34;&gt;1.3、本地方法栈&lt;/h4&gt;
&lt;p&gt;本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机 栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native） 方法服务。&lt;/p&gt;
&lt;h4 id=&#34;14堆&#34;&gt;1.4、堆&lt;/h4&gt;
&lt;p&gt;Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java 世界里“几乎”所有的对象实例都在这里分配内存。&lt;/p&gt;
&lt;p&gt;Class 对象也存储在堆中。以 Person 类为例，类加载时会创建 instanceKlass （jvm 的一种数据结构）用来存储 Person 类的元数据，包括常量池、字段、方法等，存放在方法区，若是第一次加载 Person 类，会同时生成这个类对应的Class对象， instanceKlass 中包含指向该 Class 对象的指针；之后每次创建 person 实例时都是通过Class对象作为模板创建的（即不是根据 instanceKlass 创建对象），person 实例中包含指向方法区  instanceKlass 的指针。&lt;/p&gt;
&lt;p&gt;Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该 被视为连续的。&lt;/p&gt;
&lt;h4 id=&#34;15方法区&#34;&gt;1.5、方法区&lt;/h4&gt;
&lt;p&gt;方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。&lt;/p&gt;
&lt;p&gt;运行时常量池（Runtime Constant Pool）是方法区的一部分。用于存放编译期生成的各种字面量与符号引用。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2hotspot虚拟机对象探秘&#34;&gt;2、HotSpot虚拟机对象探秘&lt;/h3&gt;
&lt;h4 id=&#34;21对象的创建&#34;&gt;2.1、对象的创建&lt;/h4&gt;
&lt;p&gt;1、先检查类是否已经被加载、解析和初始化过，如果没有，那必须先执行相应的类加载过程。&lt;/p&gt;
&lt;p&gt;2、为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。当使用带压缩整理过程的收集器时，内存的分配算法是指针碰撞，既简单又高效；而当使用基于清除算法的收集器时，采用较为复杂的空闲列表来分配内存。&lt;/p&gt;
&lt;p&gt;3、虚拟机将分配到的内存空间（但不包括对象头）都初始化为零值。&lt;/p&gt;
&lt;p&gt;4、设置对象头中的信息。&lt;/p&gt;
&lt;p&gt;5、执行构造函数，按照程序员的意愿对对象进行初始化。&lt;/p&gt;
&lt;h4 id=&#34;22对象的内存布局&#34;&gt;2.2、对象的内存布局&lt;/h4&gt;
&lt;p&gt;对象在堆内存中的存储布局可以划分为三个部分：对象头、实例数据和对齐填充。&lt;/p&gt;</description>
    </item>
    <item>
      <title>c语言数组赋值问题</title>
      <link>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC/</link>
      <pubDate>Sun, 06 Jun 2021 20:57:45 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC/</guid>
      <description>&lt;p&gt;数组正常初始化是没问题的&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; ch[&lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Reindeer&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但是分步赋值，或重新赋值就会报错&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 分步赋值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; ch[&lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ch &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Reindeer&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 重新赋值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; ch[&lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Reindeer&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ch &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Ethereal&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 报错  Array type &amp;#39;char [50]&amp;#39; is not assignable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;原因&lt;/strong&gt;： ch 就是字符数组的首地址，是一个常量，不能作为左值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决&lt;/strong&gt;：可以使用 strcpy 函数赋值&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; ch[&lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;strcpy&lt;/span&gt;(ch, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Ethereal&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>javaScript学习笔记</title>
      <link>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/javascript%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 31 May 2021 19:42:15 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/javascript%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;p&gt;javaScript 也是万物皆对象。&lt;/p&gt;
&lt;h2 id=&#34;数据类型&#34;&gt;数据类型&lt;/h2&gt;
&lt;p&gt;ES6开始，所有的局部变量声明都用let，ES5及之前所有的变量声明都用var。&lt;/p&gt;
&lt;p&gt;ES6开始支持 &amp;ldquo;use strict&amp;rdquo; 即严格检查模式，预防javaScript的随意性导致的一些问题，使用时必须写在javaScript的第一行&lt;/p&gt;
&lt;h4 id=&#34;数值&#34;&gt;数值&lt;/h4&gt;
&lt;p&gt;弱类型，无需指定具体类型，只看做变量即可。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1.2&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1e5&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;字符串&#34;&gt;字符串&lt;/h4&gt;
&lt;p&gt;字符串是常量，不可变。&lt;/p&gt;
&lt;p&gt;单引号或双引号都可以，还可以用反引号写多行文字。特殊字符用 \ 转义。\n   \r   等与其他语言一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模板字符串&lt;/strong&gt;（和EL表达式一样） ES6才有&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Reindeer&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;greet&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello, ${name}&amp;#34;&lt;/span&gt;;    &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;Hello, Reindeer&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;方法&lt;/strong&gt;：java中String的方法基本都有，且名字和作用都一样。在js中字符串可以使用下标，且length是属性不是方法。&lt;/p&gt;
&lt;h4 id=&#34;数组&#34;&gt;数组&lt;/h4&gt;
&lt;p&gt;js中数组的长度可变：通过给arr.length赋值，可改变数组长度。若变大，新扩展单元为undefined；若变小，则截取前半段&lt;/p&gt;
&lt;p&gt;同一个数组中可以包含任意的数据类型，如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2.5&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;c&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;方法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;;                        &lt;span style=&#34;color:#75715e&#34;&gt;// 数组长度
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;------------------------------------------------------------------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;indexOf&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;2.5&lt;/span&gt;);                  &lt;span style=&#34;color:#75715e&#34;&gt;// 通过元素索引下标
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;------------------------------------------------------------------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 若数组中同时包含 数字1 和字符串&amp;#34;1&amp;#34; ，则他俩不一样
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;------------------------------------------------------------------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;newArr&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;slice&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)              &lt;span style=&#34;color:#75715e&#34;&gt;// 从下标2开始复制到末尾，返回新数组
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;newArr&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;slice&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;)           &lt;span style=&#34;color:#75715e&#34;&gt;// 从下标2开始复制下标4，返回新数组
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;------------------------------------------------------------------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 作为栈使用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;push&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Reindeer&amp;#34;&lt;/span&gt;);              &lt;span style=&#34;color:#75715e&#34;&gt;// 向数组尾部压入元素
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;pop&lt;/span&gt;();                         &lt;span style=&#34;color:#75715e&#34;&gt;// 从数组尾部弹出元素
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;unshift&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Reindeer&amp;#34;&lt;/span&gt;);           &lt;span style=&#34;color:#75715e&#34;&gt;// 向数组头部压入元素
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;shift&lt;/span&gt;();                       &lt;span style=&#34;color:#75715e&#34;&gt;// 从数组头部弹出元素
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 两者结合也可以用作队列
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;------------------------------------------------------------------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 其他常用方法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;sort&lt;/span&gt;();                        &lt;span style=&#34;color:#75715e&#34;&gt;// 排序  [1, 2.5, &amp;#34;c&amp;#34;, &amp;#34;hello&amp;#34;, true]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;reverse&lt;/span&gt;();                     &lt;span style=&#34;color:#75715e&#34;&gt;// 反转  [true, &amp;#34;hello&amp;#34;, &amp;#34;c&amp;#34;, 2.5, 1]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;concat&lt;/span&gt;([&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;]);             &lt;span style=&#34;color:#75715e&#34;&gt;// 拼接，返回新数组，不改变原数组。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;join&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;--&amp;#39;&lt;/span&gt;)                     &lt;span style=&#34;color:#75715e&#34;&gt;// 连接为字符串，&amp;#34;1--2.5--c--hello--true&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;], [&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;],[&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;]];  &lt;span style=&#34;color:#75715e&#34;&gt;// 多维数组
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;对象&#34;&gt;对象&lt;/h4&gt;
&lt;p&gt;js 的对象长得和 python 的字典一样。键都为字符串，值任意&lt;/p&gt;</description>
    </item>
    <item>
      <title>MyISAM与InnoDB 的区别</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/myisam%E4%B8%8Einnodb%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 22 May 2021 17:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/myisam%E4%B8%8Einnodb%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;InnoDB支持外键，而MyISAM不支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;InnoDB是聚集索引，InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt=&#34;MyISAM与InnoDB的索引&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/myisam%E4%B8%8Einnodb%E7%9A%84%E5%8C%BA%E5%88%AB/MyISAM%E4%B8%8EInnoDB%E7%9A%84%E7%B4%A2%E5%BC%95.jpg&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;InnoDB不保存表的具体行数，而MyISAM用一个变量保存了整个表的行数。（因为事务）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;InnoDB支持行级锁，MyISAM不支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;InnoDB表必须有主键索引（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    <item>
      <title>MySQL概述</title>
      <link>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 22 May 2021 17:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h3 id=&#34;基本命令&#34;&gt;基本命令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;show columns from user&lt;/code&gt; == &lt;code&gt;describe user&lt;/code&gt; == &lt;code&gt;desc user&lt;/code&gt;查询user表的结构&lt;/li&gt;
&lt;li&gt;sql的注释为两个杠 &lt;code&gt;--&lt;/code&gt;，多行注释为/*  */&lt;/li&gt;
&lt;li&gt;创建表：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 表明和字段名用反引号引起来是为了防止与sql的关键字相同，更规范
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;IF&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;EXISTS&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;user&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; (   &lt;span style=&#34;color:#75715e&#34;&gt;-- IF NOT EXISTS 为可选
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;-- COMMENT 为注释，在表中看不到，但是调出创建表的命令时，可以直观看到字段的含义
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;id&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; int &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; AUTO_INCREMENT &lt;span style=&#34;color:#66d9ef&#34;&gt;COMMENT&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;学号&amp;#39;&lt;/span&gt;,   
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;name&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; varchar(&lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;COMMENT&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;名字&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;birthday&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; DATETIME &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;COMMENT&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;出生日期&amp;#39;&lt;/span&gt;, 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;passwd&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; varchar(&lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;COMMENT&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;密码&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;perms&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt; varchar(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;normal&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;COMMENT&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;权限&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;id&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) ENGINE&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;InnoDB &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;utf8  &lt;span style=&#34;color:#75715e&#34;&gt;-- 显示声明引擎和默认字符集（可在my.ini中修改）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- 真实开发中还需要有，version（乐观锁）、deleted（逻辑删除）、gmt_create（创建时间）、
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;					&lt;span style=&#34;color:#75715e&#34;&gt;-- gmt_modified（修改时间）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;修改表&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ALTER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; teacher &lt;span style=&#34;color:#66d9ef&#34;&gt;RENAME&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; teacher1    &lt;span style=&#34;color:#75715e&#34;&gt;-- 修改表名
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ALTER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; teacher &lt;span style=&#34;color:#66d9ef&#34;&gt;ADD&lt;/span&gt; age INT           &lt;span style=&#34;color:#75715e&#34;&gt;-- 添加字段
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ALTER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; teacher &lt;span style=&#34;color:#66d9ef&#34;&gt;MODIFY&lt;/span&gt; age VARCHAR(&lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;)    &lt;span style=&#34;color:#75715e&#34;&gt;-- 修改字段的约束
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ALTER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; teacher CHANGE &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;旧名&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;新名&lt;/span&gt; INT   &lt;span style=&#34;color:#75715e&#34;&gt;-- 修改字段名（可以同时修改约束）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ALTER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; teacher &lt;span style=&#34;color:#66d9ef&#34;&gt;DROP&lt;/span&gt; age              &lt;span style=&#34;color:#75715e&#34;&gt;-- 删除字段
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;删除表&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;DROP&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;IF&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;EXISTS&lt;/span&gt; teacher              &lt;span style=&#34;color:#75715e&#34;&gt;-- 加上判断的删除
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;查看相关历史命令语句&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SHOW&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DATABASE&lt;/span&gt; mybatis &lt;span style=&#34;color:#75715e&#34;&gt;-- 查看创建数据库的语句
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SHOW&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;user&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;     &lt;span style=&#34;color:#75715e&#34;&gt;-- 查看创建数据表的语句
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h3 id=&#34;数据表类型引擎&#34;&gt;数据表类型（引擎）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MYISAM   早期使用          InnoDB 默认使用&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;/th&gt;
          &lt;th&gt;MYISAM&lt;/th&gt;
          &lt;th&gt;InnoDB&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;事务支持&lt;/td&gt;
          &lt;td&gt;不支持&lt;/td&gt;
          &lt;td&gt;支持&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;数据行锁定&lt;/td&gt;
          &lt;td&gt;不支持&lt;/td&gt;
          &lt;td&gt;支持&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;外键约束&lt;/td&gt;
          &lt;td&gt;不支持&lt;/td&gt;
          &lt;td&gt;支持&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;全文检索&lt;/td&gt;
          &lt;td&gt;支持&lt;/td&gt;
          &lt;td&gt;现在支持&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;表空间大小&lt;/td&gt;
          &lt;td&gt;较小&lt;/td&gt;
          &lt;td&gt;较大，约两倍&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;主要区别
&lt;ul&gt;
&lt;li&gt;MYISAM   节约空间，速度较快&lt;/li&gt;
&lt;li&gt;InnoDB     安全性高，支持事务，多表多用户操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;数据管理&#34;&gt;数据管理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DDL&lt;/strong&gt;，Data Definition Language，数据库定义语言
用于定义和管理数据库所有对象的语言，包括：CREATE，ALERT，DROP，TRUNCATE&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DML&lt;/strong&gt;，Data Manipulation Language，数据库操作语言
SQL中处理数据等操作，包括：SELECT，INSERT，UPDATE，DELETE，CALL，EXPLAIN PLAN，LOCK&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DCL&lt;/strong&gt;，Data Control Language，数据库控制语言
用来授予或回收访问数据库和某种特权并控制数据库操纵事务发生的时间及效果，对数据库实行监控，包括：COMMIT，SAVEPOINT，ROLLBACK，SET TRANSACTION&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;delete和truncate的区别&#34;&gt;delete和truncate的区别&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;TRUNCATE student&lt;/code&gt; == &lt;code&gt;DELETE FROM student&lt;/code&gt; 清空表内容&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java学习笔记</title>
      <link>https://ethereal-lu.github.io/posts/java/java%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 20 May 2021 17:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/java/java%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;数组&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    数组的初始化方式&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;动态初始化&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;指定长度&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;  数据类型&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; 数组名 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; 数据类型&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;数组长度&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;；&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;静态初始化&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;指定内容&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;  数据类型&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; 数组名 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; 数据类型&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; {元素1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; 元素2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; 元素3&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; ... }&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;；&lt;/span&gt; 元素值可以是变量
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             省略的静态初始化   数据类型&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; 数组名 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {元素1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; 元素2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; 元素3&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; ... }&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;；&lt;/span&gt;  该方式不允许拆分为2步&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;即先定义数组名&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;再经行赋值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    直接打印数组名&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;打印的是数组的内存地址&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    支持下标索引&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    未初始化的默认初始值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        整数类型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        浮点类型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 0.&lt;span style=&#34;color:#a6e22e&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        字符类型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\u0000&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        布尔类型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        引用类型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    获取数组长度&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 数组名.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    获取数组副本&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 数组名.&lt;span style=&#34;color:#a6e22e&#34;&gt;clone&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;成员变量与局部变量&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    成员变量定义在类内&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;方法外&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;局部变量定义在方法内&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    成员变量不要写static关键字&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;???&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    成员变量有默认值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;而局部变量没有默认值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    当成员变量与局部变量的命名冲突时&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;按照就近原则&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;优先使用局部变量&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;若想使用全局变量&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;使用this.&lt;span style=&#34;color:#a6e22e&#34;&gt;成员变量名&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;可变参数:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    使用前提&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;当方法的参数类型确定&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;但是参数个数不确定时&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;使用可变参数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    使用格式&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;修饰符 返回值类型 &lt;span style=&#34;color:#a6e22e&#34;&gt;方法名&lt;/span&gt;(数据类型...&lt;span style=&#34;color:#a6e22e&#34;&gt;变量名&lt;/span&gt;) {}   例如:   &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;... num) {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    原理&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;   可变参数底层是一个数组&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;根据传递参数个数的不同&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;会创建不同长度的数组&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;来存储这些参数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;参数个数可以是0个或多个&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            因此&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;方法中的变量名其实就是数组的名字&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;可以作为数组使用&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    注意&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;   一个方法的参数列表中只能有一个可变参数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            如果方法有多个参数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则可变参数必须放在参数末尾&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;类的使用:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;导包&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; 包路径.类名称   当类与当前文件处于同一个包中时&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;可以不用导包&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;只有java.&lt;span style=&#34;color:#a6e22e&#34;&gt;lang下的包不需要导包&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;其他都需要导包&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                            但实际使用中&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;可以不用手动导包&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;当你使用某个类时&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;系统会自动帮你导包&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;实例化&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 类名称 对象名 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; 类名称();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    3&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;使用: 对象名.&lt;span style=&#34;color:#a6e22e&#34;&gt;成员变量名&lt;/span&gt;        对象名.&lt;span style=&#34;color:#a6e22e&#34;&gt;成员方法名&lt;/span&gt;(参数)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Private:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Getter: 函数格式必须是 getXXX   如果变量是布尔类型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则使用isXXX
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Setter: 函数格式必须是 setXXX
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Private修饰构造函数时&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;外部不能再构造该类的实例&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;故只能在类内构造好全部实例并赋给static类型的变量&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;叫构造函数私有化
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;this: this是当前对象的引用&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;即this和对象是同一个东西&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;成员变量&lt;/span&gt;    调用本类成员变量    可以将类内的成员变量与方法中的同名局部变量区分&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;成员方法&lt;/span&gt;    调用本类成员方法
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;this&lt;/span&gt;(...)      调用本类构造函数 &lt;span style=&#34;color:#f92672&#34;&gt;--&amp;gt;&lt;/span&gt; 写在第一行&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;只能调用一个&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;  若子类使用了this(...)&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则不再默认赠送super()&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;成员变量&lt;/span&gt;   调用父类成员变量     可以将父类中的成员变量和子类中的同名成员变量区分&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;成员方法&lt;/span&gt;   调用父类成员变量
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;super&lt;/span&gt;(...)     调用父类类构造函数 &lt;span style=&#34;color:#f92672&#34;&gt;--&amp;gt;&lt;/span&gt; 写在第一行&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;只能调用一个&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;构造函数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    格式&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; 类名&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;参数类型 参数名称 &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; ...&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;{...}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    注意事项&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 构造方法的名称和类名要严格相等&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;大小写敏感&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             构造方法没有返回值类型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             若不明确定义构造函数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则会自动生成默认构造函数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;若手动定义了任意形式的构造函数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;编译器将不会再生成默认构造函数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             构造函数支持重载
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    继承中的构造函数:  构造链&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;同C&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;一样&lt;span style=&#34;color:#f92672&#34;&gt;--&amp;gt;&lt;/span&gt; 祖宗 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; 父类 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; 子类        子类构造方法中若不显式调用super&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则默认隐含一个 &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;super()&amp;#34;&lt;/span&gt; 调用&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    子类构造函数可以显式地写 &lt;span style=&#34;color:#a6e22e&#34;&gt;super&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;参数1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;) 来调用父类的重载构造函数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;且必须在方法体的第一行&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;即只能调用一个&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;标准类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;也叫做 Java Bean
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    通常包含以下4部分内容&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        所有的成员变量都要使用private关键字&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        为每一个成员变量编写一对儿Getter&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;Setter方法
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        编写一个无参构造函数
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        编写一个全参构造函数
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    点击 Code&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;Generate 或者 快捷键 alt &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; insert 可以自动生成上述内容
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    对于基本类型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 比较的是值
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    对于引用类型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 比较的是地址
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;基本类型与字符串之间的转换&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    基本类型 &lt;span style=&#34;color:#f92672&#34;&gt;--&amp;gt;&lt;/span&gt; 字符串
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;基本数据类型的值&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;  最简单的方式&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;工作中常用&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;使用包装类的静态方法   &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; String &lt;span style=&#34;color:#a6e22e&#34;&gt;toString&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i)  将i变为字符串形式   如 Integer.&lt;span style=&#34;color:#a6e22e&#34;&gt;toString&lt;/span&gt;(100);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        3&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;使用String类的静态方法   &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; String &lt;span style=&#34;color:#a6e22e&#34;&gt;valueOf&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i)  将i变为字符串形式   如 String.&lt;span style=&#34;color:#a6e22e&#34;&gt;valueOf&lt;/span&gt;(100);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    字符串 &lt;span style=&#34;color:#f92672&#34;&gt;--&amp;gt;&lt;/span&gt; 基本类型
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        使用包装类的静态方法 &lt;span style=&#34;color:#a6e22e&#34;&gt;parseXX&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;字符串&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            Integer    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;parseInt&lt;/span&gt;(String s)     如 Integer.&lt;span style=&#34;color:#a6e22e&#34;&gt;parseInt&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;100&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ... ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;泛型:  泛型名字不一定是E&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;可以是任意大写字母&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    类: &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ClassName&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;E&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; { ... 在类内将需要的地方都用E代替}     实例化对象时确定类型
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    方法: 修饰符 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;E&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; 返回值类型 &lt;span style=&#34;color:#a6e22e&#34;&gt;方法名&lt;/span&gt;(参数列表){ ... }                   调用方法时确定类型
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    接口: 含有泛型的接口定义与类相同&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;  确定类型的方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;在实现类中确定类型   2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;实现类依然沿用接口的泛型E&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;实现类创建对象时确定类型
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    通配符: &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;?&amp;gt;&lt;/span&gt;  代表任意数据类型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        使用: 例如当多个不同类型的ArrayList集合要作为参数调用同一个方法时&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;可以将参数设置为ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; list方便接受任意类型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        高级使用: &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; E 表示 &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; 只能是E的子类&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;本身
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt; E   表示 &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; 只能是E的父类&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;本身
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;static:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    带上static的成员变量或函数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;不属于对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;而是属于类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;所有对象共享&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    类名.&lt;span style=&#34;color:#a6e22e&#34;&gt;静态变量&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    类名.&lt;span style=&#34;color:#a6e22e&#34;&gt;静态方法&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    注意事项&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;静态不能直接访问非静态 &lt;span style=&#34;color:#f92672&#34;&gt;--&amp;gt;&lt;/span&gt; 在内存中&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;先有静态&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;后有非静态
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            静态不能使用this
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    静态代码块&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt;{  ...  }  首次用到类时&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;静态代码块唯一执行一次&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              典型用途&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;一次性地对静态成员变量赋值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;override:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    在子类的覆盖重写方法前面加上 &lt;span style=&#34;color:#a6e22e&#34;&gt;@override&lt;/span&gt; 可以检验该方法是否为重写方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;建议写上&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    子类方法的返回值的范围必须 小于等于 父类方法的返回值的范围&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    子类方法的权限必须 大于等于 父类方法的权限
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;权限&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;     (&lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;) 表示什么也不写&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;留空&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        同一个类        YES       YES          YES        &lt;span style=&#34;color:#a6e22e&#34;&gt;YES&lt;/span&gt;     (我自己)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        同一个包        YES       YES          YES        &lt;span style=&#34;color:#a6e22e&#34;&gt;NO&lt;/span&gt;      (我领居)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        不同包子类       YES       YES          NO         &lt;span style=&#34;color:#a6e22e&#34;&gt;NO&lt;/span&gt;     (我儿子)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        不同包不同类     YES        NO          NO         &lt;span style=&#34;color:#a6e22e&#34;&gt;NO&lt;/span&gt;      (陌生人)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;abstract:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    抽象方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;只定义&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;不实现&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;加上abstract关键字&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;去掉大括号&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;直接分号结束&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    抽象类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 抽象方法所在的类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;必须是抽象类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;在class前加上abstract即可&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;但抽象类中不一定包含抽象方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;通常是有的&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    使用步骤&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        抽象类不能直接创建对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        必须用一个子类继承抽象父类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        子类必须覆盖重写抽象父类中的所有抽象方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;--&amp;gt;&lt;/span&gt;此处覆盖重写即实现&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;子类去掉抽象方法的abstract关键字&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;然后补上方法体大括号&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        创建子类对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;并使用&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;概念&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;接口就是多个类的公共规范&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;是一种引用数据类型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;最重要的就是其中的抽象方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    定义&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;接口名称&lt;/span&gt; { ... }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    包含&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;常量&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;抽象方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;默认方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;静态方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;私有方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    常量&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;可以理解为成员变量&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;但是必须使用 &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; 三个关键字修饰&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;故相当于常量&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; 数据类型 常量名称 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 值  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;三个关键字可省略&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;但不能换为别的&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         注意&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;接口中的常量可以省略public &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;但写不写效果一样&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;接口中的常量必须手动赋值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;不能不赋值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;赋值之后无法改变&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              3&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;常量名称全部大写&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;由下划线连接&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         使用&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;接口名称.&lt;span style=&#34;color:#a6e22e&#34;&gt;常量&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    抽象方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;接口中的抽象方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;修饰符固定为 &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;abstract&lt;/span&gt;  (可省略&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;但不能换为别的)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;方法的三要素可随意定义&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    默认方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt; 返回值类型 &lt;span style=&#34;color:#a6e22e&#34;&gt;方法名&lt;/span&gt;(参数列表) {方法体} (public可省略&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;default不能省略)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            可以解决接口升级的问题&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。（&lt;/span&gt;不想改变实现类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;但是接口中又想要添加新方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则接口就可以用默认方法自己实现&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）（&lt;/span&gt;实现类可以覆盖重写默认方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            默认方法会被实现类继承&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;故可以通过实现类的对象访问默认方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    静态方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; 返回值类型 &lt;span style=&#34;color:#a6e22e&#34;&gt;方法名&lt;/span&gt;(参数列表) {方法体}  (public可省略&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;static不能省略)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            使用&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;接口名称.&lt;span style=&#34;color:#a6e22e&#34;&gt;静态方法&lt;/span&gt;(参数);  不能通过对象访问&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    私有方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;普通私有方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;解决多个默认方法之间的重复代码问题  &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; 返回值类型 &lt;span style=&#34;color:#a6e22e&#34;&gt;方法名&lt;/span&gt;(参数列表) {方法体}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                只有接口中的默认方法能访问&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;静态私有方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;解决多个静态方法之间的重复代码问题  &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; 返回值类型 &lt;span style=&#34;color:#a6e22e&#34;&gt;方法名&lt;/span&gt;(参数列表) {方法体}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                只有接口中的默认方法和静态方法能访问&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    使用&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;接口不能直接使用&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;必须有一个&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;“&lt;/span&gt;实现类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;”&lt;/span&gt;来&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;“&lt;/span&gt;实现&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;”&lt;/span&gt;该接口&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;实现类名称&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;implements&lt;/span&gt; 接口名称 {...}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;接口的实现类必须实现接口中的全部抽象方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;去掉abstract关键字&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;加上大括号实现体&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         3&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;创建实现类对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;使用&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    注意事项&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;接口没有静态代码块和构造方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;如果实现类没有覆盖重写所有接口中的所有方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则该实现类自己就必须是抽象类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            3&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;一个实现类可以实现多个接口  &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;类名&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;implements&lt;/span&gt; interface1, interface2 {}&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            4&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;若一个类实现的多个接口中有重名的抽象方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则只需实现一个即可&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            5&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;若一个类实现的多个接口中有重名的默认方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则该实现类必须对重名默认方法覆盖重写&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            6&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;若一个类的直接父类中的方法和它实现的接口中的默认方法重名&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则优先使用直接父类的方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt; 在java中&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;【&lt;/span&gt;继承 优先于 接口&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;】&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            7&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;接口是多继承的&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;多个父接口当中的抽象方法如果重名&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;没关系&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                           多个父接口当中的默认方法如果重名&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则子接口必须对重名的默认方法覆盖重写&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，【&lt;/span&gt;而且带着default关键字&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;】&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;多态&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：（&lt;/span&gt;一个子类对象既有子类形态&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;又有父类形态&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;一个对象拥有多种形态&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;即&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;【&lt;/span&gt;对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;】&lt;/span&gt;的多态性&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。【&lt;/span&gt;多态性指的是对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;而不是类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;】&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    代码中体现多态性&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 父类引用指向子类对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    格式   父类名称 对象名 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; 子类名称();   或   接口名称 对象名 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; 实现类名称();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;【&lt;/span&gt;初步理解: 定义了一个指向子类对象的父类引用&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;这个引用指向的是子类的对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;但是只能访问父类大小的内存空间&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;所以它只能访问父类继承到子类当中的成员
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;包括成员变量和成员函数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;的那部分内存空间&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;而不能访问子类独有的多出来的那部分内存空间&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;而对于被子类重写了的方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;该引用依然可以访问
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              这部分内存&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;只是内存中的内容已经被改写了&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;所以访问到的是子类重写之后的方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;综上所述&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;该引用能访问的范围是所有从父类继承下来的变量和
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              父类独有方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;以及被子类重写之后的方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。】&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    多态对象访问成员变量&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 对象名.&lt;span style=&#34;color:#a6e22e&#34;&gt;成员变量&lt;/span&gt;  访问的是父类的成员变量&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;若没有则向上找&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;不会向下找&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt; 不能用这种方法访问子类特有成员变量&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    多态对象访问成员函数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 若子类重写了父类的成员函数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则访问子类的成员函数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt; 若子类没有重写&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则访问父类的成员函数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;没有则向上找&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt; 同样不能访问子类特有成员函数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        记忆口诀&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;；&lt;/span&gt;对于成员变量&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;等号左边是谁就优先用谁&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;对于成员方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;new的是谁就优先用谁&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    使用多态的好处&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;比如将父类的引用作为参数传入方法中&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则该引用可以指向不同的子类对象使方法实现不同的功能&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;却不需要改变方法中的任何代码&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;对象的向上转型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 在特定场合会自动向上转型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;如方法参数要求为父类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;但是传入一个子类对象也正确&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;这时就发生了自动向上转型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;与int double发生自动类型转换原理一样&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    格式&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;与多态相同&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;父类名称 对象名 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; 子类名称();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    含义&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;创建一个子类对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;把它当作父类来看待使用&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;【&lt;/span&gt;向上转型一定是安全的&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;】&lt;/span&gt;从小范围转向了大范围&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;如将小范围的猫向上转型为更大范围的动物&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt; 类似于将short转换为int&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    弊端&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;不能访问子类特有方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;对象的向下转型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;其实是一个&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;【&lt;/span&gt;还原&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;】&lt;/span&gt;的动作&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    格式&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;   子类名称 对象名 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (子类名称) 父类对象;   (子类名称)必须有&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;不能省略&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    含义&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;   将向上转型之后的父类对象还原为本来的子类对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    注意&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;   只有本来是猫&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;向上转型为动物后&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;再向下转型为猫才是正确的&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            若本来不是猫&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;却硬要向下转型为猫就会出错(编译不会报错&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;但运行会出现异常ClassCastException)&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;instanceof&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        格式&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 对象名 &lt;span style=&#34;color:#66d9ef&#34;&gt;instanceof&lt;/span&gt; 类名
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        作用&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 返回一个布尔值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;判断前面的对象能不能当作后面类的实例&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        应用&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 在向下转型之前&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;判断需要转型的对象是不是目标类的对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;是则向下转型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;不是则不转型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;final: 该关键字表示最终的&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;不可再改变的&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    用法: 修饰一个类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;局部变量&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;成员变量&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         修饰一个类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;类名&lt;/span&gt; {...}  不能有子类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         修饰一个方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 该方法不能被重写&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;   对于类和方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; 和 &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; 不能同时使用&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;会矛盾&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         修饰一个局部变量&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 一次赋值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;终生不变&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。（&lt;/span&gt;可以先定义&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;再赋值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;分两步&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;对于基本类型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;值不可变&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;对于引用类型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;地址值不可变&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         修饰一个成员变量&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 由于成员变量有默认值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;所以不能分两步&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;必须当场手动赋值或通过构造函数赋值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         修饰一个数组或集合&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 该数组或集合不能再被赋值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;但内部的数据还可以改变&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;内部类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 一个类内部包含另一个类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;即一个事物内部包含另一个事物&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt; 例如 身体和心脏的关系
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    分类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 成员内部类      局部内部类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;包含匿名内部类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    成员内部类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;修饰符 &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;外部类名称&lt;/span&gt; { 修饰符 &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;内部类名称&lt;/span&gt; {...} ... }  内用外&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;随意访问&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;外用内&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;需要内部类对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             在main方法中使用&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;间接方式&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 在外部类的方法中调用内部类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;然后main通过访问外部类的方法调用内部类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;直接方式&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 外部类名称.&lt;span style=&#34;color:#a6e22e&#34;&gt;内部类名称&lt;/span&gt; 对象名 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; 外部类名称().&lt;span style=&#34;color:#a6e22e&#34;&gt;new&lt;/span&gt; 内部类名称();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             当局部变量&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;内部类的成员变量&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;外部类的成员变量重名时&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                内部类的成员方法调用内部类的成员变量用this.&lt;span style=&#34;color:#a6e22e&#34;&gt;内部成员变量&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt; 内部类的成员方法调用外部类的成员变量用Outer.&lt;span style=&#34;color:#a6e22e&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;外部成员变量&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    局部内部类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;如果一个类定义在方法内部&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;就是局部内部类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;---&lt;/span&gt;只有当前所属的方法才能使用它&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;出了这个方法就不能使用了&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             格式&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;修饰符 &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;外部类名称&lt;/span&gt; {... 修饰符 返回值类型 &lt;span style=&#34;color:#a6e22e&#34;&gt;外部类方法名称&lt;/span&gt;(参数列表) { &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;内部局部类名称&lt;/span&gt; {...} ... } ...}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             注意&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;若局部内部类要访问所在方法的局部变量&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则该局部变量必须是&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;【&lt;/span&gt;有效final的&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;】（&lt;/span&gt;即可以不写final关键字&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;但是不能变&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        因为局部内部类在堆中&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;生命周期长&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;而局部变量在栈中&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;生命周期短&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;所以不能变&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;【&lt;/span&gt;匿名内部类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;】：【&lt;/span&gt;用的最多&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;】&lt;/span&gt; 如果接口的实现类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;或者父类的子类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;只需使用唯一的一次&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则可以省略该类的定义&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;而改为使用匿名内部类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             格式&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;接口名称 对象名 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; 接口名称() { 重写所有抽象方法 };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             注意&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;匿名内部类只能唯一&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;【&lt;/span&gt;创建一次对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;】。&lt;/span&gt;若想多次创建对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;就要单独定义实现类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                  2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;匿名对象只能唯一&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;【&lt;/span&gt;调用一次方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;】。&lt;/span&gt;若想多次调用方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;就要给对象起个名字&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                  3&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;匿名内部类是省略了实现类&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;子类名称&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;而匿名对象是省略了对象名称&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;他俩不是一回事&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; 接口名() { 重写所有抽象方法 }.&lt;span style=&#34;color:#a6e22e&#34;&gt;方法&lt;/span&gt;(参数);  即匿名内部类又匿名对象的使用方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;异常:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; : 用于抛出异常&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;   例如: &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; NullPointerException(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;异常产生的原因&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        若抛出运行时异常&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;可不理会&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;默认由JVM处理
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        若抛出编译器异常&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则必须处理&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;throws或try&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt;: 声明异常&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;  (用于甩锅)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        格式: 修饰符 返回值类型 &lt;span style=&#34;color:#a6e22e&#34;&gt;方法名&lt;/span&gt;(参数列表) &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; AAAException, BBBException... {&lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; AAAException(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;原因&amp;#34;&lt;/span&gt;)...}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        注意: 1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;throws必须写在方法声明处
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;throws后面必须是Exception或者是其子类
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             3&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;throws后面必须声明方法内部抛出的所有异常
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             4&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;若调用了一个声明抛出异常的方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则必须处理这些异常&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;可以继续抛出&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;也可以自己处理&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt;:  自己处理异常
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        try可以抛出多个异常&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;这时需要使用多个catch来捕获异常&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        try中若产生异常&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则try代码块中产生异常之后的代码不会执行&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;而跳转到catch&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        try中若没有产生异常&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则执行完try中的代码继续执行try&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;catch之后的代码&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;finally&lt;/span&gt;: 不论是否发生异常&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;finally代码块中的代码一定会执行&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        格式 : &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;{} &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt;{} &lt;span style=&#34;color:#66d9ef&#34;&gt;finally&lt;/span&gt;{}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        注意 : finally必须与try一起使用&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;一般用于资源释放&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               正是由于其有一定会执行到&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;所以若finally代码块中有return语句&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则一定会返回finally中的结果&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。（&lt;/span&gt;要避免&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    注意 : 子类异常一定要与父类异常一致&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Thread : Thread类是描述线程的类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;要实现多线程&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;必须继承Thread类
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    每个线程拥有一个自己独立的栈&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;但是共享进程的堆空间&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Thread.&lt;span style=&#34;color:#a6e22e&#34;&gt;sleep&lt;/span&gt;(毫秒)                          &lt;span style=&#34;color:#75715e&#34;&gt;// 静态方法  睡眠&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Thread thread &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Thread.&lt;span style=&#34;color:#a6e22e&#34;&gt;currentThread&lt;/span&gt;();     &lt;span style=&#34;color:#75715e&#34;&gt;// 获取当前线程&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    第一种方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 创建Thread类的子类
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;创建Thread类的子类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;并重写run方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;其中设置线程的任务
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;创建子类对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;并执行start方法  (执行start方法会创建一个新的栈空间&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;并在该栈空间中执行run方法)(每执行一次步骤2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;就开启一个新的线程)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    第二种方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 实现Runnable接口  (推荐使用这种)   &lt;span style=&#34;color:#f92672&#34;&gt;---&amp;gt;&lt;/span&gt;  使用该方法时&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;Thread 类是咱们自定义类的静态代理类
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;创建一个Runnable接口的实现类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;并重写run方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;其中设置线程的任务
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;创建对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;并将其作为参数传递给Thread类的构造方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;再调用start方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Thread(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; MyRunnable()).&lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        匿名内部类实现&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Thread(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Runnable(){重写run方法}).&lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    第三种方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 实现Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;V&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;接口  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;面试可能会问到&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Callable接口类似于Runnable&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，【&lt;/span&gt;Runnable不会返回结果&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;也不会抛出检查异常&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;Callable可以&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;】&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;创建一个Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;V&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;接口的实现类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;并重写call方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;其中设置线程的任务
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;在使用的地方创建该类对象 obj &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        3&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;ExecutorService executorService &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Executors.&lt;span style=&#34;color:#a6e22e&#34;&gt;newFixedThreadPool&lt;/span&gt;(5);  &lt;span style=&#34;color:#75715e&#34;&gt;// 创建执行服务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        4&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;Future&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;V&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; future &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; executorService.&lt;span style=&#34;color:#a6e22e&#34;&gt;submit&lt;/span&gt;(obj);                     &lt;span style=&#34;color:#75715e&#34;&gt;// 提交执行&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        5&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;V result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; future.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;();                                            &lt;span style=&#34;color:#75715e&#34;&gt;// 获取结果&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        6&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;executorService.&lt;span style=&#34;color:#a6e22e&#34;&gt;shutdownNow&lt;/span&gt;();                                      &lt;span style=&#34;color:#75715e&#34;&gt;// 关闭服务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;同步&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;  多个对象访问同一个资源&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;可以并发读取&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;但当其中某一个对象要修改时&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;就必须实现同步
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    所有的对象都拥有一把锁&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    锁对象选取总结为一句话就是 在同步代码中要改变谁就锁谁&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    方法一&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 同步代码块&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; (锁对象) {访问共享数据的代码}  线程不仅要抢夺CUP&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;还要占用锁对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;同时拥有才能执行代码
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        锁对象可以是任意对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;但必须是同一个对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;推荐将共享资源作为锁对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;线程占用锁对象后直到执行完毕才释放&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    方法二&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 同步方法
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        修饰符 &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; 返回值类型 &lt;span style=&#34;color:#a6e22e&#34;&gt;方法名&lt;/span&gt; (参数列表) {访问共享数据的代码}     &lt;span style=&#34;color:#75715e&#34;&gt;// 该方法即为同步方法&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        首先将 访问共享数据的代码块 抽取出来&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;作为上述方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        同步方法的锁对象默认为 &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;即同步方法所在类的对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;；&lt;/span&gt;创建该类的对象后&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;该对象调用同步方法时就会锁住对象自己&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        当同步方法同时也是静态方法时&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;锁对象为同步方法所在类的 Class 对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    方法三&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; Lock锁
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Lock是一个接口&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;有两个方法 &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt;()  获取锁  和  &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unlock&lt;/span&gt;()  释放锁
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        它有一个实现类ReentrantLock&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;可重入锁&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;），&lt;/span&gt; 先实例化一个ReentrantLock对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        在出现安全问题代码之前用该对象调用 &lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt;() 方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;在出现安全问题代码之后用该对象调用 &lt;span style=&#34;color:#a6e22e&#34;&gt;unlock&lt;/span&gt;() 方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             lock() 和  &lt;span style=&#34;color:#a6e22e&#34;&gt;unlock&lt;/span&gt;() 方法建议放在 &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;---&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;finally&lt;/span&gt; 代码块中
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;线程状态&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    线程停止&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;不推荐使用 Thread 类提供的 &lt;span style=&#34;color:#a6e22e&#34;&gt;stop&lt;/span&gt;() 等方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;推荐自己通过一个标志位控制停止
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyRunnable&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;implements&lt;/span&gt; Runnable {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (flag) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            TODO...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;stop&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			通过调用自己实现的 stop 方法来停止线程
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    下方所有方法都是 Thread 类中的方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;！&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    线程休眠&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;Thread.&lt;span style=&#34;color:#a6e22e&#34;&gt;sleep&lt;/span&gt;(毫秒)      &lt;span style=&#34;color:#75715e&#34;&gt;// sleep 不会释放锁、 wait 会释放锁。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    线程礼让&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; Thread.&lt;span style=&#34;color:#a6e22e&#34;&gt;yield&lt;/span&gt;();  使当前线程从运行状态变为就绪状态&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;让 cpu 从所有就绪的线程中挑一个运行&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                礼让有可能不成功&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;因为 cpu 可能再挑选一次还是让当前线程继续执行&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    线程强制执行&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; join()    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;相当于插队&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;停止现在执行的线程&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;立刻执行自己的线程&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;且本线程执行结束才能执行其他线程
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyRunnable&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;implements&lt;/span&gt; Runnable {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 1000; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Runnable &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; i);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; InterruptedException {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        MyRunnable myRunnable &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; MyRunnable();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        Thread thread &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Thread(myRunnable);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        thread.&lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 500; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 200) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                thread.&lt;span style=&#34;color:#a6e22e&#34;&gt;join&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;主线程&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; i);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              在上方举例代码中&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;主线程执行到200之前&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;主线程和Runnable线程交替执行&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;当主线程执行到200次时&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              Runnable 线程插队接着执行&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;之后Runnable线程全部执行完毕后才由主线程继续执行&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     查看线程状态&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;Thread.&lt;span style=&#34;color:#a6e22e&#34;&gt;State&lt;/span&gt; state &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; thread.&lt;span style=&#34;color:#a6e22e&#34;&gt;getState&lt;/span&gt;();      &lt;span style=&#34;color:#75715e&#34;&gt;// Thread.State 是一个枚举类型&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     线程优先级&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;1 最小&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;；&lt;/span&gt;10 最大&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;；&lt;/span&gt;默认为5&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;优先级越高在就绪状态很大可能越早执行&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;但也不是一定&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     守护&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;daemon&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;线程&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         线程分为用户线程和守护线程&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         虚拟机必须保证用户线程执行完毕&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;但不用等待守护线程执行完毕&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         守护线程有&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;后台记录日志&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;监控内存&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;垃圾回收等
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; daemon &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;    &lt;span style=&#34;color:#75715e&#34;&gt;// 默认 daemon 属性是关闭的，即默认为用户线程&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         thread.&lt;span style=&#34;color:#a6e22e&#34;&gt;setDaemon&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;);            &lt;span style=&#34;color:#75715e&#34;&gt;// 可通过这样将线程设置为 守护线程。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#75715e&#34;&gt;// 将线程设置为守护线程之后，虚拟机将不再保证该线程是否执行结束，&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#75715e&#34;&gt;// 即只要当用户线程执行结束后就将整个程序关闭，而不考虑守护线程此时是否已经执行完毕。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;线程池 :   底层原理 &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 线程池就是一个容纳多个线程的容器&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;可由集合实现
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    使用步骤: 1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;使用线程池工厂类Executors里面的静态方法newFixedThreadPool生产一个指定线程数量的线程池&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;由ExecutorService接口接收&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;创建Runnable接口的实现类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;重写run方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;设置线程任务&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             3&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;调用ExecutorService中的execute方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;传递线程任务&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;开启线程&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;执行run方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           例:   ExecutorService executorService &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Executors.&lt;span style=&#34;color:#a6e22e&#34;&gt;newFixedThreadPool&lt;/span&gt;(5);  &lt;span style=&#34;color:#75715e&#34;&gt;// 创建服务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 Runnable runnable &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Runnable() {  &lt;span style=&#34;color:#75715e&#34;&gt;//此处虽然new 的是Runnable接口，但是立即重写了run方法，故相当于其实现类。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     &lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                         &lt;span style=&#34;color:#75715e&#34;&gt;//线程任务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 executorService.&lt;span style=&#34;color:#a6e22e&#34;&gt;execute&lt;/span&gt;(runnable);                                  &lt;span style=&#34;color:#75715e&#34;&gt;// 执行服务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 executorService.&lt;span style=&#34;color:#a6e22e&#34;&gt;shutdownNow&lt;/span&gt;();                                      &lt;span style=&#34;color:#75715e&#34;&gt;// 关闭服务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	ExecutorService 中的 &lt;span style=&#34;color:#a6e22e&#34;&gt;submit&lt;/span&gt;()方法和 &lt;span style=&#34;color:#a6e22e&#34;&gt;execute&lt;/span&gt;()方法作用相同&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;只是适用于不同场景
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;execute&lt;/span&gt;(Runnable command)           &lt;span style=&#34;color:#75715e&#34;&gt;// 执行任务，没有返回值，一般用于执行 Runnable&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; Future&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;submit&lt;/span&gt;(Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; task);  &lt;span style=&#34;color:#75715e&#34;&gt;// 执行任务，有返回值，一般用于执行 Callable&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Lambda表达式 :  可推导&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;可省略
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    格式&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;  () &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    使用前提&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 必须是接口&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;且接口中有且只有一个抽象方法  (有且只有一个抽象方法的接口&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;称为&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;函数式接口&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    可以省略的内容&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;(参数列表) 参数列表中的数据类型可以省略&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; 如果参数只有一个&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则括号()也可以省略
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;{方法体}   如果{}中的代码只有一行&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;无论是否有返回值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;都可以省略 {}&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; 分号   &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;要省一起省&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;注解:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@override&lt;/span&gt;                    检测是否为覆盖重写
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@FunctionalInterface&lt;/span&gt;         检测是否为函数式接口
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;------------------------------------------------------------------------------------------------------------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;API使用&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Scanner&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        功能&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;从键盘输入数据到程序&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        包路径&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;java.&lt;span style=&#34;color:#a6e22e&#34;&gt;util&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Scanner&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        实例化&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;Scanner sc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Scanner(System.&lt;span style=&#34;color:#a6e22e&#34;&gt;in&lt;/span&gt;);  System.&lt;span style=&#34;color:#a6e22e&#34;&gt;in&lt;/span&gt; 表示从键盘输入数据&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;---&lt;/span&gt;其实键盘输入的一切东西都是字符串&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;使用不同的函数会将字符串转换为相应的类型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;--&amp;gt;&lt;/span&gt;故若记不住也可以一直使用sc.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;();之后再转换类型
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            获取键盘输入的一个int数字&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sc.&lt;span style=&#34;color:#a6e22e&#34;&gt;nextInt&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            获取键盘输入的一个字符串&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; String str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sc.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        读取文件内容&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;Scanner in &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Scanner(Paths.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\u202AC:\\Users\\Lenovo\\Desktop\\1.txt&amp;#34;&lt;/span&gt;), StandardCharsets.&lt;span style=&#34;color:#a6e22e&#34;&gt;UTF_8&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            之后再用in的各种方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;nextLine();   next();   nextInt(); 等
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Random:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    功能: 获取随机数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    实例化&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;Random rand &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Random();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; rand_num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand.&lt;span style=&#34;color:#a6e22e&#34;&gt;nextInt&lt;/span&gt;(n)  在&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;0, n)中随机取一个数字&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;----&amp;gt;&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; rand.&lt;span style=&#34;color:#a6e22e&#34;&gt;nextInt&lt;/span&gt;(n)取到&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;m, m &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; n&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;中的随机数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ArrayList: &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;元素1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; 元素2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; 元素3&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; ...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    功能&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;可变长的数组&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    泛型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;装在集合中的元素必须是同一个类型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;只能是引用类型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;不能是基本类型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    实例化&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; list &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    注意事项&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;直接打印list输出的不是一个地址值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;而是空的中括号&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            不支持下标索引&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;只能用get()方法获取&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    常用方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;list.&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;李沁&amp;#34;&lt;/span&gt;)  添加元素&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;返回一个boolean值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;表示添加的动作是否成功&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;一定成功&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;可以不接受返回值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            list.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(index)  根据索引获取元素&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;返回获取的元素&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            list.&lt;span style=&#34;color:#a6e22e&#34;&gt;remove&lt;/span&gt;(index)  根据索引删除元素&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;返回被删除的元素&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            list.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;()  获取集合长度&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    若想在ArrayList中存储基本类型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;需要使用其包装类(引用类型)&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        基本类型         包装类
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;            Byte
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;short&lt;/span&gt;           Short
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ...             ...   &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;与上方一样&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;只需首字母大写&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;             Integer    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;【&lt;/span&gt;特殊&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;】&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;            Character  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;【&lt;/span&gt;特殊&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;】&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Integer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; list_int &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//  自动装箱：int --&amp;gt; Integer     自动拆箱：integer --&amp;gt; int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;String:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    功能&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;字符串&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;常量&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;--&amp;gt;&lt;/span&gt; Java中所有的双引号字符串都是String类的实例&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    实例化&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;直接创建&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; String str1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;李沁&amp;#34;&lt;/span&gt;;    在字符串常量池中&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; 其他实例化方式都在堆中&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;不在池里&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          使用空构造函数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; String str2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; String();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          根据字符数组创建&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; charArray &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;c&amp;#39;&lt;/span&gt; };   String str3 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; String(charArray) &lt;span style=&#34;color:#75715e&#34;&gt;// abc&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          根据字节数组创建&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; byteArray &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { 97, 98, 99 };   String str3 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; String(byteArray)    &lt;span style=&#34;color:#75715e&#34;&gt;// abc&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;str1.&lt;span style=&#34;color:#a6e22e&#34;&gt;equals&lt;/span&gt;(str2)  比较str1和str2的值是否相等&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;返回boolean&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt; 常变量比较时推荐  常量.&lt;span style=&#34;color:#a6e22e&#34;&gt;equals&lt;/span&gt;(变量)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         str1.&lt;span style=&#34;color:#a6e22e&#34;&gt;equalsIgnoreCase&lt;/span&gt;(str2) 忽略大小写&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         str.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;()   长度
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         str.&lt;span style=&#34;color:#a6e22e&#34;&gt;concat&lt;/span&gt;(str1)   拼接
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         str.&lt;span style=&#34;color:#a6e22e&#34;&gt;charAt&lt;/span&gt;(index)  根据索引返回字符
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         str.&lt;span style=&#34;color:#a6e22e&#34;&gt;indexOf&lt;/span&gt;(str1)  在str中查找str1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;返回首次找到的索引值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;；&lt;/span&gt;若没有&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;返回&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         str.&lt;span style=&#34;color:#a6e22e&#34;&gt;substring&lt;/span&gt;(index)   截取&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;从index到末尾
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         str.&lt;span style=&#34;color:#a6e22e&#34;&gt;substring&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; begin, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; end)   截取&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;begin, end)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         str.&lt;span style=&#34;color:#a6e22e&#34;&gt;toCharArray&lt;/span&gt;()  转换为字符数组   str.&lt;span style=&#34;color:#a6e22e&#34;&gt;getBytes&lt;/span&gt;()  转换为字节数组   用于遍历字符串
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         str.&lt;span style=&#34;color:#a6e22e&#34;&gt;replace&lt;/span&gt;(old, &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;)  用new替换str中的old
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         str.&lt;span style=&#34;color:#a6e22e&#34;&gt;split&lt;/span&gt;(regex)  切割&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;返回数组
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Arrays:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    功能&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;与数组相关的类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;提供大量静态方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;用来实现数组常见的操作&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Arrays.&lt;span style=&#34;color:#a6e22e&#34;&gt;toString&lt;/span&gt;(数组)  将参数变成字符串 &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;元素1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; 元素2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;元素3&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Arrays.&lt;span style=&#34;color:#a6e22e&#34;&gt;deepToString&lt;/span&gt;(多维数组)  将参数变成字符串 &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;元素1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; 元素2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;元素3&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Arrays.&lt;span style=&#34;color:#a6e22e&#34;&gt;sort&lt;/span&gt;(数组)  排序&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;默认从小到大&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;自定义类型的排序需要Comparable或Comparator接口
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Arrays.&lt;span style=&#34;color:#a6e22e&#34;&gt;equals&lt;/span&gt;(数组1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; 数组2)    两个数组完全相等是返回ture
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Math:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    功能&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;数学相关的类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;提供大量静态方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;用来实现数学运算相关的操作&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Math.&lt;span style=&#34;color:#a6e22e&#34;&gt;abs&lt;/span&gt;()     绝对值
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Math.&lt;span style=&#34;color:#a6e22e&#34;&gt;ceil&lt;/span&gt;()    向上取整
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Math.&lt;span style=&#34;color:#a6e22e&#34;&gt;floor&lt;/span&gt;()   向下取整
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Math.&lt;span style=&#34;color:#a6e22e&#34;&gt;round&lt;/span&gt;()   四舍五入
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Collection接口: 所有单列集合的顶层接口
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    List接口:  1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;有序&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;存入和取出的顺序一致&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;  2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;允许元素重复  3&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;有索引
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Vector:(了解)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Arraylist:(重点)  底层由数组实现&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;查询快&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;增删慢&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        LinkedList:(次之) 底层由链表实现&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;查询慢&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;增删快&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            特有方法:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                addFirst() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; push()      addLast() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; add()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                getFirst()                getLast()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                removeFirst() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; pop()    removeLast()    这两种方法都会删除并返回
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        共有方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; index, E element)    将元素添加到索引位置
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            E &lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; index)                  返回索引处的元素
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            E &lt;span style=&#34;color:#a6e22e&#34;&gt;remove&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; index)               删除索引位置元素,并返回被删除的元素
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            E &lt;span style=&#34;color:#a6e22e&#34;&gt;set&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; index, E element)       替换索引位置元素,并返回被替换前的元素
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Set接口:  1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;不允许元素重复    2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;没有索引
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        TreeSet: (无序) (了解)        底层由二叉树实现&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;一般用于排序&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        HashSet: (无序) (重点)        底层由哈希表实现&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;(查询速度很快)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            注意: 使用HashCode存储自定义类型时&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;需要重写HashCode()和equals()&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;可通过alt &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; insert直接添加&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;才能保证元素不重复&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            LinkedHashSet: (有序) (次之)  底层由哈希表&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;链表实现&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; HashSet
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                比HashSet多了一条链表&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;用来记录元素的顺序
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    共有方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(E e)      添加&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;   无需接收
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;remove&lt;/span&gt;(E e)   删除&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;   若有e&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;删除并返回true&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;若没有e&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;无动作并返回false
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;clear&lt;/span&gt;()          清空&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;   但不删除集合&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;contains&lt;/span&gt;(E e) 是否包含&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;isEmpty&lt;/span&gt;()     是否为空&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;()            元素个数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Object&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;toArray&lt;/span&gt;()    转为数组&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;哈希值: 是一个十进制的整数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;由操作系统随机给出的对象的逻辑地址值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;哈希表: 拉链法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;由哈希值为元素组成数组&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;初始长度为16&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）。&lt;/span&gt;若哈希值相等&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则以链表方式挂在该哈希值后面&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;当链表长度超过8时&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;变为红黑树&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;检索速度加快&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Collections :  是Collection的工具类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;提供大量静态方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;用于操作集合&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt; 以ArrayList为例: ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; list &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    addAll(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; c, T... elements) : 往集合中添加多个元素&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;  Collections.&lt;span style=&#34;color:#a6e22e&#34;&gt;addAll&lt;/span&gt;(list, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;b&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;c&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    shuffle(List&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; list) : 打乱顺序&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;                             Collections.&lt;span style=&#34;color:#a6e22e&#34;&gt;shuffle&lt;/span&gt;(list);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sort(List&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; list)    : 排序&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; 默认升序&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;                       Collections.&lt;span style=&#34;color:#a6e22e&#34;&gt;sort&lt;/span&gt;(list);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        注意&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;若要对自定义类型排序&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则被排序的类必须实现Comparable接口&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;重写compareTo方法来定义排序规则&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 参数 &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 升序
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (了解)另一种sort()&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; Collections.&lt;span style=&#34;color:#a6e22e&#34;&gt;sort&lt;/span&gt;(arr, &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Comparator&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Integer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                               &lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                               &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;compare&lt;/span&gt;(Integer o1, Integer o2) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                   &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; o1 &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; o2;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                               }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                           });     这种方法List接口中的方法类似&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; arr.&lt;span style=&#34;color:#a6e22e&#34;&gt;sort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Comparator&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Integer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;() {...})
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Iterator: 迭代器    是接口   也有泛型 &lt;span style=&#34;color:#f92672&#34;&gt;--&amp;gt;&lt;/span&gt; Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; array &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                        Iterator&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; it &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; array.&lt;span style=&#34;color:#a6e22e&#34;&gt;iterator&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    常用方法:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hasNext&lt;/span&gt;()  是否有下一个元素&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        E &lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;()           返回下一个元素&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    使用&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; Collection中的实现类为 &lt;span style=&#34;color:#a6e22e&#34;&gt;iterator&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;实例化iterator    2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;用hasNext()    3&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;用next()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;增强for循环:  专门用来遍历数组与集合&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;由Iterator迭代器实现&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;遍历时不能做增删操作&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (元素数据类型 变量 : 集合或数组名) { ... }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Map:      &lt;span style=&#34;color:#f92672&#34;&gt;--&amp;gt;&lt;/span&gt; 字典     键值对     key是唯一的
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    HashMap: (无序)  底层为哈希表
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        LinkedHashMap : (有序)  底层为哈希表&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;链表(保证顺序)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    方法:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        V &lt;span style=&#34;color:#a6e22e&#34;&gt;put&lt;/span&gt;(K key, V value) : 添加&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;若key值不存在&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则添加并返回null&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;若key值已存在&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则更新value值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;并返回被替换掉的value值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;一般不接收返回值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        V &lt;span style=&#34;color:#a6e22e&#34;&gt;remove&lt;/span&gt;(K key)  : 删除&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;若key值存在&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;返回被删除的value&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;若key不存在&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则返回null&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        V &lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(K key)     : 获取&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;若key值存在&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;返回对应的value&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;若key不存在&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则返回null&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;containsKey&lt;/span&gt;(k key)  :  判断是否包含指定的键&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Set&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;K&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;keySet&lt;/span&gt;()   返回由键组成的Set&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;之后可以通过遍历Set来遍历Map&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (K key : map.&lt;span style=&#34;color:#a6e22e&#34;&gt;keySet&lt;/span&gt;()) { sout(key &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; map.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(key)) }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Set&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Map.&lt;span style=&#34;color:#a6e22e&#34;&gt;Entry&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;K, V&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;entrySet&lt;/span&gt;()  &lt;span style=&#34;color:#f92672&#34;&gt;--&amp;gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (Map.&lt;span style=&#34;color:#a6e22e&#34;&gt;Entry&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;K, V&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; entry : map.&lt;span style=&#34;color:#a6e22e&#34;&gt;entrySet&lt;/span&gt;()) {  也是遍历&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;看起来不好用的样子
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                                          System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(entry.&lt;span style=&#34;color:#a6e22e&#34;&gt;getKey&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; entry.&lt;span style=&#34;color:#a6e22e&#34;&gt;getValue&lt;/span&gt;());}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    用Map存储自定义类型时&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;若自定义类型作为键&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则必须将该类重写HashCode和equals方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;保证键是唯一的&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;of方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;E&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; List&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;E&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;of&lt;/span&gt; (E... elements)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;of方法只适用于List, Set, Map 接口&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;而不适用于他们的实现类
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;of方法返回一个不能被操作的集合&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;因此适合初始化&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;且初始化后不能改变&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    3&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;Set 和 Map 调用of方法时不能有重复元素&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;------------------------------------------------------------------------------------------------------------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;------------------------------------------------------------------------------------------------------------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;------------------------------------------------------------------------------------------------------------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;------------------------------------------------------------------------------------------------------------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Object&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;   以下方法所有类都有&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;只是重写之后功能有所不同&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    toString()  直接打印对象的名字&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;就是调用对象的toString方法&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;得到对象的地址值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;  没有意义&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                重写&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;可以和构造方法与Getter&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;Setter方法一样的步骤添加&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;重写&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;toString方法&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;打印出属性值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    equals()    &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;equals&lt;/span&gt;(Object obj)  判断两个对象是否&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;相等&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;返回布尔值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt; 比较两个对象的地址值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;同上方的&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;作用一样&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt; 没有意义&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                重写&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 原理 &lt;span style=&#34;color:#f92672&#34;&gt;--&amp;gt;&lt;/span&gt; 由于equals方法的参数类型为Object,所以默认向上转型了&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;若想比较两个对象的属性值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;需要先向下转型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      同样可以 alt &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; insert 直接生成equals方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt; 判断两对象的属性值是否都一样&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    hashCode()  返回对象的哈希码值
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// synchronized 能实现线程同步、但无法实现线程间通信、用如下 4 个方法可以实现线程间通信。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    wait()      等待&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;在被唤醒之前&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;放弃CPU的使用权    &lt;span style=&#34;color:#a6e22e&#34;&gt;wait&lt;/span&gt;(毫秒值)  在被唤醒或到时间之前&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;放弃CPU的使用权
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;notify&lt;/span&gt;()    唤醒&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;随机唤醒锁对象中的一个进程       &lt;span style=&#34;color:#a6e22e&#34;&gt;notifyAll&lt;/span&gt;()  唤醒锁对象(对象监视器)中的所有进程   这两种常搭配同步机制使用
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;objects:  该工具类提供的方法是容忍空指针的&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt; 若 a&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则a.&lt;span style=&#34;color:#a6e22e&#34;&gt;equals&lt;/span&gt;(b) 报错&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;而Objects.&lt;span style=&#34;color:#a6e22e&#34;&gt;equals&lt;/span&gt;(a, b) 正常运行&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Objects.&lt;span style=&#34;color:#a6e22e&#34;&gt;requireNonNull&lt;/span&gt;(T obj)   查看obj是否为空&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;用来判断参数的合法性&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;旧API :
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Date:     1970年1月1日 00:00:00 作为0时刻
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;Date&lt;/span&gt;() 无参构造&lt;span style=&#34;color:#f92672&#34;&gt;--&amp;gt;&lt;/span&gt; 获取当前时间&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Date(&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; date)  有参构造 &lt;span style=&#34;color:#f92672&#34;&gt;--&amp;gt;&lt;/span&gt; 输入毫秒值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;输出相对于0时刻的日期&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        getTime()  把日期转换为毫秒
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    DateFormat:    格式化日期&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;   抽象类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        String &lt;span style=&#34;color:#a6e22e&#34;&gt;format&lt;/span&gt;(Date date)    把日期格式化为字符串&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Date &lt;span style=&#34;color:#a6e22e&#34;&gt;parse&lt;/span&gt;(String source)   把符合的字符串解析为日期&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        SimpleDateFormat:    DateFormat的实现类
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;SimpleDateFormat&lt;/span&gt;(String pattern)  有参构造  参数一般为 &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            使用上方两个方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt; 注意&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;用parse时&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;参数的模式必须与构造SimpleDateFormat对象时的模式完全一样&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;否则报错&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Calendar:     日历类       抽象类
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;getInstance&lt;/span&gt;()  静态方法   返回Calendar类的子类对象         Calendar instance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Calendar.&lt;span style=&#34;color:#a6e22e&#34;&gt;getInstance&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            功能&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;使用默认时区和语言环境获得一个日历
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(field)  返回给定字段的值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;                  字段值有YEAR MONTH DATE HOUR MINTER SECOND 年月日时分秒   都是静态变量
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;set&lt;/span&gt;(field, value)   将给定的日历字段设置为给定值
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(field, amount)   修改指定的字段&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;通过amount的正负实现加减&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Date &lt;span style=&#34;color:#a6e22e&#34;&gt;getTime&lt;/span&gt;()      将Calendar转为Date对象
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            原理&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;实际上该类中有一个fields数组&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;上述的方法都是在对该数组操作&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;字段值YEAR等固定为0&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;2等&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;作用是对该数组的索引&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;新API
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;LocalDate, LocalTime, LocalDateTime : 之前的Date类和Calendar类都有缺陷&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;JDK8 新引入日期时间类
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    由于LocalDateTime类使用较多&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;故以他为例&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;其余两种用法相同&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    构造方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt; 1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;LocalDateTime now &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; LocalDateTime.&lt;span style=&#34;color:#a6e22e&#34;&gt;now&lt;/span&gt;();      获取当前时间
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;LocalDateTime localDateTime &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; LocalDateTime.&lt;span style=&#34;color:#a6e22e&#34;&gt;of&lt;/span&gt;(2020, 1, 20, 12, 20, 34);    获取指定时间
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    常用方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        now.&lt;span style=&#34;color:#a6e22e&#34;&gt;getDayOfMonth&lt;/span&gt;()                           获取对象是这个月的第几天&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;类似的方法获取其他属性&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        LocalDateTime time &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; now.&lt;span style=&#34;color:#a6e22e&#34;&gt;withDayOfMonth&lt;/span&gt;(12);  使用类似方法设置属性&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;但是该语句执行后&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;time为修改后的值&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;而now的值不变&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;体现了时间的不可变性&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        LocalDateTime plusDays &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; now.&lt;span style=&#34;color:#a6e22e&#34;&gt;plusDays&lt;/span&gt;(3);     使用类似方法修改属性&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;在原有基础上加3天&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;不可变性同上&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        LocalDateTime months &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; now.&lt;span style=&#34;color:#a6e22e&#34;&gt;minusMonths&lt;/span&gt;(2);    使用类似方法修改属性&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;在原有基础上减2月&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;不可变性同上&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Instant 替换 Date 类
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;DateTimeFormatter :  类似于SimpleDateFormat     日期时间的格式化与解析
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    DateTimeFormatter formatter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; DateTimeFormatter.&lt;span style=&#34;color:#a6e22e&#34;&gt;ofPattern&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;&lt;/span&gt;);   构造
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String format &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; formatter.&lt;span style=&#34;color:#a6e22e&#34;&gt;format&lt;/span&gt;(LocalDateTime.&lt;span style=&#34;color:#a6e22e&#34;&gt;now&lt;/span&gt;());                              格式化
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    TemporalAccessor parse &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; formatter.&lt;span style=&#34;color:#a6e22e&#34;&gt;parse&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2021-01-21 22:00:25&amp;#34;&lt;/span&gt;);                    解析
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;System:  提供大量静态方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; 可以获取与系统相关的信息即服务
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;currentTimeMillis&lt;/span&gt;()    返回以毫秒为单位的当前时间, 用来测试程序的效率&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;arraycopy&lt;/span&gt;(原数组&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; 原数组起始位置&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; 目标数组&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; 目标数组起始位置&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; 要复制的数组元素的数量)  复制数组
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;StringBuilder:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    在String类中&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;字符串是常量&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;底层是被final修饰的数组&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;字符串相加时&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;占用内存多&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;效率低下&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    StringBuilder类是字符串缓冲区&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;可以提高字符串的操作效率&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;看成是一个长度可以变化的字符串&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        底层也是一个数组&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;但是没有被final修饰&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;可以改变长度&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        在内存中始终是一个数组&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;初始容量为16个字节&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;超出会自动扩容&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;占用空间少&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;效率高&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    构造函数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        StringBuilder()  无参构造&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;空字符串&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        StringBuilder(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;abc&amp;#34;&lt;/span&gt;)  有参构造&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;即参数的字符串&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    成员函数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        append(任意类型)   添加到字符串&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;并返回自身&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;所以无需接收&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        toString()   将StringBuilder对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;转换为String对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;       通过StringBuilder的构造方法可以将String转换为StringBuilder.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;reverser&lt;/span&gt;()   翻转
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;File:    文件类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;主要用于文件和目录的创建&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;查找和删除等操作     File类已被Path取代
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    静态方法:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; String	pathSeparator    路径分隔符    windows ; 分号      linux  : 冒号
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; String	separator        文件名称分隔符   Windows &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt; 反斜杠   Linux  &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; 正斜杠
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    构造方法:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        File(String pathname)    路径名 &lt;span style=&#34;color:#f92672&#34;&gt;==&amp;gt;&lt;/span&gt; 文件&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;文件夹  相对&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;绝对  存在&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;不存在
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;File&lt;/span&gt;(String parent, String child)  父路径&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;子路径
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;File&lt;/span&gt;(File parent, String child)  父路径&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;子路径&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;父路径是File型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;故可以使用其方法做调整
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    常用方法:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        获取方法:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            String &lt;span style=&#34;color:#a6e22e&#34;&gt;getAbsolutePath&lt;/span&gt;()  返回绝对路径名
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            String &lt;span style=&#34;color:#a6e22e&#34;&gt;getPath&lt;/span&gt;()          返回路径名
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            String &lt;span style=&#34;color:#a6e22e&#34;&gt;getName&lt;/span&gt;()          返回末尾文件&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;文件夹 名字
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;()             返回文件大小&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;以字节为单位&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt; 不能是文件夹&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;若路径不存在&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;返回0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        判断方法:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;exists&lt;/span&gt;()          文件或文件夹是否真实存在
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;isDirectory&lt;/span&gt;()     路径是否以文件夹结尾   前提&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;真实存在
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;isFile&lt;/span&gt;()          路径是否以文件结尾     前提&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;真实存在
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        创建删除:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;creatNewFile&lt;/span&gt;()    不存在时创建文件     不能创建文件夹&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;路径必须存在
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;delete&lt;/span&gt;()          删除文件&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;文件夹
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mkdir&lt;/span&gt;()           创建单级空文件夹
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mkdirs&lt;/span&gt;()          创建单级&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;多级空文件夹     多级文件夹&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;父文件夹中包含子文件夹
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        遍历文件夹:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;list&lt;/span&gt;()           返回由所有文件或子目录组成的字符串数组
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            File&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;listFiles&lt;/span&gt;()        返回由所有文件或子目录封装而成的文件数组
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    过滤器:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        File&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; files &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dir.&lt;span style=&#34;color:#a6e22e&#34;&gt;listFiles&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; FileFilter(){重写accept()方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;该方法中写入过滤规则&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;留下的返回ture&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;不要的返回false})
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            可以写为Lambda表达式&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;读取文件的方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Scanner in &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Scanner(Paths.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;C:\\Users\\Lenovo\\Desktop\\1.txt&amp;#34;&lt;/span&gt;), StandardCharsets.&lt;span style=&#34;color:#a6e22e&#34;&gt;UTF_8&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        String num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; in.&lt;span style=&#34;color:#a6e22e&#34;&gt;nextLine&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        BufferedReader reader &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Files.&lt;span style=&#34;color:#a6e22e&#34;&gt;newBufferedReader&lt;/span&gt;(Paths.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;C:\\Users\\Lenovo\\Desktop\\1.txt&amp;#34;&lt;/span&gt;), StandardCharsets.&lt;span style=&#34;color:#a6e22e&#34;&gt;UTF_8&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        String str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; reader.&lt;span style=&#34;color:#a6e22e&#34;&gt;readLine&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;不好用&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;BufferedReader bufferedReader &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; BufferedReader(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; FileReader(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;C:\\Users\\Lenovo\\Desktop\\1.txt&amp;#34;&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        String s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bufferedReader.&lt;span style=&#34;color:#a6e22e&#34;&gt;readLine&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Properties:  用来加载配置文件,  示例如下&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            Properties properties &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Properties();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;//  ClassLoader classLoader = Person.class.getClassLoader();  注释掉的两句作用与下一句一样&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;//  InputStream is = classLoader.getResourceAsStream(&amp;#34;jdbc.properties&amp;#34;);  //  路径相对于src&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            FileInputStream fis &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; FileInputStream(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;src\\jdbc.properties&amp;#34;&lt;/span&gt;);  &lt;span style=&#34;color:#75715e&#34;&gt;// 路径相对于Module而不是src&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            properties.&lt;span style=&#34;color:#a6e22e&#34;&gt;load&lt;/span&gt;(fis);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            String user &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; properties.&lt;span style=&#34;color:#a6e22e&#34;&gt;getProperty&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            String passwd &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; properties.&lt;span style=&#34;color:#a6e22e&#34;&gt;getProperty&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;passwd&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(user &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; passwd);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;IO流:    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;默认相对路径在Module下&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    基本流:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        OutputStream: 字节输出流  (一切都以字节为单位) (一次读写一个字节)  接口
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            共有方法: write(&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; bytes)    写入多个字节
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     &lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            FileOutputStream: 文件字节输出流
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                构造方法: FileOutputStream(String name&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; append &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            参数为路径&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;即写入的目标文件路径&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;如果没有该文件&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;会先创建该文件&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;若append为ture&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;则为追加写&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;否则会覆盖原文件
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                         &lt;span style=&#34;color:#a6e22e&#34;&gt;FileOutputStream&lt;/span&gt;(File file&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; append &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;)    参数为文件&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;即写入的目标文件&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;append同上&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        InputStream: 字节输入流  接口
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            共有方法: read()   读取一个字节,返回读到的内容&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;读到文件末尾返回&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;read&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; bytes)   读取多个字节&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;将读取到的内容存入字节数组中&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;并返回读取的有效字节个数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;读到文件末尾返回&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     &lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            FileInputStream: 文件字节输入流
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                构造方法: FileInputStream(String name)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                         FileInputStream(File file)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Reader: 字符输入流  抽象
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            共有方法: read()    read(&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; c)   close()   作用和上述相同,包括返回&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1等等都相同&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;只是读取单位变为字符&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            FileReader: 文件字符输入流  &lt;span style=&#34;color:#f92672&#34;&gt;---&amp;gt;&lt;/span&gt;   只能读取IDEA默认编码格式文件(即UTF&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;8)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                构造方法: FileReader(String filename)     FileReader(File file)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Writer: 字符输出流  抽象
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            共有方法: write()  参数可以为单个字符&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;字符数组或字符串   &lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            FileWriter: 文件字符输出流
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                构造方法: FileWriter(String filename&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; append &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;)     FileWriter(File file&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; append &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                注意: 这里的write方法是将数据写入内存缓冲区(字符转为字节)&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;flash方法或close方法会数据刷新到文件&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;因此必须调用close()方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Properties集合: 实现了Map&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;K, V&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;   唯一和IO流结合的集合
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            该集合的默认键和值都是字符串类型&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;store方法能把集合中的数据存入硬盘&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;load方法会加载到该集合中&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    缓冲流:  创建一个缓冲区&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;减少系统IO次数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;提高读写效率&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        BufferedInputStream:  字节缓冲输入流 &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; InputStream        用read写入&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;close关闭&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;只需要关闭缓冲流&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;基本流会随之关闭&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            构造方法: BufferedInputStream(InputStream in&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; size&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;)       read和write方法与基本流完全相同&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        BufferedOutputStream: 字节缓冲输出流 &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; OutputStream       用write写入&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;close关闭
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            构造方法: BufferedOutputStream(OutputStream out&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; size&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                参数可以传递FileOutputStream对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;可选参数size用于指定缓冲区大小
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        BufferedWriter:  字符缓冲输出流 &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; Writer
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            构造方法: BufferedWriter(Writer out&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; size&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;)  可传入FileWriter
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            特有方法: &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;newLine&lt;/span&gt;()   无视系统差异&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;换行
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        BufferedReader:  字符缓冲输入流 &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; Reader
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            构造方法: BufferedReader(Reader in&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; size&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;)  可传入FileReader
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            特有方法: String &lt;span style=&#34;color:#a6e22e&#34;&gt;readLine&lt;/span&gt;()   读取一行数据&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;但不读取行末换行符&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;读到文件末尾返回null
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    转换流:  可以指定编码&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;解码的码表
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        OutputStreamWriter &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; Writer:  步骤: 1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;new对象 2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;write()  3&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;close()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            构造方法: OutputStreamWriter(OutputStream out&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;, String charsetName&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                参数一般传递为FileOutputStream&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;可选字段为编码表名称&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;不区分大小写&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;默认为UTF&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;8
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        InputStreamReader &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; Reader:  步骤: 1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;new对象 2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;read()  3&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;close()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            构造方法: OutputStreamWriter(InputStream in&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;, String charsetName&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (反)序列化流: 把对象以流的方式写入&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;读出到文件中     使用字节流
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ObjectOutputStream: &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; OutputStream  对象的序列化流    把对象以流的方式写入到文件中保存&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;叫写对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;也叫对象的序列化&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            构造方法: ObjectOutputStream(OutputStream out)   参数一般传递为FileOutputStream&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            特有方法: &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;writeObject&lt;/span&gt;(Object obj)   此处参数也可以是由obj组成的集合&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;如ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Person&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; list
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;被序列化的对象&lt;/span&gt;(即参数obj)必须实现Serializable接口&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;以激活(反)序列化功能&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;其为标记型接口&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;内部没有任何抽象方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ObjectInputStream: &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; InputStream   对象的反序列化流    把文件中保存的对象以流的方式读出来&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;叫读对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;也叫对象的反序列化&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            构造方法: ObjectInputStream(InputStream in)       参数一般传递为FileInputStream&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            特有方法: Object &lt;span style=&#34;color:#a6e22e&#34;&gt;readObject&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        transient关键字: 瞬态关键字&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;被其修饰的成员变量不能被序列化&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;没有替他功能&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;static关键字也有这个功能&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        注意&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;为了避免InvalidClassException,在每个被序列化的对象中都显示声明一个序列号&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; serialVersionUID &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 42L
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    打印流:  PrintStream                          System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; :    枚举类   类的对象只有确定的有限个&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;我们称之为枚举类   当需要定义一组常量时&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;强烈建议使用枚举类    默认继承java.&lt;span style=&#34;color:#a6e22e&#34;&gt;lang&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Enum&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    定义&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        类似于接口的定义&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;创建Class包时&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;选项中就有Enum的选项&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; Season {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            SPRING(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;春天&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;warm&amp;#34;&lt;/span&gt;),                               默认由public &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; 修饰
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;SUMMER&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;夏天&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sun&amp;#34;&lt;/span&gt;),                                实例写在类的最前面
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;AUTUMN&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;秋天&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cool&amp;#34;&lt;/span&gt;),                               实例之间用逗号分隔&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;最后一个结尾为分号
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;WINTER&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;冬天&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cold&amp;#34;&lt;/span&gt;);                               为什么不需要显示声明成员变量(由局部变量代替)&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;暂时不清楚
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;Season&lt;/span&gt;(String seasonName, String seasonDec){}  }      构造函数默认由private修饰&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;可省略不写&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    静态方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        values()                   返回枚举类型的对象数组&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;方便用于遍历枚举值
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;valueOf&lt;/span&gt;(String objName)    返回枚举类中对象名为objName的对象   如: Season winter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Season.&lt;span style=&#34;color:#a6e22e&#34;&gt;valueOf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;WINTER&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        toString()                 返回当前枚举类对象常量的名字
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;反射:    java.&lt;span style=&#34;color:#a6e22e&#34;&gt;lang&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Class&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            程序由javac.&lt;span style=&#34;color:#a6e22e&#34;&gt;exe编译后&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;会生成一个或多个字节码文件(.&lt;span style=&#34;color:#a6e22e&#34;&gt;class结尾&lt;/span&gt;)&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            接着使用java.&lt;span style=&#34;color:#a6e22e&#34;&gt;exe对某个字节码文件解释运行&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;就相当于将某个字节码文件加载到内存中&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;这个过程就叫类的加载&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            加载到内存中的类就叫运行时类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;这个运行时类就是Class的一个实例&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            加载到内存中的运行时类会缓存一段时间&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;在此时间内以不同方式获取到的该运行时类的Class实例都是同一个&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        获取Class实例的方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt; Class clazz &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Person.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt; Person person &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Person();     Class clazz &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; person.&lt;span style=&#34;color:#a6e22e&#34;&gt;getClass&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            3&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt; Class clazz &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Class.&lt;span style=&#34;color:#a6e22e&#34;&gt;forName&lt;/span&gt;(类相对于src的全路径);   &lt;span style=&#34;color:#75715e&#34;&gt;// 用的较多&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ClassLoader&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;引导类加载器&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;》&lt;/span&gt;加载java核心类库   引导类加载器无法获取到
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     扩展类加载器&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;》&lt;/span&gt;加载jar包      通过Class实例.&lt;span style=&#34;color:#a6e22e&#34;&gt;getClassLoader&lt;/span&gt;()即可获得类加载器&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;如
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     系统类加载器&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;》&lt;/span&gt;加载自定义类    Person.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getClassLoader&lt;/span&gt;()获取的即为系统类加载器
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        无法创建实例的类型用  Class c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;;   &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;;    Math.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;; 等
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Integer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; list &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Class l1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list.&lt;span style=&#34;color:#a6e22e&#34;&gt;getClass&lt;/span&gt;();           得到ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Integer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;类的Class实例
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        l1.&lt;span style=&#34;color:#a6e22e&#34;&gt;getDeclaredConstructors&lt;/span&gt;();         获取所有构造函数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;去掉Declared为只获取public的构造函数
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        l1.&lt;span style=&#34;color:#a6e22e&#34;&gt;getDeclaredMethods&lt;/span&gt;();              获取所有函数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;去掉Declared为只获取public的函数
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        l1.&lt;span style=&#34;color:#a6e22e&#34;&gt;getDeclaredFields&lt;/span&gt;();               获取所有属性&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;去掉Declared为只获取public的属性
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        l1.&lt;span style=&#34;color:#a6e22e&#34;&gt;getSuperclass&lt;/span&gt;();                   获取父类
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        l1.&lt;span style=&#34;color:#a6e22e&#34;&gt;getGenericSuperclass&lt;/span&gt;();            获取带泛型的父类
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        li.&lt;span style=&#34;color:#a6e22e&#34;&gt;getInterfaces&lt;/span&gt;();                   获取接口
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        li.&lt;span style=&#34;color:#a6e22e&#34;&gt;getPackage&lt;/span&gt;();                      获取包
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        li.&lt;span style=&#34;color:#a6e22e&#34;&gt;getAnnotations&lt;/span&gt;();                  获取注解
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;for&lt;/span&gt; (Method method: l1.&lt;span style=&#34;color:#a6e22e&#34;&gt;getDeclaredMethods&lt;/span&gt;()) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(Modifier.&lt;span style=&#34;color:#a6e22e&#34;&gt;toString&lt;/span&gt;(method.&lt;span style=&#34;color:#a6e22e&#34;&gt;getModifiers&lt;/span&gt;()) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; method.&lt;span style=&#34;color:#a6e22e&#34;&gt;getReturnType&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;  &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                   method.&lt;span style=&#34;color:#a6e22e&#34;&gt;getName&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;(&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Arrays.&lt;span style=&#34;color:#a6e22e&#34;&gt;toString&lt;/span&gt;(method.&lt;span style=&#34;color:#a6e22e&#34;&gt;getParameterTypes&lt;/span&gt;()) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;);&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Field f &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l1.&lt;span style=&#34;color:#a6e22e&#34;&gt;getDeclaredField&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;size&amp;#34;&lt;/span&gt;);  根据属性名称获取特定的Field对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        f.&lt;span style=&#34;color:#a6e22e&#34;&gt;setAccessible&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;);                  使其变为可访问的
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Object v &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; f.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(list);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Person person &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Person(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;alice&amp;#34;&lt;/span&gt;, 21);    方法对象调用invoke方法来执行方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Class p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; person.&lt;span style=&#34;color:#a6e22e&#34;&gt;getClass&lt;/span&gt;();                &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Object &lt;span style=&#34;color:#a6e22e&#34;&gt;invoke&lt;/span&gt;(Object obj, Object... args)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Method m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; p.&lt;span style=&#34;color:#a6e22e&#34;&gt;getMethod&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;getName&amp;#34;&lt;/span&gt;);          第一个参数为对象名&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;之后的参数为方法的参数&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (String) m.&lt;span style=&#34;color:#a6e22e&#34;&gt;invoke&lt;/span&gt;(person);       调用的是静态方法时&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;第一个参数为null&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    代理的作用就是在不修改源码的情况下&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;对目标对象的方法增强&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    静态代理&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;接口 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 代理类 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 被代理类   &lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;》&lt;/span&gt;  一个代理类只能对应一个被代理类         代理类与被代理类实现同样的接口
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    动态代理&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;接口 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 代理类 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 多个被代理类   &lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;》&lt;/span&gt;  一个代理类可以对应多个被代理类     代理类与被代理类实现同样的接口
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        结合src&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;proxy&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;annotationProxy包下的例子理解
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;根据自己需求创建一个被代理类对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;想象在项目中&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;要增强功能时&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;一定在之前已经使用过这个对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        2&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;根据这个被代理类对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;动态获取一个代理类对象&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;（&lt;/span&gt;因此&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;没有显示的代理类&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;是被动态获取到的&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        3&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;、&lt;/span&gt;使用代理类对象调用被代理类的方法&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。（&lt;/span&gt;具体原理看包中例子的注释&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Annotation学习笔记</title>
      <link>https://ethereal-lu.github.io/posts/java/annotation%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 12 May 2021 18:48:13 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/java/annotation%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h3 id=&#34;元注解&#34;&gt;元注解&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;元注解用于修饰注解&lt;/li&gt;
&lt;li&gt;元注解有6中，如下：
&lt;ul&gt;
&lt;li&gt;@Target        规定所修饰的注解只能用于指定的区域&lt;/li&gt;
&lt;li&gt;@Documented    将注解生成在javadoc中&lt;/li&gt;
&lt;li&gt;@Inherited     所修饰的注解作用于某类后，该类的子类会默认继承父类的注解&lt;/li&gt;
&lt;li&gt;@Retention     所修饰的注解的作用时间，RUNTIME&amp;gt;CLASS&amp;gt;SOURCE&lt;/li&gt;
&lt;li&gt;@Native        使用本地方法&lt;/li&gt;
&lt;li&gt;@Repeatable    可重复&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;注解接口格式&#34;&gt;注解接口格式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;注解接口必须为&lt;code&gt;public @interface Target {....}&lt;/code&gt;，其中public可以不写，@interface表示默认继承了 &lt;code&gt;java.lang.annotation.Annotation&lt;/code&gt;接口&lt;/li&gt;
&lt;li&gt;属性格式：属性类型 + 属性名 + ()；还可以使用default给属性赋予默认值&lt;/li&gt;
&lt;li&gt;当属性只有一个且属性名为value()时，在使用的时候可以不指定属性名直接赋值&lt;/li&gt;
&lt;li&gt;一个自定义的注解接口如下：
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Target&lt;/span&gt;(ElementType.&lt;span style=&#34;color:#a6e22e&#34;&gt;METHOD&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@Retention&lt;/span&gt;(RetentionPolicy.&lt;span style=&#34;color:#a6e22e&#34;&gt;RUNTIME&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@interface&lt;/span&gt; MyAnnotation {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    String &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;// 使用时可以不赋值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;age&lt;/span&gt;();      &lt;span style=&#34;color:#75715e&#34;&gt;// 使用时必须赋值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;通过反射解析注解&#34;&gt;通过反射解析注解&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Class类中有getAnnotation​()等获取注解的相关方法，通过调用这些方法获取我们填入的参数，从而做出相应的操作&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>SpringBoot学习笔记</title>
      <link>https://ethereal-lu.github.io/posts/java/springboot%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 10 May 2021 17:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/java/springboot%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/spring-projects/spring-boot&#34;&gt;Spring Boot&lt;/a&gt; 是 Spring 的&lt;strong&gt;子项目&lt;/strong&gt;，正如其名字，提供 Spring 的引导( &lt;strong&gt;Boot&lt;/strong&gt; )的功能。&lt;/p&gt;
&lt;p&gt;通过 Spring Boot ，开发者可以快速配置 Spring 项目，引入各种 Spring MVC、Spring Transaction、Spring AOP、等等框架，而无需不断重复编写繁重的 Spring 配置，降低了 Spring 的使用成本。&lt;/p&gt;
&lt;h3 id=&#34;项目创建&#34;&gt;项目创建&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;新建 spring initializr 项目，在新建过程中引入 spring web 依赖&lt;/li&gt;
&lt;li&gt;将所有的controller、pojo、dao等包创建在Application类的同名目录下（约定大于配置），创建在其他目录下会报错&lt;/li&gt;
&lt;li&gt;在resources目录下创建banner.txt文件，可以在里面粘贴一些图片用于启动时展示&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;自动装配原理&#34;&gt;自动装配原理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;父工程 &lt;code&gt;spring-boot-dependencies&lt;/code&gt; 对springboot的所有依赖进行管理，其中就有依赖的版本控制，因此我们在pom.xml中引入依赖时，不需要指定版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动器：启动器都以&lt;code&gt;spring-boot-starter&lt;/code&gt;打头，就是springboot的启动场景，如&lt;code&gt;spring-boot-starter-web&lt;/code&gt;，就会帮我们自动导入web环境所有的依赖。springboot会将所有的功能场景变为一个个的启动器。我们要使用什么功能，只需要找到相对应的启动器并导入即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主程序：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// @SpringBootApplication ：标注这个类是springboot的应用&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@SpringBootApplication&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Springboot01HelloworldApplication&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; args) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 启动springboot&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        SpringApplication.&lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;(Springboot01HelloworldApplication.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;, args);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;@SpringBootApplication&lt;/code&gt; 是复合注解，主要包括 **&lt;code&gt;@ComponentScan&lt;/code&gt;, &lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;, &lt;code&gt;@SpringBootConfiguration&lt;/code&gt;**三个注解。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@SpringBootConfiguration&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@EnableAutoConfiguration&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@ComponentScan&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    excludeFilters &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#a6e22e&#34;&gt;@Filter&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    type &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FilterType.&lt;span style=&#34;color:#a6e22e&#34;&gt;CUSTOM&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    classes &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {TypeExcludeFilter.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;), &lt;span style=&#34;color:#a6e22e&#34;&gt;@Filter&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    type &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FilterType.&lt;span style=&#34;color:#a6e22e&#34;&gt;CUSTOM&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    classes &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {AutoConfigurationExcludeFilter.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@interface&lt;/span&gt; SpringBootApplication
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;@ComponentScan 注解&lt;/code&gt;&lt;/strong&gt;：组件扫描。 spring里有四大注解：&lt;code&gt;@Service&lt;/code&gt;,&lt;code&gt;@Repository&lt;/code&gt;,&lt;code&gt;@Component&lt;/code&gt;,&lt;code&gt;@Controller&lt;/code&gt;用来定义一个bean.&lt;code&gt;@ComponentScan&lt;/code&gt;注解就是用来自动扫描被这些注解标识的类，最终生成ioc容器里的bean．&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;@SpringBootConfiguration 注解&lt;/code&gt;&lt;/strong&gt;：@SpringBootConfiguration继承自@Configuration，二者功能也一致，标注当前类是配置类， 并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;@EnableAutoConfiguration 注解&lt;/code&gt;&lt;/strong&gt;：从 classpath 中搜索所有的 META-INF/spring.factories 配置文件，然后将其中key为org.springframework.boot.autoconfigure.EnableAutoConfiguration 的 value 加载到spring容器中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注解：&lt;/p&gt;</description>
    </item>
    <item>
      <title>mybatis学习笔记</title>
      <link>https://ethereal-lu.github.io/posts/java/mybatis%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 26 Apr 2021 19:42:15 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/java/mybatis%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h3 id=&#34;第一个mybatis项目&#34;&gt;第一个MyBatis项目&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;先进入mysql创建mybatis数据库，并在其中创建user表，其中有字段值如实体类User中的属性&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;新建一个Maven项目，作为父项目，在其pom.xml配置文件中引入依赖（mysql驱动、junit、mybatis）。则其子模块中都继承了这些依赖。&lt;/li&gt;
&lt;li&gt;在父项目下新建一个Maven子模块，在其main目录的resources下新建文件mybatis-config.xml作为配置文件，内容如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34; ?&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!DOCTYPE configuration
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;        PUBLIC &amp;#34;-//mybatis.org//DTD Config 3.0//EN&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;        &amp;#34;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;#34;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--核心配置文件--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--下方这一句为引入外部属性文件，需在resources下创建jdbc.properties文件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;        也可以不引入外部属性文件而直接对4个value赋值--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;properties&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;resource=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;jdbc.properties&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;environments&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;default=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;development&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;environment&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;development&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;transactionManager&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;type=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;JDBC&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dataSource&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;type=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;POOLED&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--只需为下面四项赋值即可--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;property&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;driver&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;${jdbc.driveClass}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;property&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;url&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;${jdbc.url}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;property&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;username&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;${jdbc.username}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;property&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;${jdbc.password}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dataSource&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/environment&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/environments&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--每一个sql映射文件Mapper.xml都需要在Mybatis的核心配置文件中的&amp;lt;mappers&amp;gt;标签下注册，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;        否则就会报错Type interface com.lu.dao.UserDao is not known to the MapperRegistry.--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;mappers&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--如果Mapper.xml在resources目录下，则直接写文件名即可，若在其他路径，则要写全路径，用/分割目录--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;mapper&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;resource=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;UserMapper.xml&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/mappers&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;jdbc.properties文件如下：其中jdbc.url字段特别容易引发错误&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-properties&#34; data-lang=&#34;properties&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;jdbc.driveClass&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;com.mysql.cj.jdbc.Driver&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;jdbc.url&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=Asia/Shanghai&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;jdbc.userName&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;root&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;jdbc.password&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;gaolu666&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;创建获取sqlSession对象的工具类（类中代码如下）。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// sqlSessionFactory --&amp;gt;  SqlSession&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MybatisUtils&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; SqlSessionFactory sqlSessionFactory;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 用Mybatis的配置文件获取sqlSessionFactory对象&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        String resource &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;mybatis-config.xml&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        InputStream inputStream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            inputStream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Resources.&lt;span style=&#34;color:#a6e22e&#34;&gt;getResourceAsStream&lt;/span&gt;(resource);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; (IOException e) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            e.&lt;span style=&#34;color:#a6e22e&#34;&gt;printStackTrace&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sqlSessionFactory &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; SqlSessionFactoryBuilder().&lt;span style=&#34;color:#a6e22e&#34;&gt;build&lt;/span&gt;(inputStream);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 用sqlSessionFactory对象获取SqlSession对象&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; SqlSession &lt;span style=&#34;color:#a6e22e&#34;&gt;getSqlSession&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; sqlSessionFactory.&lt;span style=&#34;color:#a6e22e&#34;&gt;openSession&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;实现。创建实体类、UserDao接口以及Mapper配置文件UserMapper.xml（该文件代替JDBC中的UserDaoImpl实现类，但是仍然可以将该文件理解为UserDao的实现类），分别如下：&lt;strong&gt;【实体类要实现序列化接口】&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 实体类&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;User&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;implements&lt;/span&gt; Serializable {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; id;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; String name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; String passwd;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ... &lt;span style=&#34;color:#75715e&#34;&gt;// 省略部分为有参无参构造，getter、setter方法&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// UserDao接口&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;UserDao&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    List&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;User&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getUserList&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 根据ID查询用户&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    User &lt;span style=&#34;color:#a6e22e&#34;&gt;getUserById&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; id);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 添加用户&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addUser&lt;/span&gt;(User user);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 修改用户&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;updateUser&lt;/span&gt;(User user);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 删除用户&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;deleteUser&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; id);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--sql映射文件UserMapper.xml--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34; ?&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!DOCTYPE mapper
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;        PUBLIC &amp;#34;-//mybatis.org//DTD Mapper 3.0//EN&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;        &amp;#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;#34;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;mapper&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;namespace=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;com.lu.dao.UserDao&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--namespace绑定一个Mapper（Dao）接口--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--id对应绑定的接口中的一个方法名，resultType为返回值，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;        当该方法的返回值为集合时resultType对应集合泛型中的类的全路径--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;select&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;getUserList&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;resultType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;com.lu.pojo.User&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        select * from user
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/select&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--parameterType对应参数类型，当方法的参数只有一个，且参数类型为基本类型时，可以不写parameterType这一项，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;        方法参数有多个时，用map或注解--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;select&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;getUserById&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;parameterType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;int&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;resultType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;com.lu.pojo.User&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        select * from user where id = #{id}  /*此处#{id}接收getUserById方法的参数，因此名称与参数名一致*/
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/select&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;insert&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;addUser&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;parameterType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;com.lu.pojo.User&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        /*此处#{id}, #{name}, #{passwd}自动接收User类中的属性，因此名字与三个属性名一致*/
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        insert into user (id, name, passwd) values (#{id}, #{name}, #{passwd})
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/insert&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;update&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;updateUser&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;parameterType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;com.lu.pojo.User&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        update user set name = #{name}, passwd = #{passwd} where id = #{id} /*修改多个参数中间用逗号隔开不要忘*/
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/update&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;delete&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;deleteUser&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;parameterType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;int&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        delete from user where id = #{id}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/delete&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/mapper&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;测试，代码如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;UserDaoTest&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Test&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getUserListTest&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 第一步：获取sqlSession对象&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        SqlSession sqlSession &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; MybatisUtils.&lt;span style=&#34;color:#a6e22e&#34;&gt;getSqlSession&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 第二部：getMapper&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        UserDao mapper &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sqlSession.&lt;span style=&#34;color:#a6e22e&#34;&gt;getMapper&lt;/span&gt;(UserDao.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 第三步：执行sql&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (User user: mapper.&lt;span style=&#34;color:#a6e22e&#34;&gt;getUserList&lt;/span&gt;())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(user);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 第四步：关闭连接&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sqlSession.&lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 注意事项：增删改操作必须要提交事务 --&amp;gt; sqlSession.commit();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h3 id=&#34;map的使用野路子增加灵活性但不利于维护&#34;&gt;map的使用（野路子，增加灵活性但不利于维护）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用场景：当表中的字段过多，而只需要更新少量字段时，不需要像上方一样，传入一个带全部字段的新对象，而只需要利用map传递需要的字段即可。同样在添加操作时，也可以在map中只存放notnull的字段，对于允许null的字段，可以不添加。示例如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;update&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;updateUser2&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;parameterType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;map&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        /*上方参数类型map即表示Map类型，下方的#{key_name}和#{key_id}接收map中的值，故名称与map中的键名一致*/
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        update user set name = #{key_name} where id = #{key_id}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/update&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h3 id=&#34;配置解析&#34;&gt;配置解析&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;核心配置文件mybatis-config.xml
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;environments&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;environments标签下可以有多套环境，但同时最多只能使用一套（即互斥使用），修改default的值即可切换环境&lt;/li&gt;
&lt;li&gt;transactionManager标签即事务管理器，只需知道除了JDBC还有一个MANAGED即可&lt;/li&gt;
&lt;li&gt;dataSource即数据源，type的值默认为POOLED即使用连接池，只需知道type不止这一个值即可&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;properties&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;properties标签即引入外部属性文件&lt;/li&gt;
&lt;li&gt;properties标签必须位于configuration标签下的第一行&lt;/li&gt;
&lt;li&gt;properties标签下也可以添加propertie标签，并优先读取propertie标签内的值，然后读取外部文件，并覆盖同名键&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;typeAliases&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;typeAliases即类型别名，为java类型设置一个短的名字，用于减少类完全限定名（类的全路径）的冗余&lt;/li&gt;
&lt;li&gt;类型别名有两种实现方式，一种为typeAlias，即为每一个类自定义一个别名，另一种为package，它指定一个包，将包下所有类的别名设定为类名的首字母小写（其实大写也可以用，但建议小写），如下：（当实体类少时用第一种，实体类多时用第二种）&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;typeAliases&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;typeAlias&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;type=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;com.lu.pojo.User&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;alias=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;User&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;com.lu.pojo&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/typeAliases&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;settings&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;logImpl：设置日志&lt;/li&gt;
&lt;li&gt;cacheEnabled：缓存&lt;/li&gt;
&lt;li&gt;lazyLoadingEnabled：懒加载&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mappers&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;一般会将操作数据库的接口与其同名sql映射文件mapper.xml放在同一个包下，但这样还需另外设置过滤操作。也可以在resources目录下创建与接口所在目录的同名目录，然后将sql映射文件放入该目录中，这样在编译后接口与映射文件就在同一个包下了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;生命周期与作用域&#34;&gt;生命周期与作用域&lt;/h3&gt;
&lt;p&gt;错误的使用可能会导致严重的&lt;strong&gt;并发问题&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>SpringMVC学习笔记</title>
      <link>https://ethereal-lu.github.io/posts/java/springmvc%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 25 Apr 2021 14:58:37 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/java/springmvc%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h3 id=&#34;第一个springmvc项目&#34;&gt;第一个SpringMVC项目&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;新建maven父项目，引入依赖：junit，spring-webmvc，servlet-api，jsp-api，jstl&lt;/li&gt;
&lt;li&gt;新建maven子项目，添加web支持&lt;/li&gt;
&lt;li&gt;配置web.xml，注册DispatcherServlet，如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;web-app&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;xmlns=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://xmlns.jcp.org/xml/ns/javaee&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#a6e22e&#34;&gt;xmlns:xsi=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#a6e22e&#34;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#a6e22e&#34;&gt;version=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;4.0&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--配置DispatcherServlet--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;servlet&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;springmvc&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;servlet-class&amp;gt;&lt;/span&gt;org.springframework.web.servlet.DispatcherServlet&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/servlet-class&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--绑定一个springmvc的配置文件： [servlet-name]-servlet.xml--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;init-param&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;param-name&amp;gt;&lt;/span&gt;contextConfigLocation&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/param-name&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;param-value&amp;gt;&lt;/span&gt;classpath:springmvc-servlet.xml&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/param-value&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/init-param&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--启动级别 1， 1级表示随着服务器一起启动--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;load-on-startup&amp;gt;&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/load-on-startup&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/servlet&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- / 匹配所有请求（不包括 .jsp)--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- /* 匹配所有请求（包括 .jsp)，若此处使用/*则在视图解析时会再加上.jsp，使页面名变为a.jsp.jsp从而出错--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;springmvc&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;/&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/servlet-mapping&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/web-app&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;在resource下创建springmvc-servlet.xml，如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;beans&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;xmlns=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://www.springframework.org/schema/beans&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       &lt;span style=&#34;color:#a6e22e&#34;&gt;xmlns:xsi=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       &lt;span style=&#34;color:#a6e22e&#34;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://www.springframework.org/schema/beans
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;       http://www.springframework.org/schema/beans/spring-beans.xsd&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--处理器映射器--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;bean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--处理器适配器--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;bean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--视图解析器--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;bean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;org.springframework.web.servlet.view.InternalResourceViewResolver&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;internalResourceViewResolver&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;property&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;prefix&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/WEB-INF/jsp/&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--前缀--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;property&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;suffix&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;.jsp&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;          &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--后缀--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;bean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/hello&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;com.lu.controller.HelloController&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;java下创建Controller类&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 实现Controller接口，就是一个控制器，就会获得控制器功能：处理请求并返回一个模型与视图对象&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;HelloController&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;implements&lt;/span&gt; Controller {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; ModelAndView &lt;span style=&#34;color:#a6e22e&#34;&gt;handleRequest&lt;/span&gt;(HttpServletRequest request, HttpServletResponse response) &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; Exception {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ModelAndView mv &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ModelAndView();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 业务代码&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        String result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;SpringMVC&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mv.&lt;span style=&#34;color:#a6e22e&#34;&gt;addObject&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;msg&amp;#34;&lt;/span&gt;, result);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 视图跳转&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mv.&lt;span style=&#34;color:#a6e22e&#34;&gt;setViewName&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; mv;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;WEB-INF下的jsp下创建hello.jsp，里面的body中添加${msg}即可&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;springmvc执行流程&#34;&gt;SpringMVC执行流程&lt;/h3&gt;
&lt;p&gt;&lt;img alt=&#34;SpringMVC流程&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/java/springmvc%E7%AC%94%E8%AE%B0/SpringMVC%E6%B5%81%E7%A8%8B.jpg&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>MarkDown无法显示本地图片</title>
      <link>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/markdown/</link>
      <pubDate>Wed, 21 Apr 2021 21:08:18 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/markdown/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;访问控制的原因：在vscode中按ctrl+shift+p打开命令面板，输入更改预览安全设置，选中允许不安全的本地内容&lt;/li&gt;
&lt;li&gt;本地图片不允许使用png格式（网络图片却可以），最好换为jpg格式（有可能只适用于本机）&lt;/li&gt;
&lt;li&gt;本地图片路径不支持绝对路径，要通过../../&amp;hellip;改为相对路径&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    <item>
      <title>Servlet学习笔记</title>
      <link>https://ethereal-lu.github.io/posts/java/servlet%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 21 Apr 2021 18:48:13 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/java/servlet%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h3 id=&#34;servlet定义&#34;&gt;Servlet定义&lt;/h3&gt;
&lt;p&gt;Servlet是一个Java应用程序，运行在服务器端，用来处理客户端请求并作出响应的程序。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;实现servlet的主要方式&#34;&gt;实现Servlet的主要方式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h4 id=&#34;程序实现servlet接口很少使用&#34;&gt;程序实现Servlet接口（很少使用）&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;编写类实现Servlet接口&lt;/li&gt;
&lt;li&gt;根据业务重写service方法&lt;/li&gt;
&lt;li&gt;到web.xml中配置Servlet程序的访问地址（基于注解时不需要）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;程序继承httpservlet类一般使用这种&#34;&gt;程序继承HttpServlet类（一般使用这种）&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;编写类继承HttpServlet类&lt;/li&gt;
&lt;li&gt;根据业务需要重写doGet或doPost方法&lt;/li&gt;
&lt;li&gt;到web.xml中配置Servlet程序的访问地址（基于注解时不需要）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;在idea中直接创建servlet程序&#34;&gt;在IDEA中直接创建Servlet程序&lt;/h4&gt;
实质上还是第二种方法，只是IDEA帮你做了一些通用的工作&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;servlet的生命周期&#34;&gt;Servlet的生命周期&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;执行Servlet构造器方法，该方法在&lt;u&gt;初次访问&lt;/u&gt;时调用一次。由Servlet容器（Tomcat）创建。&lt;strong&gt;这说明 Servlet 是单实例的!&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;执行init初始化方法，该方法在&lt;u&gt;初次访问&lt;/u&gt;时调用一次。&lt;/li&gt;
&lt;li&gt;执行service方法，该方法在&lt;u&gt;每次访问&lt;/u&gt;时都会调用一次。&lt;/li&gt;
&lt;li&gt;执行destory方法，该方法在&lt;u&gt;web工程停止&lt;/u&gt;时调用一次。  用于释放当前 Servlet 所占用的资源。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;servlet接口的架构&#34;&gt;Servlet接口的架构&lt;/h3&gt;
&lt;p&gt;&lt;img alt=&#34;Servlet&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/java/servlet%E7%AC%94%E8%AE%B0/Servlet.jpg&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;servlet的域对象&#34;&gt;Servlet的域对象&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;概念：可以在不同Servlet之间传递数据的对象，就是域对象。通俗的讲就是这个对象本身可以存储一定范围内的所有数据，通过它就能获取和存储数据。&lt;/li&gt;
&lt;li&gt;域对象共有的方法：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getAttribute(String name)&lt;/code&gt; 获取对应的数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getAttributeNames()&lt;/code&gt; 获取所有的key&lt;/li&gt;
&lt;li&gt;&lt;code&gt;removeAttribute(String name)&lt;/code&gt; 移除对应的数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setAttribute(String name, Object object)&lt;/code&gt; 设置数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Servlet的三大域对象分别为&lt;strong&gt;ServletRequest域&lt;/strong&gt;、&lt;strong&gt;HttpSession域&lt;/strong&gt;、&lt;strong&gt;ServletContext域&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;ServletRequest：
&lt;ul&gt;
&lt;li&gt;生命周期：请求开始到请求结束&lt;/li&gt;
&lt;li&gt;作用域：整个请求链（包括请求转发）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HttpSession：
&lt;ul&gt;
&lt;li&gt;生命周期：会话开始到会话结束，服务器会为每个浏览器创建一个供其独享的Session对象，当一段时间内，session没有被使用（默认是30分钟），服务器会销毁该session。&lt;/li&gt;
&lt;li&gt;作用域：一次会话&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ServletContext：
&lt;ul&gt;
&lt;li&gt;生命周期：服务器开启到服务器关闭&lt;/li&gt;
&lt;li&gt;作用域：整个web应用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;servletconfig类&#34;&gt;ServletConfig类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ServletConfig类是Servlet程序的配置信息类，里面封装了一些初始化配置的信息&lt;/li&gt;
&lt;li&gt;Servlet程序和ServletConfig对象都是由Tomcat负责创建，供我们使用。&lt;/li&gt;
&lt;li&gt;每创建一次Servlet程序时，就创建一个ServletConfig对象。&lt;/li&gt;
&lt;li&gt;每个ServletConfig对象都只能获取自己的Servlet的信息，不能跨域获取&lt;/li&gt;
&lt;li&gt;重写init方法时要带上父类的init方法，如果不带上，则在使用ServletConfig相关方法时就会引发NullPointerException，这是因为父类GenericServlet的init方法中保存了ServletConfig对象，如果重写了init方法，该对象就会丢失，故而引发NullPointerException。&lt;/li&gt;
&lt;li&gt;作用：
&lt;ol&gt;
&lt;li&gt;获取Servlet程序的别名，即servlet-name的值&lt;code&gt;servletConfig.getServletName()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获取初始化参数init-param&lt;code&gt;servletConfig.getInitParameter()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获取ServletContext对象&lt;code&gt;servletConfig.getServletContext()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;servletcontext类&#34;&gt;ServletContext类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ServletContext是接口，表示Servlet上下文对象&lt;/li&gt;
&lt;li&gt;一个web工程只有一个ServletContext对象实例，在web工程启动时创建，停止时销毁&lt;/li&gt;
&lt;li&gt;ServletContext对象是一个域对象
&lt;ul&gt;
&lt;li&gt;域对象是可以像map一样存取数据的对象，域指的是存取数据的操作范围&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;                        存数据                  取数据                     删除数据  
        Map             put()                   get()                     remove()  
        域对象      serAttribute()          getAttribute()             removeAttribute()
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;作用：
&lt;ol&gt;
&lt;li&gt;获取web.xml中配置的上下文参数context-param: &lt;code&gt;servletContext.getInitParameter()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获取当前的工程路径，格式：/工程路径: &lt;code&gt;servletContext.getContextPath()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获取工程部署后在服务器硬盘上的绝对路径: &lt;code&gt;servletContext.getRealPath(&amp;quot;/&amp;quot;)&lt;/code&gt;其中/在服务器解析时，表示地址为：&lt;code&gt;http://ip:port/工程路径&lt;/code&gt;映射到IDEA为web目录&lt;/li&gt;
&lt;li&gt;像map一样存储数据&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;httpservletrequest类&#34;&gt;HttpServletRequest类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;作用：每次只要有请求进入Tomcat服务器，Tomcat服务器就会把请求过来的HTTP协议信息解析好封装到Request对象中，然后传递到service方法（doGet和DoPost中给我们使用，我们可以通过HttpServletRequest对象，获取到所有请求的信息。（每次请求创建一个，请求完成即销毁）&lt;/li&gt;
&lt;li&gt;常见API：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;request.getRequestURI()&lt;/code&gt; ：获取请求的资源路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;request.getRequestURL()&lt;/code&gt; ：获取请求的url&lt;/li&gt;
&lt;li&gt;&lt;code&gt;request.getRemoteHost()&lt;/code&gt; ：获取客户端ip地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;request.getHeader(String key)&lt;/code&gt; ：获取请求头中对应键的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;request.getMethod()&lt;/code&gt; ：获取请求方式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;request.getParameter(String key)&lt;/code&gt; ：获取请求参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;request.getParameterValues(String key)&lt;/code&gt;: 获取请求参数，用于参数值有多个时&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通常在doPost方法的第一行写&lt;code&gt;request.setCharacterEncoding(&amp;quot;UTF-8&amp;quot;);&lt;/code&gt;用来解决post请求的中文乱码问题&lt;/li&gt;
&lt;li&gt;HttpServletRequest对象也是域对象。每个请求对应着唯一一个HttpServletRequest对象，而且在请求结束之前会一直存在，故在处理请求过程中可以使用&lt;code&gt;request.setAttribute(String name, Object o)&lt;/code&gt;方法对该对象添加属性，用&lt;code&gt;request.getAttribute(String name)&lt;/code&gt;获取该对象的属性，从而执行一些操作。&lt;/li&gt;
&lt;li&gt;请求转发：服务器收到请求后，从一个资源转到另一个资源的操作
&lt;ul&gt;
&lt;li&gt;特点：1、浏览器地址栏没有改变。2、属于一次请求：由多个servlet资源共同完成的同一个请求，故HttpServletRequest对象的作用域涵盖请求转发过程，从而这些servlet资源可以共享该对象中的数据。3、能访问WEB-INF中的资源。4、不可以访问当前工程以外的资源。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RequestDispatcher requestDispatcher = request.getRequestDispatcher(&amp;quot;/目的资源名称&amp;quot;);&lt;/code&gt;请求转发必须以斜杠/开头，/表示&lt;code&gt;http://ip:port/工程路径&lt;/code&gt;映射到IDEA为web目录&lt;/li&gt;
&lt;li&gt;base标签的作用：所有的相对路径都是以base标签中的地址为参照。在没有base标签时，所有路径都以当前地址栏中的地址为参照，这在某些情况下会出错（如请求转发时，地址栏中的地址不变，但页面改变，若此页面中有相对路径，则参考基准不再是当前页面，而是地址栏的地址，从而出错）。若在页面中引入base标签，则相对路径参考基准成为base标签的路径。base标签在HTML文档的head标签内，如&lt;code&gt;&amp;lt;base herf=&amp;quot;http://localhost:8080/project/a/b.html&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;httpservletresponse类&#34;&gt;HttpServletResponse类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;作用：HttpServletResponse类和HttpServletRequest类一样，每次请求进来，Tomcat服务器都会创建一个Response对象传递给Servlet程序去使用。HttpServletRequest表示请求过来的信息，HttpServletResponse表示所有响应的信息，如果需要设置返回给客户端的信息，都可以通过HttpServletResponse对象进行设置。&lt;/li&gt;
&lt;li&gt;输出流：HttpServletResponse类通过流将响应传递给客户端。
&lt;ol&gt;
&lt;li&gt;字节流 &lt;code&gt;getOutputStream();&lt;/code&gt;  常用于下载（传递）二进制数据&lt;/li&gt;
&lt;li&gt;字符流 &lt;code&gt;getWriter();&lt;/code&gt;    常用于回传字符串（常用）&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;两个流只能互斥使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;中文乱码：HttpServletResponse响应的默认字符集为ISO-8859-1，所以会中文乱码，可以通过&lt;code&gt;response.setContentType(&amp;quot;text/html; charset=UTF-8&amp;quot;);&lt;/code&gt;将服务器和浏览器的字符集以及响应头都设置为UTF-8，就能解决中文乱码问题。&lt;strong&gt;此方法必须在获取流对象之前调用才有效&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;请求重定向：
&lt;ul&gt;
&lt;li&gt;第一种方法：在下图的response1中写&lt;code&gt;response.setStatus(302)&lt;/code&gt; 来设置响应状态码，&lt;code&gt;response.setHeader(&amp;quot;Location&amp;quot;, &amp;quot;http://ip:port/工程路径/response2&lt;/code&gt; 来设置响应头，告知新地址。&lt;/li&gt;
&lt;li&gt;第二种方法（&lt;strong&gt;推荐使用&lt;/strong&gt;）：在下图的response1中写&lt;code&gt;response.sendRedirect(http://ip:port/工程路径/response2&lt;/code&gt;即可。&lt;/li&gt;
&lt;li&gt;请求重定向是两次独立的请求，只是第二次有浏览器代劳，不需要手动发起请求而已。&lt;/li&gt;
&lt;li&gt;特点：1、浏览器地址栏发生变化。2、属于两次请求。3、前后两个servlet资源不共享request域中的数据。4、不能访问WEB-INF中的资源。5、可以访问当前工程以外的资源。&lt;br&gt;
&lt;img alt=&#34;请求重定向&#34; loading=&#34;lazy&#34; src=&#34;https://ethereal-lu.github.io/posts/java/servlet%E7%AC%94%E8%AE%B0/%E8%AF%B7%E6%B1%82%E9%87%8D%E5%AE%9A%E5%90%91.jpg&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;web中--的不同含义&#34;&gt;web中 / 的不同含义&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在web中 / 斜杠是一种&lt;strong&gt;绝对路径&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;/ 斜杠如果被浏览器解析，得到地址为：&lt;code&gt;http://ip:port/&lt;/code&gt;，如html中的&lt;code&gt;&amp;lt;a href=&amp;quot;/&amp;quot;&amp;gt;斜杠&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;/ 斜杠如果被服务器解析，得到地址为：&lt;code&gt;http://ip:port/工程路径&lt;/code&gt;，如  &lt;code&gt;&amp;lt;url-pattern&amp;gt;/hello&amp;lt;/url-pattern&amp;gt;&lt;/code&gt; 、
&lt;code&gt;servletContext.getRealPath(&amp;quot;/&amp;quot;)&lt;/code&gt; 、 &lt;code&gt;request.getRequestDispatcher(&amp;quot;/&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;特殊情况：&lt;code&gt;response.sendRediect(&amp;quot;/&amp;quot;);&lt;/code&gt;重定向，会将 / 斜杠发送给浏览器解析，得到&lt;code&gt;http://ip:port/&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;基于xml的方式&#34;&gt;基于xml的方式&lt;/h3&gt;
&lt;h4 id=&#34;servlet中webxml的配置&#34;&gt;Servlet中web.xml的配置&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;web-app&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;xmlns=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://xmlns.jcp.org/xml/ns/javaee&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#a6e22e&#34;&gt;xmlns:xsi=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#a6e22e&#34;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#a6e22e&#34;&gt;version=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;4.0&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--servlet标签给Tomcat配置Servlet程序--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;servlet&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--servlet-name标签：给Servlet程序起一个别名（一般是类名）--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;HiServlet&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--servlet-class是Servlet程序的全类名--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;servlet-class&amp;gt;&lt;/span&gt;com.example.tomcat.HiServlet&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/servlet-class&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/servlet&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--servlet-mapping标签给Servlet程序配置访问地址--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--servlet-name标签告诉服务器，我当前配置的地址给哪个Servlet程序使用--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;HiServlet&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--url-pattern标签配置访问地址
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;            /   斜杠在服务器解析时，表示地址为：http://ip:port/工程路径   本工程即为http://localhost:8080/tomcat_war_exploded/
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;            /hello  表示：http://ip:port/工程路径/hello    即http://localhost:8080/tomcat_war_exploded/hello
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;        --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;/hello&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/servlet-mapping&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/web-app&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;从url定位到servlet程序过程&#34;&gt;从url定位到Servlet程序过程&lt;/h4&gt;
&lt;p&gt;对照上方的xml配置文件：当在地址栏输入&lt;code&gt;http://localhost:8080/tomcat_war_exploded/hello&lt;/code&gt;时，由8080定位到Tomcat服务器，再由/tomcat_war_exploded定位到该工程，然后根据/hello定位到xml配置文件中&lt;code&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/code&gt;标签下的&lt;code&gt;&amp;lt;url-pattern&amp;gt;&lt;/code&gt;标签，其对应的&lt;code&gt;&amp;lt;servlet-name&amp;gt;&lt;/code&gt;标签值为HiServlet，再根据这个标识符找到相同名的&lt;code&gt;&amp;lt;servlet&amp;gt;&lt;/code&gt;标签，根据其标签下&lt;code&gt;&amp;lt;servlet-class&amp;gt;&lt;/code&gt;的值定位到类的位置，然后执行类中的service方法。&lt;/p&gt;</description>
    </item>
    <item>
      <title>tomcat笔记</title>
      <link>https://ethereal-lu.github.io/posts/java/tomcat%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 20 Apr 2021 20:39:32 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/java/tomcat%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h3 id=&#34;将工程部署到tomcat中&#34;&gt;将工程部署到tomcat中&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;直接将工程拖拽到tomcat的webapps目录下即可访问&lt;/li&gt;
&lt;li&gt;在tomcat中的conf\Catalina\localhost下添加配置文件来配置工程，此时工程可以存放于机器的任何位置
&lt;ul&gt;
&lt;li&gt;配置文件的示例如下
&lt;ul&gt;
&lt;li&gt;&amp;lt;Context path=&amp;quot;/github_blog&amp;quot; docBase=&amp;ldquo;E:\programme_work\vscode_work\GitHubSite\public&amp;rdquo;/&amp;gt;&lt;/li&gt;
&lt;li&gt;&lt;u&gt;其中，Context表示一个工程上下文&lt;br&gt;
path表示工程的访问路径。是该文件的映射，即在url中输入 &lt;code&gt;http://localhost:8080/github_blog/&lt;/code&gt;，就会进入这个工程。&lt;br&gt;
docBase表示工程目录的实际位置&lt;/u&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一个配置文件对应于一个工程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    <item>
      <title>hexo的常见问题</title>
      <link>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/hexo/</link>
      <pubDate>Tue, 20 Apr 2021 20:07:32 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/hexo/</guid>
      <description>&lt;h3 id=&#34;hexo的分类问题&#34;&gt;hexo的分类问题&lt;/h3&gt;
&lt;p&gt;在每个markdown文件的头部，date的下一行添加一行&lt;br&gt;
&lt;u&gt;categories: 类别1&lt;/u&gt;
即可将该文件归类为 “类别1” 这一类中&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;hexo无法显示图片问题&#34;&gt;hexo无法显示图片问题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;确认根目录_config.yml中有:  &lt;code&gt;post_asset_folder: true&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;确保在md文件所在目录下创建和md文件同名的目录，在里面放该md需要的图片，然后在md中插入&lt;code&gt;![](文件名.jpg)&lt;/code&gt; &lt;strong&gt;只需写图片文件名，不用写目录名&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果还不行，在站点根目录下先执行&lt;code&gt;npm uninstall hexo-asset-image --save&lt;/code&gt;（如果之前下载过）。再执行&lt;code&gt;npm install hexo-asset-image --save&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Chrome浏览器图片显示正常，而Edge浏览器无法显示&lt;/strong&gt;，有可能是Egde不支持，故使用Chrome就可以了&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    <item>
      <title>Tomcat启动一闪而过以及报java.lang.IllegalStateException: 无输出目录以及乱码</title>
      <link>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/tomcat/</link>
      <pubDate>Tue, 20 Apr 2021 17:20:53 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/tomcat/</guid>
      <description>&lt;h4 id=&#34;黑屏一闪而过&#34;&gt;黑屏一闪而过&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：环境变量中没有JAVA_HOME变量。&lt;br&gt;
&lt;strong&gt;解决&lt;/strong&gt;：添加该变量，值为jdk的根目录，例如  D:\java\jdk&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;报javalangillegalstateexception-无输出目录&#34;&gt;报java.lang.IllegalStateException: 无输出目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：Tomcat文件的权限不够，导致不能正常编译。&lt;br&gt;
&lt;strong&gt;解决&lt;/strong&gt;：将Tomcat文件的权限提升为完全控制&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;乱码&#34;&gt;乱码&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：编码格式的问题
&lt;strong&gt;解决&lt;/strong&gt;：将tomcat下的conf\logging.properties中的java.util.logging.ConsoleHandler.encoding的值从UTF-8修改为GBK&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring5学习笔记</title>
      <link>https://ethereal-lu.github.io/posts/java/spring5%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 20 Apr 2021 15:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/java/spring5%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;p&gt;IOC： 控制反转，把创建对象的过程交给Spring进行管理   &lt;br&gt;
Aop： 面向切片，不修改源代码进行功能增强&lt;/p&gt;
&lt;p&gt;Spring5入门案例基本步骤：   &lt;br&gt;
1、创建项目   &lt;br&gt;
2、在项目中创建一个lib文件夹，把需要的jar包复制进来   &lt;br&gt;
3、点击  file -&amp;gt; project structure -&amp;gt; modules -&amp;gt; dependencies -&amp;gt; 左下角的 + 号 -&amp;gt; jars or directories -&amp;gt; 选中刚复制过来的jar包，将导入的jar包全选，点击ok   &lt;br&gt;
4、创建普通类User   &lt;br&gt;
5、创建Spring配置文件，在配置文件配置创建的对象在src中创建xml格式的Spring配置文件， 在&amp;lt;beans&amp;gt;的内部末尾添加   &lt;br&gt;
&amp;lt;!&amp;ndash;配置User对象创建&amp;ndash;&amp;gt;  &amp;lt;bean id=&amp;ldquo;user&amp;rdquo; class=&amp;ldquo;com.ethereal.spring5.User&amp;rdquo;&amp;gt;&amp;lt;/bean&amp;gt; 两行&lt;br&gt;
6、进行测试代码编写&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TestSpring5&lt;/span&gt; {      
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;@Test&lt;/span&gt;      
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;testAdd&lt;/span&gt;() {      
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 加载spring配置文件      &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                ApplicationContext context &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;bean1.xml&amp;#34;&lt;/span&gt;);      
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 获取配置创建的对象      &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                User user &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; context.&lt;span style=&#34;color:#a6e22e&#34;&gt;getBean&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user&amp;#34;&lt;/span&gt;, User.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;);      
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(user);      
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                user.&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;();      
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }      
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;IOC容器： (Inversion of Control) 控制反转，把创建对象和对象之间调用的过程交给Spring进行管理   &lt;br&gt;
1、IOC底层原理     xml解析 + 反射 + 工厂模式      （降低耦合度）&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 基础</title>
      <link>https://ethereal-lu.github.io/posts/go/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 02 Jan 2021 17:39:41 +0000</pubDate>
      <guid>https://ethereal-lu.github.io/posts/go/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;1基础&#34;&gt;1、基础&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;包含有 main 函数的包，其包名必须是 main。包名与文件名没有任何关系。但在只包含一个main函数的项目中，一般文件名与包名一致&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;go 语句的末尾加不加分号都可以，建议不加&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;导包时推荐使用第二种&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;time&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;time&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;函数体前的大括号必须与函数名在同一行，否则报错&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello go&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;同样 if else 中的 else 必须与 if 的末尾大括号在同一行，否则报错&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;空切片&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;非空&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2变量&#34;&gt;2、变量&lt;/h2&gt;
&lt;h3 id=&#34;21变量声明&#34;&gt;2.1、变量声明&lt;/h3&gt;
&lt;p&gt;方法一二三既可以用于局部变量也可以用于全局变量，而方法四只能在函数体内用于局部变量&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 方法一：只声明，不显式赋值，默认值为0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;)  &lt;span style=&#34;color:#75715e&#34;&gt;// 0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 方法二：声明并显式初始化
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;)  &lt;span style=&#34;color:#75715e&#34;&gt;// 100
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 方法三：初始化时省去数据类型，自动推导
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;abc&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;)  &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;abc&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 方法四：省去 var 关键字，直接使用海象运算符类型推导（常用这种），表示声明并初始化
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;d&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4.5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;d&lt;/span&gt;)  &lt;span style=&#34;color:#75715e&#34;&gt;// 4.5
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;type of d is %T\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;d&lt;/span&gt;)  &lt;span style=&#34;color:#75715e&#34;&gt;// 格式化打印，%T 表示打印变量类型；此处输出为 float64
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;22多个变量的声明&#34;&gt;2.2、多个变量的声明&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;aa&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;bb&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cc&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;dd&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;4.5&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;abc&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 或者下面这种写法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;ee&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;300&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;ff&lt;/span&gt; = &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 也可以这样
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;gg&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;hh&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;3常量与枚举&#34;&gt;3、常量与枚举&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 常量（只读）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// const 定义枚举类型
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 在第一个枚举成员后赋值关键字 iota，之后的每行的成员的值自动加 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;SPRING&lt;/span&gt; = &lt;span style=&#34;color:#66d9ef&#34;&gt;iota&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;// iota 为常量 0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;SUMMER&lt;/span&gt;          &lt;span style=&#34;color:#75715e&#34;&gt;// 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;AUTUMN&lt;/span&gt;          &lt;span style=&#34;color:#75715e&#34;&gt;// 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;WINTER&lt;/span&gt;          &lt;span style=&#34;color:#75715e&#34;&gt;// 3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 也可以赋值 iota 的表达式，此时之后的成员都会在 iota 加一的基础上赋值表达式
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;SPRING&lt;/span&gt; = &lt;span style=&#34;color:#66d9ef&#34;&gt;iota&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;// 0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;SUMMER&lt;/span&gt;               &lt;span style=&#34;color:#75715e&#34;&gt;// 10
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;AUTUMN&lt;/span&gt;               &lt;span style=&#34;color:#75715e&#34;&gt;// 20
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;WINTER&lt;/span&gt;               &lt;span style=&#34;color:#75715e&#34;&gt;// 30
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// iota 逐行累加；iota 只能出现在 const 的括号中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; = &lt;span style=&#34;color:#66d9ef&#34;&gt;iota&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;iota&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// iota = 0; a = 1; b = 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;d&lt;/span&gt;                       &lt;span style=&#34;color:#75715e&#34;&gt;// iota = 1; c = 2; d = 3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;                       &lt;span style=&#34;color:#75715e&#34;&gt;// iota = 2; e = 3; f = 4
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;g&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt; = &lt;span style=&#34;color:#66d9ef&#34;&gt;iota&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;iota&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// iota = 3; g = 6; h = 9
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;k&lt;/span&gt;                       &lt;span style=&#34;color:#75715e&#34;&gt;// iota = 4; i = 8; k = 12
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;4函数&#34;&gt;4、函数&lt;/h2&gt;
&lt;p&gt;若函数名首字母大写，表示 public；小写，表示 private&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
