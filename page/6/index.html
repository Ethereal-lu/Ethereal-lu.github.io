<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.140.1"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>lu</title>
<meta name=description content><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://ethereal-lu.github.io/index.xml><link rel=alternate type=application/json href=https://ethereal-lu.github.io/index.json><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/"><meta property="og:site_name" content="lu"><meta property="og:title" content="lu"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="lu"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"lu","url":"https://ethereal-lu.github.io/","description":"","logo":"https://ethereal-lu.github.io/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="lu (Alt + H)">lu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>VMware + Ubuntu18.04设置静态 IP</h2></header><div class=entry-content><p>进入VMware 的虚拟网络编辑器；
选择 VMnet8，点击 DHCP 设置，记住子网 IP，子网掩码和起始终止 IP，关闭。
点击右下方的更改设置，取消勾选 DHCP 分配 IP。再输入刚才记住的子网 IP 和子网掩码。
点击 NET 设置，记住网关并点击左下方的 DNS 设置，取消勾选自动检测并设置首选DNS为 8.8.8.8，备用为 114.114.114.114。确定、确定、应用。
打开主机的网络适配器中的 VMnet8 ，进入它的 IPV4 设置，将 IP 设置为之前记住的起始终止 IP 之间的任意一个，子网掩码和 DNS 都与之前设置的VMware一致。
一路确定并禁用再启用 VMnet8。
打开虚拟机，bash 输入 vim /etc/network/interfaces，内容如下：
source /etc/network/interfaces.d/* auto lo iface lo inet loopback auto ens32 iface ens32 inet static # 下方设置与之前步骤设置的一致 address 192.168.40.130 # 主机中设置的 IP，以后虚拟机 IP 固定为它 netmask 255.255.255.0 # 子网掩码 gateway 192.168.40.2 # 网关 dns-nameservers 8.8.8.8 # dns 输入vim /etc/systemd/resolved.conf，使其内容如下：
...</p></div><footer class=entry-footer><span title='2021-11-14 22:08:18 +0000 UTC'>2021-11-14</span>&nbsp;·&nbsp;122 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to VMware + Ubuntu18.04设置静态 IP" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81-ip/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>feign发起https请求</h2></header><div class=entry-content><p>1、安装 openssl 2、bash 进入任意目录执行以下命令
mkdir certs # 证书目录 mkdir private # 密钥目录 openssl rand -out private/.rand 1000 # 在构建根证书之前需要构建随机数文件(.rand) openssl genrsa -aes256 -out private/ca.key.pem 2048 # 构建根证书私钥 openssl req -new -key private/ca.key.pem -out private/ca.csr -subj "/C=CN/ST=BJ/L=BJ/O=FATE/OU=fate/CN=*.FATE.ORG" # 生成根证书签发申请 openssl x509 -req -days 10000 -sha1 -extensions v3_ca -signkey private/ca.key.pem -in private/ca.csr -out certs/ca.cer # 签发根证书 openssl pkcs12 -export -cacerts -inkey private/ca.key.pem -in certs/ca.cer -out certs/ca.p12 # 根证书转换为PKCS12格式密钥库 openssl genrsa -aes256 -out private/server.key.pem 2048 # 构建服务器证书私钥 openssl req -new -key private/server.key.pem -out private/server.csr -subj "/C=CN/ST=BJ/L=BJ/0=fate/OU=fate/CN=www.fate.org" # 生成服务器证书签发申请 openssl x509 -req -days 3650 -sha1 -extensions v3_req -CA certs/ca.cer -CAkey private/ca.key.pem -CAserial ca.srl -CAcreateserial -in private/server.csr -out certs/server.cer # 签发服务器证书 openssl pkcs12 -export -clcerts -inkey private/server.key.pem -in certs/server.cer -out certs/server.p12 # 服务器证书转换为PKCS12格式密钥库 3、将 server.p12 复制到微服务端的 resources 目录下
...</p></div><footer class=entry-footer><span title='2021-11-02 11:08:18 +0000 UTC'>2021-11-02</span>&nbsp;·&nbsp;187 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to feign发起https请求" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/feign%E5%8F%91%E8%B5%B7https%E8%AF%B7%E6%B1%82/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>微服务学习笔记</h2></header><div class=entry-content><p>1、微服务架构介绍 1.1、微服务概念 微服务就是将一个单体架构的应用按业务划分为一个个独立运行的程序即服务，他们之间通过 HTTP 协议进行通信（也可以采用消息队列来通信，如 RabbotMQ、Kafaka 等），可以采用不同的编程语言，使用不同的存储技术，自动化部署（如Jenkins）减少人为控制，降低出错概率。服务数量越多，管理起来越复杂，因此采用集中化管理。例如 Eureka，Zookeeper 等都是比较常见的服务集中化管理框架。
微服务是一种架构风格。有两个特点：
职责单一：一个微服务解决一个业务问题（注意是一个业务问题而不是一个接口）。 面向服务：将自己的业务能力封装并对外提供服务，这是继承SOA的核心思想，一个微服务本身也可能调用其它的微服务。 1.2、微服务设计原则 AKF 拆分原则
前后端分离原则
无状态服务
状态：如果一个数据需要被多个服务共享，才能完成一笔交易，那么这个数据被称为状态。进而依赖这个状态数据的服务被称为有状态服务，反之称为无状态服务。
例如对空调的设置：1、若空调遥控器发送加一或减一的指令，空调根据现在的温度计算并调整温度，则空调提供的是有状态服务，状态是空调当前温度。2、若空调遥控器发送的是加一或减一之后的温度数值，空调根据接收到的温度数值设置温度，则空调提供的是无状态服务。
Restful 通信风格
2、Eureka 注册中心 应用微服务化之后，首先遇到的第一个问题就是服务发现问题，一个微服务如何发现其他微服务呢？最简单的方式就是每个微服务里面配置其他微服务的地址，但是当微服务数量众多的时候，这样做明显不现实。所以需要使用到微服务架构中的一个最重要的组件：服务注册中心，所有服务都注册到服务注册中心，同时也可以从服务注册中心获取当前可用的服务清单。
2.1、注册中心概念 注册中心可以理解为微服务架构中的“通讯录”。它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其他服务时，就到这里找到服务的地址，进行调用。
张三办了张新的电话卡并将号码告诉我，我将其名字和号码的映射保存进通讯录。 -- 服务注册 我想给张三打电话，于是在通讯录中根据其名字找到张三，然后根据映射到的电话号码拨打 -- 服务发现 --------------------------------------------------------- 上例中我和张三分别代表一个微服务，通讯录是独立于我和张三的服务注册中心 总结：服务注册中心的作用就是服务的注册和服务的发现。
2.2、Eureka 入门案例 1、创建一个 SpringBoot 项目并引入web、test和下方两个依赖 。
&lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-dependencies&lt;/artifactId> &lt;version>2020.0.4&lt;/version> &lt;type>pom&lt;/type> &lt;scope>runtime&lt;/scope> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-eureka-server&lt;/artifactId> &lt;version>3.0.4&lt;/version> &lt;/dependency> 2、application.yaml 如下
server: port: 8761 # 官方文档使用的端口 spring: application: name: eureka-server # 应用名称 # 配置 eureka-server 注册中心 eureka: instance: hostname: localhost # 主机名，默认根据操作系统的主机名获取 client: # 下方值为 false 的两项，只有当自身为单节点的注册中心时才需要设置为 false 。 # 单节点指的是只有一个注册中心，不是只有一个微服务。 # 当自身是微服务或者是集群中的注册中心之一时无需设置，使用默认 true。 register-with-eureka: false # 是否将自己注册到注册中心，默认为 true fetch-registry: false # 是否从注册中心获取服务注册信息，默认 true service-url: # 注册中心对外暴露的注册地址 defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ 3、启动类前添加 @EnableEurekaServer 注解
...</p></div><footer class=entry-footer><span title='2021-10-25 17:42:15 +0000 UTC'>2021-10-25</span>&nbsp;·&nbsp;2155 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 微服务学习笔记" href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>设计模式</h2></header><div class=entry-content><p>1、设计模式分类 创建型模式
用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。
结构型模式
用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。
行为型模式
用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。
2、UML图 统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。
2.1、类的表示方式 在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。
属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：
+：表示public
-：表示private
#：表示protected
属性的完整表示方式是： 可见性 名称 ：类型 [ = 缺省值]
方法的完整表示方式是： 可见性 名称(参数列表) [ ： 返回类型]
2.2、类与类之间关系的表示方式 感觉没必要记，用到时再查吧。
3、软件设计原则 在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。
3.1 开闭原则 对扩展开放，对修改关闭。即使用接口和抽象类，扩展时实现新的派生类而不修改子类。增加新功能时添加新的代码，而不要修改原有代码。
3.2 里氏代换原则 里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。
3.3 依赖倒转原则 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。
简单说就是尽量让接口作为成员变量，而不要让实现类作为成员变量。
3.4 接口隔离原则 客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。
被迫依赖：类 B 为了定义一个已经在类 A 中定义了的方法而去继承类 A，此时类 B 被迫依赖于类 A 中其他它并不需要的方法。
应该将该方法单独抽象为接口，若所有实现类的方法体都一样，可以用 default 修饰并实现。
继承接口时也一样，不要使类被迫依赖于接口中其他不适用的方法。应该将接口拆分为多个接口。
...</p></div><footer class=entry-footer><span title='2021-09-25 17:12:41 +0000 UTC'>2021-09-25</span>&nbsp;·&nbsp;6688 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 设计模式" href=https://ethereal-lu.github.io/posts/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>指令重排与内存屏障</h2></header><div class=entry-content><p>指令重排 有两种发生指令重排的情况：一个是编译的时候，由编译原理的知识知道，编译器会对代码进行优化，这一步就涉及到指令重排，当然，编译完成之后的目标代码中指令的顺序就是确定的，不同线程执行该代码的顺序是一样的；另一个就是CPU在执行具体的指令的时候，也会因为计算机当前的状态（比如寄存器的占用情况、ALU的使用情况，cup缓存层的存在等原因）的不同导致指令最终的执行顺序发生变化(实际上，cpu本身并不会对指令进行重排，它本身是按照编译后的顺序来执行指令的，只是由于执行不同的指令需要的时间长短不同，以及缓存层的存在，再加上CPU执行指令的流水线并不是串行化等因素，那么就有可能出现排在靠前位置的指令还没执行完，而排在靠后的指令已经执行完了的情况，这一情况就是所谓的CPU执行指令的乱序）
编译器指令重排 如果两条有依赖关系 (像 a++; b=f(a); ) 的指令挨得很近，后一条指令必定会因为等待前一条执行的结果，而在流水线中阻塞很久(这个“很久”是对计算机而言哈)。而编译器的乱序，作为编译优化的一种手段，则试图通过指令重排，在这两条指令之间插入其他指令，将这两条指令拉开一定的距离，以保证后一条指令执行的时候前一条指令结果已经得到了，那么也就不需要阻塞等待了。所以相比于CPU的乱序，编译器的乱序才是真正对指令顺序做了调整，但是编译器所进行的调整也必须保证上下文的依赖逻辑，即存在依赖关系的指令顺序不能调整。
CPU 指令重排 现在的CPU一般采用流水线来执行指令。一个指令的执行被分成：取址，译码，访存，执行，写回等若干个阶段。流水线中的多个指令是可以同时处于同一个阶段的，只要CPU内部相应的处理部件未被占满。这样一来，乱序就可能产生了。比如一条加法指令出现在一条除法指令的后面，但由于除法的执行时间很长，在它执行完之前，加法可能就先执行完了。再比如两条访存指令，可能由于第二条指令中了cache(或其它原因)而导致它先于第一条指令完成。指令流水线除了在资源不足的情况下会卡住之外(如一个加法器应付两条加法指令)，指令之间存在的相互依赖才是导致流水线阻塞的主要原因。当然，CPU的乱序执行并不是任意地乱序，而必须保证上下文依赖逻辑的正确性。
内存屏障 不存在依赖关系的内存操作会被按随机顺序有效得到执行，但这在CPU与CPU(多核)交互时或CPU与IO设备交互(一般IO比较耗时)时，这可能成为问题。我们需要一些手段来干预编译器和CPU对指令顺序的影响，而内存屏障就是这样的干预手段。它们能保证处于屏障两边的内存操作满足部分有序(“部分有序”的意思是，内存屏障之前的操作必须都先于屏障之后的操作，但是如果几个操作出现在屏障的一边，则不保证它们有序)。这样的强制措施是非常重要的，因为系统中的CPU和其它设备可以使用各种各样的策略来提高性能，包括对内存操作的乱序、延迟和合并执行、预取、投机性的分支预测和各种缓存……内存屏障就是用于禁用或者抑制这些策略，使代码能够清楚地控制多个CPU和/或设备的交互。操心系统中存在各式各样的内存屏障，不同的内存屏障涉及到了各种复杂的实现，这里不过多地讲了，但关于内存屏障还要记住的一点就是：在内存屏障之前出现的内存访问不保证在内存屏障指令完成之前完成，内存屏障相当于在该CPU的访问队列中画了一条线，使得相关访存类型的请求不能相互跨越(用于实现内存屏障的指令，其本身并不作为参考对象，其两边的访存操作才被当作参考对象，所以屏障指令执行完成并不表示出现在屏障之前的所有访存操作都已经完成，但如果屏障之后的某一个访存操作已经完成，则屏障指令之前的所有访存操作必定都已经完成了)。
要想并发程序正确地执行，必须要保证程序的原子性、可见性以及有序性。只要有一个没有被保证，就可能会导致程序运行不正确。</p></div><footer class=entry-footer><span title='2021-08-26 23:08:18 +0000 UTC'>2021-08-26</span>&nbsp;·&nbsp;15 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 指令重排与内存屏障" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E4%B8%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>lambda 表达式中使用的变量为什么必须是 final</h2></header><div class=entry-content><p>Java 规范中规定：Lambda 表达式中要用到的，但又未在 Lambda 表达式中声明的变量，必须声明为 final 或者是 effectively final，否则就会出现编译错误。
有效 final 即不用显示声明为 final，由 JVM 添加 final。
个人理解 由于 lambda 表达式相当于生成一个对象，存储在堆中（生命周期长），而方法的局部变量存储在栈中（生命周期短）。如果 lambda 表达式在使用了外部方法中的局部变量后，该局部变量又发生变化，且方法执行完毕内存被释放，此 lambda 表达式生成的对象可能依然存活（未被GC回收），但是却无法得知局部变量改变后的值，造成数据一致性破坏。
// 报错 public class Test { public void func() { int a = 5; Runnable runnable = () -> { a++; }; } } 上方在方法中报错而下方在类中不报错，因此推断与栈和堆的生存周期有关系。
// 不报错 public class Test { private int a = 3; Runnable runnable = () -> { a++; }; } **存在问题：**作为方法中的内部类，既然方法被释放后，该类绝不可能再被使用，矛盾！
其他理解 lambda是对接口中的方法的一种简写方式，当方法想要使用外部的变量的时候，需要把值给传过去，但是方法中无论怎么改变量的值，都不会改变这个变量在外部的值（值传递和引用传递的区别），所以加上final就是为了方便开发者，以免误以为可以更改这个变量的值。final的目的就是告诉开发人员不能改变外面的变量值。
**存在问题：**外部变量什么时候传递给 lambda 的。难道隐式的传了？
悬而未决，先睡觉
...</p></div><footer class=entry-footer><span title='2021-08-18 23:08:18 +0000 UTC'>2021-08-18</span>&nbsp;·&nbsp;76 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to lambda 表达式中使用的变量为什么必须是 final" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/lambda/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>文件的 MD5 值</h2></header><div class=entry-content><p>是什么 文件的 MD5 值不是文件的属性也不是文件存储的内容，而是由分析程序根据文件的信息分析得到的一串独一无二的字符值。当两个文件的 MD5 值相同时说明这两个文件的内容完全一样。任何数据计算得到的 MD5 值长度都相等。
作用 由于同一个分析程序对于内容一样的文件分析得到的 MD5 值始终是一样的，因此可以通过对传输前后的文件进行 MD5 值的对比来检验传输途中文件是否被他人篡改。
MD5 值何时改变 1、不同的分析程序对同一份文件分析得到的 MD5 值可能不同。
2、对文件的内容进行增删改后，文件的 MD5 值会发生改变。
3、修改文件的名称和后缀都不会改变文件的 MD5 值。
查看文件 MD5 值的方法 1、Windows
certutil -hashfile 文件路径 md5 # 示例 certutil -hashfile E:\资料\作业资料\abc.py md5 2、Linux
md5sum 文件路径</p></div><footer class=entry-footer><span title='2021-08-18 23:08:18 +0000 UTC'>2021-08-18</span>&nbsp;·&nbsp;42 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 文件的 MD5 值" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E6%96%87%E4%BB%B6md5/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>JUC 并发编程</h2></header><div class=entry-content><p>线程基础知识 概述 每个线程拥有一个自己独立的栈，但是共享进程的堆空间。
Thread 中的 run 方法是一个回调函数，与普通函数没什么区别，所以以如下方式调用run时，就是一个普通的方法执行。而 start 方法会在本地创建一个线程，然后在本地代码中通过 jvm 回调 run 方法来执行任务。
Thread thread = new Thread(() -> {...}); thread.run(); 线程实现方法 Thread类是描述线程的类，要实现多线程，必须继承Thread类
方法一、创建Thread类的子类 1、创建Thread类的子类，并重写run方法，其中设置线程的任务
2、创建子类对象，并执行start方法
​ （执行start方法会创建一个新的栈空间，并在该栈空间中执行run方法。每执行一次步骤2，就开启一个新的线程）
方法二、实现Runnable接口 推荐使用这种 —> 使用该方法时，Thread 类是咱们自定义类的静态代理类
1、创建一个Runnable接口的实现类，并重写run方法，其中设置线程的任务
2、创建对象，并将其作为参数传递给Thread类的构造方法，再调用start方法。
​ new Thread(new MyRunnable()).start(); ​ 匿名内部类实现： new Thread(new Runnable(){重写run方法}).start();
方法三、实现Callable接口 Callable接口类似于Runnable，但Runnable不会返回结果，也不会抛出检查异常，Callable可以，Runnable 效率比 Callable 低。
1、创建一个Callable接口的实现类，并重写call方法，其中设置线程的任务 2、在使用的地方创建该类对象 obj 。 3、ExecutorService executorService = Executors.newFixedThreadPool(5); // 创建执行服务 4、Future future = executorService.submit(obj); // 提交执行 5、V result = future.get(); // 获取结果 6、executorService.shutdownNow(); // 关闭服务
...</p></div><footer class=entry-footer><span title='2021-08-16 17:12:41 +0000 UTC'>2021-08-16</span>&nbsp;·&nbsp;2357 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to JUC 并发编程" href=https://ethereal-lu.github.io/posts/java/juc%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Enum 向注解赋值问题</h2></header><div class=entry-content><p>问题 Enum 如下
@Getter @AllArgsConstructor(access = AccessLevel.PRIVATE) public enum RoleEnum { ADMIN (0, "admin"), ANALYST (1, "analyst"); private final Integer intValue; private final String strValue; } 将该 enum 对象的属性赋值给注解时报错：
@RequiresRoles(RoleEnum.ADMIN.getStrValue()) // error: "attribute value must be constant" 报错显示注解所需值必须是常量
这是因为 ADMIN 作为 RoleEnum 的对象，只有当 RoleEnum 被类加载器所加载之后才会生成，而在编译期 strValue 属性还是变量，所以会报错。
解决 在 enum 中添加内部类存储常量
@Getter @AllArgsConstructor(access = AccessLevel.PRIVATE) public enum RoleEnum { ADMIN (0, Names.ADMIN), ANALYST (1, Names.ANALYST); public static class Names { public static final String ADMIN = "admin"; public static final String ANALYST = "analyst"; } private final Integer intValue; private final String strValue; } 向注解中赋值时使用内部类的常量
...</p></div><footer class=entry-footer><span title='2021-08-11 16:39:41 +0000 UTC'>2021-08-11</span>&nbsp;·&nbsp;97 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Enum 向注解赋值问题" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/enum%E8%B5%8B%E5%80%BC/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Shrio学习笔记</h2></header><div class=entry-content><p>作者 小陈
微信 chenxu521600
B站 编程不良人 | 百知教育
资料 http://www.baizhiedu.xin
1.权限的管理 1.1 什么是权限管理 基本上涉及到用户参与的系统都要进行权限管理，权限管理属于系统安全的范畴，权限管理实现对用户访问系统的控制，按照安全规则或者安全策略控制用户可以访问而且只能访问自己被授权的资源。
权限管理包括用户身份认证和授权两部分，简称认证授权。对于需要访问控制的资源用户首先经过身份认证，认证通过后用户具有该资源的访问权限方可访问。
1.2 什么是身份认证 身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确。对于采用指纹等系统，则出示指纹；对于硬件Key等刷卡系统，则需要刷卡。
1.3 什么是授权 授权，即访问控制，控制谁能访问哪些资源。主体进行身份认证后需要分配权限方可访问系统的资源，对于某些资源没有权限是无法访问的
2.什么是shiro Apache Shiro™ is a powerful and easy-to-use Java security framework that performs authentication, authorization, cryptography, and session management. With Shiro’s easy-to-understand API, you can quickly and easily secure any application – from the smallest mobile applications to the largest web and enterprise applications.
Shiro 是一个功能强大且易于使用的Java安全框架，它执行身份验证、授权、加密和会话管理。使用Shiro易于理解的API，您可以快速轻松地保护任何应用程序—从最小的移动应用程序到最大的web和企业应用程序。
Shiro是apache旗下一个开源框架，它将软件系统的安全认证相关的功能抽取出来，实现用户身份认证，权限授权、加密、会话管理等功能，组成了一个通用的安全认证框架。
3.shiro的核心架构 ...</p></div><footer class=entry-footer><span title='2021-07-27 18:48:13 +0000 UTC'>2021-07-27</span>&nbsp;·&nbsp;2810 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Shrio学习笔记" href=https://ethereal-lu.github.io/posts/java/shiro%E7%AC%94%E8%AE%B0/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://ethereal-lu.github.io/page/5/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://ethereal-lu.github.io/page/7/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>