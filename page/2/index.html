<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.140.1"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>lu</title>
<meta name=description content><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity="sha256-1yREUm1+y9sAFUOKf6iQVKZYv3WdBULi5d+BzpS0k+4=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://ethereal-lu.github.io/index.xml><link rel=alternate type=application/json href=https://ethereal-lu.github.io/index.json><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/"><meta property="og:site_name" content="lu"><meta property="og:title" content="lu"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="lu"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"lu","url":"https://ethereal-lu.github.io/","description":"","logo":"https://ethereal-lu.github.io/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://ethereal-lu.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Netty</h2></header><div class=entry-content><p>1 NIO基础 non-blocking io 非阻塞IO
1.1 三大组件 1.1.1 Channel & Buffer Buffer是内存中的数据缓冲区，Channel 是内存与磁盘之间的数据通道。不同于InputStream、OutputStream等BIO中的流都是单向数据通道，Channel 是双向数据通道，可以从 Channel 将数据读入 Buffer，也可以将Buffer 中的数据写入Channel 。
常见的 Channel 有：
FileChannel ：文件通道 DatagramChannel ：udp SocketChannel ：tcp；客户端服务端都可以 ServerSocketChannel ：tcp；专用于服务端 Buffer 使用最多的就是 ByteBuffer，其他的也是每种基础数据类型有一个对应的Buffer，但用的不多。
1.1.2 Selector 在使用传统BIO开发时，要么对每个连接都新建一个线程处理（线程太多撑爆内存、线程切换成本高），要么使用线程池（阻塞IO，同时只能处理一个连接，线程利用率不高）—> 正因为此，原始的HTTP1.0才使用短连接，一个请求处理完立刻释放连接，让线程可以处理其他请求。
Selector 的作用就是配合一个线程来管理多个Channel ，获取这些Channel 上发生的事件，将有事件发生的Channel 交给线程处理。适合连接数多但流量低的场景，流量大意味着一个Channel 要处理大量数据，会使其他Channel 饥饿。
1.2 ByteBuffer 1.2.1 基本使用 public class TestByteBuffer { public static void main(String[] args) { // 获取 FileChannel try (FileChannel channel = new FileInputStream("data.txt").getChannel()) { // 申请 10 个字节的缓冲区 ByteBuffer buffer = ByteBuffer.allocate(10); // 读取channel中的数据到buffer。read 方法返回读取到的字节数，-1表示读完了 while (channel.read(buffer) != -1) { buffer.flip(); // 切换为读模式 while (buffer.hasRemaining()) { System.out.println(buffer.get()); // get 每次读一个字节 } buffer.clear(); // 切换为写模式 } } catch (IOException e) { e.printStackTrace(); } } } 1.2.2 内部结构 ByteBuffer有以下几个重要属性
...</p></div><footer class=entry-footer><span title='2022-07-09 19:12:41 +0000 UTC'>2022-07-09</span>&nbsp;·&nbsp;1470 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Netty" href=https://ethereal-lu.github.io/posts/java/netty/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kuberbetes基础</h2></header><div class=entry-content><p>Kubernetes 是 Google 开源的一个容器编排引擎，用于自动化容器化应用程序的部署和管理。
1、Kubernetes整体架构 Master
k8s集群控制节点，对集群进行调度管理，接受集群外用户去集群操作请求；
Master Node 由 API Server、Scheduler、ClusterState Store（ETCD 数据库）和 Controller MangerServer 所组成；
Nodes
集群工作节点，运行用户业务应用容器；
Nodes节点也叫Worker Node，包含kubelet、kube proxy 和 Pod（Container Runtime）；
2、Kubernetes环境搭建 kubeadm是官方社区推出的一个用于快速部署 kubernetes 集群的工具。两个指令即可完成集群搭建：
创建一个Master节点：kubeadm init 将Node节点加入到Master集群中：kubeadm join &lt;Master节点的IP和端口> 2.1、初始环境准备 硬件：内存2G+，CPU 2核+；
关闭防火墙：ufw disable
关闭selinux：sed -i 's/enforcing/disabled/' /etc/selinux/config #永久 ；setenforce 0 #临时
关闭swap：sed -ri 's/.*swap.*/#&/' /etc/fstab #永久 ；swapoff -a #临时
设置网桥参数
cat > /etc/sysctl.d/k8s.conf &lt;&lt; EOF net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sysctl --system #生效 在master添加hosts
...</p></div><footer class=entry-footer><span title='2022-06-06 17:12:41 +0000 UTC'>2022-06-06</span>&nbsp;·&nbsp;162 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Kuberbetes基础" href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8/kuberbetes/kuberbetes%E5%9F%BA%E7%A1%80/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>分布式基础</h2></header><div class=entry-content><p>1、分布式Session 解决分布式Session有两种方案：
将所有Session存放在Redis服务器中，所有请求过来后先到Redis服务器中获取Session token：用户首次登录后，将用户信息加密为token下发给客户端，之后每次请求都携带该token，token验证通过即承认其合法身份。多个服务器都使用相同的密钥和算法对 token 进行验证。</p></div><footer class=entry-footer><span title='2022-06-02 19:42:15 +0000 UTC'>2022-06-02</span>&nbsp;·&nbsp;6 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 分布式基础" href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>HTTP</h2></header><div class=entry-content><p>1、HTTP请求方法 index method description 1 GET 请求指定页面信息，并返回实体主体 2 HEAD 类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头 3 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 4 PUT 从客户端向服务器传送的数据取代指定的文档的内容。（全部取代） 5 PATCH 从客户端向服务器传送的数据取代指定的文档的内容。（部分取代） 6 DELETE 请求服务器删除指定的页面。 7 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 8 OPTIONS 允许客户端查看服务器的性能。 9 TRACE 回显服务器收到的请求，主要用于测试或诊断。 2、HTTP队头阻塞 在HTTP1.0中不使用TCP长连接，每次收到响应后才能发起下一个请求。每个请求都需要 3 + 4.
在HTTP1.1中使用TCP长连接，一个TCP连接中可以处理多个请求，但是如果前面的请求没有收到响应就会阻塞后续的请求。因此引入管道来提高效率。但是管道的引入带来了对头阻塞，管道特性允许客户端在已发送的请求收到服务端的响应之前发送下一个请求，但是由于HTTP请求和响应并没有序号标识，无法将乱序的响应与请求关联起来，因此响应顺序必须与请求顺序一致。如果某个响应由于一些原因延迟了，那么后面的响应就都会被阻塞，这就是队头阻塞。
由于队头阻塞和幂等性问题，现代浏览器默认都关闭了管道化，并且大部分服务器也是默认不支持管道化的。
解决队头阻塞问题可以采用并发TCP连接，即每个浏览器可以对同一个域名发起多个TCP连接，如谷歌浏览器默认最大可以同时发起6个TCP连接，此时不同TCP连接中的请求便不存在队头阻塞问题。但是连接数量有限且需要额外的资源，因此只能做有效缓解。
3、HTTP幂等性 当客户端在支持管道化时需要保持未收到响应的请求，当连接意外中断时，需要重新发送这部分请求。因此客户端在使用管道化的时候请求方式必须是幂等请求。
HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。这里的副作用是指对于资源造成的改变，而不是响应结果必须一样。
GET 操作是幂等的，原因是 GET 操作根本不会对服务器产生任何修改。 PUT 方法通常是对已经存在的资源进行修改，也是幂等的。如将数字 1 改为 2，执行一次成功后，后续的操作都应该找不到数字 1 DELETE 方法也是幂等的，例如我们连续发起多个对 A 的删除请求，如果第一个成功的话，后面的请求都应返回资源找不到的错误 POST 一般是指新增资源，不是幂等的。如果连续发起三个 A 资源的增加，最终的结果会是三个 A 资源，而不是一个 因此，POST方法不能使用 Pipeline。
4、http2 和http1.1 区别 新的二进制格式（Binary Format），http1.1和2.0 最大的区别是二进制框架层。与 http1.1把所有请求和响应作为纯文本不同，http2 使用二进制框架层把所有消息封装成二进制。二进制协议解析起来更高效且错误更少。 多路复用（MultiPlexing），客户端与服务端只建立一个TCP连接，所有的请求都共享这个连接。一个request对应一个id，再将一个请求切割成多个帧，同一个请求的多个帧都携带同一个请求id，这样一个连接上可以有多个request，每个请求的帧可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。 header压缩，HTTP报文的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。 服务端推送（server push），实现复杂。 5、TSL TLS（传输层安全）是更为安全的升级版 SSL。该协议由两层组成： TLS 记录协议和 TLS 握手协议。记录协议主要负责使用对称密码对消息进行加密。握手协议负责在客户端和服务器端商定密码算法和共享密钥，以及证书认证。
...</p></div><footer class=entry-footer><span title='2022-06-01 12:39:41 +0000 UTC'>2022-06-01</span>&nbsp;·&nbsp;119 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to HTTP" href=https://ethereal-lu.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Nginx基础</h2></header><div class=entry-content><p>Tomcat 稳定但不支持高并发，因此支持高并发的 Nginx 诞生了。Nginx使用基于事件驱动架构，使其可以支持数以百万级别的TCP连接。
1、Nginx 应用场景 Nginx是一款高性能的HTTP服务器和反向代理服务器。Nginx 最常用的应用场景就是这两个。
1.1、反向代理 正向代理，“它代理的是客户端，代客户端发出请求”，是一个位于客户端和原始服务器之间的中间服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。
反向代理，“它代理的是服务端，代服务端接收请求”，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息。Nginx 作为服务端暴露的地址，所有客户端的请求都会进入 Nginx 服务器，然后由 Nginx 按照一定的规则将请求分发给具体的业务处理服务器，客户端并不知道是哪台服务器为自己服务，这里Nginx 扮演的就是反向代理服务器。
反向代理的作用：
保证内网的安全，通常将反向代理作为公网访问地址，Web服务器是内网 负载均衡，通过反向代理服务器来优化网站的负载 负载均衡
上方提到的请求分发就是依据这里的负载均衡策略分发的。
负载均衡分为硬件负载均衡和软件负载均衡两种，硬件如F5负载均衡，相对造价昂贵成本较高，但是数据的稳定性安全性高；除了移动联通等运营商使用的都是软件负载均衡，软件负载均衡是利用现有的技术结合主机硬件实现的一种消息队列分发机制。
Nginx支持的负载均衡调度算法如下：重点掌握权重轮询即可，其余的基本不用。但作为面试还是要能说出来。
权重轮询(默认）：接收到的请求按照权重分配到不同的后端服务器，可以根据服务器的硬件性能配置不同的权重，权重越大被分配到请求的几率越大。 ip_hash：每个请求按照发起客户端的ip的hash结果进行匹配，对于一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。但是移动端的ip可能一直变化，所以较为鸡肋。 fair：智能调整调度算法，动态的根据后端服务器的响应时长进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高。Nginx默认不支持fair算法，需要安装upstream_fair模块。可能造成流量倾斜，大量请求进入响应时长短的服务器导致崩溃。 url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在Nginx作为静态服务器的情况下提高缓存效率。同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装Nginx的hash软件包。 1.2、web 服务器 可以先通过动态/静态内容分离，而后为静态内容（html/css/js/图片等）提供HTTP访问功能；而动态内容可以整合代理模块，代理给上游服务器，来支持对外部程序的直接调用或者解析。
2、Nginx 基本架构 一个master进程生成多个worker子进程（每个进程只有一个线程），一个worker进程可以响应多个用户请求； 非阻塞、IO复用、事件驱动：select，poll， epoll， kqueue，/dev/poll； 支持sendfile，sendfile64； 支持文件AIO（异步I/O）； 支持mmap； 灵活的文件配置； 占用内存小：10,000个非活动HTTP保持连接占用大约2.5M内存。 3、Nginx 并发模型 一个master进程生成多个worker子进程（每个进程只有一个线程），一个worker响应多个用户请求。如果单进程启动：仅有一个进程，既充当master进程的角色，也充当worker进程的角色。
3.1、master进程 充当整个进程组与用户的交互接口（接收来自外界的信号，向各worker进程发送信号），同时监控worker进程的运行状态。
它不需要处理网络事件，不负责业务的执行，只会通过管理worker进程来实现重启服务、平滑升级、更换日志文件、配置文件实时生效等功能。
3.2、worker进程 主要任务是处理基本的网络事件，完成具体的任务逻辑。多个worker进程之间是对等的，互相独立的。
worker进程主要关注点是与客户端或后端服务器（此时nginx作为中间代理）之间的数据可读/可写等I/O交互事件，所以工作进程的阻塞点是在像select()、epoll_wait()等这样的I/O多路复用函数调用处，以等待发生数据可读/写事件。当然也可能被新收到的进程信号中断。
worker进程个数：
如果负载以CPU密集型应用为主，一般会设置与机器cpu核数一致或少一个（用来处理用户等其他任务）； 如果负载以IO密集型为主，如响应大量内容给客户端，则worker数应该为CPU个数的1.5或2倍。 因为更多的worker数，只会导致进程来竞争cpu资源了，从而带来不必要的上下文切换。而且，nginx为了更好的利用多核特性，具有cpu绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来cache的失效。
3.3、并发处理 在master进程里面，先创建socket，并bind、listen在80端口（所以master进程需要root权限）； 然后再fork出多个worker进程，这样每个worker进程都可以去accept这个socket（会产生惊群问题）， 或者使用锁机制，让抢到锁的一个worker进程去accept这个socket，注意这里一般使用select/poll/epoll机制来解决accept阻塞问题； 当一个新连接进来后，而只有抢到锁的一个进程可以accept这个连接进行处理（也是放入epoll中）； 抢到锁的worker进程accept到新连接后，会立即释放锁；然后所有worker进程再次参与抢锁，这样就回到了第二步，进行循环处理并发连接； 3.4、惊群问题 产生原因：像上面第二步，多个worker进程等待同一个socket的连接事件，当这个事件发生时，这些进程被同时唤醒，就是惊群。
注意，在linux2.6内核上，accept系统调用已经不存在惊群，但用epoll机制来解决accept阻塞问题，epoll_wait会有惊群问题（新增 EPOLLEXCLUSIVE 选项解决了）。
导致后果：许多worker进程被内核重新调度唤醒，只有一个进程可以accept这个连接进行处理，其他余者皆失败，导致性能浪费。
nginx解决方案：使用锁机制，让抢到锁的一个worker进程去accept（epoll_wait）这个socket；如果操作系统支持原子整型，才会使用共享内存实现原子上锁，否则使用文件上锁。
4、Nginx 配置 4.1、默认配置文件 /etc/nginx/nginx.conf
...</p></div><footer class=entry-footer><span title='2022-05-30 22:42:15 +0000 UTC'>2022-05-30</span>&nbsp;·&nbsp;485 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Nginx基础" href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/nginx/nginx%E5%9F%BA%E7%A1%80/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>分布式锁</h2></header><div class=entry-content><p>1、前言 单纯的Java Api并不能提供分布式锁的能力。目前比较常用的分布式锁的实现方案有如下三种：
基于数据库实现分布式锁 基于缓存实现分布式锁 基于Zookeeper实现分布式锁 分布式锁应该实现如下功能：
互斥性：在任何时刻，对于同一条数据，只有一台应用可以获取到分布式锁； 高可用性：在分布式场景下，一小部分服务器宕机不影响正常使用，这种情况就需要将提供分布式锁的服务以集群的方式部署； 防止锁超时：如果客户端没有主动释放锁，服务器会在一段时间之后自动释放锁，防止客户端宕机或者网络不可达时产生死锁； 独占性：加锁解锁必须由同一台服务器进行，也就是锁的持有者才可以释放锁，不能出现你加的锁，别人给你解锁了； 2、基于数据库实现分布式锁 2.1、实现方式 在数据库中存储方法名，将数据库的自动提交关闭，然后在查询语句后面增加for update来查询需要上锁的方法名，数据库会在查询过程中给数据库表增加排他锁。值得注意的是：只有通过索引进行检索的时候才会使用行级锁，所以应该给方法名加上唯一锁，同时为了避免重载方法也被锁住，应该在方法名上将参数类型也加上。等临界资源使用完毕后再手动提交事务。
2.2、缺点 数据在磁盘中，查询开销很大 事务提交之前客户端失联，会导致死锁 如果表中数据量不大，查询优化器可能会通过全表扫描执行，此时会使用表锁，而非行锁。 3、基于缓存实现分布式锁 3.1、实现方式 以 redis 为例来说明基于缓存实现分布式锁。
Redis分布式锁主要是通过在 set 命令中添加 nx 和 ex 这两个参数实现的。
核心思想就是每次想要获取锁的时候，就对一个固定的 key 值以 SET NX EX的方式存放，如果成功，就说明获取锁成功，否则以自旋的方式持续获取锁，直到超时获取失败。解锁通过 LUA 代码实现，LUA是原子性的。
3.2、优缺点 优点：性能好，redis 是 NoSQL，数据在内存中，支持高性能，高并发。
缺点：过期时间需要手动提前设置，若设置太长当线程阻塞后需要较长时间才锁过期，会影响性能，若设置太短会导致提前释放产生并发问题。所以可靠性稍低。
关于 redis 实现分布式锁更多内容查看 redis 目录中的分布式锁篇章
4、基于Zookeeper实现分布式锁 4.1、实现方式 在与方法对应的永久节点下创建一个临时序号节点 获取当前永久节点下的所有子节点 判断自己是否是最小节点 如果是，上锁成功 如果不是，说明前面还有锁，上锁失败，监听比自己小的节点，形成链式监听，当触发监听时，再次执行步骤 2 惊群效应（羊群效应）：如果在上锁时，每个节点监听的是最小的节点，那么每次最小节点发生改变都会触发大量的监听事件，对于 zk 压力非常大，这就是惊群效应。故应该使用上述的链式监听，因为如果前一个结点没有获取到锁，自然也轮不到自己获取。这样只能实现公平锁。
客户端突然失联，会自动释放锁 可以在临时序号节点的值中保存当前主机和线程的信息，实现可重入锁 4.2、优缺点 优点：可靠性高；断开连接自动释放锁，无需手动设置过期时间
缺点：
性能没有 reids 高。因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同不到所有的Follower机器上。 可能产生并发问题：如果由于网络抖动，服务端没有收到客户端的心跳包，服务端就会删除临时节点让其他节点获取锁，从而使多个客户端获取到锁。但是 zk 有重试机制，如果检测不到客户端的心跳，就会重试连接，所以这种情况并不常见。</p></div><footer class=entry-footer><span title='2022-05-30 10:42:15 +0000 UTC'>2022-05-30</span>&nbsp;·&nbsp;71 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 分布式锁" href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>零碎算法</h2></header><div class=entry-content><p>不大于 num 的最大值 给定整数 num，使用数组 arr 中的元素组成不大于 num 的最大数；1 &lt;= arr[i] &lt;= 9。例如 arr = {1, 2, 4, 9}，num = 2533，则返回 2499。
**整体思路：**每次都选择恰好等于当前值的元素，若顺利遍历完则所选元素组成的数等于给定值；若遍历到某个值时数组中的所有元素都大于该值，则需要回溯，将前一个元素减小；若遍历到某个值时数组中不存在等于当前值的元素，则选择较小的元素，并将之后所有元素全部置为数组中的最大值。
import java.util.Arrays; class Solution { public int findMax(int[] arr, int num) { Arrays.sort(arr); int n = String.valueOf(num).length(); int ret = dfs(arr, num, 0, 0, n); // 这里 ret &lt; 0 是递归的最外层返回 -1，说明数位相同没有答案，必须少一位。 if (ret &lt; 0) { ret = 0; while (ret &lt; num) ret = ret * 10 + arr[arr.length - 1]; ret /= 10; // 这里 ret 如果为 0，说明数组中的数不可能组成答案。 ret = ret == 0 ? -1 : ret; } return ret; } // 只负责处理第一个数位相同的情况，因为数位不相同的情况只有一种，很简单，交给主函数处理即可。 private int dfs(int[] arr, int num, int target, int index, int n) { if (index == n) { if (target &lt;= num) return target; return -1; } int curr = Integer.parseInt(String.valueOf(num).charAt(index) + ""); // arr[i] 为不大于 curr 的最大值 int i = arr.length - 1; for (; i >= 0 && arr[i] > curr; i--); // i &lt; 0 表示所有值都大于 curr。不正确，回退。 if (i &lt; 0) return -1; int ret = -1; // arr[i] == curr, 继续往后走。 if (arr[i] == curr) { ret = dfs(arr, num, target * 10 + arr[i], index + 1, n); if (ret > 0) return ret; } // arr[i] &lt; curr，则后续所有值直接取最大值即可。 if (arr[i] &lt; curr || i > 0) { // 如果 arr[i] == curr 且走到这里，说明当前选择 arr[i] 走不通，选择更小的 arr[i - 1]; if (arr[i] == curr) i--; target = target * 10 + arr[i]; while (target &lt; num) target = target * 10 + arr[arr.length - 1]; ret = target / 10; } return ret; } public static void main(String[] args) { Solution solution = new Solution(); System.out.println(solution.findMax(new int[]{1, 2, 4, 9}, 2533)); } } 右侧小于当前元素的个数 给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。如：nums = [5,2,6,1]，返回 [2,1,1,0]
...</p></div><footer class=entry-footer><span title='2022-05-22 11:12:41 +0000 UTC'>2022-05-22</span>&nbsp;·&nbsp;934 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 零碎算法" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9B%B6%E7%A2%8E%E7%AE%97%E6%B3%95/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>分布式事务</h2></header><div class=entry-content><p>1 事务 事务可以看做是一次大的活动，它由不同的小活动组成，这些活动要么全部成功，要么全部失败。
1.1 本地事务 在计算机系统中，更多的是通过关系型数据库来控制事务，这是利用数据库本身的事务特性来实现的，因此叫数据库事务，由于应用主要靠关系数据库来控制事务，而数据库通常和应用在同一个服务器，所以基于关系型数据库的事务又被称为本地事务。
1.2 分布式事务 随着互联网的快速发展，软件系统由原来的单体应用转变为分布式应用。分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操作，这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务，例如用户注册送积分事务、创建订单减库存事务，银行转账事务等都是分布式事务。
1.3 BASE 理论 由于 CAP 理论，大型互联网应用为达到良好的响应性能来提高用户体验，一般会保证 P 和 A ，舍弃 C 强一致，保证最终一致性。
BASE 是 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent （最终一致性）三个短语的缩写。BASE 理论通过牺牲强一致性来获得可用性，当出现故障允许部分不可用但要保证核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。满足BASE理论的事务，我们称之为“柔性事务”。
基本可用：分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。如电商网站交易付款出现问题了，商品依然可以正常浏览。
软状态：由于不要求强一致性，所以BASE允许系统中存在中间状态（也叫软状态），这个状态不影响系统可用性，如订单的"支付中"、“数据同步中”等状态，待数据最终一致后状态改为“成功”状态。
最终一致：最终一致是指经过一段时间后，所有节点数据都将会达到一致。如订单的"支付中"状态，最终会变 为“支付成功”或者"支付失败"，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待。
2 分布式事务解决方案 2.1 2PC 2PC 即两阶段提交协议，是将整个事务流程分为两个阶段，准备阶段（Prepare phase）、提交阶段（commit phase），2 是指两个阶段，P 是指准备阶段，C 是指提交阶段。
整个事务过程由事务管理器和参与者组成，事务管理器负责决策整个分布式事务的提交和回滚，事务参与者负责自己本地事务的提交和回滚。
在准备阶段 事务管理器给每个参与者发送 Prepare 消息，每个数据库参与者在本地执行事务（此时本地事务不提交），并将自己的执行结果发送给事务管理器。 在提交阶段 事务管理器只要发现有任意一个数据库参与者执行失败，就会直接给每个参与者发送回滚（Rollback）消息；否则，发送提交（Commit）消息；参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的锁资源。注意：必须在最后阶段释放锁资源。 tips：Mysql 中，事务执行是指在内存中修改值；事务提交是指将 undolog 和 redolog 存储在磁盘中。事务已经提交，仍然可以回滚。
2.2 TCC TCC 是 Try、Conﬁrm、Cancel 三个词语的缩写，TCC 要求每个分支事务实现三个操作：预处理、确认 、撤销 。
Try 阶段是做完业务检查（一致性）及资源预留（隔离），此阶段仅是一个初步操作，它和后续的 Conﬁrm 一起才能真正构成一个完整的业务逻辑。 Confirm 阶段是做确认提交，Try 阶段所有分支事务执行成功后开始执行 Conﬁrm。通常情况下，采用 TCC 则认为 Conﬁrm 阶段是不会出错的。即：只要 Try 成功，Conﬁrm 一定成功。若 Conﬁrm 阶段真的出错了，需引入重试机制或人工处理。 Cancel 阶段是在业务执行错误需要回滚的状态下执行分支事务的业务取消，预留资源释放。通常情况下，采用 TCC 则认为 Cancel 阶段也是一定成功的。若 Cancel 阶段真的出错了，需引入重试机制或人工处理。 事务管理器首先发起所有的分支事务的 Try 操作，任何一个分支事务的Try操作执行失败，事务管理器将会发起所有分支事务的 Cancel 操作，若 Try 操作全部成功，事务管理器将会发起所有分支事务的 Conﬁrm 操作，其中 Conﬁrm/Cancel 操作若执行失败，事务管理器会进行重试。
...</p></div><footer class=entry-footer><span title='2022-05-19 17:42:15 +0000 UTC'>2022-05-19</span>&nbsp;·&nbsp;130 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 分布式事务" href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MySQL默认数据库</h2></header><div class=entry-content><p>Mysql系统默认数据库 information_schema performance_schema mysql sys 一、information_schema（信息概要） 保存了MySQl服务所有数据库的信息。 具体MySQL服务有多少个数据库，各个数据库有哪些表，各个表中的字段是什么数据类型，各个表中有哪些索引，各个数据库要什么权限才能访问。 二、performance_schema（性能概要） 主要用于收集数据库服务器性能参数。5.7后默认开启。 提供进程等待的详细信息，包括锁、互斥变量、文件信息； 保存历史的事件汇总信息，为提供MySQL服务器性能做出详细的判断； 三、mysql（核心数据库） 保存MySQL的用户、权限设置、关键字等 如哪些user可以访问这个数据、DB参数、插件、主从 四、Sys（系统表） Sys库所有的数据源来自：performance_schema。目标是把performance_schema的把复杂度降低，让DBA能更好的阅读这个库里的内容。让DBA更快的了解DB的运行情况。</p></div><footer class=entry-footer><span title='2022-05-17 17:39:41 +0000 UTC'>2022-05-17</span>&nbsp;·&nbsp;17 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to MySQL默认数据库" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E5%BA%93/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ZAB协议</h2></header><div class=entry-content><p>1、ZAB协议介绍 Zookeeper Atomic Broadcast，是 Zookeeper 专门设计的一种支持崩溃恢复的原子广播协议。用来实现分布式数据一致性。包含两种基本模式，分别是 崩溃恢复、原子广播。
当整个集群在启动时，或当leader 节点崩溃时，ZAB协议就会进入恢复模式并选举产生新的leader，当leader选举出来后，并且集群中有过半机器和该leader节点完成数据同步后，ZAB协议就会退出恢复模式进入消息广播模式。
2、崩溃恢复 崩溃恢复阶段的任务主要为 Leader 选举和数据同步。
1、选举基本原则 选举投票必须在同一轮次中进行 事务ID 大的节点优先成为 Leader 服务器ID大的节点优先成为 Leader 2、相关参数 SID：服务器ID ZXID：事务ID。在集群范围内全局唯一单调递增，是一个64位的数字，高 32 位是Epoch，低 32 位是单调递增的计数器。每次选举会使 Epoch 加 1，每个写操作会使计数器加1，由于写操作全部由Leader执行，故Leader 节点总是保持着最大的事务 ID，然后根据一致性协议向 Flower 同步数据。由于各 Flower 与 Leader 通信的时差，可能某些 Flower 中保存的数据不是最新的，即各 Flower 的事务 ID 可能不同。事务ID越大说明其保存的数据越新。 Epoch：选举轮次。每个服务器都会维护一个名为logicClock的变量，用于标识当前选举的轮次。每开始一次Leader选举，服务器都会将自己存储的logicClock执行加一操作，并且投票时会附带上这个logicClock。如果其他服务器收到了一个带有旧的logicClock的投票，则会直接忽略这个投票。若一个节点中途宕机之后又连接上，由于其保存的是旧的logicClock，则其不能参与本次选举。logicClock变量只在一次Leader选举开始时执行一次递增操作，一次选举中的多轮投票并不会改变logicClock变量的值。 3、节点状态 LOOKING：正在选举。在选举阶段集群不能对外提供服务。 FOLLOWING：跟随者状态。 LEADING：领导者状态。 OBSERVING：观察者状态。 4、选举流程 自增选举轮次：每开始一次新的选举，节点先将自己的logicClock加 1，并且投票时会附带上这个logicClock。 初始化选票：每个服务器在广播自己的选票前，会将自己的投票箱清空。投票箱记录了所收到的选票。票箱中只会记录每一个投票者的最新的选票。实际上投票箱是一个 Map，节点 id 为键，选票为值，如果收到某个节点的新选票，更新该 Map 即可。 发送选票：节点给自己投票，将投给自己的选票放入投票箱，然后广播该选票，用于与其它节点交换选票信息。 接收其他节点广播的选票：对于接收到的其他节点的选票进行logicClock的校验 如果收到的选票中的logicClock大于自己的logicClock，则清空自己的投票箱，并更新自己的logicClock，然后进行步骤5 如果收到的选票中的logicClock小于自己的logicClock，直接丢弃 如果收到的选票中的logicClock等于自己的logicClock，进行步骤5 选票比较：首先比较 ZXID，如果收到的选票中的 ZXID 较大，则更新自己的选票。如果 ZXID 一致，则比较 SID，如果收到的选票中的 SID较大，则更新自己的选票。将收到的选票存入投票箱。 再次发送选票：进过步骤 5 的选票比较，如果自己的选票需要改变，则修改自己的选票并更新到投票箱，然后再次广播出去。 统计选票：统计自己的投票箱，如果超过半数的节点投票一致，则终止投票。否则继续接收其他节点的投票。 更新节点状态：若过半的票投给了自己，则将自己的服务器状态更新为LEADING，否则将自己的状态更新为FOLLOWING。 6、选举时机 当集群第一次启动时会发起一次选举；当 Leader 崩溃后会发起一次选举。
...</p></div><footer class=entry-footer><span title='2022-05-08 19:42:15 +0000 UTC'>2022-05-08</span>&nbsp;·&nbsp;361 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to ZAB协议" href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zab%E5%8D%8F%E8%AE%AE/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://ethereal-lu.github.io/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://ethereal-lu.github.io/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>