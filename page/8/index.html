<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.140.1"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>lu</title>
<meta name=description content><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://ethereal-lu.github.io/index.xml><link rel=alternate type=application/json href=https://ethereal-lu.github.io/index.json><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/"><meta property="og:site_name" content="lu"><meta property="og:title" content="lu"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="lu"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"lu","url":"https://ethereal-lu.github.io/","description":"","logo":"https://ethereal-lu.github.io/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="lu (Alt + H)">lu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SpringMVC学习笔记</h2></header><div class=entry-content><p>第一个SpringMVC项目 新建maven父项目，引入依赖：junit，spring-webmvc，servlet-api，jsp-api，jstl 新建maven子项目，添加web支持 配置web.xml，注册DispatcherServlet，如下： &lt;?xml version="1.0" encoding="UTF-8"?> &lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"> &lt;!--配置DispatcherServlet--> &lt;servlet> &lt;servlet-name>springmvc&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;!--绑定一个springmvc的配置文件： [servlet-name]-servlet.xml--> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:springmvc-servlet.xml&lt;/param-value> &lt;/init-param> &lt;!--启动级别 1， 1级表示随着服务器一起启动--> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;!-- / 匹配所有请求（不包括 .jsp)--> &lt;!-- /* 匹配所有请求（包括 .jsp)，若此处使用/*则在视图解析时会再加上.jsp，使页面名变为a.jsp.jsp从而出错--> &lt;servlet-mapping> &lt;servlet-name>springmvc&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> &lt;/web-app> 在resource下创建springmvc-servlet.xml，如下： &lt;?xml version="1.0" encoding="utf-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"> &lt;!--处理器映射器--> &lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/> &lt;!--处理器适配器--> &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"/> &lt;!--视图解析器--> &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" id="internalResourceViewResolver"> &lt;property name="prefix" value="/WEB-INF/jsp/" /> &lt;!--前缀--> &lt;property name="suffix" value=".jsp" /> &lt;!--后缀--> &lt;/bean> &lt;bean id="/hello" class="com.lu.controller.HelloController"/> &lt;/beans> java下创建Controller类 // 实现Controller接口，就是一个控制器，就会获得控制器功能：处理请求并返回一个模型与视图对象 public class HelloController implements Controller { @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { ModelAndView mv = new ModelAndView(); // 业务代码 String result = "SpringMVC"; mv.addObject("msg", result); // 视图跳转 mv.setViewName("hello"); return mv; } } WEB-INF下的jsp下创建hello.jsp，里面的body中添加${msg}即可 SpringMVC执行流程 ...</p></div><footer class=entry-footer><span title='2021-04-25 14:58:37 +0000 UTC'>2021-04-25</span>&nbsp;·&nbsp;699 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to SpringMVC学习笔记" href=https://ethereal-lu.github.io/posts/java/springmvc%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MarkDown无法显示本地图片</h2></header><div class=entry-content><p>访问控制的原因：在vscode中按ctrl+shift+p打开命令面板，输入更改预览安全设置，选中允许不安全的本地内容 本地图片不允许使用png格式（网络图片却可以），最好换为jpg格式（有可能只适用于本机） 本地图片路径不支持绝对路径，要通过../../…改为相对路径</p></div><footer class=entry-footer><span title='2021-04-21 21:08:18 +0000 UTC'>2021-04-21</span>&nbsp;·&nbsp;3 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to MarkDown无法显示本地图片" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/markdown/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Servlet学习笔记</h2></header><div class=entry-content><p>Servlet定义 Servlet是一个Java应用程序，运行在服务器端，用来处理客户端请求并作出响应的程序。
实现Servlet的主要方式 程序实现Servlet接口（很少使用） 编写类实现Servlet接口 根据业务重写service方法 到web.xml中配置Servlet程序的访问地址（基于注解时不需要） 程序继承HttpServlet类（一般使用这种） 编写类继承HttpServlet类 根据业务需要重写doGet或doPost方法 到web.xml中配置Servlet程序的访问地址（基于注解时不需要） 在IDEA中直接创建Servlet程序 实质上还是第二种方法，只是IDEA帮你做了一些通用的工作 Servlet的生命周期 执行Servlet构造器方法，该方法在初次访问时调用一次。由Servlet容器（Tomcat）创建。这说明 Servlet 是单实例的! 执行init初始化方法，该方法在初次访问时调用一次。 执行service方法，该方法在每次访问时都会调用一次。 执行destory方法，该方法在web工程停止时调用一次。 用于释放当前 Servlet 所占用的资源。 Servlet接口的架构 Servlet的域对象 概念：可以在不同Servlet之间传递数据的对象，就是域对象。通俗的讲就是这个对象本身可以存储一定范围内的所有数据，通过它就能获取和存储数据。 域对象共有的方法： getAttribute(String name) 获取对应的数据 getAttributeNames() 获取所有的key removeAttribute(String name) 移除对应的数据 setAttribute(String name, Object object) 设置数据 Servlet的三大域对象分别为ServletRequest域、HttpSession域、ServletContext域 ServletRequest： 生命周期：请求开始到请求结束 作用域：整个请求链（包括请求转发） HttpSession： 生命周期：会话开始到会话结束，服务器会为每个浏览器创建一个供其独享的Session对象，当一段时间内，session没有被使用（默认是30分钟），服务器会销毁该session。 作用域：一次会话 ServletContext： 生命周期：服务器开启到服务器关闭 作用域：整个web应用 ServletConfig类 ServletConfig类是Servlet程序的配置信息类，里面封装了一些初始化配置的信息 Servlet程序和ServletConfig对象都是由Tomcat负责创建，供我们使用。 每创建一次Servlet程序时，就创建一个ServletConfig对象。 每个ServletConfig对象都只能获取自己的Servlet的信息，不能跨域获取 重写init方法时要带上父类的init方法，如果不带上，则在使用ServletConfig相关方法时就会引发NullPointerException，这是因为父类GenericServlet的init方法中保存了ServletConfig对象，如果重写了init方法，该对象就会丢失，故而引发NullPointerException。 作用： 获取Servlet程序的别名，即servlet-name的值servletConfig.getServletName() 获取初始化参数init-paramservletConfig.getInitParameter() 获取ServletContext对象servletConfig.getServletContext() ServletContext类 ServletContext是接口，表示Servlet上下文对象 一个web工程只有一个ServletContext对象实例，在web工程启动时创建，停止时销毁 ServletContext对象是一个域对象 域对象是可以像map一样存取数据的对象，域指的是存取数据的操作范围 存数据 取数据 删除数据 Map put() get() remove() 域对象 serAttribute() getAttribute() removeAttribute() 作用： 获取web.xml中配置的上下文参数context-param: servletContext.getInitParameter() 获取当前的工程路径，格式：/工程路径: servletContext.getContextPath() 获取工程部署后在服务器硬盘上的绝对路径: servletContext.getRealPath("/")其中/在服务器解析时，表示地址为：http://ip:port/工程路径映射到IDEA为web目录 像map一样存储数据 HttpServletRequest类 作用：每次只要有请求进入Tomcat服务器，Tomcat服务器就会把请求过来的HTTP协议信息解析好封装到Request对象中，然后传递到service方法（doGet和DoPost中给我们使用，我们可以通过HttpServletRequest对象，获取到所有请求的信息。（每次请求创建一个，请求完成即销毁） 常见API： request.getRequestURI() ：获取请求的资源路径 request.getRequestURL() ：获取请求的url request.getRemoteHost() ：获取客户端ip地址 request.getHeader(String key) ：获取请求头中对应键的值 request.getMethod() ：获取请求方式 request.getParameter(String key) ：获取请求参数 request.getParameterValues(String key): 获取请求参数，用于参数值有多个时 通常在doPost方法的第一行写request.setCharacterEncoding("UTF-8");用来解决post请求的中文乱码问题 HttpServletRequest对象也是域对象。每个请求对应着唯一一个HttpServletRequest对象，而且在请求结束之前会一直存在，故在处理请求过程中可以使用request.setAttribute(String name, Object o)方法对该对象添加属性，用request.getAttribute(String name)获取该对象的属性，从而执行一些操作。 请求转发：服务器收到请求后，从一个资源转到另一个资源的操作 特点：1、浏览器地址栏没有改变。2、属于一次请求：由多个servlet资源共同完成的同一个请求，故HttpServletRequest对象的作用域涵盖请求转发过程，从而这些servlet资源可以共享该对象中的数据。3、能访问WEB-INF中的资源。4、不可以访问当前工程以外的资源。 RequestDispatcher requestDispatcher = request.getRequestDispatcher("/目的资源名称");请求转发必须以斜杠/开头，/表示http://ip:port/工程路径映射到IDEA为web目录 base标签的作用：所有的相对路径都是以base标签中的地址为参照。在没有base标签时，所有路径都以当前地址栏中的地址为参照，这在某些情况下会出错（如请求转发时，地址栏中的地址不变，但页面改变，若此页面中有相对路径，则参考基准不再是当前页面，而是地址栏的地址，从而出错）。若在页面中引入base标签，则相对路径参考基准成为base标签的路径。base标签在HTML文档的head标签内，如&lt;base herf="http://localhost:8080/project/a/b.html>。 HttpServletResponse类 作用：HttpServletResponse类和HttpServletRequest类一样，每次请求进来，Tomcat服务器都会创建一个Response对象传递给Servlet程序去使用。HttpServletRequest表示请求过来的信息，HttpServletResponse表示所有响应的信息，如果需要设置返回给客户端的信息，都可以通过HttpServletResponse对象进行设置。 输出流：HttpServletResponse类通过流将响应传递给客户端。 字节流 getOutputStream(); 常用于下载（传递）二进制数据 字符流 getWriter(); 常用于回传字符串（常用） 两个流只能互斥使用 中文乱码：HttpServletResponse响应的默认字符集为ISO-8859-1，所以会中文乱码，可以通过response.setContentType("text/html; charset=UTF-8");将服务器和浏览器的字符集以及响应头都设置为UTF-8，就能解决中文乱码问题。此方法必须在获取流对象之前调用才有效 请求重定向： 第一种方法：在下图的response1中写response.setStatus(302) 来设置响应状态码，response.setHeader("Location", "http://ip:port/工程路径/response2 来设置响应头，告知新地址。 第二种方法（推荐使用）：在下图的response1中写response.sendRedirect(http://ip:port/工程路径/response2即可。 请求重定向是两次独立的请求，只是第二次有浏览器代劳，不需要手动发起请求而已。 特点：1、浏览器地址栏发生变化。2、属于两次请求。3、前后两个servlet资源不共享request域中的数据。4、不能访问WEB-INF中的资源。5、可以访问当前工程以外的资源。
web中 / 的不同含义 在web中 / 斜杠是一种绝对路径 / 斜杠如果被浏览器解析，得到地址为：http://ip:port/，如html中的&lt;a href="/">斜杠&lt;/a> / 斜杠如果被服务器解析，得到地址为：http://ip:port/工程路径，如 &lt;url-pattern>/hello&lt;/url-pattern> 、 servletContext.getRealPath("/") 、 request.getRequestDispatcher("/") 特殊情况：response.sendRediect("/");重定向，会将 / 斜杠发送给浏览器解析，得到http://ip:port/ 基于xml的方式 Servlet中web.xml的配置 &lt;?xml version="1.0" encoding="UTF-8"?> &lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"> &lt;!--servlet标签给Tomcat配置Servlet程序--> &lt;servlet> &lt;!--servlet-name标签：给Servlet程序起一个别名（一般是类名）--> &lt;servlet-name>HiServlet&lt;/servlet-name> &lt;!--servlet-class是Servlet程序的全类名--> &lt;servlet-class>com.example.tomcat.HiServlet&lt;/servlet-class> &lt;/servlet> &lt;!--servlet-mapping标签给Servlet程序配置访问地址--> &lt;servlet-mapping> &lt;!--servlet-name标签告诉服务器，我当前配置的地址给哪个Servlet程序使用--> &lt;servlet-name>HiServlet&lt;/servlet-name> &lt;!--url-pattern标签配置访问地址 / 斜杠在服务器解析时，表示地址为：http://ip:port/工程路径 本工程即为http://localhost:8080/tomcat_war_exploded/ /hello 表示：http://ip:port/工程路径/hello 即http://localhost:8080/tomcat_war_exploded/hello --> &lt;url-pattern>/hello&lt;/url-pattern> &lt;/servlet-mapping> &lt;/web-app> 从url定位到Servlet程序过程 对照上方的xml配置文件：当在地址栏输入http://localhost:8080/tomcat_war_exploded/hello时，由8080定位到Tomcat服务器，再由/tomcat_war_exploded定位到该工程，然后根据/hello定位到xml配置文件中&lt;servlet-mapping>标签下的&lt;url-pattern>标签，其对应的&lt;servlet-name>标签值为HiServlet，再根据这个标识符找到相同名的&lt;servlet>标签，根据其标签下&lt;servlet-class>的值定位到类的位置，然后执行类中的service方法。
...</p></div><footer class=entry-footer><span title='2021-04-21 18:48:13 +0000 UTC'>2021-04-21</span>&nbsp;·&nbsp;243 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Servlet学习笔记" href=https://ethereal-lu.github.io/posts/java/servlet%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>tomcat笔记</h2></header><div class=entry-content><p>将工程部署到tomcat中 直接将工程拖拽到tomcat的webapps目录下即可访问 在tomcat中的conf\Catalina\localhost下添加配置文件来配置工程，此时工程可以存放于机器的任何位置 配置文件的示例如下 &lt;Context path="/github_blog" docBase=“E:\programme_work\vscode_work\GitHubSite\public”/> 其中，Context表示一个工程上下文
path表示工程的访问路径。是该文件的映射，即在url中输入 http://localhost:8080/github_blog/，就会进入这个工程。
docBase表示工程目录的实际位置 一个配置文件对应于一个工程</p></div><footer class=entry-footer><span title='2021-04-20 20:39:32 +0000 UTC'>2021-04-20</span>&nbsp;·&nbsp;12 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to tomcat笔记" href=https://ethereal-lu.github.io/posts/java/tomcat%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>hexo的常见问题</h2></header><div class=entry-content><p>hexo的分类问题 在每个markdown文件的头部，date的下一行添加一行
categories: 类别1 即可将该文件归类为 “类别1” 这一类中
hexo无法显示图片问题 确认根目录_config.yml中有: post_asset_folder: true 确保在md文件所在目录下创建和md文件同名的目录，在里面放该md需要的图片，然后在md中插入![](文件名.jpg) 只需写图片文件名，不用写目录名 如果还不行，在站点根目录下先执行npm uninstall hexo-asset-image --save（如果之前下载过）。再执行npm install hexo-asset-image --save Chrome浏览器图片显示正常，而Edge浏览器无法显示，有可能是Egde不支持，故使用Chrome就可以了</p></div><footer class=entry-footer><span title='2021-04-20 20:07:32 +0000 UTC'>2021-04-20</span>&nbsp;·&nbsp;21 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to hexo的常见问题" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/hexo/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Tomcat启动一闪而过以及报java.lang.IllegalStateException: 无输出目录以及乱码</h2></header><div class=entry-content><p>黑屏一闪而过 问题：环境变量中没有JAVA_HOME变量。
解决：添加该变量，值为jdk的根目录，例如 D:\java\jdk
报java.lang.IllegalStateException: 无输出目录 问题：Tomcat文件的权限不够，导致不能正常编译。
解决：将Tomcat文件的权限提升为完全控制
乱码 问题：编码格式的问题 解决：将tomcat下的conf\logging.properties中的java.util.logging.ConsoleHandler.encoding的值从UTF-8修改为GBK</p></div><footer class=entry-footer><span title='2021-04-20 17:20:53 +0000 UTC'>2021-04-20</span>&nbsp;·&nbsp;11 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Tomcat启动一闪而过以及报java.lang.IllegalStateException: 无输出目录以及乱码" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/tomcat/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Spring5学习笔记</h2></header><div class=entry-content><p>IOC： 控制反转，把创建对象的过程交给Spring进行管理 Aop： 面向切片，不修改源代码进行功能增强
Spring5入门案例基本步骤： 1、创建项目 2、在项目中创建一个lib文件夹，把需要的jar包复制进来 3、点击 file -> project structure -> modules -> dependencies -> 左下角的 + 号 -> jars or directories -> 选中刚复制过来的jar包，将导入的jar包全选，点击ok 4、创建普通类User 5、创建Spring配置文件，在配置文件配置创建的对象在src中创建xml格式的Spring配置文件， 在&lt;beans>的内部末尾添加 &lt;!–配置User对象创建–> &lt;bean id=“user” class=“com.ethereal.spring5.User”>&lt;/bean> 两行
6、进行测试代码编写
public class TestSpring5 { @Test public void testAdd() { // 加载spring配置文件 ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml"); // 获取配置创建的对象 User user = context.getBean("user", User.class); System.out.println(user); user.add(); } } IOC容器： (Inversion of Control) 控制反转，把创建对象和对象之间调用的过程交给Spring进行管理 1、IOC底层原理 xml解析 + 反射 + 工厂模式 （降低耦合度）
...</p></div><footer class=entry-footer><span title='2021-04-20 15:39:41 +0000 UTC'>2021-04-20</span>&nbsp;·&nbsp;578 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Spring5学习笔记" href=https://ethereal-lu.github.io/posts/java/spring5%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go 基础</h2></header><div class=entry-content><p>1、基础 包含有 main 函数的包，其包名必须是 main。包名与文件名没有任何关系。但在只包含一个main函数的项目中，一般文件名与包名一致
go 语句的末尾加不加分号都可以，建议不加
导包时推荐使用第二种
// 1 import "fmt" import "time" // 2 import ( "fmt" "time" ) 函数体前的大括号必须与函数名在同一行，否则报错 func main() { fmt.Println("hello go") } 同样 if else 中的 else 必须与 if 的末尾大括号在同一行，否则报错 if arr == nil { fmt.Println("空切片") } else { fmt.Println("非空") } 2、变量 2.1、变量声明 方法一二三既可以用于局部变量也可以用于全局变量，而方法四只能在函数体内用于局部变量
// 方法一：只声明，不显式赋值，默认值为0 var a int fmt.Println(a) // 0 // 方法二：声明并显式初始化 var b int = 100 fmt.Println(b) // 100 // 方法三：初始化时省去数据类型，自动推导 var c = "abc" fmt.Println(c) // "abc" // 方法四：省去 var 关键字，直接使用海象运算符类型推导（常用这种），表示声明并初始化 d := 4.5 fmt.Println(d) // 4.5 fmt.Printf("type of d is %T\n", d) // 格式化打印，%T 表示打印变量类型；此处输出为 float64 2.2、多个变量的声明 var aa, bb = 100, 200 var cc, dd = 4.5, "abc" // 或者下面这种写法 var ( ee = 300 ff = true ) // 也可以这样 gg, hh := 3, true 3、常量与枚举 func main() { // 常量（只读） const length = 10 fmt.Println(length) } // const 定义枚举类型 const ( // 在第一个枚举成员后赋值关键字 iota，之后的每行的成员的值自动加 1 SPRING = iota // iota 为常量 0 SUMMER // 1 AUTUMN // 2 WINTER // 3 ) const ( // 也可以赋值 iota 的表达式，此时之后的成员都会在 iota 加一的基础上赋值表达式 SPRING = iota * 10 // 0 SUMMER // 10 AUTUMN // 20 WINTER // 30 ) // iota 逐行累加；iota 只能出现在 const 的括号中 const ( a, b = iota + 1, iota + 2 // iota = 0; a = 1; b = 2 c, d // iota = 1; c = 2; d = 3 e, f // iota = 2; e = 3; f = 4 g, h = iota * 2, iota * 3 // iota = 3; g = 6; h = 9 i, k // iota = 4; i = 8; k = 12 ) 4、函数 若函数名首字母大写，表示 public；小写，表示 private
...</p></div><footer class=entry-footer><span title='2021-01-02 17:39:41 +0000 UTC'>2021-01-02</span>&nbsp;·&nbsp;2306 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Go 基础" href=https://ethereal-lu.github.io/posts/go/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://ethereal-lu.github.io/page/7/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>