<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.140.1"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>lu</title>
<meta name=description content><meta name=author content="lu"><link rel=canonical href=http://localhost:1313/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity="sha256-1yREUm1+y9sAFUOKf6iQVKZYv3WdBULi5d+BzpS0k+4=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=http://localhost:1313/index.xml><link rel=alternate type=application/json href=http://localhost:1313/index.json><link rel=alternate hreflang=en href=http://localhost:1313/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/"><meta property="og:site_name" content="lu"><meta property="og:title" content="lu"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="lu"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"lu","url":"http://localhost:1313/","description":"","logo":"http://localhost:1313/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/categories/ title=categories><span>categories</span></a></li><li><a href=http://localhost:1313/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>mybatis学习笔记</h2></header><div class=entry-content><p>第一个MyBatis项目 先进入mysql创建mybatis数据库，并在其中创建user表，其中有字段值如实体类User中的属性 新建一个Maven项目，作为父项目，在其pom.xml配置文件中引入依赖（mysql驱动、junit、mybatis）。则其子模块中都继承了这些依赖。 在父项目下新建一个Maven子模块，在其main目录的resources下新建文件mybatis-config.xml作为配置文件，内容如下： &lt;?xml version="1.0" encoding="UTF-8" ?> &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"> &lt;!--核心配置文件--> &lt;configuration> &lt;!--下方这一句为引入外部属性文件，需在resources下创建jdbc.properties文件 也可以不引入外部属性文件而直接对4个value赋值--> &lt;properties resource="jdbc.properties"/> &lt;environments default="development"> &lt;environment id="development"> &lt;transactionManager type="JDBC"/> &lt;dataSource type="POOLED"> &lt;!--只需为下面四项赋值即可--> &lt;property name="driver" value="${jdbc.driveClass}"/> &lt;property name="url" value="${jdbc.url}"/> &lt;property name="username" value="${jdbc.username}"/> &lt;property name="password" value="${jdbc.password}"/> &lt;/dataSource> &lt;/environment> &lt;/environments> &lt;!--每一个sql映射文件Mapper.xml都需要在Mybatis的核心配置文件中的&lt;mappers>标签下注册， 否则就会报错Type interface com.lu.dao.UserDao is not known to the MapperRegistry.--> &lt;mappers> &lt;!--如果Mapper.xml在resources目录下，则直接写文件名即可，若在其他路径，则要写全路径，用/分割目录--> &lt;mapper resource="UserMapper.xml"/> &lt;/mappers> &lt;/configuration> jdbc.properties文件如下：其中jdbc.url字段特别容易引发错误
jdbc.driveClass=com.mysql.cj.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai jdbc.userName=root jdbc.password=gaolu666 创建获取sqlSession对象的工具类（类中代码如下）。 // sqlSessionFactory --> SqlSession public class MybatisUtils { private static final SqlSessionFactory sqlSessionFactory; // 用Mybatis的配置文件获取sqlSessionFactory对象 static { String resource = "mybatis-config.xml"; InputStream inputStream = null; try { inputStream = Resources.getResourceAsStream(resource); } catch (IOException e) { e.printStackTrace(); } sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } // 用sqlSessionFactory对象获取SqlSession对象 public static SqlSession getSqlSession() { return sqlSessionFactory.openSession(); } } 实现。创建实体类、UserDao接口以及Mapper配置文件UserMapper.xml（该文件代替JDBC中的UserDaoImpl实现类，但是仍然可以将该文件理解为UserDao的实现类），分别如下：【实体类要实现序列化接口】 // 实体类 public class User implements Serializable { private int id; private String name; private String passwd; ... // 省略部分为有参无参构造，getter、setter方法 } // UserDao接口 public interface UserDao { List&lt;User> getUserList(); // 根据ID查询用户 User getUserById(int id); // 添加用户 void addUser(User user); // 修改用户 void updateUser(User user); // 删除用户 void deleteUser(int id); } &lt;!--sql映射文件UserMapper.xml--> &lt;?xml version="1.0" encoding="UTF-8" ?> &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"> &lt;mapper namespace="com.lu.dao.UserDao"> &lt;!--namespace绑定一个Mapper（Dao）接口--> &lt;!--id对应绑定的接口中的一个方法名，resultType为返回值， 当该方法的返回值为集合时resultType对应集合泛型中的类的全路径--> &lt;select id="getUserList" resultType="com.lu.pojo.User"> select * from user &lt;/select> &lt;!--parameterType对应参数类型，当方法的参数只有一个，且参数类型为基本类型时，可以不写parameterType这一项， 方法参数有多个时，用map或注解--> &lt;select id="getUserById" parameterType="int" resultType="com.lu.pojo.User"> select * from user where id = #{id} /*此处#{id}接收getUserById方法的参数，因此名称与参数名一致*/ &lt;/select> &lt;insert id="addUser" parameterType="com.lu.pojo.User"> /*此处#{id}, #{name}, #{passwd}自动接收User类中的属性，因此名字与三个属性名一致*/ insert into user (id, name, passwd) values (#{id}, #{name}, #{passwd}) &lt;/insert> &lt;update id="updateUser" parameterType="com.lu.pojo.User"> update user set name = #{name}, passwd = #{passwd} where id = #{id} /*修改多个参数中间用逗号隔开不要忘*/ &lt;/update> &lt;delete id="deleteUser" parameterType="int"> delete from user where id = #{id} &lt;/delete> &lt;/mapper> 测试，代码如下： public class UserDaoTest { @Test public void getUserListTest() { // 第一步：获取sqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); // 第二部：getMapper UserDao mapper = sqlSession.getMapper(UserDao.class); // 第三步：执行sql for (User user: mapper.getUserList()) System.out.println(user); // 第四步：关闭连接 sqlSession.close(); // 注意事项：增删改操作必须要提交事务 --> sqlSession.commit(); } } map的使用（野路子，增加灵活性但不利于维护） 使用场景：当表中的字段过多，而只需要更新少量字段时，不需要像上方一样，传入一个带全部字段的新对象，而只需要利用map传递需要的字段即可。同样在添加操作时，也可以在map中只存放notnull的字段，对于允许null的字段，可以不添加。示例如下： &lt;update id="updateUser2" parameterType="map"> /*上方参数类型map即表示Map类型，下方的#{key_name}和#{key_id}接收map中的值，故名称与map中的键名一致*/ update user set name = #{key_name} where id = #{key_id} &lt;/update> 配置解析 核心配置文件mybatis-config.xml environments environments标签下可以有多套环境，但同时最多只能使用一套（即互斥使用），修改default的值即可切换环境 transactionManager标签即事务管理器，只需知道除了JDBC还有一个MANAGED即可 dataSource即数据源，type的值默认为POOLED即使用连接池，只需知道type不止这一个值即可 properties properties标签即引入外部属性文件 properties标签必须位于configuration标签下的第一行 properties标签下也可以添加propertie标签，并优先读取propertie标签内的值，然后读取外部文件，并覆盖同名键 typeAliases typeAliases即类型别名，为java类型设置一个短的名字，用于减少类完全限定名（类的全路径）的冗余 类型别名有两种实现方式，一种为typeAlias，即为每一个类自定义一个别名，另一种为package，它指定一个包，将包下所有类的别名设定为类名的首字母小写（其实大写也可以用，但建议小写），如下：（当实体类少时用第一种，实体类多时用第二种） &lt;typeAliases> &lt;typeAlias type="com.lu.pojo.User" alias="User"/> &lt;package name="com.lu.pojo"/> &lt;/typeAliases> settings logImpl：设置日志 cacheEnabled：缓存 lazyLoadingEnabled：懒加载 mappers 一般会将操作数据库的接口与其同名sql映射文件mapper.xml放在同一个包下，但这样还需另外设置过滤操作。也可以在resources目录下创建与接口所在目录的同名目录，然后将sql映射文件放入该目录中，这样在编译后接口与映射文件就在同一个包下了。 生命周期与作用域 错误的使用可能会导致严重的并发问题
...</p></div><footer class=entry-footer><span title='2021-04-26 19:42:15 +0000 UTC'>2021-04-26</span>&nbsp;·&nbsp;976 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to mybatis学习笔记" href=http://localhost:1313/posts/java/mybatis%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SpringMVC学习笔记</h2></header><div class=entry-content><p>第一个SpringMVC项目 新建maven父项目，引入依赖：junit，spring-webmvc，servlet-api，jsp-api，jstl 新建maven子项目，添加web支持 配置web.xml，注册DispatcherServlet，如下： &lt;?xml version="1.0" encoding="UTF-8"?> &lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"> &lt;!--配置DispatcherServlet--> &lt;servlet> &lt;servlet-name>springmvc&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;!--绑定一个springmvc的配置文件： [servlet-name]-servlet.xml--> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:springmvc-servlet.xml&lt;/param-value> &lt;/init-param> &lt;!--启动级别 1， 1级表示随着服务器一起启动--> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;!-- / 匹配所有请求（不包括 .jsp)--> &lt;!-- /* 匹配所有请求（包括 .jsp)，若此处使用/*则在视图解析时会再加上.jsp，使页面名变为a.jsp.jsp从而出错--> &lt;servlet-mapping> &lt;servlet-name>springmvc&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> &lt;/web-app> 在resource下创建springmvc-servlet.xml，如下： &lt;?xml version="1.0" encoding="utf-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"> &lt;!--处理器映射器--> &lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/> &lt;!--处理器适配器--> &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"/> &lt;!--视图解析器--> &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" id="internalResourceViewResolver"> &lt;property name="prefix" value="/WEB-INF/jsp/" /> &lt;!--前缀--> &lt;property name="suffix" value=".jsp" /> &lt;!--后缀--> &lt;/bean> &lt;bean id="/hello" class="com.lu.controller.HelloController"/> &lt;/beans> java下创建Controller类 // 实现Controller接口，就是一个控制器，就会获得控制器功能：处理请求并返回一个模型与视图对象 public class HelloController implements Controller { @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { ModelAndView mv = new ModelAndView(); // 业务代码 String result = "SpringMVC"; mv.addObject("msg", result); // 视图跳转 mv.setViewName("hello"); return mv; } } WEB-INF下的jsp下创建hello.jsp，里面的body中添加${msg}即可 SpringMVC执行流程 ...</p></div><footer class=entry-footer><span title='2021-04-25 14:58:37 +0000 UTC'>2021-04-25</span>&nbsp;·&nbsp;699 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to SpringMVC学习笔记" href=http://localhost:1313/posts/java/springmvc%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MarkDown无法显示本地图片</h2></header><div class=entry-content><p>访问控制的原因：在vscode中按ctrl+shift+p打开命令面板，输入更改预览安全设置，选中允许不安全的本地内容 本地图片不允许使用png格式（网络图片却可以），最好换为jpg格式（有可能只适用于本机） 本地图片路径不支持绝对路径，要通过../../…改为相对路径</p></div><footer class=entry-footer><span title='2021-04-21 21:08:18 +0000 UTC'>2021-04-21</span>&nbsp;·&nbsp;3 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to MarkDown无法显示本地图片" href=http://localhost:1313/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/markdown/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Servlet学习笔记</h2></header><div class=entry-content><p>Servlet定义 Servlet是一个Java应用程序，运行在服务器端，用来处理客户端请求并作出响应的程序。
实现Servlet的主要方式 程序实现Servlet接口（很少使用） 编写类实现Servlet接口 根据业务重写service方法 到web.xml中配置Servlet程序的访问地址（基于注解时不需要） 程序继承HttpServlet类（一般使用这种） 编写类继承HttpServlet类 根据业务需要重写doGet或doPost方法 到web.xml中配置Servlet程序的访问地址（基于注解时不需要） 在IDEA中直接创建Servlet程序 实质上还是第二种方法，只是IDEA帮你做了一些通用的工作 Servlet的生命周期 执行Servlet构造器方法，该方法在初次访问时调用一次。由Servlet容器（Tomcat）创建。这说明 Servlet 是单实例的! 执行init初始化方法，该方法在初次访问时调用一次。 执行service方法，该方法在每次访问时都会调用一次。 执行destory方法，该方法在web工程停止时调用一次。 用于释放当前 Servlet 所占用的资源。 Servlet接口的架构 Servlet的域对象 概念：可以在不同Servlet之间传递数据的对象，就是域对象。通俗的讲就是这个对象本身可以存储一定范围内的所有数据，通过它就能获取和存储数据。 域对象共有的方法： getAttribute(String name) 获取对应的数据 getAttributeNames() 获取所有的key removeAttribute(String name) 移除对应的数据 setAttribute(String name, Object object) 设置数据 Servlet的三大域对象分别为ServletRequest域、HttpSession域、ServletContext域 ServletRequest： 生命周期：请求开始到请求结束 作用域：整个请求链（包括请求转发） HttpSession： 生命周期：会话开始到会话结束，服务器会为每个浏览器创建一个供其独享的Session对象，当一段时间内，session没有被使用（默认是30分钟），服务器会销毁该session。 作用域：一次会话 ServletContext： 生命周期：服务器开启到服务器关闭 作用域：整个web应用 ServletConfig类 ServletConfig类是Servlet程序的配置信息类，里面封装了一些初始化配置的信息 Servlet程序和ServletConfig对象都是由Tomcat负责创建，供我们使用。 每创建一次Servlet程序时，就创建一个ServletConfig对象。 每个ServletConfig对象都只能获取自己的Servlet的信息，不能跨域获取 重写init方法时要带上父类的init方法，如果不带上，则在使用ServletConfig相关方法时就会引发NullPointerException，这是因为父类GenericServlet的init方法中保存了ServletConfig对象，如果重写了init方法，该对象就会丢失，故而引发NullPointerException。 作用： 获取Servlet程序的别名，即servlet-name的值servletConfig.getServletName() 获取初始化参数init-paramservletConfig.getInitParameter() 获取ServletContext对象servletConfig.getServletContext() ServletContext类 ServletContext是接口，表示Servlet上下文对象 一个web工程只有一个ServletContext对象实例，在web工程启动时创建，停止时销毁 ServletContext对象是一个域对象 域对象是可以像map一样存取数据的对象，域指的是存取数据的操作范围 存数据 取数据 删除数据 Map put() get() remove() 域对象 serAttribute() getAttribute() removeAttribute() 作用： 获取web.xml中配置的上下文参数context-param: servletContext.getInitParameter() 获取当前的工程路径，格式：/工程路径: servletContext.getContextPath() 获取工程部署后在服务器硬盘上的绝对路径: servletContext.getRealPath("/")其中/在服务器解析时，表示地址为：http://ip:port/工程路径映射到IDEA为web目录 像map一样存储数据 HttpServletRequest类 作用：每次只要有请求进入Tomcat服务器，Tomcat服务器就会把请求过来的HTTP协议信息解析好封装到Request对象中，然后传递到service方法（doGet和DoPost中给我们使用，我们可以通过HttpServletRequest对象，获取到所有请求的信息。（每次请求创建一个，请求完成即销毁） 常见API： request.getRequestURI() ：获取请求的资源路径 request.getRequestURL() ：获取请求的url request.getRemoteHost() ：获取客户端ip地址 request.getHeader(String key) ：获取请求头中对应键的值 request.getMethod() ：获取请求方式 request.getParameter(String key) ：获取请求参数 request.getParameterValues(String key): 获取请求参数，用于参数值有多个时 通常在doPost方法的第一行写request.setCharacterEncoding("UTF-8");用来解决post请求的中文乱码问题 HttpServletRequest对象也是域对象。每个请求对应着唯一一个HttpServletRequest对象，而且在请求结束之前会一直存在，故在处理请求过程中可以使用request.setAttribute(String name, Object o)方法对该对象添加属性，用request.getAttribute(String name)获取该对象的属性，从而执行一些操作。 请求转发：服务器收到请求后，从一个资源转到另一个资源的操作 特点：1、浏览器地址栏没有改变。2、属于一次请求：由多个servlet资源共同完成的同一个请求，故HttpServletRequest对象的作用域涵盖请求转发过程，从而这些servlet资源可以共享该对象中的数据。3、能访问WEB-INF中的资源。4、不可以访问当前工程以外的资源。 RequestDispatcher requestDispatcher = request.getRequestDispatcher("/目的资源名称");请求转发必须以斜杠/开头，/表示http://ip:port/工程路径映射到IDEA为web目录 base标签的作用：所有的相对路径都是以base标签中的地址为参照。在没有base标签时，所有路径都以当前地址栏中的地址为参照，这在某些情况下会出错（如请求转发时，地址栏中的地址不变，但页面改变，若此页面中有相对路径，则参考基准不再是当前页面，而是地址栏的地址，从而出错）。若在页面中引入base标签，则相对路径参考基准成为base标签的路径。base标签在HTML文档的head标签内，如&lt;base herf="http://localhost:8080/project/a/b.html>。 HttpServletResponse类 作用：HttpServletResponse类和HttpServletRequest类一样，每次请求进来，Tomcat服务器都会创建一个Response对象传递给Servlet程序去使用。HttpServletRequest表示请求过来的信息，HttpServletResponse表示所有响应的信息，如果需要设置返回给客户端的信息，都可以通过HttpServletResponse对象进行设置。 输出流：HttpServletResponse类通过流将响应传递给客户端。 字节流 getOutputStream(); 常用于下载（传递）二进制数据 字符流 getWriter(); 常用于回传字符串（常用） 两个流只能互斥使用 中文乱码：HttpServletResponse响应的默认字符集为ISO-8859-1，所以会中文乱码，可以通过response.setContentType("text/html; charset=UTF-8");将服务器和浏览器的字符集以及响应头都设置为UTF-8，就能解决中文乱码问题。此方法必须在获取流对象之前调用才有效 请求重定向： 第一种方法：在下图的response1中写response.setStatus(302) 来设置响应状态码，response.setHeader("Location", "http://ip:port/工程路径/response2 来设置响应头，告知新地址。 第二种方法（推荐使用）：在下图的response1中写response.sendRedirect(http://ip:port/工程路径/response2即可。 请求重定向是两次独立的请求，只是第二次有浏览器代劳，不需要手动发起请求而已。 特点：1、浏览器地址栏发生变化。2、属于两次请求。3、前后两个servlet资源不共享request域中的数据。4、不能访问WEB-INF中的资源。5、可以访问当前工程以外的资源。
web中 / 的不同含义 在web中 / 斜杠是一种绝对路径 / 斜杠如果被浏览器解析，得到地址为：http://ip:port/，如html中的&lt;a href="/">斜杠&lt;/a> / 斜杠如果被服务器解析，得到地址为：http://ip:port/工程路径，如 &lt;url-pattern>/hello&lt;/url-pattern> 、 servletContext.getRealPath("/") 、 request.getRequestDispatcher("/") 特殊情况：response.sendRediect("/");重定向，会将 / 斜杠发送给浏览器解析，得到http://ip:port/ 基于xml的方式 Servlet中web.xml的配置 &lt;?xml version="1.0" encoding="UTF-8"?> &lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"> &lt;!--servlet标签给Tomcat配置Servlet程序--> &lt;servlet> &lt;!--servlet-name标签：给Servlet程序起一个别名（一般是类名）--> &lt;servlet-name>HiServlet&lt;/servlet-name> &lt;!--servlet-class是Servlet程序的全类名--> &lt;servlet-class>com.example.tomcat.HiServlet&lt;/servlet-class> &lt;/servlet> &lt;!--servlet-mapping标签给Servlet程序配置访问地址--> &lt;servlet-mapping> &lt;!--servlet-name标签告诉服务器，我当前配置的地址给哪个Servlet程序使用--> &lt;servlet-name>HiServlet&lt;/servlet-name> &lt;!--url-pattern标签配置访问地址 / 斜杠在服务器解析时，表示地址为：http://ip:port/工程路径 本工程即为http://localhost:8080/tomcat_war_exploded/ /hello 表示：http://ip:port/工程路径/hello 即http://localhost:8080/tomcat_war_exploded/hello --> &lt;url-pattern>/hello&lt;/url-pattern> &lt;/servlet-mapping> &lt;/web-app> 从url定位到Servlet程序过程 对照上方的xml配置文件：当在地址栏输入http://localhost:8080/tomcat_war_exploded/hello时，由8080定位到Tomcat服务器，再由/tomcat_war_exploded定位到该工程，然后根据/hello定位到xml配置文件中&lt;servlet-mapping>标签下的&lt;url-pattern>标签，其对应的&lt;servlet-name>标签值为HiServlet，再根据这个标识符找到相同名的&lt;servlet>标签，根据其标签下&lt;servlet-class>的值定位到类的位置，然后执行类中的service方法。
...</p></div><footer class=entry-footer><span title='2021-04-21 18:48:13 +0000 UTC'>2021-04-21</span>&nbsp;·&nbsp;243 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Servlet学习笔记" href=http://localhost:1313/posts/java/servlet%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>tomcat笔记</h2></header><div class=entry-content><p>将工程部署到tomcat中 直接将工程拖拽到tomcat的webapps目录下即可访问 在tomcat中的conf\Catalina\localhost下添加配置文件来配置工程，此时工程可以存放于机器的任何位置 配置文件的示例如下 &lt;Context path="/github_blog" docBase=“E:\programme_work\vscode_work\GitHubSite\public”/> 其中，Context表示一个工程上下文
path表示工程的访问路径。是该文件的映射，即在url中输入 http://localhost:8080/github_blog/，就会进入这个工程。
docBase表示工程目录的实际位置 一个配置文件对应于一个工程</p></div><footer class=entry-footer><span title='2021-04-20 20:39:32 +0000 UTC'>2021-04-20</span>&nbsp;·&nbsp;12 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to tomcat笔记" href=http://localhost:1313/posts/java/tomcat%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>hexo的常见问题</h2></header><div class=entry-content><p>hexo的分类问题 在每个markdown文件的头部，date的下一行添加一行
categories: 类别1 即可将该文件归类为 “类别1” 这一类中
hexo无法显示图片问题 确认根目录_config.yml中有: post_asset_folder: true 确保在md文件所在目录下创建和md文件同名的目录，在里面放该md需要的图片，然后在md中插入![](文件名.jpg) 只需写图片文件名，不用写目录名 如果还不行，在站点根目录下先执行npm uninstall hexo-asset-image --save（如果之前下载过）。再执行npm install hexo-asset-image --save Chrome浏览器图片显示正常，而Edge浏览器无法显示，有可能是Egde不支持，故使用Chrome就可以了</p></div><footer class=entry-footer><span title='2021-04-20 20:07:32 +0000 UTC'>2021-04-20</span>&nbsp;·&nbsp;21 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to hexo的常见问题" href=http://localhost:1313/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/hexo/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Tomcat启动一闪而过以及报java.lang.IllegalStateException: 无输出目录以及乱码</h2></header><div class=entry-content><p>黑屏一闪而过 问题：环境变量中没有JAVA_HOME变量。
解决：添加该变量，值为jdk的根目录，例如 D:\java\jdk
报java.lang.IllegalStateException: 无输出目录 问题：Tomcat文件的权限不够，导致不能正常编译。
解决：将Tomcat文件的权限提升为完全控制
乱码 问题：编码格式的问题 解决：将tomcat下的conf\logging.properties中的java.util.logging.ConsoleHandler.encoding的值从UTF-8修改为GBK</p></div><footer class=entry-footer><span title='2021-04-20 17:20:53 +0000 UTC'>2021-04-20</span>&nbsp;·&nbsp;11 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Tomcat启动一闪而过以及报java.lang.IllegalStateException: 无输出目录以及乱码" href=http://localhost:1313/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/tomcat/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Spring5学习笔记</h2></header><div class=entry-content><p>IOC： 控制反转，把创建对象的过程交给Spring进行管理 Aop： 面向切片，不修改源代码进行功能增强
Spring5入门案例基本步骤： 1、创建项目 2、在项目中创建一个lib文件夹，把需要的jar包复制进来 3、点击 file -> project structure -> modules -> dependencies -> 左下角的 + 号 -> jars or directories -> 选中刚复制过来的jar包，将导入的jar包全选，点击ok 4、创建普通类User 5、创建Spring配置文件，在配置文件配置创建的对象在src中创建xml格式的Spring配置文件， 在&lt;beans>的内部末尾添加 &lt;!–配置User对象创建–> &lt;bean id=“user” class=“com.ethereal.spring5.User”>&lt;/bean> 两行
6、进行测试代码编写
public class TestSpring5 { @Test public void testAdd() { // 加载spring配置文件 ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml"); // 获取配置创建的对象 User user = context.getBean("user", User.class); System.out.println(user); user.add(); } } IOC容器： (Inversion of Control) 控制反转，把创建对象和对象之间调用的过程交给Spring进行管理 1、IOC底层原理 xml解析 + 反射 + 工厂模式 （降低耦合度）
...</p></div><footer class=entry-footer><span title='2021-04-20 15:39:41 +0000 UTC'>2021-04-20</span>&nbsp;·&nbsp;578 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Spring5学习笔记" href=http://localhost:1313/posts/java/spring5%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go 基础</h2></header><div class=entry-content><p>1、基础 包含有 main 函数的包，其包名必须是 main。包名与文件名没有任何关系。但在只包含一个main函数的项目中，一般文件名与包名一致
go 语句的末尾加不加分号都可以，建议不加
导包时推荐使用第二种
// 1 import "fmt" import "time" // 2 import ( "fmt" "time" ) 函数体前的大括号必须与函数名在同一行，否则报错 func main() { fmt.Println("hello go") } 同样 if else 中的 else 必须与 if 的末尾大括号在同一行，否则报错 if arr == nil { fmt.Println("空切片") } else { fmt.Println("非空") } 2、变量 2.1、变量声明 方法一二三既可以用于局部变量也可以用于全局变量，而方法四只能在函数体内用于局部变量
// 方法一：只声明，不显式赋值，默认值为0 var a int fmt.Println(a) // 0 // 方法二：声明并显式初始化 var b int = 100 fmt.Println(b) // 100 // 方法三：初始化时省去数据类型，自动推导 var c = "abc" fmt.Println(c) // "abc" // 方法四：省去 var 关键字，直接使用海象运算符类型推导（常用这种），表示声明并初始化 d := 4.5 fmt.Println(d) // 4.5 fmt.Printf("type of d is %T\n", d) // 格式化打印，%T 表示打印变量类型；此处输出为 float64 2.2、多个变量的声明 var aa, bb = 100, 200 var cc, dd = 4.5, "abc" // 或者下面这种写法 var ( ee = 300 ff = true ) // 也可以这样 gg, hh := 3, true 3、常量与枚举 func main() { // 常量（只读） const length = 10 fmt.Println(length) } // const 定义枚举类型 const ( // 在第一个枚举成员后赋值关键字 iota，之后的每行的成员的值自动加 1 SPRING = iota // iota 为常量 0 SUMMER // 1 AUTUMN // 2 WINTER // 3 ) const ( // 也可以赋值 iota 的表达式，此时之后的成员都会在 iota 加一的基础上赋值表达式 SPRING = iota * 10 // 0 SUMMER // 10 AUTUMN // 20 WINTER // 30 ) // iota 逐行累加；iota 只能出现在 const 的括号中 const ( a, b = iota + 1, iota + 2 // iota = 0; a = 1; b = 2 c, d // iota = 1; c = 2; d = 3 e, f // iota = 2; e = 3; f = 4 g, h = iota * 2, iota * 3 // iota = 3; g = 6; h = 9 i, k // iota = 4; i = 8; k = 12 ) 4、函数 若函数名首字母大写，表示 public；小写，表示 private
...</p></div><footer class=entry-footer><span title='2021-01-02 17:39:41 +0000 UTC'>2021-01-02</span>&nbsp;·&nbsp;2306 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Go 基础" href=http://localhost:1313/posts/go/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>&lt;!DOCTYPE html>
plt_quickStart
In [1]:
import matplotlib.pyplot as plt
import numpy as np
In [2]:
fig = plt.figure() # an empty figure with no Axes
fig, ax = plt.subplots() # a figure with a single Axes
fig, axs = plt.subplots(2, 2) # a figure with a 2x2 grid of Axes
&lt;Figure size 432x288 with 0 Axes>
In [3]:
ax.plot([1, 2, 3, 4], [1, 4, 2, 3]) # Plot some data on the axes.
Out[3]:
[&lt;matplotlib.lines.Line2D at 0x1b040657310>]
In [4]:
x = np.linspace(0, 2, 100)
# Note that even in the OO-style, we use `.pyplot.figure` to create the figure.
fig, ax = plt.subplots() # Create a figure and an axes.
ax.plot(x, x, label='linear') # Plot some data on the axes.
ax.plot(x, x**2, label='quadratic') # Plot more data on the axes...
ax.plot(x, x**3, label='cubic') # ... and some more.
ax.set_xlabel('x label') # Add an x-label to the axes.
ax.set_ylabel('y label') # Add a y-label to the axes.
ax.set_title("Simple Plot") # Add a title to the axes.
ax.legend() # Add a legend.
Out[4]:
&lt;matplotlib.legend.Legend at 0x1b042839b80>
In [5]:
plt.ion() # 开启交互模式，即输入命令后会直接将图形展示出来
plt.ioff() # 关闭交互模式，即输入命令后不会直接将图形展示出来，需要输入plt.show()才会展示图形
In [6]:
# 以上介绍的是面向对象的使用方法，但是更常用的是 pyplot API 方法，如下：
In [7]:
import matplotlib.pyplot as plt
plt.plot([1, 2, 3, 4]) # x轴默认为 lan(y)，从0开始
plt.ylabel('some numbers')
plt.show()
In [8]:
plt.plot([1, 2, 3, 4], [1, 4, 9, 16]) # 用 plt.plot 即可直接创建图形，无需先创建画布 fig, ax = plt.subplots()
Out[8]:
[&lt;matplotlib.lines.Line2D at 0x1b042941550>]
In [9]:
plt.plot([1, 2, 3, 4], [1, 4, 9, 16], 'ro') # 其余参数可以指定线形和颜色、默认为蓝实线。此处指定为红色圆圈
plt.axis([0, 6, 0, 20]) # [xmin, xmax, ymin, ymax] 指定 x 轴和 y 轴的范围
plt.show()
In [10]:
# evenly sampled time at 200ms intervals
t = np.arange(0., 5., 0.2)
# red dashes, blue squares and green triangles
plt.plot(t, t, 'r--', t, t**2, 'bs', t, t**3, 'g^')
plt.show()
In [15]:
data = {'a': np.arange(50),
'c': np.random.randint(0, 50, 50),
'd': np.random.randn(50)}
data['b'] = data['a'] + 10 * np.random.randn(50)
data['d'] = np.abs(data['d']) * 100
# matplotlib.pyplot.scatter(x, y, s=None, c=None, marker=None, data=None, ....) # 该函数用于绘制散点图，x 和 y 为坐标（长度需相等）；c控制颜色，一般传入与xy等长的数组为每个点指定不同颜色，易于区分。
# s控制点的大小，本例s传入一个数组，使每个点的大小不同，更美观。marker控制点的形状。
plt.scatter('a', 'b', c='c', s='d',marker='o', data=data)
plt.xlabel('entry a')
plt.ylabel('entry b')
plt.show()
In [16]:
names = ['group_a', 'group_b', 'group_c']
values = [1, 10, 100]
plt.figure(figsize=(9, 3)) # 新建画布，宽 9 ，高 3
# 拆分子画布，plt.subplot(nrows, ncols, index) index指向当前画布（可以是元组，包含多个子画布） plt.subplot(131) 等同于plt.subplot(1，3，1) plt.subplot(131) plt.bar(names, values) # 条形图
plt.subplot(132)
plt.scatter(names, values) # 散点图
plt.subplot(133)
plt.plot(names, values) # 普通折线图
plt.suptitle('Categorical Plotting')
plt.show()
In [17]:
x = np.arange(50)
y = x + 10 * np.random.randn(50)
plt.plot(x, y, linewidth=2.0) # 通过关键字的方法 设置线宽
Out[17]:
[&lt;matplotlib.lines.Line2D at 0x1b042cbf160>]
In [18]:
# 关于python的返回值解包：
# 普通函数若返回一个值，则不会包装就是返回值本身；若返回多个值，当用一个变量接受时会封装为一个元组
# 当用相等个数变量接收时就是对应的值本身，这就是解包装
# 如下方函数 plt.plot 返回的是一个手动封装好的列表，则 # line = plt.plot(x, y, '-') ，line为一个列表（列表中只有一个元素）
# line, = plt.plot(x, y, '-')，line就是列表中的第一个元素。line后的逗号就解包装的提示
# 类似 line1，line2 = plt.plot(x1, y1, x2, y2) 也是解包装
line, = plt.plot(x, y, '-') # plt.plot 返回由图形对象组成的列表
line.set_antialiased(False) # 通过 获得图形对象，并对其用set方法关闭抗锯齿
In [20]:
# 用setp方法也能设置图形的属性
lines = plt.plot(x, y)
# use keyword args
plt.setp(lines, color='r', linewidth=2.0)
# or MATLAB style string value pairs
plt.setp(lines, 'color', 'r', 'linewidth', 2.0)
Out[20]:
[None, None]
In [21]:
lines = plt.plot([1, 2, 3])
plt.setp(lines) # 获取 lines 的所有属性
agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array
alpha: float or None
animated: bool
antialiased or aa: bool
clip_box: `.Bbox`
clip_on: bool
clip_path: Patch or (Path, Transform) or None
color or c: color
contains: unknown
dash_capstyle: {'butt', 'round', 'projecting'}
dash_joinstyle: {'miter', 'round', 'bevel'}
dashes: sequence of floats (on/off ink in points) or (None, None)
data: (2, N) array or two 1D arrays
drawstyle or ds: {'default', 'steps', 'steps-pre', 'steps-mid', 'steps-post'}, default: 'default'
figure: `.Figure`
fillstyle: {'full', 'left', 'right', 'bottom', 'top', 'none'}
gid: str
in_layout: bool
label: object
linestyle or ls: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
linewidth or lw: float
marker: marker style string, `~.path.Path` or `~.markers.MarkerStyle`
markeredgecolor or mec: color
markeredgewidth or mew: float
markerfacecolor or mfc: color
markerfacecoloralt or mfcalt: color
markersize or ms: float
markevery: None or int or (int, int) or slice or List[int] or float or (float, float) or List[bool]
path_effects: `.AbstractPathEffect`
picker: unknown
pickradius: float
rasterized: bool or None
sketch_params: (scale: float, length: float, randomness: float)
snap: bool or None
solid_capstyle: {'butt', 'round', 'projecting'}
solid_joinstyle: {'miter', 'round', 'bevel'}
transform: `matplotlib.transforms.Transform`
url: str
visible: bool
xdata: 1D array
ydata: 1D array
zorder: float
In [22]:
def f(t):
return np.exp(-t) * np.cos(2*np.pi*t)
t1 = np.arange(0.0, 5.0, 0.1)
t2 = np.arange(0.0, 5.0, 0.02)
plt.figure()
plt.subplot(211)
plt.plot(t1, f(t1), 'bo', t2, f(t2), 'k') # 蓝圈， 黑线
plt.subplot(212)
plt.plot(t2, np.cos(2*np.pi*t2), 'r--') # 红虚线
plt.show()
In [23]:
# 轴不仅可以放在左下角，还可以手动放在任意位置
In [1]:
# 切换 轴 和 画布
import matplotlib.pyplot as plt
plt.figure(1) # the first figure
plt.subplot(211) # the first subplot in the first figure
plt.plot([1, 2, 3])
plt.subplot(212) # the second subplot in the first figure
plt.plot([4, 5, 6])
plt.figure(2) # a second figure
plt.plot([4, 5, 6]) # creates a subplot() by default
plt.figure(1) # figure 1 current; subplot(212) still current
plt.subplot(211) # make subplot(211) in figure1 current
plt.title('Easy as 1, 2, 3') # subplot 211 title
Out[1]:
Text(0.5, 1.0, 'Easy as 1, 2, 3')
In [4]:
import numpy as np
mu, sigma = 100, 15
x = mu + sigma * np.random.randn(10000)
# 直方图 matplot.pyplot.hist(x, bins=None, range=None, density=None,
# 参数中 bins 若为整数表示柱子的个数,density 若为True表示柱子原始值除以所有柱子总面积之和（即频数变为频率）
n, bins, patches = plt.hist(x, 50, density=True, facecolor='g', alpha=0.75)
plt.xlabel('Smarts', fontsize=14, color='red') # 可以对行/列标签设置属性
plt.ylabel('Probability')
plt.title('Histogram of IQ')
plt.text(60, .025, r'$\mu=100,\ \sigma=15$') # 在坐标（60, 0.025）处添加值 由 $ 号包围的 LaTeX 语法
plt.axis([40, 160, 0, 0.03])
plt.grid(True) # 有无网格
plt.show()
In [5]:
# matplotlib 可以在任何输入文本的地方输入 LaTeX 表达式 ,如下：
plt.title(r'$\sigma_i=15$')
Out[5]:
Text(0.5, 1.0, '$\\sigma_i=15$')
In [6]:
# plt.annotate 注释文本，对绘图的某些特征进行注释
ax = plt.subplot()
t = np.arange(0.0, 5.0, 0.01)
s = np.cos(2*np.pi*t)
line, = plt.plot(t, s, lw=2)
plt.annotate('local max', xy=(2, 1), xytext=(3, 1.5), # 分别为 注释的内容、注释指向的位置、注释所在的位置
arrowprops=dict(facecolor='black', shrink=0.05), # 箭头的参数
)
plt.ylim(-2, 2) # 设置当前轴的y的范围
plt.show()
In [7]:
# matplotlib 还支持非线性的坐标刻度
plt.xscale('logit')
In [ ]:
#</p></div><footer class=entry-footer>925 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to " href=http://localhost:1313/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/matplotlib%E5%AD%A6%E4%B9%A0/plt_quickstart/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=http://localhost:1313/page/8/>«&nbsp;Prev&nbsp;
</a><a class=next href=http://localhost:1313/page/10/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>