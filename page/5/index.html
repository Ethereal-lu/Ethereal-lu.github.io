<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.140.1"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>lu</title>
<meta name=description content><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://ethereal-lu.github.io/index.xml><link rel=alternate type=application/json href=https://ethereal-lu.github.io/index.json><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/"><meta property="og:site_name" content="lu"><meta property="og:title" content="lu"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="lu"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"lu","url":"https://ethereal-lu.github.io/","description":"","logo":"https://ethereal-lu.github.io/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="lu (Alt + H)">lu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Redis基础</h2></header><div class=entry-content><p>概述 Redis是什么？
Redis（Remote Dictionary Server )，即远程字典服务！
Redis能干吗？ —》 数据库、缓存、中间件
内存存储、持久化（rdb、aof） 效率高，可用于缓存 发布订阅系统 地图信息分析 计时器、计数器 。。。 Redis 通过“Redis序列化协议”（简称“RESP”），实现客户端与服务端之间的连接通信，其底层是通过TCP来完成的。
Linux安装配置redis 下载并解压redis后，将解压好的包移动到/usr/local/redis中，然后cd /usr/local/redis，依次在该目录下执行make，make test（也可以不执行）和make install。之后将该目录下的redis.conf备份，再vim redis.conf，将daemonize的值从no改为yes。cd /usr/local/bin，执行redis-server ../redis/redis.conf。配置完成。
redis 是单线程 对Redis来说，执行get、set以及eval等API，都是一个一个的任务，这些任务都会由Redis的线程（单线程）去负责执行，任务要么执行成功，要么执行失败，这就是Redis的命令是原子性的原因。
redis 6 引入了多线程 redis 5 及之前的版本一直使用的是单线程，多线程是 Redis6.0 推出的一个新特性。 Redis 的核心线程负责网络 IO ，命令处理以及写数据到缓冲，而随着网络硬件的性能提升，单个主线程处理⽹络请求的速度跟不上底层⽹络硬件的速度，导致网络 IO 的处理成为了 Redis 的性能瓶颈。
而 Redis6.0 就是从单线程处理网络请求到多线程处理，通过多个 IO 线程并⾏处理网络操作提升实例的整体处理性能。需要注意的是对于读写命令，Redis 仍然使⽤单线程来处理，这是因为继续使⽤单线程执行命令操作，就不⽤为了保证 Lua 脚本、事务的原⼦性，额外开发多线程互斥机制了。
redis 将所有的数据都放在内存中。单线程避免切换上下文，所以快。
多线程开发中并发访问控制是⼀个难点，需要精细的设计才能处理。如果只是简单地处理，比如简单地采⽤⼀个粗粒度互斥锁，只会出现不理想的结果。即便增加了线程，系统吞吐率也不会随着线程的增加而增加，因为大部分线程还在等待获取访问共享资源的互斥锁。而且，大部分采用多线程开发引入的同步原语保护共享资源的并发访问，也会降低系统代码的易调试性和可维护性。而正是以上这些问题，才让 Redis 采⽤了单线程模式。
官方解释：因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦)。
基础知识 redis所有命令不区分大小写
数据库基本命令 redis默认有16个数据库（0~15），默认使用第0个数据库。数据库之间数据相互隔离
127.0.0.1:6379> SELECT 3 # 切换数据库 OK 127.0.0.1:6379[3]> DBSIZE # 查看当前数据库大小 (integer) 0 127.0.0.1:6379> FLUSHDB # 清空当前数据库 OK 127.0.0.1:6379> FLUSHALL # 清空所有数据库 OK 127.0.0.1:6379> SHUTDOWN # 关闭redis服务 Redis-key基本命令 127.0.0.1:6379> set age 18 # 添加键值对 OK 127.0.0.1:6379> get name # 通过key获取value "xunlu" 127.0.0.1:6379> KEYS * # KEYS + 正则表达式。返回所有符合正则表达式的键 1) "age" 2) "name" 127.0.0.1:6379> EXISTS name # 判断是否存在指定的key (integer) 1 # 返回1则存在，0则不存在 127.0.0.1:6379> EXPIRE name 10 # 设置键name的有效期为10秒 (integer) 1 127.0.0.1:6379> ttl name # 查看键name的有效时间还剩下多少 (integer) 4 127.0.0.1:6379> MOVE name 1 # 将键值对移动到指定的数据库中 (integer) 1 127.0.0.1:6379> DEL name # 删除键值对 (integer) 1 127.0.0.1:6379> TYPE age # 获取当前键对应值的类型 string 数据类型 五种基本数据类型 String —> 应用：计数器（如访问量，点赞数等） 127.0.0.1:6379> set name xunlu OK 127.0.0.1:6379> APPEND name feilu # 追加字符串，类似StringBuilder的append (integer) 10 # 若追加的键不存在，则新建键值对 127.0.0.1:6379> get name "xunlufeilu" ----------------------------------------------- 127.0.0.1:6379> STRLEN name # 返回值的长度 (integer) 10 ----------------------------------------------- 127.0.0.1:6379> set views 0 OK 127.0.0.1:6379> INCR views # 每执行一次，值就会加1.（只能作用于integer类型） (integer) 1 127.0.0.1:6379> INCR views (integer) 2 127.0.0.1:6379> DECR views # 每执行一次，值就会减1.（只能作用于integer类型） (integer) 1 127.0.0.1:6379> INCRBY views 10 # 指定增加的步长 (integer) 11 127.0.0.1:6379> DECRBY views 10 # 指定减少的步长 (integer) 1 ----------------------------------------------- 127.0.0.1:6379> set name xunlu OK 127.0.0.1:6379> GETRANGE name 0 2 # 截取部分值（start和end都包括在内） "xun" 127.0.0.1:6379> GETRANGE name 0 -1 # == get name "xunlu" 127.0.0.1:6379> SETRANGE name 0 gao # 替换部分字符，起始替换位置 + 替换的值 (integer) 5 127.0.0.1:6379> get name "gaolu" ----------------------------------------------- # setex(set with expire) 【原子性操作】 # setnx(set if not exist) 【原子性操作】 127.0.0.1:6379> setex name 30 xunlu # 新建键值对，并设置有效期为30秒 OK # 等同于 set name xunlu ex 30 127.0.0.1:6379> setnx gender male # nx表示键不存在时才能正确执行，即只能新建 OK # 等同于 set gender male nx # 常用于分布式锁 127.0.0.1:6379> get gender "male" 127.0.0.1:6379> set gender female nx # 此时键gender已经存在，执行失败 (nil) ----------------------------------------------- 127.0.0.1:6379> MSET k1 v1 k2 v1 k3 v1 # 批量创建键值对 OK 127.0.0.1:6379> KEYS * 1) "k1" # msetnx 【原子性操作】 2) "k3" 3) "k2" 127.0.0.1:6379> MGET k1 k2 k3 # 批量获取 1) "v1" 2) "v1" 3) "v1" ------------------------------------------------ 127.0.0.1:6379> set user {id:1,name:xunlu,age:3} # 可以将值设为json字符串，然后通过json解析 OK 127.0.0.1:6379> mset user:name xunlu user:age 18 # redis支持键中存在`:`冒号，亦可用于解析 OK ------------------------------------------------ 127.0.0.1:6379> getset db redis # 先get再set。没有返回nil，再设新值 (nil) 127.0.0.1:6379> getset db redis # 有则返回旧值，再设新值 "redis" List（双向链表） 绝大部分的list命令都以l开头，list的名字也可作为key，故有些redis-key的命令也可用 应用：消息队列、栈 # 添加、范围读取 LPUSH key element [element ...] # key为列表的名字，添加到列表的头部 RPUSH key element [element ...] # 添加到列表的尾部 127.0.0.1:6379> LPUSH list mid # 列表名为list，head、mid、tail为元素 (integer) 1 127.0.0.1:6379> LPUSH list head (integer) 2 127.0.0.1:6379> RPUSH list tail (integer) 3 127.0.0.1:6379> LRANGE list 0 -1 1) "head" 2) "mid" 3) "tail" 127.0.0.1:6379> LRANGE list 0 1 # 从头向尾读，没有RRANGE这个命令 1) "head" 2) "mid" -------------------------------------------------- # 删除、改变list LPOP key [count] # 从头部弹出元素 RPOP key [count] # 从尾部弹出元素 LREM key count element # 根据值移除元素，count表示从多个相同的值中移除的个数 LTRIM key start stop # 将列表截断，只保留[start ~ stop]的值 -------------------------------------------------- # 按下标索引 127.0.0.1:6379> LINDEX list 0 # 获取list的第i个值 "head" 127.0.0.1:6379> LINDEX list 1 "mid" -------------------------------------------------- # 长度 127.0.0.1:6379> LLEN list # 获取list的长度 (integer) 3 -------------------------------------------------- # 组合命令 RPOPLPUSH source destination # 从容器source的尾部弹出并添加到容器destination的头部 "tail" # source和destination自然可以是同一个列表 ------------------------------------------------- # 修改列表中的值 LSET key index element # 修改列表指定下标处的值 127.0.0.1:6379> LSET list 0 prehead OK ------------------------------------------------- # 插值 LINSERT key BEFORE|AFTER pivot element # pivot为列表中已有的元素，往列表中元素的前或后插入元素 Set（无序不重复）（命令都以s打头） # 添加、查看 SADD key member [member ...] # 添加元素（可以批量） 127.0.0.1:6379> SADD set first second third (integer) 3 127.0.0.1:6379> SMEMBERS set # 查看所有元素 1) "second" 2) "third" 3) "first" 127.0.0.1:6379> SISMEMBER set first # 判断是否包含指定元素 (integer) 1 127.0.0.1:6379> SISMEMBER set fifth (integer) 0 127.0.0.1:6379> SCARD set # 集合的长度 (integer) 3 ------------------------------------------------- # 移除 SREM key member [member ...] # 删除指定元素（可以批量） SPOP key [count] # 随机删除元素（可以指定个数） SMOVE source destination member # 将指定元素从集合source移动到集合destination ------------------------------------------------- SRANDMEMBER key [count] # 随机返回元素（可以指定个数） ------------------------------------------------- # 集合计算 # 差集 SDIFF set1 set2 # 集合set1中有但set2中没有的元素 # 交集 SINTER set1 set2 # 交 # 并集 SUNION set1 set2 # 并 Hash（命令都以h打头） 相当于map，则变为key-(key-value)，故（更适合对象的存储） # 添加 HSET key field value [field value ...] # 存值，key为hash容器的名字 HMSET key field value [field value ...] # 批量存值 127.0.0.1:6379> HSET hash name xunlu (integer) 1 127.0.0.1:6379> HSET hash age 18 (integer) 1 ------------------------------------------------- # 查看 HGET key field # 指定字段的取值 HMGET key field [field ...] # 批量取值 127.0.0.1:6379> HGET hash name "xunlu" 127.0.0.1:6379> HGETALL hash # 查看全部内容 1) "name" 2) "xunlu" 3) "age" 4) "18" ------------------------------------------------- # 删除 HDEL key field [field ...] # 删除指定元素（可批量） ------------------------------------------------- # 长度 127.0.0.1:6379> HLEN hash (integer) 2 ------------------------------------------------- # 是否存在 HEXISTS key field # 判断指定字段是否存在 ------------------------------------------------- 127.0.0.1:6379> HKEYS hash # 取全部字段名 1) "name" 2) "age" 127.0.0.1:6379> HVALS hash # 取全部字段的值 1) "xunlu" 2) "18" ------------------------------------------------- # 自增、自减 HINCRBY key field increment # field = field + increment （increment为负数即为减） ------------------------------------------------- HSETNX key field value # 和setnx作用类似 Zset（有序集合）【底层为跳表】 # 添加、查看 ZADD key score member [score member ...] # score用于排序 127.0.0.1:6379> ZADD salary 2500 mary 3000 alice 1000 lisa (integer) 3 ZRANGE salary 0 -1 # 返回所有数据 -------------------------------------------------- # 排序 ZRANGE salary 100 0 byscore rev withscores # ZRANGE 后可跟上多个参数来约束比较，如通过score、降序、带上score ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] # 小到大 ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count] # 大到小 127.0.0.1:6379> ZRANGEBYSCORE salary -inf +inf # 返回score在-inf +inf之间元素的排序，小到大 1) "lisa" 2) "mary" 3) "alice" -------------------------------------------------- # 移除 ZREM key member [member ...] -------------------------------------------------- # 长度 127.0.0.1:6379> ZCARD salary # 总个数 (integer) 3 127.0.0.1:6379> zcount salary 2000 3000 # 指定区间个数（score的区间） (integer) 2 三种特殊数据类型 Geospatial 地理位置 【底层由Zset实现、因此可以使用zset的命令，如ZREM等】 # 添加城市及经纬度信息 GEOADD key [NX|XX] [CH] longitude latitude member [longitude latitude member ...] 127.0.0.1:6379> GEOADD china:city 116.40 39.90 beijing # 经度、纬度 (integer) 1 127.0.0.1:6379> GEOADD china:city 121.47 31.23 shanghai (integer) 1 127.0.0.1:6379> type china:city # 底层由Zset实现 zset ------------------------------------------------------------ # 获取指定城市的经纬度信息 GEOPOS key member [member ...] 127.0.0.1:6379> GEOPOS china:city beijing 1) 1) "116.39999896287918091" 2) "39.90000009167092543" ------------------------------------------------------------- # 获取两地的距离（直线距离） GEODIST key member1 member2 [m|km|ft|mi] # 可指定单位，默认为米 127.0.0.1:6379> GEODIST china:city beijing shanghai km "1067.3788" ------------------------------------------------------------- # 获取范围内的元素 GEORADIUS key longitude latitude radius m|km|ft|mi # 根据指定经纬度和半径获取范围内的元素 127.0.0.1:6379> GEORADIUS china:city 120 30 500 km # 经度、维度、半径 1) "hangzhou" 2) "shanghai" GEORADIUSBYMEMBER key member radius m|km|ft|mi # 根据元素名和半径获取范围内的元素 Hypeloglog（基数统计、即去重后计数）【占用内存很小，最大只需要12KB】（有0.81%错误率）— 使用伯努利概率分布，根据第一个 1 出现的位置推测有多少基数。 PFADD key element [element ...] # 添加 PFCOUNT key [key ...] # 基数统计 127.0.0.1:6379> pfadd key a a a a l k j h j k l d (integer) 1 127.0.0.1:6379> PFCOUNT key (integer) 6 PFMERGE destkey sourcekey [sourcekey ...] # 合并 Bitmaps（位图） 位存储、只有两种状态的都可以用它存储 SETBIT key offset value # 添加，其中value的值只能是 0 或 1 GETBIT key offset # 查看 BITCOUNT key [start end] # 统计value为 1 的个数 发布订阅 基于频道 基于频道(Channel)的发布/订阅有两个命令分别是 publish 和 subscribe 。
...</p></div><footer class=entry-footer><span title='2022-04-01 17:39:41 +0000 UTC'>2022-04-01</span>&nbsp;·&nbsp;1606 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Redis基础" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MySQL主从复制</h2></header><div class=entry-content><p>复制原理 主从复制的原理其实就是把主服务器上的 binlog 日志复制到从服务器上执行一遍，这样从服务器上的数据就和主服务器上的数据相同了。
复制过程 主节点开启bin-log功能，记录任何修改了数据库数据的事件。 从节点每隔一定时间探测 master 的 binlog 是否发生改变，如果发生改变，则开启一个线程（I/O Thread)把自己扮演成 mysql 的客户端，请求主节点的binlog，请求时携带参数 position 表示请求该位置之后的内容；如果不携带表示从头开始复制（用于首次复制）。 主节点启动一个线程（dump Thread）与从节点的 I/O Thread建立连接，将 binlog 中 position 之后的内容返回给从节点 IO 线程。 从节点接收到主节点发送过来的数据把它放置到中继日志（Relay log）文件中。 从节点启动另外一个线程（sql Thread ），把 Relay log 中的事件读取出来，并在本地再执行一次。 复制策略 「同步策略」：Master会等待所有的Slave都回应后才会提交，用于强一致性场景但会严重影响性能 「半同步策略」：Master至少会等待一个Slave回应后提交。 「异步策略」：Master不用等待Slave回应就可以提交。 「延迟策略」：Slave要落后于Master指定的时间。 Binlog 格式 statement：记录的是修改SQL语句 row：记录的是每行实际数据的变更 mixed：statement和row模式的混合 面试题 主从复制功能
负载均衡、读写分离 备份容灾 高可用和故障切换 主从复制，达到了写性能的瓶颈如何解决
分库分表
主从复制的过程有数据延迟怎么办
数据延迟会导致Slave被读取到的数据并不是最新数据。
如果业务场景需要强一致性，使用复制策略中的同步策略。</p></div><footer class=entry-footer><span title='2022-03-27 21:39:41 +0000 UTC'>2022-03-27</span>&nbsp;·&nbsp;54 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to MySQL主从复制" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>InnoDB锁</h2></header><div class=entry-content><p>锁机制用于管理对共享资源的并发访问。
1、锁粒度 表锁是MySQL中最大粒度的锁定机制，会锁定整张表，可以很好的避免死锁，是 MySQL 中最大颗粒度的锁定机制。表锁由 MySQL Server 实现，一般在执行 DDL 语句时会对整个表进行加锁，比如说ALTER TABLE等操作。在执行 DML 语句时，也可以通过LOCK TABLES显式指定对某个表进行加锁。
页级锁锁定一页，主要应用于 BDB 存储引擎。
行级锁的锁定颗粒度在 MySQL 中是最小的，只针对操作的当前行进行加锁，所以行级锁发生锁定资源争用的概率也最小。只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。InnoDB 默认使用行级锁。
2、行锁详解 InnoDB默认使用行锁，实现了两种标准的行锁——共享锁与排他锁；
1、除了显式加锁的情况，其他情况下的加锁与解锁都无需人工干预。 2、InnoDB所有的行锁算法都是基于索引实现的，锁定的也都是索引或索引区间
lock in share mode与for update的区别：
lock in share mode 是共享锁；for update 是排他锁 没有覆盖索引时，两种锁都需要即锁辅助索引又锁主键索引；当有覆盖索引时，lock in share mode 只锁辅助索引，而 for update 即锁辅助索引又锁主键索引。 3、当前读与快照读 **1、当前读：**即加锁读，读取记录的最新版本，会加锁保证其他并发事务不能修改当前记录，直至获取锁的事务释放锁；使用当前读的操作主要包括：显式加锁的读操作与插入/更新/删除等写操作。
2、快照读：即不加锁读，读取记录的快照版本而非最新版本，通过MVCC实现；
InnoDB默认的RR事务隔离级别下，不显式加『lock in share mode』与『for update』的『select』操作都属于快照读，保证事务执行过程中只有第一次读之前提交的修改和自己的修改可见，其他的均不可见；
4、MVCC MVCC『多版本并发控制』，与之对应的是『基于锁的并发控制』；
MVCC的最大好处：读不加任何锁，读写不冲突，对于读操作多于写操作的应用，极大的增加了系统的并发性能；
5、锁算法 InnoDB主要实现了三种行锁算法：
5.1、记录锁 记录锁(Record Locks)也称为行锁，顾名思义，表示对某一行记录加锁。
5.2、间隙锁 Gap锁，锁定的是索引记录之间的间隙，是防止幻读的关键；并发事务插入新数据前会先检测间隙中是否已被加锁，防止幻读的出现；间隙锁与间隙锁不互斥。
注意！间隙锁锁住的是一个区间，而不仅仅是这个区间中目前仅存在的数据行。
插入意向锁名字里虽然有意向锁这三个字，但是它并不是意向锁，它属于行级锁，是一种特殊的间隙锁，该锁只用于并发插入操作。是在插入一条记录行前，由 INSERT 操作产生的一种间隙锁。该锁用以表示插入意向，由于插入意向锁只是锁住一个点，当多个事务在同一区间插入位置不同的多条数据时，事务之间不需要互相等待。 间隙锁的意义只在于阻止区间被插入，因此是可以共存的。一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁，共享和排他的间隙锁是没有区别的，他们相互不冲突，且功能相同。
...</p></div><footer class=entry-footer><span title='2022-03-27 17:39:41 +0000 UTC'>2022-03-27</span>&nbsp;·&nbsp;100 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to InnoDB锁" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/innodb%E9%94%81/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MySQL小知识</h2></header><div class=entry-content><p>1、or和union的区别 对于单列来说，用or是没有任何问题的，但是or涉及到多个列的时候，每次select只能选取一个index，另一列需要进行table-scan，即全部扫描一遍，但是使用union就可以解决这个问题，分别使用各自列的index进行查询。 但是这里还会有一个问题就是，UNION会对结果进行排序去重，可能会降低一些performance。
2、having和where的区别 where是在分组前对数据进行过滤；where后面不可以使用聚合函数 having是在分组后对数据进行过滤；having后面可以使用聚合函数 having 的作用就是弥补 where 的粗粒度，实现在组内更细粒度的筛选。
在查询过程中执行顺序：from>where>group（含聚合）>having>order>select。</p></div><footer class=entry-footer><span title='2022-03-27 17:39:41 +0000 UTC'>2022-03-27</span>&nbsp;·&nbsp;11 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to MySQL小知识" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%B0%8F%E7%9F%A5%E8%AF%86/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MySQL索引</h2></header><div class=entry-content><p>索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组。
1、索引类型 普通索引：最基本的索引，可以在任意一列或多列的组合上加普通索引。允许存在重复值以及空值。 唯一索引：与普通索引不同的是，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。 主键索引：与唯一索引不同的是，不允许有空值。 组合索引：组合索引与单列索引相对应，只包含一个字段的索引叫做单列索引，包含两个或以上字段的索引叫做复合索引（或组合索引）。上述三种索引既可以是单列索引也可以是组合索引。 2、聚集索引 聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。
怎么理解呢？
聚簇索引的顺序，就是数据在硬盘上的物理顺序。一般情况下主键就是默认的聚簇索引。
一张表只允许存在一个聚簇索引，因为真实数据的物理顺序只能有一种。如果一张表上还没有聚簇索引，为它新创建聚簇索引时，就需要对已有数据重新进行排序，所以对表进行修改速度较慢是聚簇索引的缺点，对于经常更新的列不宜建立聚簇索引。
聚簇索引性能最好，因为一旦具有第一个索引值的记录被找到，具有连续索引值的记录也一定物理地紧跟其后。一张表只能有一个聚簇索引，所以非常珍贵，必须慎重设置，一般要根据这个表最常用的SQL查询方式选择某个（或多个）字段作为聚簇索引（或复合聚簇索引）。
InnoDB对主键建立聚簇索引。 如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。 如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引。 3、索引的最左匹配 最左前缀匹配原则，非常重要的原则，建立一个索引，对于索引中的字段，mysql会一直向右匹配直到遇到范围查询(>、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。
mysql创建复合索引的规则是首先会对复合索引的最左边的，也就是第一个name字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的cid字段进行排序。其实就相当于实现了类似 order by name cid这样一种排序规则。 所以：第一个name字段是绝对有序的，而第二字段就是无序的了。所以通常情况下，直接使用第二个cid字段进行条件判断是用不到索引的。
在第一个值等值匹配的前提下，第二个值是有序的，因此mysql索引规则中要求复合索引要想使用第二个索引，必须先使用第一个索引的原因。（而且第一个索引必须是等值匹配）。
order by也会用到索引，但前提是 where子句必须用到索引；如果 where子句的字段没有索引，即使order by的字段有索引也不会用到。where和order by使用的索引可以是同一个组合索引，同样符合最左匹配原则，比如 select * from tb_user where name = "lu" and age &lt; 21 order by score，如果有 (name, age, score) 的组合索引，由于 age 使用了范围搜索，score 索引就会失效。
...</p></div><footer class=entry-footer><span title='2022-03-27 17:39:41 +0000 UTC'>2022-03-27</span>&nbsp;·&nbsp;371 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to MySQL索引" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E7%B4%A2%E5%BC%95/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>事务实现原理</h2></header><div class=entry-content><p>MySQL 默认开启事务自动提交模式，即除非显式的开启事务（BEGIN 或 START TRANSACTION），否则每条 SOL 语句都会被当做一个单独的事务自动执行。
在 MySQL 中，可以使用 SET autocommit 语句设置事务的自动提交模式，语法格式如下：
SET autocommit = 0|1|ON|OFF; 对取值的说明：
值为 0 和值为 OFF：关闭事务自动提交。如果关闭自动提交，用户将会一直处于某个事务中，只有提交或回滚后才会结束当前事务，重新开始一个新事务。 值为 1 和值为 ON：开启事务自动提交。如果开启自动提交，则每执行一条 SQL 语句，事务都会提交一次。 事务想要做到可靠性以及并发处理。
1、redo log 与 undo log 1.1、redo log mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Boffer Pool(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做缓冲池和磁盘之间的同步。
那么问题来了，如果还没来的同步的时候宕机或断电了怎么办？还没来得及执行上面图中红色的操作。这样会导致丢部分已提交事务的修改信息！
所以引入了redo log来记录已成功提交事务的修改信息，并且会把redo log持久化到磁盘，系统重启之后在读取redo log恢复最新数据。
redo log在事务提交时就写入磁盘，不会等待后台程序执行。
总结： redo log是用来恢复数据的 用于保障，已提交事务的持久化特性。
既然redo log也需要存储，也涉及磁盘IO为啥还用它？
（1）redo log 的存储是顺序存储，而缓存同步是随机操作。
（2）缓存同步是以数据页为单位的，每次传输的数据大小大于redo log。
1.2、undo log undo log 叫做回滚日志，用于记录数据被修改前的信息。会记录执行的操作以及修改前的信息，这样根据操作记录做相反的操作即可恢复到事务执行前的状态。
undo log 记录事务修改之前版本的数据信息，因此假如由于系统错误或者rollback操作而回滚的话可以根据undo log的信息来进行回滚到没被修改前的状态。
总结： undo log是用来回滚数据的用于保障 未提交事务的原子性
2、事务的实现 事务的原子性是通过 undo log 来实现的 事务的持久性性是通过 redo log 来实现的 事务的隔离性是通过 (读写锁+MVCC)来实现的 一致性是通过原子性，持久性，隔离性来实现的！！ 2.1、原子性的实现 一个事务必须被视为不可分割的最小工作单位，一个事务中的所有操作要么全部成功提交，要么全部失败回滚，对于一个事务来说不可能只执行其中的部分操作，这就是事务的原子性。
...</p></div><footer class=entry-footer><span title='2022-03-27 17:39:41 +0000 UTC'>2022-03-27</span>&nbsp;·&nbsp;188 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 事务实现原理" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ConcurrentHashMap</h2></header><div class=entry-content><p>1、ConcurrentHashMap 如何保证线程安全 ConcurrentHashMap 是由 Node 数组构成，这里先将 Node 数组的每个下标对应的空间称为一个桶，以方便叙述。ConcurrentHashMap 的 get 操作不需要加锁，只有 put 和 remove 需要加锁。当执行 put\remove 操作时，会先定位到桶，然后将桶中的链表头节点或树的根节点锁住，因为必须要获取到链表头节点或树的根节点才能对整个链表或树操作，所以可以保证线程安全。
当 put 操作发现桶中没有数据时，会通过 cas 操作赋值，而不是上锁。
2、ConcurrentHashMap 扩容 ConcurrentHashMap 中有一个 sizeCtl 变量，它类似于 HashMap 中的 threshold ，通过比较元素数量与 sizeCtl 的大小判断是否需要扩容。扩容时，先创建一个2倍大小的新数组并初始化一个forwardNode实例fwd，然后遍历每一个桶，若桶中元素为 null 时，直接将其赋值为fwd，否则将桶中的元素转移到新数组，再将其赋值为fwd。在扩容的过程中若进来其他的读线程，若读线程发现桶中的元素是 fwd，就会帮助进行转移，否则进行正常的读操作。若进来写线程，若写线程发现桶中的元素是 fwd，就会帮助进行转移，否则阻塞，直到扩容完成。</p></div><footer class=entry-footer><span title='2022-03-26 11:12:41 +0000 UTC'>2022-03-26</span>&nbsp;·&nbsp;38 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to ConcurrentHashMap" href=https://ethereal-lu.github.io/posts/java/java-%E8%BF%9B%E9%98%B6/concurrenthashmap/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>基础数据结构</h2></header><div class=entry-content><p>1、总体注意事项 1.1、输入方式 两种输入方式，对于绝大多数时候，均选择Scanner作为输入。
import java.util.Scanner; Scanner sc = new Scanner(System.in); 当输入数据很大时，选择 BufferedReader，但其只能以行作为单位读取，需要分割为字符串数组，再解析为其他类型。
import java.io.BufferedReader; import java.io.InputStreamReader; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 1.2、读取 有些题目会有共包含 T 组案例，每组案例内 *** 操作，这种只需按 T 建循环即可。但有些题目没有指明共有 T 组案例，却在案例中包含了多组案例，此使必须在所有代码的外面包裹一层 while (sc.hasNext()) {...}，否则会出现虽然自测通过，但提交时却通过 0 组。
1.3、审题 当感觉找到一个比题目复杂度要求还低的方法时，一定要慎重考虑，这个方法真的对吗，能否覆盖所有情况，尽早换思路。 遇到与数字相关的题目，先看能不能找规律或化简，将题目转化为简单的模型再做。 与数字相关的题目，一定看是否为越界，注意用 long 和 double。 2、链表 2.1、链表反转 可以使用的方法有 栈、三指针法、头插法
使用头插法，因为对于一个区间的反转或者 k 个一组反转，使用头插法非常方便。
public ListNode reverseKGroup (ListNode head, int k) { ListNode pre = new ListNode(-1); pre.next = head; ListNode ret = pre, p = head; tag: while (p != null) { // 如果最后不够 k 个，则不反转 for (int i = 0; i &lt; k; i++) { if (p == null) break tag; p = p.next; } p = pre.next; // 使用头插法，注意：循环 k - 1 次。 for (int i = 0; i &lt; k - 1; i++) { ListNode temp = p.next; p.next = temp.next; temp.next = pre.next; pre.next = temp; } pre = p; p = p.next; } return ret.next; } 2.2、LRU缓存 方法一：LinkedHashMap。
...</p></div><footer class=entry-footer><span title='2022-03-26 11:12:41 +0000 UTC'>2022-03-26</span>&nbsp;·&nbsp;991 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 基础数据结构" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Docker基础</h2></header><div class=entry-content><p>1、概述 Docker 基于 Go 语言实现。一次镜像，处处运行。
Go文件编译后是平台级别的机器码，因此Docker 不需要 Go 环境支撑。由于 Docker 容器模型是基于 linux 内核的，因此 Docker 必须安装在 linux 环境上。
Docker for Windows 中负责运行环境配置的工具是 Docker Machine。它会在 Windows 上创建一个 Linux 虚拟机，用于运行 Docker 引擎。
Docker 相关的本地资源都存放在/var/lib/docker/目录下
docker 的配置文件路劲：/etc/default/docker
1.1、LCX Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。
LXC与docker的关系
Docker并不是LXC的替代品，Docker的底层就是使用了LXC来实现的。LXC将Linux进程沙盒化，使得进程之间相互隔离，并且能够控制各进程的资源分配。 在LXC的基础之上，Docker提供了一系列更强的功能。 移植性：通过抽象容器配置，容器可以实现一个平台移植到另一个平台； 镜像系统：基于 AUFS 的镜像系统为容器的分发带来了很多的便利，同时共同的 镜像层只需要存储一份，实现高效率的存储； 版本管理：类似于 GIT 的版本管理理念，用户可以更方面的创建、管理镜像文件； 仓库系统：仓库系统大大降低了镜像的分发和管理的成本； 1.2、docker 启动为什么比虚拟机快 1.Docker有着比虚拟机更少的抽象层，由于Docker不需要Hypervisor实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在Cpu、内存利用率上Docker将会在效率上有明显优势。
2.Docker利用的是宿主机的内核，而不需要Guest OS，因此，当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统，避免了引导、加载操作系统内核这个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载Guest OS，这个新建过程是分钟级别的，而Docker由于直接利用宿主机的操作系统则省略了这个过程，因此新建一个Docker容器只需要几秒钟。
Docker容器 虚拟机（VM） 操作系统 与宿主机共享OS 宿主机OS上运行宿主机OS 存储大小 镜像小，便于存储与传输 镜像庞大（vmdk等） 运行性能 几乎无额外性能损失 操作系统额外的cpu、内存消耗 移植性 轻便、灵活、适用于Linux 笨重、与虚拟化技术耦合度高 硬件亲和性 面向软件开发者 面向硬件运维者 2、基本组成 docker 的三要素是：镜像、容器、仓库。
...</p></div><footer class=entry-footer><span title='2022-03-17 17:12:41 +0000 UTC'>2022-03-17</span>&nbsp;·&nbsp;631 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Docker基础" href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8/docker/docker%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C# 学习笔记</h2></header><div class=entry-content><p>1、基础概念 1.1、.Net 概念 通常所说的 .Net 包括 .Net 平台和 .Net FrameWork 框架。它们两者的关系即 jvm 和 jre 的关系。
.Net FrameWork 框架由两部分组成，分别是 .Net 类库和 CLR（公共语言运行时）。
1.2、C# 语言 C# 是一种编程语言，可以开发基于 .Net 平台 的应用。
1.3、.Net 作用 Winform 开发桌面应用程序 ASP.NET 开发 web 网站 Unity3D 开发游戏和虚拟现实 1.4、.Net 两种交互模式 C/S：客户机（Client）/服务器模式。客户端需要安装专用的客户端软件，如 微信。 B/S：浏览器（Browser）/服务器模式。客户端只需要安装浏览器即可。 2、语法规则 C# 的基础语法规则几乎与 java 一样。
2.1、基本类型 与 java 一样，包括 byte、short、int、long、float、double、bool等，u开头表示无符号。
如果一个小数是浮点类型，则其后需加个 f ，否则默认为 double 型。
2.2、字符串 类名为 string ，小写。它的使用和 java 几乎一样，注意方法名为大写开头。
字符串格式化：string str = $"{name}的年龄为{age}"，其中name和age为之前声明的变量。
2.3、函数 C# 的函数名要大写开头。
...</p></div><footer class=entry-footer><span title='2021-12-01 21:39:41 +0000 UTC'>2021-12-01</span>&nbsp;·&nbsp;349 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to C# 学习笔记" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/c%23-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://ethereal-lu.github.io/page/4/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://ethereal-lu.github.io/page/6/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>