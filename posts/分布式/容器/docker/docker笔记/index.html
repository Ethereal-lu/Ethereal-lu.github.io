<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker基础 | lu</title>
<meta name=keywords content><meta name=description content="1、概述
Docker 基于 Go 语言实现。一次镜像，处处运行。
Go文件编译后是平台级别的机器码，因此Docker 不需要 Go 环境支撑。由于 Docker 容器模型是基于 linux 内核的，因此 Docker 必须安装在 linux 环境上。
Docker for Windows 中负责运行环境配置的工具是 Docker Machine。它会在 Windows 上创建一个 Linux 虚拟机，用于运行 Docker 引擎。
Docker 相关的本地资源都存放在/var/lib/docker/目录下
docker 的配置文件路劲：/etc/default/docker
1.1、LCX
Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。
LXC与docker的关系

Docker并不是LXC的替代品，Docker的底层就是使用了LXC来实现的。LXC将Linux进程沙盒化，使得进程之间相互隔离，并且能够控制各进程的资源分配。
在LXC的基础之上，Docker提供了一系列更强的功能。

移植性：通过抽象容器配置，容器可以实现一个平台移植到另一个平台；
镜像系统：基于 AUFS 的镜像系统为容器的分发带来了很多的便利，同时共同的 镜像层只需要存储一份，实现高效率的存储；
版本管理：类似于 GIT 的版本管理理念，用户可以更方面的创建、管理镜像文件；
仓库系统：仓库系统大大降低了镜像的分发和管理的成本；



1.2、docker 启动为什么比虚拟机快
1.Docker有着比虚拟机更少的抽象层，由于Docker不需要Hypervisor实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在Cpu、内存利用率上Docker将会在效率上有明显优势。
2.Docker利用的是宿主机的内核，而不需要Guest OS，因此，当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统，避免了引导、加载操作系统内核这个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载Guest OS，这个新建过程是分钟级别的，而Docker由于直接利用宿主机的操作系统则省略了这个过程，因此新建一个Docker容器只需要几秒钟。

  
      
          
          Docker容器
          虚拟机（VM）
      
  
  
      
          操作系统
          与宿主机共享OS
          宿主机OS上运行宿主机OS
      
      
          存储大小
          镜像小，便于存储与传输
          镜像庞大（vmdk等）
      
      
          运行性能
          几乎无额外性能损失
          操作系统额外的cpu、内存消耗
      
      
          移植性
          轻便、灵活、适用于Linux
          笨重、与虚拟化技术耦合度高
      
      
          硬件亲和性
          面向软件开发者
          面向硬件运维者
      
  

2、基本组成
docker 的三要素是：镜像、容器、仓库。"><meta name=author content="lu"><link rel=canonical href=http://localhost:1313/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8/docker/docker%E7%AC%94%E8%AE%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity="sha256-1yREUm1+y9sAFUOKf6iQVKZYv3WdBULi5d+BzpS0k+4=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8/docker/docker%E7%AC%94%E8%AE%B0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8/docker/docker%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="lu"><meta property="og:title" content="Docker基础"><meta property="og:description" content="1、概述 Docker 基于 Go 语言实现。一次镜像，处处运行。
Go文件编译后是平台级别的机器码，因此Docker 不需要 Go 环境支撑。由于 Docker 容器模型是基于 linux 内核的，因此 Docker 必须安装在 linux 环境上。
Docker for Windows 中负责运行环境配置的工具是 Docker Machine。它会在 Windows 上创建一个 Linux 虚拟机，用于运行 Docker 引擎。
Docker 相关的本地资源都存放在/var/lib/docker/目录下
docker 的配置文件路劲：/etc/default/docker
1.1、LCX Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。
LXC与docker的关系
Docker并不是LXC的替代品，Docker的底层就是使用了LXC来实现的。LXC将Linux进程沙盒化，使得进程之间相互隔离，并且能够控制各进程的资源分配。 在LXC的基础之上，Docker提供了一系列更强的功能。 移植性：通过抽象容器配置，容器可以实现一个平台移植到另一个平台； 镜像系统：基于 AUFS 的镜像系统为容器的分发带来了很多的便利，同时共同的 镜像层只需要存储一份，实现高效率的存储； 版本管理：类似于 GIT 的版本管理理念，用户可以更方面的创建、管理镜像文件； 仓库系统：仓库系统大大降低了镜像的分发和管理的成本； 1.2、docker 启动为什么比虚拟机快 1.Docker有着比虚拟机更少的抽象层，由于Docker不需要Hypervisor实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在Cpu、内存利用率上Docker将会在效率上有明显优势。
2.Docker利用的是宿主机的内核，而不需要Guest OS，因此，当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统，避免了引导、加载操作系统内核这个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载Guest OS，这个新建过程是分钟级别的，而Docker由于直接利用宿主机的操作系统则省略了这个过程，因此新建一个Docker容器只需要几秒钟。
Docker容器 虚拟机（VM） 操作系统 与宿主机共享OS 宿主机OS上运行宿主机OS 存储大小 镜像小，便于存储与传输 镜像庞大（vmdk等） 运行性能 几乎无额外性能损失 操作系统额外的cpu、内存消耗 移植性 轻便、灵活、适用于Linux 笨重、与虚拟化技术耦合度高 硬件亲和性 面向软件开发者 面向硬件运维者 2、基本组成 docker 的三要素是：镜像、容器、仓库。"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-17T17:12:41+00:00"><meta property="article:modified_time" content="2022-03-17T17:12:41+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker基础"><meta name=twitter:description content="1、概述
Docker 基于 Go 语言实现。一次镜像，处处运行。
Go文件编译后是平台级别的机器码，因此Docker 不需要 Go 环境支撑。由于 Docker 容器模型是基于 linux 内核的，因此 Docker 必须安装在 linux 环境上。
Docker for Windows 中负责运行环境配置的工具是 Docker Machine。它会在 Windows 上创建一个 Linux 虚拟机，用于运行 Docker 引擎。
Docker 相关的本地资源都存放在/var/lib/docker/目录下
docker 的配置文件路劲：/etc/default/docker
1.1、LCX
Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。
LXC与docker的关系

Docker并不是LXC的替代品，Docker的底层就是使用了LXC来实现的。LXC将Linux进程沙盒化，使得进程之间相互隔离，并且能够控制各进程的资源分配。
在LXC的基础之上，Docker提供了一系列更强的功能。

移植性：通过抽象容器配置，容器可以实现一个平台移植到另一个平台；
镜像系统：基于 AUFS 的镜像系统为容器的分发带来了很多的便利，同时共同的 镜像层只需要存储一份，实现高效率的存储；
版本管理：类似于 GIT 的版本管理理念，用户可以更方面的创建、管理镜像文件；
仓库系统：仓库系统大大降低了镜像的分发和管理的成本；



1.2、docker 启动为什么比虚拟机快
1.Docker有着比虚拟机更少的抽象层，由于Docker不需要Hypervisor实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在Cpu、内存利用率上Docker将会在效率上有明显优势。
2.Docker利用的是宿主机的内核，而不需要Guest OS，因此，当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统，避免了引导、加载操作系统内核这个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载Guest OS，这个新建过程是分钟级别的，而Docker由于直接利用宿主机的操作系统则省略了这个过程，因此新建一个Docker容器只需要几秒钟。

  
      
          
          Docker容器
          虚拟机（VM）
      
  
  
      
          操作系统
          与宿主机共享OS
          宿主机OS上运行宿主机OS
      
      
          存储大小
          镜像小，便于存储与传输
          镜像庞大（vmdk等）
      
      
          运行性能
          几乎无额外性能损失
          操作系统额外的cpu、内存消耗
      
      
          移植性
          轻便、灵活、适用于Linux
          笨重、与虚拟化技术耦合度高
      
      
          硬件亲和性
          面向软件开发者
          面向硬件运维者
      
  

2、基本组成
docker 的三要素是：镜像、容器、仓库。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Docker基础","item":"http://localhost:1313/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8/docker/docker%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker基础","name":"Docker基础","description":"1、概述 Docker 基于 Go 语言实现。一次镜像，处处运行。\nGo文件编译后是平台级别的机器码，因此Docker 不需要 Go 环境支撑。由于 Docker 容器模型是基于 linux 内核的，因此 Docker 必须安装在 linux 环境上。\nDocker for Windows 中负责运行环境配置的工具是 Docker Machine。它会在 Windows 上创建一个 Linux 虚拟机，用于运行 Docker 引擎。\nDocker 相关的本地资源都存放在/var/lib/docker/目录下\ndocker 的配置文件路劲：/etc/default/docker\n1.1、LCX Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。\nLXC与docker的关系\nDocker并不是LXC的替代品，Docker的底层就是使用了LXC来实现的。LXC将Linux进程沙盒化，使得进程之间相互隔离，并且能够控制各进程的资源分配。 在LXC的基础之上，Docker提供了一系列更强的功能。 移植性：通过抽象容器配置，容器可以实现一个平台移植到另一个平台； 镜像系统：基于 AUFS 的镜像系统为容器的分发带来了很多的便利，同时共同的 镜像层只需要存储一份，实现高效率的存储； 版本管理：类似于 GIT 的版本管理理念，用户可以更方面的创建、管理镜像文件； 仓库系统：仓库系统大大降低了镜像的分发和管理的成本； 1.2、docker 启动为什么比虚拟机快 1.Docker有着比虚拟机更少的抽象层，由于Docker不需要Hypervisor实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在Cpu、内存利用率上Docker将会在效率上有明显优势。\n2.Docker利用的是宿主机的内核，而不需要Guest OS，因此，当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统，避免了引导、加载操作系统内核这个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载Guest OS，这个新建过程是分钟级别的，而Docker由于直接利用宿主机的操作系统则省略了这个过程，因此新建一个Docker容器只需要几秒钟。\nDocker容器 虚拟机（VM） 操作系统 与宿主机共享OS 宿主机OS上运行宿主机OS 存储大小 镜像小，便于存储与传输 镜像庞大（vmdk等） 运行性能 几乎无额外性能损失 操作系统额外的cpu、内存消耗 移植性 轻便、灵活、适用于Linux 笨重、与虚拟化技术耦合度高 硬件亲和性 面向软件开发者 面向硬件运维者 2、基本组成 docker 的三要素是：镜像、容器、仓库。\n","keywords":[],"articleBody":"1、概述 Docker 基于 Go 语言实现。一次镜像，处处运行。\nGo文件编译后是平台级别的机器码，因此Docker 不需要 Go 环境支撑。由于 Docker 容器模型是基于 linux 内核的，因此 Docker 必须安装在 linux 环境上。\nDocker for Windows 中负责运行环境配置的工具是 Docker Machine。它会在 Windows 上创建一个 Linux 虚拟机，用于运行 Docker 引擎。\nDocker 相关的本地资源都存放在/var/lib/docker/目录下\ndocker 的配置文件路劲：/etc/default/docker\n1.1、LCX Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。\nLXC与docker的关系\nDocker并不是LXC的替代品，Docker的底层就是使用了LXC来实现的。LXC将Linux进程沙盒化，使得进程之间相互隔离，并且能够控制各进程的资源分配。 在LXC的基础之上，Docker提供了一系列更强的功能。 移植性：通过抽象容器配置，容器可以实现一个平台移植到另一个平台； 镜像系统：基于 AUFS 的镜像系统为容器的分发带来了很多的便利，同时共同的 镜像层只需要存储一份，实现高效率的存储； 版本管理：类似于 GIT 的版本管理理念，用户可以更方面的创建、管理镜像文件； 仓库系统：仓库系统大大降低了镜像的分发和管理的成本； 1.2、docker 启动为什么比虚拟机快 1.Docker有着比虚拟机更少的抽象层，由于Docker不需要Hypervisor实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在Cpu、内存利用率上Docker将会在效率上有明显优势。\n2.Docker利用的是宿主机的内核，而不需要Guest OS，因此，当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统，避免了引导、加载操作系统内核这个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载Guest OS，这个新建过程是分钟级别的，而Docker由于直接利用宿主机的操作系统则省略了这个过程，因此新建一个Docker容器只需要几秒钟。\nDocker容器 虚拟机（VM） 操作系统 与宿主机共享OS 宿主机OS上运行宿主机OS 存储大小 镜像小，便于存储与传输 镜像庞大（vmdk等） 运行性能 几乎无额外性能损失 操作系统额外的cpu、内存消耗 移植性 轻便、灵活、适用于Linux 笨重、与虚拟化技术耦合度高 硬件亲和性 面向软件开发者 面向硬件运维者 2、基本组成 docker 的三要素是：镜像、容器、仓库。\n镜像：类似于 Java 的类；镜像由两部分组成：文件和元数据。文件即 /bin/bash 等，元数据即环境变量、端口映射、卷等。\n容器：类似于根据上方的类实例出来的对象\n仓库：集中存放镜像文件的地方，类似于 Maven 仓库\n也可以将容器看作是一个简易版的 Linux 环境，只包含root用户空间、进程空间、网络空间等（不包含内核，使用宿主机的内核）以及运行在其上的应用程序。\nDocker 软件本身是一个容器的运行载体及管理引擎。我们将应用程序和配置环境打包形成一个可交付的运行环境就是镜像文件，可以根据自己打包的或从仓库中拉取的镜像生成容器实例。\n3、工作原理 Docker 是一个 Client-Server 结构的系统，Docker 守护进程运行在主机上，客户端通过 Socket 连接访问该守护进程，守护进程从客户端接收命令并管理运行在主机上的容器。\n4、架构 Docker 是一个 C/S 模式的架构，后端是一个松耦合架构，模块各司其职。下图是它的总体架构图：\n1 用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求给后者。\n2 Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Docker Server 的功能使其可以接受 Docker Client 的请求。\n3 Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式的存在。\n4 Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graphdriver 将下载镜像以 Graph 的形式存储。\n5 当需要为 Docker 创建网络环境时，通过网络管理驱动 Networkdriver 创建并配置 Docker容器网络环境。\n6 当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Execdriver 来完成。\n7 Libcontainer 是一项独立的容器管理包，Networkdriver 以及 Execdriver 都是通过 Libcontainer 来实现具体对容器进行的操作。\nDocker 架构中各模块解析\n5、容器 Docker 容器本质上是宿主机上的一个进程。Docker 通过 namespace 实现了资源隔离，通过 cgroups 实现了资源的限制，通过写时复制机制（copy-on-write）实现了高效的文件操作。\n5.1、容器的本质 用命令 docker run 创建的容器就是 进程/usr/bin/containerd 创建的一个组长进程，（该组长进程的父进程可能是 init 进程(docker 版本20.10.10) 也可能是 /usr/bin/containerd 进程(docker 版本 18.09.9)，这取决于 docker 的版本。\n在启动容器时指定的应用程序（/bin/bash）就是该组长进程的子进程，包括创建容器时的/bin/bash和exec重新进入容器时的/bin/bash都是该组长进程的子进程\n容器内 PID=1 的进程就是创建容器时指定的命令所对应的进程。\nLinux 容器的“单进程”模型，指的是容器的生命周期等同于 PID=1 的进程（即上面这个进程）的生命周期，而不是说容器里不能创建多进程。\n当通过 docker stop container 时，这个容器的进程及其所有子进程全部退出。\n5.2、run –name=“容器名字” 为容器指定一个名称；\n-d: 后台运行容器，并返回容器ID；\n-i: 以交互模式运行容器，通常与 -t 同时使用；\n-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；\n-P: 随机端口映射，容器内部端口随机映射到主机的端口\n-p: 指定端口映射，格式为：主机(宿主)端口:容器端口\n端口映射时一般使用小写的 -p 以映射到指定端口。例如：当我们在 docker 中运行了redis 服务，并开启了 6379 端口监听。但是由于 docker 的隔离，在外面无法直接通过 6379 端口访问到 redis 服务。因此，需要将容器中的端口映射到物理机上，这样当访问映射到物理机的端口时，就找到了 docker，之后 docker 再根据映射表找到容器中真实的服务。\n#将nginx的80端口映射到宿主机的800端口上 docker run -it -p 800:80 nginx 5.3、命令 docker system df 查看镜像/容器/数据卷所占的空间。\ndocker ps：列出所有正在运行的容器。其后可以跟选项，用时再查。\n进入容器后有以下两种退出方式\nexit：容器停止（这只针对于 linux 系列容器，其他容器需要使用对应的退出命令）\nctrl + p + q ：容器不停止\n以下命令后都可以接容器名或容器id。\ndocker start :启动一个或多个已经被停止的容器\ndocker stop :停止一个运行中的容器\ndocker restart :重启容器\ndocker kill :杀掉一个运行中的容器。\ndocker rm ：删除一个或多个容器。\ndocker logs：查看容器日志\ndocker top :查看容器中运行的进程信息，支持 ps 命令参数。\ndocker inspect : 获取容器/镜像的元数据。\ndocker cp :用于容器与主机之间的数据拷贝。可双向复制\ndocker export：将容器作为一个tar文件导出到STDOUT。因此一般使用 -o 参数或 \u003e 重定向 导出为一个 tar 文件。\ndocker import : 从归档文件中创建镜像。 cat /tmp/hello-world.tar | docker import - hello-world:0.0.1\n5.4、后台容器自动退出 当用 docker 以守护进程的方式启动一个容器后，用docker ps -a 查看，会发现容器已经退出。\n退出原因\n1、docker容器运行必须有一个前台进程， 如果没有前台进程执行，容器认为空闲，就会自行退出 2、容器运行的命令如果不是那些一直挂起的命令（ 运行top，tail、循环等），就是会自动退出 3、这个是 docker 的机制问题\n解决方案\ndocker run -d centos /bin/bash -c \"tail -f /dev/null\" # 使后台程序一直有事干 docker run -dit centos # 后台交互😀 5.5、重新进入容器 重新进入一个正在运行的容器有以下两种方法\ndocker exec -it docker attach exec 与 attach 的区别\nattach 不会新建一个终端，它直接进入该容器启动时所用的终端，因此使用 exit 退出时，会导致容器停止。\nexec 会在容器中打开一个新的终端，使用 exit 退出时，不会导致容器停止。【使用这个】\n6、镜像 Docker 镜像可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。\n镜像中最重要的概念就是镜像层(Layers)。镜像层依赖于一系列的底层技术，比如文件系统(filesystems)、写时复制(copy-on-write)、联合挂载(union mounts)等。\n6.1、联合文件系统 联合文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。\n联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。不同 Docker 容器可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。\nDocker 中使用的 AUFS（AnotherUnionFS）就是一种联合文件系统。 AUFS 支持为每一个成员目录（类似 Git 的分支）设定只读（readonly）、读写（readwrite）和写出（whiteout-able）权限。\n特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。\nDocker镜像原理之联合文件系统和分层理解\n6.2 commit 制作镜像 Docker Hub 中的 ubuntu 不具备 vim 功能，通过这个 ubuntu 镜像创建一个容器，在该容器中下载 vim 工具，然后用 commit 指令将该容器生成一个镜像，则新镜像就自带有 vim 工具。\ndocker commit -m=\"描述信息\" -a=\"作者\" 容器id 仓库名:tag 6.3 push 推送至远程仓库 阿里云提供免费的个人版的镜像仓库服务。开启后创建命名空间与仓库名称，选择本地仓库上传。\n# 登录阿里云Docker Registry $ docker login --username=驯鹿是鹿呀 registry.cn-hangzhou.aliyuncs.com # docker push : 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库 # 给 6.2 创建的镜像打标签，使其与远程仓库地址一致；若不打标签，默认推送到 docker.io/library/** 下，会被拒绝。 # docker push 推送镜像的规范是：注册用户名/镜像名 $ docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/just_for_lu/mycentos:[镜像版本号] $ docker push registry.cn-hangzhou.aliyuncs.com/just_for_lu/mycentos:[镜像版本号] 6.4 私有镜像仓库 Docker Registry 是官方提供的工具，可以用于构建私有镜像仓库。\n先下载 Docker Registry ，它本身也是个镜像，直接拉取。docker pull registry\n6.5、制作镜像 镜像的定制实际上就是定制每一层所添加的配置、文件。\n6.5.1、Dockerfile Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。\n在 Dockerfile 中， 每一条指令都会创建一个镜像层，继而会增加整体镜像的大小。 Dockerfile命令\nDockerfile中ADD与COPY命令的区别：\nadd：复制文件、目录、url、压缩文件 copy：复制文件、目录。不支持 url 和解压。为简化 add 而生。docker 团队建议使用copy 6.5.2、build docker build -t . # -t 打标签；最后的点是构建上下文；可以用 -f 指定 Dockerfile 的位置 执行该命令后，docker 客户端会将构建上下文（即 . 所在的目录）打成 tar 包发送给服务端；服务端接收并解压，在执行 Dockerfile 时就是使用这个 tar 包作为上下文环境，如 Dockerfile 中的 COPY 指令的路径就是根据 tar 包的相对路径进行复制的。\n编写 .dockerignore 文件，放到 docker 构建上下文的根路径下，可以省略无需打包的文件。如 COPY 指令中的目录里有一些没用的文件，就可以省略，既能加快构建速度，又能减小镜像体积。但不添加该文件也不会对镜像造成太大影响。\n6.6、虚悬镜像 虚悬镜像是仓库名、标签都是的镜像。\n虚悬镜像一般是某镜像更新了最新版本，当我们使用docker pull拉取该最新镜像时，仓库名和标签给了新的镜像，旧的镜像仓库和标签则被取消，成为虚悬镜像。\n# 该命令可以删除所有虚悬镜像 docker rmi $(docker images -f \"dangling=true\" -q) # 或者 # 这个命令会删除所有未使用到的镜像，即使并不是没有仓库名或没有标签。 docker image prune 7、核心技术 从操作系统上来看，目前Docker底层依赖到核心技术主要包括Linux操作系统的命名空间（namespace）,控制组（Control Group）,联合文件系统（Union File System）和 Linux网络虚拟化支持．\n7.1、命名空间 命名空间是 Linux 内核一个强大的特性。每个容器都有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统中运行一样。命名空间保证了容器之间彼此互不影响。\npid 命名空间 不同的进程就是通过 pid 命名空间隔离开的，且不同命名空间中可以有相同 pid。一个 Docker 容器就是一个进程，即每个容器都有自己的命名空间，从而达到容器的隔离。\nnet 命名空间 有了 pid 命名空间, 每个命名空间中的 pid 能够相互隔离，但是网络端口还是共享 host 的端口。网络隔离是通过 net 命名空间实现的， 每个 net 命名空间有独立的 网络设备, IP 地址, 路由表, /proc/net 目录。这样每个容器的网络就能隔离开来。Docker 默认采用 veth 的方式，将容器中的虚拟网卡同 host 上的一 个Docker 网桥 docker0 连接在一起。\n其他的命名空间还有ipc 命名空间（隔离进程间通信）、mnt 命名空间（隔离文件结构）、uts 命名空间 （隔离主机名、域名）、user 命名空间 （隔离用户、用户组）。\n8、docker 如何保证安全 Docker是基于 Linux 内核的 Namespace 技术实现资源隔离的，所有的容器都共享主机的内核。\n虚拟机是通过虚拟机监视器(Hypervisor)模拟出 CPU、内存、网络等硬件，然后在这些模拟的硬件上创建客户内核和操作系统。这样做的好处就是虚拟机有自己的内核和操作系统，并且硬件都是通过虚拟机管理系统模拟出来的，用户程序无法直接使用到主机的操作系统和硬件资源，因此虚拟机也对隔离性和安全性有着更好的保证。\n而 Docker 容器则是通过 Linux 内核的 Namespace 技术实现了文件系统、进程、设备以及网络的隔离，然后再通过 Cgroups 对 CPU、 内存等资源进行限制，最终实现了容器之间相互不受影响，由于容器的隔离性仅仅依靠内核来提供，因此容器的隔离性也远弱于虚拟机。\n通过 User Namespace 做用户隔离，实现了容器中的 root 用户映射到主机上的非 root 用户，从而大大减轻了容器被突破的风险。\n在私有镜像仓库安装镜像安全扫描组件，在拉取镜像时，确保只从受信任的镜像仓库拉取，并且与镜像仓库通信使用 HTTPS 协议。\n在 docker run 时添加下列参数以限制容器的资源使用\n--cpus 限制 CPU 配额 -m, --memory 限制内存配额 --pids-limit 限制容器的 PID 个数 ","wordCount":"631","inLanguage":"en","datePublished":"2022-03-17T17:12:41Z","dateModified":"2022-03-17T17:12:41Z","author":{"@type":"Person","name":"lu"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8/docker/docker%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"lu","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/categories/ title=categories><span>categories</span></a></li><li><a href=http://localhost:1313/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Docker基础</h1><div class=post-meta><span title='2022-03-17 17:12:41 +0000 UTC'>2022-03-17</span>&nbsp;·&nbsp;631 words&nbsp;·&nbsp;lu</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1概述>1、概述</a><ul><li><a href=#11lcx>1.1、LCX</a></li><li><a href=#12docker-启动为什么比虚拟机快>1.2、docker 启动为什么比虚拟机快</a></li></ul></li><li><a href=#2基本组成>2、基本组成</a></li><li><a href=#3工作原理>3、工作原理</a></li><li><a href=#4架构>4、架构</a></li><li><a href=#5容器>5、容器</a><ul><li><a href=#51容器的本质>5.1、容器的本质</a></li><li><a href=#52run>5.2、run</a></li><li><a href=#53命令>5.3、命令</a></li><li><a href=#54后台容器自动退出>5.4、后台容器自动退出</a></li><li><a href=#55重新进入容器>5.5、重新进入容器</a></li></ul></li><li><a href=#6镜像>6、镜像</a><ul><li><a href=#61联合文件系统>6.1、联合文件系统</a></li><li><a href=#62-commit-制作镜像>6.2 commit 制作镜像</a></li><li><a href=#63-push-推送至远程仓库>6.3 push 推送至远程仓库</a></li><li><a href=#64-私有镜像仓库>6.4 私有镜像仓库</a></li><li><a href=#65制作镜像>6.5、制作镜像</a></li><li><a href=#66虚悬镜像>6.6、虚悬镜像</a></li></ul></li><li><a href=#7核心技术>7、核心技术</a><ul><li><a href=#71命名空间>7.1、命名空间</a></li></ul></li><li><a href=#8docker-如何保证安全>8、docker 如何保证安全</a></li></ul></nav></div></details></div><div class=post-content><h2 id=1概述>1、概述<a hidden class=anchor aria-hidden=true href=#1概述>#</a></h2><p>Docker 基于 Go 语言实现。一次镜像，处处运行。</p><p>Go文件编译后是平台级别的机器码，因此Docker 不需要 Go 环境支撑。由于 Docker 容器模型是基于 linux 内核的，因此 Docker 必须安装在 linux 环境上。</p><p>Docker for Windows 中负责运行环境配置的工具是 Docker Machine。它会在 Windows 上创建一个 Linux 虚拟机，用于运行 Docker 引擎。</p><p>Docker 相关的本地资源都存放在<code>/var/lib/docker/</code>目录下</p><p>docker 的配置文件路劲：<code>/etc/default/docker</code></p><h3 id=11lcx>1.1、LCX<a hidden class=anchor aria-hidden=true href=#11lcx>#</a></h3><p>Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。</p><p>LXC与docker的关系</p><ul><li>Docker并不是LXC的替代品，Docker的底层就是使用了LXC来实现的。LXC将Linux进程沙盒化，使得进程之间相互隔离，并且能够控制各进程的资源分配。</li><li>在LXC的基础之上，Docker提供了一系列更强的功能。<ul><li>移植性：通过抽象容器配置，容器可以实现一个平台移植到另一个平台；</li><li>镜像系统：基于 AUFS 的镜像系统为容器的分发带来了很多的便利，同时共同的 镜像层只需要存储一份，实现高效率的存储；</li><li>版本管理：类似于 GIT 的版本管理理念，用户可以更方面的创建、管理镜像文件；</li><li>仓库系统：仓库系统大大降低了镜像的分发和管理的成本；</li></ul></li></ul><h3 id=12docker-启动为什么比虚拟机快>1.2、docker 启动为什么比虚拟机快<a hidden class=anchor aria-hidden=true href=#12docker-启动为什么比虚拟机快>#</a></h3><p>1.Docker有着比虚拟机更少的抽象层，由于Docker不需要Hypervisor实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在Cpu、内存利用率上Docker将会在效率上有明显优势。</p><p>2.Docker利用的是宿主机的内核，而不需要Guest OS，因此，当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统，避免了引导、加载操作系统内核这个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载Guest OS，这个新建过程是分钟级别的，而Docker由于直接利用宿主机的操作系统则省略了这个过程，因此新建一个Docker容器只需要几秒钟。</p><table><thead><tr><th></th><th>Docker容器</th><th>虚拟机（VM）</th></tr></thead><tbody><tr><td>操作系统</td><td>与宿主机共享OS</td><td>宿主机OS上运行宿主机OS</td></tr><tr><td>存储大小</td><td>镜像小，便于存储与传输</td><td>镜像庞大（vmdk等）</td></tr><tr><td>运行性能</td><td>几乎无额外性能损失</td><td>操作系统额外的cpu、内存消耗</td></tr><tr><td>移植性</td><td>轻便、灵活、适用于Linux</td><td>笨重、与虚拟化技术耦合度高</td></tr><tr><td>硬件亲和性</td><td>面向软件开发者</td><td>面向硬件运维者</td></tr></tbody></table><h2 id=2基本组成>2、基本组成<a hidden class=anchor aria-hidden=true href=#2基本组成>#</a></h2><p>docker 的三要素是：镜像、容器、仓库。</p><p>镜像：类似于 Java 的类；镜像由两部分组成：文件和元数据。文件即 /bin/bash 等，元数据即环境变量、端口映射、卷等。</p><p>容器：类似于根据上方的类实例出来的对象</p><p>仓库：集中存放镜像文件的地方，类似于 Maven 仓库</p><p>也可以将容器看作是一个简易版的 Linux 环境，只包含root用户空间、进程空间、网络空间等（不包含内核，使用宿主机的内核）以及运行在其上的应用程序。</p><p>Docker 软件本身是一个容器的运行载体及管理引擎。我们将应用程序和配置环境打包形成一个可交付的运行环境就是镜像文件，可以根据自己打包的或从仓库中拉取的镜像生成容器实例。</p><p><img alt=镜像与容器 loading=lazy src=/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8/docker/docker%E7%AC%94%E8%AE%B0/%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8.jpg></p><h2 id=3工作原理>3、工作原理<a hidden class=anchor aria-hidden=true href=#3工作原理>#</a></h2><p><img alt=Docker原理 loading=lazy src=/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8/docker/docker%E7%AC%94%E8%AE%B0/Docker%E5%8E%9F%E7%90%86.jpg></p><p>Docker 是一个 Client-Server 结构的系统，Docker 守护进程运行在主机上，客户端通过 Socket 连接访问该守护进程，守护进程从客户端接收命令并管理运行在主机上的容器。</p><h2 id=4架构>4、架构<a hidden class=anchor aria-hidden=true href=#4架构>#</a></h2><p>Docker 是一个 C/S 模式的架构，后端是一个松耦合架构，模块各司其职。下图是它的总体架构图：</p><p><img alt=Docker架构 loading=lazy src=/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8/docker/docker%E7%AC%94%E8%AE%B0/Docker%E6%9E%B6%E6%9E%84.jpeg></p><p>1 用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求给后者。</p><p>2 Docker Daemon 作为 Docker 架构中的主体部分，首先提供 Docker Server 的功能使其可以接受 Docker Client 的请求。</p><p>3 Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式的存在。</p><p>4 Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graphdriver 将下载镜像以 Graph 的形式存储。</p><p>5 当需要为 Docker 创建网络环境时，通过网络管理驱动 Networkdriver 创建并配置 Docker容器网络环境。</p><p>6 当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Execdriver 来完成。</p><p>7 Libcontainer 是一项独立的容器管理包，Networkdriver 以及 Execdriver 都是通过 Libcontainer 来实现具体对容器进行的操作。</p><p><a href=https://cloud.tencent.com/developer/article/1768295>Docker 架构中各模块解析</a></p><h2 id=5容器>5、容器<a hidden class=anchor aria-hidden=true href=#5容器>#</a></h2><p>Docker 容器本质上是宿主机上的一个进程。Docker 通过 namespace 实现了资源隔离，通过 cgroups 实现了资源的限制，通过写时复制机制（copy-on-write）实现了高效的文件操作。</p><h3 id=51容器的本质>5.1、容器的本质<a hidden class=anchor aria-hidden=true href=#51容器的本质>#</a></h3><p>用命令 docker run 创建的容器就是 <strong>进程/usr/bin/containerd</strong> 创建的一个组长进程，（该组长进程的父进程可能是 init 进程(docker 版本20.10.10) 也可能是 /usr/bin/containerd 进程(docker 版本 18.09.9)，这取决于 docker 的版本。</p><p>在启动容器时指定的应用程序（/bin/bash）就是该组长进程的子进程，包括创建容器时的/bin/bash和exec重新进入容器时的/bin/bash都是该组长进程的子进程</p><p>容器内 PID=1 的进程就是创建容器时指定的命令所对应的进程。</p><p>Linux 容器的“单进程”模型，指的是容器的生命周期等同于 PID=1 的进程（即上面这个进程）的生命周期，而不是说容器里不能创建多进程。</p><p>当通过 docker stop container 时，这个容器的进程及其所有子进程全部退出。</p><h3 id=52run>5.2、run<a hidden class=anchor aria-hidden=true href=#52run>#</a></h3><ul><li><p><strong>&ndash;name</strong>=“容器名字” 为容器指定一个名称；</p></li><li><p><strong>-d:</strong> 后台运行容器，并返回容器ID；</p></li><li><p><strong>-i:</strong> 以交互模式运行容器，通常与 -t 同时使用；</p></li><li><p><strong>-t:</strong> 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p></li><li><p><strong>-P:</strong> 随机端口映射，容器内部端口随机映射到主机的端口</p></li><li><p><strong>-p:</strong> 指定端口映射，格式为：<strong>主机(宿主)端口:容器端口</strong></p><p>端口映射时一般使用小写的 -p 以映射到指定端口。例如：当我们在 docker 中运行了redis 服务，并开启了 6379 端口监听。但是由于 docker 的隔离，在外面无法直接通过 6379 端口访问到 redis 服务。因此，需要将容器中的端口映射到物理机上，这样当访问映射到物理机的端口时，就找到了 docker，之后 docker 再根据映射表找到容器中真实的服务。</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#将nginx的80端口映射到宿主机的800端口上</span>
</span></span><span style=display:flex><span>docker run -it -p 800:80 nginx 
</span></span></code></pre></div><h3 id=53命令>5.3、命令<a hidden class=anchor aria-hidden=true href=#53命令>#</a></h3><ul><li><p><code>docker system df</code> 查看镜像/容器/数据卷所占的空间。</p></li><li><p>docker ps：列出所有正在运行的容器。其后可以跟选项，用时再查。</p></li></ul><p>进入容器后有以下两种退出方式</p><ul><li><p>exit：容器停止（这只针对于 linux 系列容器，其他容器需要使用对应的退出命令）</p></li><li><p>ctrl + p + q ：容器不停止</p></li></ul><p>以下命令后都可以接容器名或容器id。</p><ul><li><p>docker start :启动一个或多个已经被停止的容器</p></li><li><p>docker stop :停止一个运行中的容器</p></li><li><p>docker restart :重启容器</p></li><li><p>docker kill :杀掉一个运行中的容器。</p></li><li><p>docker rm ：删除一个或多个容器。</p></li><li><p>docker logs：查看容器日志</p></li><li><p>docker top :查看容器中运行的进程信息，支持 ps 命令参数。</p></li><li><p>docker inspect : 获取容器/镜像的元数据。</p></li><li><p>docker cp :用于容器与主机之间的数据拷贝。可双向复制</p></li><li><p>docker export：将容器作为一个tar文件导出到STDOUT。因此一般使用 -o 参数或 > 重定向 导出为一个 tar 文件。</p></li><li><p>docker import : 从归档文件中创建镜像。 <code>cat /tmp/hello-world.tar | docker import - hello-world:0.0.1</code></p></li></ul><h3 id=54后台容器自动退出>5.4、后台容器自动退出<a hidden class=anchor aria-hidden=true href=#54后台容器自动退出>#</a></h3><p>当用 docker 以守护进程的方式启动一个容器后，用docker ps -a 查看，会发现容器已经退出。</p><p><strong>退出原因</strong></p><p>1、docker容器运行必须有一个前台进程， 如果没有前台进程执行，容器认为空闲，就会自行退出
2、容器运行的命令如果不是那些一直挂起的命令（ 运行top，tail、循环等），就是会自动退出
3、这个是 docker 的机制问题</p><p><strong>解决方案</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run -d centos /bin/bash -c <span style=color:#e6db74>&#34;tail -f /dev/null&#34;</span>   <span style=color:#75715e># 使后台程序一直有事干</span>
</span></span><span style=display:flex><span>docker run -dit centos                                  <span style=color:#75715e># 后台交互😀</span>
</span></span></code></pre></div><h3 id=55重新进入容器>5.5、重新进入容器<a hidden class=anchor aria-hidden=true href=#55重新进入容器>#</a></h3><p>重新进入一个正在运行的容器有以下两种方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker exec -it &lt;container id/name&gt;
</span></span><span style=display:flex><span>docker attach &lt;container id/name&gt;
</span></span></code></pre></div><p><strong>exec 与 attach 的区别</strong></p><p>attach 不会新建一个终端，它直接进入该容器启动时所用的终端，因此使用 exit 退出时，会导致容器停止。</p><p>exec 会在容器中打开一个新的终端，使用 exit 退出时，不会导致容器停止。【使用这个】</p><h2 id=6镜像>6、镜像<a hidden class=anchor aria-hidden=true href=#6镜像>#</a></h2><p>Docker 镜像可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>镜像中最重要的概念就是镜像层(Layers)。镜像层依赖于一系列的底层技术，比如文件系统(filesystems)、写时复制(copy-on-write)、联合挂载(<a href="https://www.zhihu.com/search?q=union+mounts&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A230398763%7D">union mounts</a>)等。</p><p><img alt=镜像层 loading=lazy src=/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8/docker/docker%E7%AC%94%E8%AE%B0/%E9%95%9C%E5%83%8F%E5%B1%82.png></p><h3 id=61联合文件系统>6.1、联合文件系统<a hidden class=anchor aria-hidden=true href=#61联合文件系统>#</a></h3><p>联合文件系统（<a href=https://en.wikipedia.org/wiki/UnionFS>UnionFS</a>）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。</p><p>联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。不同 Docker 容器可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。</p><p>Docker 中使用的 AUFS（AnotherUnionFS）就是一种联合文件系统。 <code>AUFS</code> 支持为每一个成员目录（类似 Git 的分支）设定只读（readonly）、读写（readwrite）和写出（whiteout-able）权限。</p><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><p><a href=https://www.php.cn/docker/488967.html>Docker镜像原理之联合文件系统和分层理解</a></p><h3 id=62-commit-制作镜像>6.2 commit 制作镜像<a hidden class=anchor aria-hidden=true href=#62-commit-制作镜像>#</a></h3><p>Docker Hub 中的 ubuntu 不具备 vim 功能，通过这个 ubuntu 镜像创建一个容器，在该容器中下载 vim 工具，然后用 commit 指令将该容器生成一个镜像，则新镜像就自带有 vim 工具。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker commit -m<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;描述信息&#34;</span> -a<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;作者&#34;</span> 容器id 仓库名:tag
</span></span></code></pre></div><h3 id=63-push-推送至远程仓库>6.3 push 推送至远程仓库<a hidden class=anchor aria-hidden=true href=#63-push-推送至远程仓库>#</a></h3><p>阿里云提供免费的个人版的镜像仓库服务。开启后创建命名空间与仓库名称，选择本地仓库上传。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 登录阿里云Docker Registry</span>
</span></span><span style=display:flex><span>$ docker login --username<span style=color:#f92672>=</span>驯鹿是鹿呀 registry.cn-hangzhou.aliyuncs.com
</span></span><span style=display:flex><span><span style=color:#75715e># docker push : 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 给 6.2 创建的镜像打标签，使其与远程仓库地址一致；若不打标签，默认推送到 docker.io/library/** 下，会被拒绝。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># docker push 推送镜像的规范是：注册用户名/镜像名</span>
</span></span><span style=display:flex><span>$ docker tag <span style=color:#f92672>[</span>ImageId<span style=color:#f92672>]</span> registry.cn-hangzhou.aliyuncs.com/just_for_lu/mycentos:<span style=color:#f92672>[</span>镜像版本号<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>$ docker push registry.cn-hangzhou.aliyuncs.com/just_for_lu/mycentos:<span style=color:#f92672>[</span>镜像版本号<span style=color:#f92672>]</span>
</span></span></code></pre></div><h3 id=64-私有镜像仓库>6.4 私有镜像仓库<a hidden class=anchor aria-hidden=true href=#64-私有镜像仓库>#</a></h3><p>Docker Registry 是官方提供的工具，可以用于构建私有镜像仓库。</p><p>先下载 Docker Registry ，它本身也是个镜像，直接拉取。<code>docker pull registry</code></p><h3 id=65制作镜像>6.5、制作镜像<a hidden class=anchor aria-hidden=true href=#65制作镜像>#</a></h3><p>镜像的定制实际上就是定制每一层所添加的配置、文件。</p><h4 id=651dockerfile>6.5.1、Dockerfile<a hidden class=anchor aria-hidden=true href=#651dockerfile>#</a></h4><p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><pre tabindex=0><code>在 Dockerfile 中， 每一条指令都会创建一个镜像层，继而会增加整体镜像的大小。
</code></pre><p><a href=https://www.cnblogs.com/ityouknow/p/8595384.html>Dockerfile命令</a></p><p><a href=https://www.cnblogs.com/zdz8207/p/linux-docker-add-copy.html>Dockerfile中ADD与COPY命令的区别</a>：</p><ul><li>add：复制文件、目录、url、压缩文件</li><li>copy：复制文件、目录。不支持 url 和解压。为简化 add 而生。docker 团队建议使用copy</li></ul><h4 id=652build>6.5.2、build<a hidden class=anchor aria-hidden=true href=#652build>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker build -t &lt;imageName:imageTag&gt; .      <span style=color:#75715e># -t 打标签；最后的点是构建上下文；可以用 -f 指定 Dockerfile 的位置</span>
</span></span></code></pre></div><p>执行该命令后，docker 客户端会将<a href=https://www.jianshu.com/p/592ff5ee3b62>构建上下文</a>（即 . 所在的目录）打成 tar 包发送给服务端；服务端接收并解压，在执行 Dockerfile 时就是使用这个 tar 包作为上下文环境，如 Dockerfile 中的 COPY 指令的路径就是根据 tar 包的相对路径进行复制的。</p><p>编写 <code>.dockerignore</code> 文件，放到 docker 构建上下文的根路径下，可以省略无需打包的文件。如 COPY 指令中的目录里有一些没用的文件，就可以省略，既能加快构建速度，又能减小镜像体积。但不添加该文件也不会对镜像造成太大影响。</p><h3 id=66虚悬镜像>6.6、虚悬镜像<a hidden class=anchor aria-hidden=true href=#66虚悬镜像>#</a></h3><p>虚悬镜像是仓库名、标签都是&lt;none>的镜像。</p><p>虚悬镜像一般是某镜像更新了最新版本，当我们使用docker pull拉取该最新镜像时，仓库名和标签给了新的镜像，旧的镜像仓库和标签则被取消，成为虚悬镜像。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 该命令可以删除所有虚悬镜像</span>
</span></span><span style=display:flex><span>docker rmi <span style=color:#66d9ef>$(</span>docker images -f <span style=color:#e6db74>&#34;dangling=true&#34;</span> -q<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#75715e># 或者</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#75715e># 这个命令会删除所有未使用到的镜像，即使并不是没有仓库名或没有标签。</span>
</span></span><span style=display:flex><span>docker image prune
</span></span></code></pre></div><h2 id=7核心技术>7、核心技术<a hidden class=anchor aria-hidden=true href=#7核心技术>#</a></h2><p>从操作系统上来看，目前Docker底层依赖到核心技术主要包括Linux操作系统的命名空间（namespace）,控制组（Control Group）,联合文件系统（Union File System）和 Linux网络虚拟化支持．</p><h3 id=71命名空间>7.1、命名空间<a hidden class=anchor aria-hidden=true href=#71命名空间>#</a></h3><p>命名空间是 Linux 内核一个强大的特性。<strong>每个容器都有自己单独的命名空间</strong>，运行在其中的应用都像是在独立的操作系统中运行一样。命名空间保证了容器之间彼此互不影响。</p><ul><li><p>pid 命名空间
不同的进程就是通过 pid 命名空间隔离开的，且<strong>不同命名空间中可以有相同 pid</strong>。一个 Docker 容器就是一个进程，即每个容器都有自己的命名空间，从而达到容器的隔离。</p></li><li><p>net 命名空间
有了 pid 命名空间, 每个命名空间中的 pid 能够相互隔离，但是网络端口还是<strong>共享 host 的端口</strong>。网络隔离是通过 net 命名空间实现的， 每个 net 命名空间有独立的 网络设备, IP 地址, 路由表, /proc/net 目录。这样每个容器的网络就能隔离开来。Docker 默认采用 <a href=https://www.ibm.com/developerworks/cn/linux/1310_xiawc_networkdevice/>veth</a> 的方式，将容器中的虚拟网卡同 host 上的一 个Docker 网桥 docker0 连接在一起。</p></li></ul><p>其他的命名空间还有ipc 命名空间（隔离进程间通信）、mnt 命名空间（隔离文件结构）、uts 命名空间 （隔离主机名、域名）、user 命名空间 （隔离用户、用户组）。</p><h2 id=8docker-如何保证安全>8、docker 如何保证安全<a hidden class=anchor aria-hidden=true href=#8docker-如何保证安全>#</a></h2><p>Docker是基于 Linux 内核的 Namespace 技术实现资源隔离的，所有的容器都共享主机的内核。</p><p>虚拟机是通过虚拟机监视器(Hypervisor)模拟出 CPU、内存、网络等硬件，然后在这些模拟的硬件上创建客户内核和操作系统。这样做的好处就是虚拟机有自己的内核和操作系统，并且硬件都是通过虚拟机管理系统模拟出来的，用户程序无法直接使用到主机的操作系统和硬件资源，因此虚拟机也对隔离性和安全性有着更好的保证。</p><p>而 Docker 容器则是通过 Linux 内核的 Namespace 技术实现了文件系统、进程、设备以及网络的隔离，然后再通过 Cgroups 对 CPU、 内存等资源进行限制，最终实现了容器之间相互不受影响，由于容器的隔离性仅仅依靠内核来提供，因此容器的隔离性也远弱于虚拟机。</p><ul><li><p>通过 User Namespace 做用户隔离，实现了容器中的 root 用户映射到主机上的非 root 用户，从而大大减轻了容器被突破的风险。</p></li><li><p>在私有镜像仓库安装镜像安全扫描组件，在拉取镜像时，确保只从受信任的镜像仓库拉取，并且与镜像仓库通信使用 HTTPS 协议。</p></li><li><p>在 docker run 时添加下列参数以限制容器的资源使用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  --cpus                          限制 CPU 配额
</span></span><span style=display:flex><span>  -m, --memory                    限制内存配额
</span></span><span style=display:flex><span>  --pids-limit                    限制容器的 PID 个数
</span></span></code></pre></div></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/%E9%9D%A2%E7%BB%8F/%E9%9D%A2%E7%BB%8F-%E7%BE%8E%E5%9B%A2/><span class=title>« Prev</span><br><span>面经-美团</span>
</a><a class=next href=http://localhost:1313/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/c%23-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><span class=title>Next »</span><br><span>C# 学习笔记</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>