<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Zookeeper基础 | lu</title>
<meta name=keywords content><meta name=description content="1、概述
Zookeeper 是一个分布式程序协调服务，提供的主要功能包括：配置管理、名字服务、分布式锁、集群管理。 由 java 编写。
1.1、特点

一主多从：一个 Leader 负责写数据，多个 Follower 负责读数据。
集群中只要有半数以上节点存活，Zookeeper 集群就能正常服务，因此 Zookeeper 适合安装奇数台服务器。
所有节点数据一致
来自同一个客户端的多个请求按顺序执行
每个写操作都是事务，具有原子性。
在一定时间范围内，Client 能读到最新的数据。最终一致性。

1.2、应用场景

分布式协调：客户端先后对不同节点的同一个变量设置不同的值，此时数据不一致。通过 Zookeeper 监听该变量，当变量改变时通知其他节点修改该值。
分布式锁
无状态化实现：在分布式登陆场景中，若将用户的登录信息放在某一个节点中，则下一次登录到其他节点就无法获取登录信息。可以将登录信息放在 Zookeeper 中，每个节点都到 Zookeeper 查询登录信息。这样对于每个节点而言就实现了无状态登录。

2、数据结构
Zookeeper 的数据结构类似于 Unix 文件系统，可以看作一棵树，每个节点称为一个 ZNode ，每个 ZNode 都可以通过其路径唯一标识。为了保证高吞吐和低延迟，znode只适合存储非常小的数据，不能超过1M。

2.1、节点结构
每个 ZNode 包含四部分：

data：保存数据
acl：权限。 c：创建权限；w：更新权限；r：读权限；d：删除权限；a：管理员权限，允许设置该节点的权限。
stat：元数据
child：子节点

2.2、节点类型

临时节点实现原理：
客户端与服务端之间的连接是基于 TCP 长连接，client 端连接 server 端默认的 2181 端口，也就是 session 会话。
客户端与服务端建立连接后，服务端会给客户端分配一个全局唯一的  session id。这个  session id 是有期限的，会话期间客户端会定时向服务端发送一个 ping 请求（心跳），服务端每次收到 ping 请求都会给  session id 续约。只要  session id 不过期，临时节点就一直存在。会话断开后，客户端便不再发送 ping 信号，session id 就会过期。服务端会定时查看 session id 是否过期，如果过期就将与之绑定的临时节点删除。"><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper%E5%9F%BA%E7%A1%80/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity="sha256-1yREUm1+y9sAFUOKf6iQVKZYv3WdBULi5d+BzpS0k+4=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper%E5%9F%BA%E7%A1%80/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="lu"><meta property="og:title" content="Zookeeper基础"><meta property="og:description" content="1、概述 Zookeeper 是一个分布式程序协调服务，提供的主要功能包括：配置管理、名字服务、分布式锁、集群管理。 由 java 编写。
1.1、特点 一主多从：一个 Leader 负责写数据，多个 Follower 负责读数据。 集群中只要有半数以上节点存活，Zookeeper 集群就能正常服务，因此 Zookeeper 适合安装奇数台服务器。 所有节点数据一致 来自同一个客户端的多个请求按顺序执行 每个写操作都是事务，具有原子性。 在一定时间范围内，Client 能读到最新的数据。最终一致性。 1.2、应用场景 分布式协调：客户端先后对不同节点的同一个变量设置不同的值，此时数据不一致。通过 Zookeeper 监听该变量，当变量改变时通知其他节点修改该值。 分布式锁 无状态化实现：在分布式登陆场景中，若将用户的登录信息放在某一个节点中，则下一次登录到其他节点就无法获取登录信息。可以将登录信息放在 Zookeeper 中，每个节点都到 Zookeeper 查询登录信息。这样对于每个节点而言就实现了无状态登录。 2、数据结构 Zookeeper 的数据结构类似于 Unix 文件系统，可以看作一棵树，每个节点称为一个 ZNode ，每个 ZNode 都可以通过其路径唯一标识。为了保证高吞吐和低延迟，znode只适合存储非常小的数据，不能超过1M。
2.1、节点结构 每个 ZNode 包含四部分：
data：保存数据 acl：权限。 c：创建权限；w：更新权限；r：读权限；d：删除权限；a：管理员权限，允许设置该节点的权限。 stat：元数据 child：子节点 2.2、节点类型 临时节点实现原理：
客户端与服务端之间的连接是基于 TCP 长连接，client 端连接 server 端默认的 2181 端口，也就是 session 会话。
客户端与服务端建立连接后，服务端会给客户端分配一个全局唯一的 session id。这个 session id 是有期限的，会话期间客户端会定时向服务端发送一个 ping 请求（心跳），服务端每次收到 ping 请求都会给 session id 续约。只要 session id 不过期，临时节点就一直存在。会话断开后，客户端便不再发送 ping 信号，session id 就会过期。服务端会定时查看 session id 是否过期，如果过期就将与之绑定的临时节点删除。"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-08T17:42:15+00:00"><meta property="article:modified_time" content="2022-05-08T17:42:15+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Zookeeper基础"><meta name=twitter:description content="1、概述
Zookeeper 是一个分布式程序协调服务，提供的主要功能包括：配置管理、名字服务、分布式锁、集群管理。 由 java 编写。
1.1、特点

一主多从：一个 Leader 负责写数据，多个 Follower 负责读数据。
集群中只要有半数以上节点存活，Zookeeper 集群就能正常服务，因此 Zookeeper 适合安装奇数台服务器。
所有节点数据一致
来自同一个客户端的多个请求按顺序执行
每个写操作都是事务，具有原子性。
在一定时间范围内，Client 能读到最新的数据。最终一致性。

1.2、应用场景

分布式协调：客户端先后对不同节点的同一个变量设置不同的值，此时数据不一致。通过 Zookeeper 监听该变量，当变量改变时通知其他节点修改该值。
分布式锁
无状态化实现：在分布式登陆场景中，若将用户的登录信息放在某一个节点中，则下一次登录到其他节点就无法获取登录信息。可以将登录信息放在 Zookeeper 中，每个节点都到 Zookeeper 查询登录信息。这样对于每个节点而言就实现了无状态登录。

2、数据结构
Zookeeper 的数据结构类似于 Unix 文件系统，可以看作一棵树，每个节点称为一个 ZNode ，每个 ZNode 都可以通过其路径唯一标识。为了保证高吞吐和低延迟，znode只适合存储非常小的数据，不能超过1M。

2.1、节点结构
每个 ZNode 包含四部分：

data：保存数据
acl：权限。 c：创建权限；w：更新权限；r：读权限；d：删除权限；a：管理员权限，允许设置该节点的权限。
stat：元数据
child：子节点

2.2、节点类型

临时节点实现原理：
客户端与服务端之间的连接是基于 TCP 长连接，client 端连接 server 端默认的 2181 端口，也就是 session 会话。
客户端与服务端建立连接后，服务端会给客户端分配一个全局唯一的  session id。这个  session id 是有期限的，会话期间客户端会定时向服务端发送一个 ping 请求（心跳），服务端每次收到 ping 请求都会给  session id 续约。只要  session id 不过期，临时节点就一直存在。会话断开后，客户端便不再发送 ping 信号，session id 就会过期。服务端会定时查看 session id 是否过期，如果过期就将与之绑定的临时节点删除。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ethereal-lu.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Zookeeper基础","item":"https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper%E5%9F%BA%E7%A1%80/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Zookeeper基础","name":"Zookeeper基础","description":"1、概述 Zookeeper 是一个分布式程序协调服务，提供的主要功能包括：配置管理、名字服务、分布式锁、集群管理。 由 java 编写。\n1.1、特点 一主多从：一个 Leader 负责写数据，多个 Follower 负责读数据。 集群中只要有半数以上节点存活，Zookeeper 集群就能正常服务，因此 Zookeeper 适合安装奇数台服务器。 所有节点数据一致 来自同一个客户端的多个请求按顺序执行 每个写操作都是事务，具有原子性。 在一定时间范围内，Client 能读到最新的数据。最终一致性。 1.2、应用场景 分布式协调：客户端先后对不同节点的同一个变量设置不同的值，此时数据不一致。通过 Zookeeper 监听该变量，当变量改变时通知其他节点修改该值。 分布式锁 无状态化实现：在分布式登陆场景中，若将用户的登录信息放在某一个节点中，则下一次登录到其他节点就无法获取登录信息。可以将登录信息放在 Zookeeper 中，每个节点都到 Zookeeper 查询登录信息。这样对于每个节点而言就实现了无状态登录。 2、数据结构 Zookeeper 的数据结构类似于 Unix 文件系统，可以看作一棵树，每个节点称为一个 ZNode ，每个 ZNode 都可以通过其路径唯一标识。为了保证高吞吐和低延迟，znode只适合存储非常小的数据，不能超过1M。\n2.1、节点结构 每个 ZNode 包含四部分：\ndata：保存数据 acl：权限。 c：创建权限；w：更新权限；r：读权限；d：删除权限；a：管理员权限，允许设置该节点的权限。 stat：元数据 child：子节点 2.2、节点类型 临时节点实现原理：\n客户端与服务端之间的连接是基于 TCP 长连接，client 端连接 server 端默认的 2181 端口，也就是 session 会话。\n客户端与服务端建立连接后，服务端会给客户端分配一个全局唯一的 session id。这个 session id 是有期限的，会话期间客户端会定时向服务端发送一个 ping 请求（心跳），服务端每次收到 ping 请求都会给 session id 续约。只要 session id 不过期，临时节点就一直存在。会话断开后，客户端便不再发送 ping 信号，session id 就会过期。服务端会定时查看 session id 是否过期，如果过期就将与之绑定的临时节点删除。\n","keywords":[],"articleBody":"1、概述 Zookeeper 是一个分布式程序协调服务，提供的主要功能包括：配置管理、名字服务、分布式锁、集群管理。 由 java 编写。\n1.1、特点 一主多从：一个 Leader 负责写数据，多个 Follower 负责读数据。 集群中只要有半数以上节点存活，Zookeeper 集群就能正常服务，因此 Zookeeper 适合安装奇数台服务器。 所有节点数据一致 来自同一个客户端的多个请求按顺序执行 每个写操作都是事务，具有原子性。 在一定时间范围内，Client 能读到最新的数据。最终一致性。 1.2、应用场景 分布式协调：客户端先后对不同节点的同一个变量设置不同的值，此时数据不一致。通过 Zookeeper 监听该变量，当变量改变时通知其他节点修改该值。 分布式锁 无状态化实现：在分布式登陆场景中，若将用户的登录信息放在某一个节点中，则下一次登录到其他节点就无法获取登录信息。可以将登录信息放在 Zookeeper 中，每个节点都到 Zookeeper 查询登录信息。这样对于每个节点而言就实现了无状态登录。 2、数据结构 Zookeeper 的数据结构类似于 Unix 文件系统，可以看作一棵树，每个节点称为一个 ZNode ，每个 ZNode 都可以通过其路径唯一标识。为了保证高吞吐和低延迟，znode只适合存储非常小的数据，不能超过1M。\n2.1、节点结构 每个 ZNode 包含四部分：\ndata：保存数据 acl：权限。 c：创建权限；w：更新权限；r：读权限；d：删除权限；a：管理员权限，允许设置该节点的权限。 stat：元数据 child：子节点 2.2、节点类型 临时节点实现原理：\n客户端与服务端之间的连接是基于 TCP 长连接，client 端连接 server 端默认的 2181 端口，也就是 session 会话。\n客户端与服务端建立连接后，服务端会给客户端分配一个全局唯一的 session id。这个 session id 是有期限的，会话期间客户端会定时向服务端发送一个 ping 请求（心跳），服务端每次收到 ping 请求都会给 session id 续约。只要 session id 不过期，临时节点就一直存在。会话断开后，客户端便不再发送 ping 信号，session id 就会过期。服务端会定时查看 session id 是否过期，如果过期就将与之绑定的临时节点删除。\n2.3、注册中心 Zookeeper 可以通过临时节点实现注册中心的功能。服务提供者在 Zookeeper 创建临时节点来注册自己的信息，并且一直与 Zookeeper 保持会话，服务消费者通过该临时节点发现服务提供者。当服务提供者断开连接后，session id 过期，该临时节点就被删除，此时服务消费者便无法获取到该服务。\n2.4、数据持久化 Zookeeper 的数据运行在内存中，Zookeeper 提供了两种持久化机制。\n事务日志：Zookeeper 把执行的命令以日志的形式保存在 dataLogDir 目录的文件中。 每次事务操作都会有一条记录保存在事务日志文件中，日志文件名后缀是一条zxid，是写入该事务文件的第一条事务记录的zxid 数据快照：用于记录zk服务器上某一时刻的全量内存数据内容。snapshot.2c021384ce，后缀也是一个zxid，表示本次数据快照开始时刻的服务器最新zxid。Zookeeper 定时将内存数据快照保存在快照文件中 Zookeeper 在恢复时，先恢复快照文件中的数据到内存，再用日志文件中的数据做增量恢复，这样恢复速度更快。\n3、客户端使用 docker 启动 Zookeeper 容器后，Zookeeper 服务端便已自动开启，在容器默认工作目录输入 zkCli.sh -server 127.0.0.1:2181即可进入 Zookeeper 客户端命令行。\n3.1、增删改查 create /node \"firstnode\" # 创建不带序号的永久节点 node ，节点中存储的值为 \"firstnode\" get /node # 获取节点 node 中存储的值；若创建时不设置值，则返回 null firstnode get -s /node # 获取节点 node 中存储的值以及 node 节点的元数据 stat /node # 只获取节点 node 的元数据 # 对于带序号的节点，获取时也必须带序号，否则报错 create -s /node/firstchild \"baby1\" # 在 node 节点下创建带序号的永久子节点 Created /node/firstchild0000000000 # 由输出结果可知，该节点带了序号 create -s /node/firstchild \"baby1\" # 再次创建相同的节点依然允许 Created /node/firstchild0000000001 # 从输出结果可知，节点序号加1，其实节点已经不同 create -e /node/secondchild # 不带序号的临时节点 create -e -s /node/secondchild # 带序号的临时节点 create -c /node/firstcontainer # 容器节点，容器节点中若没有子节点，则 60s 后被删除 set /node/secondchild \"baby2\" # 修改节点中的值 ls /node # 查看当前节点的子节点。 -s 元数据 -w 监听 delete /node/firstchild # 删除子节点 firstchild。若子节点不为空则不能删除父节点 deleteall /node # 不论有没有子节点，删除整个路径 delete -v 1 /node # 乐观锁删除。节点的元数据中包含节点版本，节点初始创建时版本号为 0，每次通过 # set 修改节点的值版本号加 1。乐观锁删除时指定版本号，若版本号不一致则删除失败 3.2、权限设置 子节点不会继承父节点的权限\n注册当前会话的账号和密码 addauth digest username:passeord 创建节点并设置权限 create /test-node \"data\" auth:username:password:cdrwa 在另一个会话中必须先执行步骤 1 才能拥有操作该节点的权限 4、spring 初体验 4.1、zkClient // 逗号左右不允许有空格 private String connectString = \"192.168.40.130:2181,192.168.40.130:2182,192.168.40.130:2183\"; private int sessionTimeout = 20000; private ZooKeeper zkClient; @Test public void init() throws IOException { zkClient = new ZooKeeper(connectString, sessionTimeout, new Watcher() { @Override public void process(WatchedEvent watchedEvent) { // 这里写监听程序 } }); } // 获取到 zkClient 客户端后，即可进行相应操作，如上方的添加、获取、删除、监听节点等。 4.2、Curator Curator 比 zkClient 更加优雅，推荐使用 Curator 。\n引入依赖\norg.apache.zookeeper zookeeper 3.8.0 org.apache.curator curator-framework 5.2.1 org.apache.curator curator-recipes 5.2.1 配置类\n@Data @Component @EnableConfigurationProperties @ConfigurationProperties(prefix = \"curator\") public class WrapperZk { private int retryCount; private int elapsedTimeMs; private String connectString; private int sessionTimeoutMs; private int connectionTimeoutMs; } @Configuration public class CuratorConfig { @Autowired WrapperZk wrapperZk; @Bean(initMethod = \"start\") public CuratorFramework curatorFramework() { return CuratorFrameworkFactory.newClient( wrapperZk.getConnectString(), wrapperZk.getSessionTimeoutMs(), wrapperZk.getConnectionTimeoutMs(), new RetryNTimes(wrapperZk.getRetryCount(), wrapperZk.getElapsedTimeMs())); } } 对上方配置类配置属性\ncurator: retryCount: 5 # 重试次数 elapsedTimeMs: 5000 #重试间隔时间 connectString: 192.168.36.128:2181 # zookeeper 地址 sessionTimeoutMs: 60000 # session超时时间 connectionTimeoutMs: 5000 # 连接超时时间 基础使用\n@SpringBootTest class ZkApplicationTests { @Autowired CuratorFramework curatorFramework; // 增 @Test public void createNode() throws Exception { // 添加持久节点 String path = curatorFramework.create().forPath(\"/curator-node\", \"hello zookeeper\".getBytes()); System.out.println(path); // 添加临时节点 String path1 = curatorFramework.create().withMode(CreateMode.EPHEMERAL). forPath(\"/ephemeral-node\", \"data\".getBytes()); } // 查 @Test public void getNode() throws Exception { byte[] bytes = curatorFramework.getData().forPath(\"/curator-node\"); System.out.println(new String(bytes)); } // 改 @Test public void setNode() throws Exception { curatorFramework.setData().forPath(\"/curator-node\", \"changed\".getBytes()); byte[] bytes = curatorFramework.getData().forPath(\"/curator-node\"); System.out.println(new String(bytes)); } // 删 @Test public void deleteNode() throws Exception { curatorFramework.delete().guaranteed().deletingChildrenIfNeeded().forPath(\"/curator-node\"); } // 监听 @Test public void nodeListener() throws IOException { CuratorCache curatorCache = CuratorCache.build(curatorFramework, \"/listener-node\"); CuratorCacheListener listener = CuratorCacheListener.builder() .forCreates(node -\u003e System.out.printf(\"[%s] has been created!%n\", node.getPath())) .forChanges(((oldNode, node) -\u003e System.out.printf(\"the value [%s] of [%s] has been changed to [%s]%n\", new String(oldNode.getData()), oldNode.getPath(), new String(node.getData())))) .forDeletes(node -\u003e System.out.printf(\"[%s] has been deleted!%n\", node.getPath())) .build(); curatorCache.listenable().addListener(listener); curatorCache.start(); } } 5、ZooKeeper 实现分布式读写锁 5.1、ZooKeeper 锁的种类 读锁：共享读，获取读锁的前提是不存在写锁 写锁：互斥写，获取写锁的前提是不存在任何锁 读-读兼容；读-写互斥；写-写互斥。\n对于分辨当前锁是读锁还是写锁有两种方案：1. 节点值分别保存为 read 和 write；2. 节点的路径保存为 read 和 write。对于第一种情况，需要每次额外去获取节点的值，比较浪费性能。因此选用第二种方案。注：即使临时序号节点的路径名不同，但其后缀序列都是单调递增的。\n5.2、ZooKeeper 上读锁 在一个永久节点下创建一个临时序号节点，节点路径名是 read，表示是读锁 获取当前永久节点下的所有子节点 判断自己是否是最小节点或者序号比自己小的节点是否都是读锁 如果比自己小的节点中存在写锁，则上锁失败，为离自己最近的写锁注册监听。 如果自己是最小节点或者序号比自己小的节点都是读锁，则上锁成功。 5.2、ZooKeeper 上写锁 创建一个临时序号节点，节点保存的数据是 write，表示是写锁 获取当前zk中所有子节点 判断自己是否是最小节点 如果是，上写锁成功 如果不是，说明前面还有锁，上锁失败，监听比自己小的节点，形成链式监听，当比自己小的节点改变时，再次执行步骤 2 惊群效应：如果在上写锁时，每个节点监听的是最小的节点，那么每次最小节点发生改变都会触发大量的监听事件，对于 zk 压力非常大，这就是惊群效应。故应该使用上述的链式监听，因为如果前一个结点没有获取到锁，自然也轮不到自己获取。这样只能实现公平锁。\n5.3、spring 上锁 @SpringBootTest class ZkApplicationTests { @Autowired CuratorFramework curatorFramework; @Test public void getReadLock() throws Exception { InterProcessReadWriteLock readWriteLock = new InterProcessReadWriteLock(curatorFramework, \"/lock-node\"); InterProcessLock readLock = readWriteLock.readLock(); System.out.println(\"阻塞获取读锁\"); readLock.acquire(); System.out.println(\"got the read lock\"); readLock.release(); System.out.println(\"release the lock\"); } @Test public void getWriteLock() throws Exception { InterProcessReadWriteLock readWriteLock = new InterProcessReadWriteLock(curatorFramework, \"/lock-node\"); InterProcessLock writeLock = readWriteLock.writeLock(); System.out.println(\"阻塞获取写锁\"); writeLock.acquire(); System.out.println(\"got the write lock\"); writeLock.release(); System.out.println(\"release the lock\"); } } 6、监听 6.1、监听 客户端监听它关心的目录节点，当目录节点发生变化（数据改变、节点删除、子目录节点增加删除）时，Zookeeper 会通知客户端。监听只生效一次，即一旦所监听的节点发生改变，后续该监听便失效了。\n监听相当于客户端向 Znode 节点注入回调函数，当节点改变时调用该函数，此时客户端会收到异步通知。客户端同时也会以 NIO 的方式等待通知的到来。\nget -w /node # 监听 node 节点的数据改变、节点删除。 WatchedEvent state:SyncConnected type:NodeDataChanged path:/node # 若 node 节点的值改变，则收到该信息 ls -w /node # 监听 node 节点的子节点是否改变。监听不到数据改变 WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/node # 若 node 节点的子节点增加或删除，收到该信息 ls -R -w /node # 监听 node 节点的所有子孙节点。监听不到数据改变 6.2、spring 实现监听 @SpringBootTest class ZkApplicationTests { @Autowired CuratorFramework curatorFramework; // 监听 @Test public void nodeListener() throws IOException { CuratorCache curatorCache = CuratorCache.build(curatorFramework, \"/listener-node\"); CuratorCacheListener listener = CuratorCacheListener.builder() .forCreates(node -\u003e System.out.printf(\"[%s] has been created!%n\", node.getPath())) .forChanges(((oldNode, node) -\u003e System.out.printf(\"the value [%s] of [%s] has been changed to [%s]%n\", new String(oldNode.getData()), oldNode.getPath(), new String(node.getData())))) .forDeletes(node -\u003e System.out.printf(\"[%s] has been deleted!%n\", node.getPath())) .build(); curatorCache.listenable().addListener(listener); curatorCache.start(); } } 7、Zookeeper 集群 7.1、角色 Zookeeper 集群中包含三种角色\nLeader：主节点，主要负责写数据，当然也可以读 Follower：从节点，只负责读数据，可以参与 Leader 的选举 Observer：观察者，只负责读数据，不参与 Leader 的选举 7.2、zoo.cfg Zookeeper 配置文件 zoo.cfg 中的各参数含义：\n参数 含义 tickTime 通信心跳时间，ZK中的一个时间单元。ZK中所有时间都是以这个时间单元为基础，进行整数倍配置的。 initLimit Follower在启动过程中，会从Leader同步所有最新数据，然后确定自己能够对外服务的起始状态。Leader允许Follower在 initLimit 时间内完成这个工作。 syncLimit 在运行过程中，Leader负责与ZK集群中所有机器进行通信，例如通过一些心跳检测机制，来检测机器的存活状态。如果Leader发出心跳包在syncLimit之后，还没有从Follower那里收到响应，那么就认为这个Follower已经不在线了。 dataDir 存储快照文件snapshot的目录。默认情况下，事务日志也会存储在这里。 clientPort 客户端连接server的端口，即对外服务端口，默认2181。 7.3、多主机搭建 Zookeeper 集群至少由3个ZooKeeper节点组成.\n在每台 Zookeeper 服务器上的 dataDir 目录下创建名为 myid 的文件，文件中写入一个全局唯一的数字代表其编号。\n在每台 Zookeeper 服务器上的 zoo.cfg 中添加如下配置：\nserver.1=hostname1:2888:3888 server.2=hostname2:2888:3888 server.3=hostname3:2888:3888 格式为 server.A=B:C:D\nA：Zookeeper 服务器编号，为 myid 中的数字。 B：Zookeeper 服务器的机器名或 ip 地址 C：Leader 和 Follower 交换信息的端口 D：Leader 下线后， Follower 之间重新选举 Leader 的端口 之后将所有 Zookeeper 服务器启动即可。\n7.4、docker 搭建 同一个docoker-compose中定义的service是直接可以通信的,docker-compose在启动后会自动创建默认的default网络用于内部通信。\n创建名为 docker-compose.yml 的文件，内容如下 version: '3.1' # 这是 compose 的 version services: zoo1: image: zookeeper:latest restart: always hostname: zoo1 ports: - 2181:2181 environment: ZOO_MY_ID: 1 ZOO_SERVERS: server.1=0.0.0.0:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=zoo3:2888:3888;2181 zoo2: image: zookeeper:latest restart: always hostname: zoo2 ports: - 2182:2181 environment: ZOO_MY_ID: 2 ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=0.0.0.0:2888:3888;2181 server.3=zoo3:2888:3888;2181 zoo3: image: zookeeper:latest restart: always hostname: zoo3 ports: - 2183:2181 environment: ZOO_MY_ID: 3 ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=0.0.0.0:2888:3888;2181 在 docker-compose.yml 所在目录下运行如下命令：\nCOMPOSE_PROJECT_NAME=zookeeper_cluster docker-compose up -d # zookeeper_cluster 为自定义的工程名称 使用 docker ps 查看发现集群已启动。\n在容器内，通过 zkCli.sh -server localhost:2181连接本节点，或通过 zkCli.sh -server localhost:2181,localhost:2182,localhost:2183连接集群\n8、NIO、BIO NIO\n在 2181 端口，使用 NIO 模型与客户端建立连接 客户端开始 Watch 时，使用 NIO 等待 Zookeeper 服务器的回调 BIO\n集群选举时，多个节点之间投票通信端口，使用 BIO 通信\n","wordCount":"917","inLanguage":"en","datePublished":"2022-05-08T17:42:15Z","dateModified":"2022-05-08T17:42:15Z","author":{"@type":"Person","name":"lu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper%E5%9F%BA%E7%A1%80/"},"publisher":{"@type":"Organization","name":"lu","logo":{"@type":"ImageObject","url":"https://ethereal-lu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://ethereal-lu.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethereal-lu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ethereal-lu.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Zookeeper基础</h1><div class=post-meta><span title='2022-05-08 17:42:15 +0000 UTC'>2022-05-08</span>&nbsp;·&nbsp;917 words&nbsp;·&nbsp;lu</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1概述>1、概述</a><ul><li><a href=#11特点>1.1、特点</a></li><li><a href=#12应用场景>1.2、应用场景</a></li></ul></li><li><a href=#2数据结构>2、数据结构</a><ul><li><a href=#21节点结构>2.1、节点结构</a></li><li><a href=#22节点类型>2.2、节点类型</a></li><li><a href=#23注册中心>2.3、注册中心</a></li><li><a href=#24数据持久化>2.4、数据持久化</a></li></ul></li><li><a href=#3客户端使用>3、客户端使用</a><ul><li><a href=#31增删改查>3.1、增删改查</a></li><li><a href=#32权限设置>3.2、权限设置</a></li></ul></li><li><a href=#4spring-初体验>4、spring 初体验</a><ul><li><a href=#41zkclient>4.1、zkClient</a></li><li><a href=#42curator>4.2、Curator</a></li></ul></li><li><a href=#5zookeeper-实现分布式读写锁>5、ZooKeeper 实现分布式读写锁</a><ul><li><a href=#51zookeeper-锁的种类>5.1、ZooKeeper 锁的种类</a></li><li><a href=#52zookeeper-上读锁>5.2、ZooKeeper 上读锁</a></li><li><a href=#52zookeeper-上写锁>5.2、ZooKeeper 上写锁</a></li><li><a href=#53spring-上锁>5.3、spring 上锁</a></li></ul></li><li><a href=#6监听>6、监听</a><ul><li><a href=#61监听>6.1、监听</a></li><li><a href=#62spring-实现监听>6.2、spring 实现监听</a></li></ul></li><li><a href=#7zookeeper-集群>7、Zookeeper 集群</a><ul><li><a href=#71角色>7.1、角色</a></li><li><a href=#72zoocfg>7.2、zoo.cfg</a></li><li><a href=#73多主机搭建>7.3、多主机搭建</a></li><li><a href=#74docker-搭建>7.4、docker 搭建</a></li></ul></li><li><a href=#8niobio>8、NIO、BIO</a></li></ul></nav></div></details></div><div class=post-content><h2 id=1概述>1、概述<a hidden class=anchor aria-hidden=true href=#1概述>#</a></h2><p>Zookeeper 是一个分布式程序协调服务，提供的主要功能包括：配置管理、名字服务、分布式锁、集群管理。 由 java 编写。</p><h3 id=11特点>1.1、特点<a hidden class=anchor aria-hidden=true href=#11特点>#</a></h3><ul><li>一主多从：一个 Leader 负责写数据，多个 Follower 负责读数据。</li><li>集群中只要有半数<strong>以上</strong>节点存活，Zookeeper 集群就能正常服务，因此 Zookeeper 适合安装奇数台服务器。</li><li>所有节点数据一致</li><li>来自同一个客户端的多个请求按顺序执行</li><li>每个写操作都是事务，具有原子性。</li><li>在一定时间范围内，Client 能读到最新的数据。最终一致性。</li></ul><h3 id=12应用场景>1.2、应用场景<a hidden class=anchor aria-hidden=true href=#12应用场景>#</a></h3><ul><li>分布式协调：客户端先后对不同节点的同一个变量设置不同的值，此时数据不一致。通过 Zookeeper 监听该变量，当变量改变时通知其他节点修改该值。</li><li>分布式锁</li><li>无状态化实现：在分布式登陆场景中，若将用户的登录信息放在某一个节点中，则下一次登录到其他节点就无法获取登录信息。可以将登录信息放在 Zookeeper 中，每个节点都到 Zookeeper 查询登录信息。这样对于每个节点而言就实现了无状态登录。</li></ul><h2 id=2数据结构>2、数据结构<a hidden class=anchor aria-hidden=true href=#2数据结构>#</a></h2><p>Zookeeper 的数据结构类似于 Unix 文件系统，可以看作一棵树，每个节点称为一个 ZNode ，每个 ZNode 都可以通过其路径唯一标识。为了保证高吞吐和低延迟，znode只适合存储非常小的数据，不能超过1M。</p><p><img alt=数据结构 loading=lazy src=/posts/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png></p><h3 id=21节点结构>2.1、节点结构<a hidden class=anchor aria-hidden=true href=#21节点结构>#</a></h3><p>每个 ZNode 包含四部分：</p><ul><li>data：保存数据</li><li>acl：权限。 c：创建权限；w：更新权限；r：读权限；d：删除权限；a：管理员权限，允许设置该节点的权限。</li><li>stat：元数据</li><li>child：子节点</li></ul><h3 id=22节点类型>2.2、节点类型<a hidden class=anchor aria-hidden=true href=#22节点类型>#</a></h3><p><img alt=节点类型 loading=lazy src=/posts/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper/zookeeper%E5%9F%BA%E7%A1%80/%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B.png></p><p>临时节点<strong>实现原理</strong>：</p><p>客户端与服务端之间的连接是基于 TCP 长连接，client 端连接 server 端默认的 2181 端口，也就是 session 会话。</p><p>客户端与服务端建立连接后，服务端会给客户端分配一个全局唯一的 session id。这个 session id 是有期限的，会话期间客户端会定时向服务端发送一个 ping 请求（心跳），服务端每次收到 ping 请求都会给 session id 续约。只要 session id 不过期，临时节点就一直存在。会话断开后，客户端便不再发送 ping 信号，session id 就会过期。服务端会定时查看 session id 是否过期，如果过期就将与之绑定的临时节点删除。</p><h3 id=23注册中心>2.3、注册中心<a hidden class=anchor aria-hidden=true href=#23注册中心>#</a></h3><p>Zookeeper 可以通过临时节点实现注册中心的功能。服务提供者在 Zookeeper 创建临时节点来注册自己的信息，并且一直与 Zookeeper 保持会话，服务消费者通过该临时节点发现服务提供者。当服务提供者断开连接后，session id 过期，该临时节点就被删除，此时服务消费者便无法获取到该服务。</p><h3 id=24数据持久化>2.4、数据持久化<a hidden class=anchor aria-hidden=true href=#24数据持久化>#</a></h3><p>Zookeeper 的数据运行在内存中，Zookeeper 提供了两种持久化机制。</p><ul><li>事务日志：Zookeeper 把执行的命令以日志的形式保存在 dataLogDir 目录的文件中。</li><li>每次事务操作都会有一条记录保存在事务日志文件中，日志文件名后缀是一条zxid，是写入该事务文件的第一条事务记录的zxid</li><li>数据快照：用于记录zk服务器上某一时刻的全量内存数据内容。snapshot.2c021384ce，后缀也是一个zxid，表示本次数据快照开始时刻的服务器最新zxid。Zookeeper 定时将内存数据快照保存在快照文件中</li></ul><p>Zookeeper 在恢复时，先恢复快照文件中的数据到内存，再用日志文件中的数据做增量恢复，这样恢复速度更快。</p><h2 id=3客户端使用>3、客户端使用<a hidden class=anchor aria-hidden=true href=#3客户端使用>#</a></h2><p>docker 启动 Zookeeper 容器后，Zookeeper 服务端便已自动开启，在容器默认工作目录输入 <code>zkCli.sh -server 127.0.0.1:2181</code>即可进入 Zookeeper 客户端命令行。</p><h3 id=31增删改查>3.1、增删改查<a hidden class=anchor aria-hidden=true href=#31增删改查>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>create /node <span style=color:#e6db74>&#34;firstnode&#34;</span>               <span style=color:#75715e># 创建不带序号的永久节点 node ，节点中存储的值为 &#34;firstnode&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>get /node                              <span style=color:#75715e># 获取节点 node 中存储的值；若创建时不设置值，则返回 null</span>
</span></span><span style=display:flex><span>firstnode
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>get -s /node                           <span style=color:#75715e># 获取节点 node 中存储的值以及 node 节点的元数据</span>
</span></span><span style=display:flex><span>stat /node                             <span style=color:#75715e># 只获取节点 node 的元数据</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 对于带序号的节点，获取时也必须带序号，否则报错</span>
</span></span><span style=display:flex><span>create -s /node/firstchild <span style=color:#e6db74>&#34;baby1&#34;</span>     <span style=color:#75715e># 在 node 节点下创建带序号的永久子节点</span>
</span></span><span style=display:flex><span>Created /node/firstchild0000000000     <span style=color:#75715e># 由输出结果可知，该节点带了序号</span>
</span></span><span style=display:flex><span>create -s /node/firstchild <span style=color:#e6db74>&#34;baby1&#34;</span>     <span style=color:#75715e># 再次创建相同的节点依然允许</span>
</span></span><span style=display:flex><span>Created /node/firstchild0000000001     <span style=color:#75715e># 从输出结果可知，节点序号加1，其实节点已经不同</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>create -e /node/secondchild            <span style=color:#75715e># 不带序号的临时节点</span>
</span></span><span style=display:flex><span>create -e -s /node/secondchild         <span style=color:#75715e># 带序号的临时节点</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>create -c /node/firstcontainer         <span style=color:#75715e># 容器节点，容器节点中若没有子节点，则 60s 后被删除</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>set /node/secondchild <span style=color:#e6db74>&#34;baby2&#34;</span>          <span style=color:#75715e># 修改节点中的值</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ls /node                               <span style=color:#75715e># 查看当前节点的子节点。 -s 元数据  -w 监听</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>delete /node/firstchild                <span style=color:#75715e># 删除子节点 firstchild。若子节点不为空则不能删除父节点</span>
</span></span><span style=display:flex><span>deleteall /node                        <span style=color:#75715e># 不论有没有子节点，删除整个路径</span>
</span></span><span style=display:flex><span>delete -v <span style=color:#ae81ff>1</span> /node                      <span style=color:#75715e># 乐观锁删除。节点的元数据中包含节点版本，节点初始创建时版本号为 0，每次通过</span>
</span></span><span style=display:flex><span>                                       <span style=color:#75715e># set 修改节点的值版本号加 1。乐观锁删除时指定版本号，若版本号不一致则删除失败</span>
</span></span></code></pre></div><h3 id=32权限设置>3.2、权限设置<a hidden class=anchor aria-hidden=true href=#32权限设置>#</a></h3><p>子节点不会继承父节点的权限</p><ol><li>注册当前会话的账号和密码 <code>addauth digest username:passeord</code></li><li>创建节点并设置权限 <code>create /test-node "data" auth:username:password:cdrwa</code></li><li>在另一个会话中必须先执行步骤 1 才能拥有操作该节点的权限</li></ol><h2 id=4spring-初体验>4、spring 初体验<a hidden class=anchor aria-hidden=true href=#4spring-初体验>#</a></h2><h3 id=41zkclient>4.1、zkClient<a hidden class=anchor aria-hidden=true href=#41zkclient>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 逗号左右不允许有空格</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> String connectString <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;192.168.40.130:2181,192.168.40.130:2182,192.168.40.130:2183&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> sessionTimeout <span style=color:#f92672>=</span> 20000;
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> ZooKeeper zkClient;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init</span>() <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>    zkClient <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ZooKeeper(connectString, sessionTimeout, <span style=color:#66d9ef>new</span> Watcher() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>process</span>(WatchedEvent watchedEvent) {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 这里写监听程序</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 获取到 zkClient 客户端后，即可进行相应操作，如上方的添加、获取、删除、监听节点等。</span>
</span></span></code></pre></div><h3 id=42curator>4.2、Curator<a hidden class=anchor aria-hidden=true href=#42curator>#</a></h3><p>Curator 比 zkClient 更加优雅，推荐使用 Curator 。</p><ol><li><p>引入依赖</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#75715e>&lt;!-- zookeeper --&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>org.apache.zookeeper<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>zookeeper<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;version&gt;</span>3.8.0<span style=color:#f92672>&lt;/version&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>&lt;!--对 zookeeper 基本命令的封装--&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>org.apache.curator<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>curator-framework<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;version&gt;</span>5.2.1<span style=color:#f92672>&lt;/version&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>&lt;!-- zookeeper 高级使用 --&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>org.apache.curator<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>curator-recipes<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;version&gt;</span>5.2.1<span style=color:#f92672>&lt;/version&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span></code></pre></div></li><li><p>配置类</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Data</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Component</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@EnableConfigurationProperties</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@ConfigurationProperties</span>(prefix <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;curator&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WrapperZk</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> retryCount;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> elapsedTimeMs;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String connectString;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> sessionTimeoutMs;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> connectionTimeoutMs;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Configuration</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CuratorConfig</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    WrapperZk wrapperZk;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>(initMethod <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;start&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> CuratorFramework <span style=color:#a6e22e>curatorFramework</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> CuratorFrameworkFactory.<span style=color:#a6e22e>newClient</span>(
</span></span><span style=display:flex><span>                wrapperZk.<span style=color:#a6e22e>getConnectString</span>(),
</span></span><span style=display:flex><span>                wrapperZk.<span style=color:#a6e22e>getSessionTimeoutMs</span>(),
</span></span><span style=display:flex><span>                wrapperZk.<span style=color:#a6e22e>getConnectionTimeoutMs</span>(),
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> RetryNTimes(wrapperZk.<span style=color:#a6e22e>getRetryCount</span>(), wrapperZk.<span style=color:#a6e22e>getElapsedTimeMs</span>()));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>对上方配置类配置属性</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>curator</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>retryCount</span>: <span style=color:#ae81ff>5</span>    <span style=color:#75715e># 重试次数</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>elapsedTimeMs</span>: <span style=color:#ae81ff>5000</span>   <span style=color:#75715e>#重试间隔时间</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>connectString</span>: <span style=color:#ae81ff>192.168.36.128</span>:<span style=color:#ae81ff>2181</span>   <span style=color:#75715e># zookeeper 地址</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>sessionTimeoutMs</span>: <span style=color:#ae81ff>60000</span>  <span style=color:#75715e># session超时时间</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>connectionTimeoutMs</span>: <span style=color:#ae81ff>5000</span>  <span style=color:#75715e># 连接超时时间</span>
</span></span></code></pre></div></li><li><p>基础使用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@SpringBootTest</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ZkApplicationTests</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    CuratorFramework curatorFramework;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 增</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>createNode</span>() <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 添加持久节点</span>
</span></span><span style=display:flex><span>        String path <span style=color:#f92672>=</span> curatorFramework.<span style=color:#a6e22e>create</span>().<span style=color:#a6e22e>forPath</span>(<span style=color:#e6db74>&#34;/curator-node&#34;</span>, <span style=color:#e6db74>&#34;hello zookeeper&#34;</span>.<span style=color:#a6e22e>getBytes</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(path);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 添加临时节点</span>
</span></span><span style=display:flex><span>        String path1 <span style=color:#f92672>=</span> curatorFramework.<span style=color:#a6e22e>create</span>().<span style=color:#a6e22e>withMode</span>(CreateMode.<span style=color:#a6e22e>EPHEMERAL</span>).
</span></span><span style=display:flex><span>                forPath(<span style=color:#e6db74>&#34;/ephemeral-node&#34;</span>, <span style=color:#e6db74>&#34;data&#34;</span>.<span style=color:#a6e22e>getBytes</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 查</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>getNode</span>() <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> bytes <span style=color:#f92672>=</span> curatorFramework.<span style=color:#a6e22e>getData</span>().<span style=color:#a6e22e>forPath</span>(<span style=color:#e6db74>&#34;/curator-node&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#66d9ef>new</span> String(bytes));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 改</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setNode</span>() <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        curatorFramework.<span style=color:#a6e22e>setData</span>().<span style=color:#a6e22e>forPath</span>(<span style=color:#e6db74>&#34;/curator-node&#34;</span>, <span style=color:#e6db74>&#34;changed&#34;</span>.<span style=color:#a6e22e>getBytes</span>());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> bytes <span style=color:#f92672>=</span> curatorFramework.<span style=color:#a6e22e>getData</span>().<span style=color:#a6e22e>forPath</span>(<span style=color:#e6db74>&#34;/curator-node&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#66d9ef>new</span> String(bytes));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 删</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>deleteNode</span>() <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        curatorFramework.<span style=color:#a6e22e>delete</span>().<span style=color:#a6e22e>guaranteed</span>().<span style=color:#a6e22e>deletingChildrenIfNeeded</span>().<span style=color:#a6e22e>forPath</span>(<span style=color:#e6db74>&#34;/curator-node&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 监听</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>nodeListener</span>() <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>        CuratorCache curatorCache <span style=color:#f92672>=</span> CuratorCache.<span style=color:#a6e22e>build</span>(curatorFramework, <span style=color:#e6db74>&#34;/listener-node&#34;</span>);
</span></span><span style=display:flex><span>        CuratorCacheListener listener <span style=color:#f92672>=</span> CuratorCacheListener.<span style=color:#a6e22e>builder</span>()
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>forCreates</span>(node <span style=color:#f92672>-&gt;</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[%s] has been created!%n&#34;</span>, node.<span style=color:#a6e22e>getPath</span>()))
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>forChanges</span>(((oldNode, node) <span style=color:#f92672>-&gt;</span> 
</span></span><span style=display:flex><span>                             System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;the value [%s] of [%s] has been changed to [%s]%n&#34;</span>,
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>new</span> String(oldNode.<span style=color:#a6e22e>getData</span>()), oldNode.<span style=color:#a6e22e>getPath</span>(), <span style=color:#66d9ef>new</span> String(node.<span style=color:#a6e22e>getData</span>()))))
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>forDeletes</span>(node <span style=color:#f92672>-&gt;</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[%s] has been deleted!%n&#34;</span>, node.<span style=color:#a6e22e>getPath</span>()))
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>        curatorCache.<span style=color:#a6e22e>listenable</span>().<span style=color:#a6e22e>addListener</span>(listener);
</span></span><span style=display:flex><span>        curatorCache.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ol><h2 id=5zookeeper-实现分布式读写锁>5、ZooKeeper 实现分布式读写锁<a hidden class=anchor aria-hidden=true href=#5zookeeper-实现分布式读写锁>#</a></h2><h3 id=51zookeeper-锁的种类>5.1、ZooKeeper 锁的种类<a hidden class=anchor aria-hidden=true href=#51zookeeper-锁的种类>#</a></h3><ul><li>读锁：共享读，获取读锁的前提是不存在写锁</li><li>写锁：互斥写，获取写锁的前提是不存在任何锁</li></ul><p>读-读兼容；读-写互斥；写-写互斥。</p><p>对于分辨当前锁是读锁还是写锁有两种方案：1. 节点值分别保存为 read 和 write；2. 节点的路径保存为 read 和 write。对于第一种情况，需要每次额外去获取节点的值，比较浪费性能。因此选用第二种方案。<strong>注：即使临时序号节点的路径名不同，但其后缀序列都是单调递增的。</strong></p><h3 id=52zookeeper-上读锁>5.2、ZooKeeper 上读锁<a hidden class=anchor aria-hidden=true href=#52zookeeper-上读锁>#</a></h3><ol><li>在一个永久节点下创建一个临时序号节点，节点路径名是 read，表示是读锁</li><li>获取当前永久节点下的所有子节点</li><li>判断自己是否是最小节点或者序号比自己小的节点是否都是读锁<ul><li>如果比自己小的节点中存在写锁，则上锁失败，为离自己最近的写锁注册监听。</li><li>如果自己是最小节点或者序号比自己小的节点都是读锁，则上锁成功。</li></ul></li></ol><h3 id=52zookeeper-上写锁>5.2、ZooKeeper 上写锁<a hidden class=anchor aria-hidden=true href=#52zookeeper-上写锁>#</a></h3><ol><li>创建一个临时序号节点，节点保存的数据是 write，表示是写锁</li><li>获取当前zk中所有子节点</li><li>判断自己是否是最小节点<ul><li>如果是，上写锁成功</li><li>如果不是，说明前面还有锁，上锁失败，监听比自己小的节点，形成链式监听，当比自己小的节点改变时，再次执行步骤 2</li></ul></li></ol><p><strong>惊群效应</strong>：如果在上写锁时，每个节点监听的是最小的节点，那么每次最小节点发生改变都会触发大量的监听事件，对于 zk 压力非常大，这就是惊群效应。故应该使用上述的链式监听，因为如果前一个结点没有获取到锁，自然也轮不到自己获取。这样只能实现公平锁。</p><h3 id=53spring-上锁>5.3、spring 上锁<a hidden class=anchor aria-hidden=true href=#53spring-上锁>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@SpringBootTest</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ZkApplicationTests</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    CuratorFramework curatorFramework;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>getReadLock</span>() <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        InterProcessReadWriteLock readWriteLock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> InterProcessReadWriteLock(curatorFramework, <span style=color:#e6db74>&#34;/lock-node&#34;</span>);
</span></span><span style=display:flex><span>        InterProcessLock readLock <span style=color:#f92672>=</span> readWriteLock.<span style=color:#a6e22e>readLock</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;阻塞获取读锁&#34;</span>);
</span></span><span style=display:flex><span>        readLock.<span style=color:#a6e22e>acquire</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;got the read lock&#34;</span>);
</span></span><span style=display:flex><span>        readLock.<span style=color:#a6e22e>release</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;release the lock&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>getWriteLock</span>() <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        InterProcessReadWriteLock readWriteLock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> InterProcessReadWriteLock(curatorFramework, <span style=color:#e6db74>&#34;/lock-node&#34;</span>);
</span></span><span style=display:flex><span>        InterProcessLock writeLock <span style=color:#f92672>=</span> readWriteLock.<span style=color:#a6e22e>writeLock</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;阻塞获取写锁&#34;</span>);
</span></span><span style=display:flex><span>        writeLock.<span style=color:#a6e22e>acquire</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;got the write lock&#34;</span>);
</span></span><span style=display:flex><span>        writeLock.<span style=color:#a6e22e>release</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;release the lock&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=6监听>6、监听<a hidden class=anchor aria-hidden=true href=#6监听>#</a></h2><h3 id=61监听>6.1、监听<a hidden class=anchor aria-hidden=true href=#61监听>#</a></h3><p>客户端监听它关心的目录节点，当目录节点发生变化（数据改变、节点删除、子目录节点增加删除）时，Zookeeper 会通知客户端。监听只生效一次，即一旦所监听的节点发生改变，后续该监听便失效了。</p><p>监听相当于客户端向 Znode 节点注入回调函数，当节点改变时调用该函数，此时客户端会收到异步通知。客户端同时也会以 NIO 的方式等待通知的到来。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>get -w /node               <span style=color:#75715e># 监听 node 节点的数据改变、节点删除。</span>
</span></span><span style=display:flex><span>WatchedEvent state:SyncConnected type:NodeDataChanged path:/node    <span style=color:#75715e># 若 node 节点的值改变，则收到该信息</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ls -w /node                <span style=color:#75715e># 监听 node 节点的子节点是否改变。监听不到数据改变</span>
</span></span><span style=display:flex><span>WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/node  <span style=color:#75715e># 若 node 节点的子节点增加或删除，收到该信息</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ls -R -w /node             <span style=color:#75715e># 监听 node 节点的所有子孙节点。监听不到数据改变</span>
</span></span></code></pre></div><h3 id=62spring-实现监听>6.2、spring 实现监听<a hidden class=anchor aria-hidden=true href=#62spring-实现监听>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@SpringBootTest</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ZkApplicationTests</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    CuratorFramework curatorFramework;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 监听</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>nodeListener</span>() <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>        CuratorCache curatorCache <span style=color:#f92672>=</span> CuratorCache.<span style=color:#a6e22e>build</span>(curatorFramework, <span style=color:#e6db74>&#34;/listener-node&#34;</span>);
</span></span><span style=display:flex><span>        CuratorCacheListener listener <span style=color:#f92672>=</span> CuratorCacheListener.<span style=color:#a6e22e>builder</span>()
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>forCreates</span>(node <span style=color:#f92672>-&gt;</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[%s] has been created!%n&#34;</span>, node.<span style=color:#a6e22e>getPath</span>()))
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>forChanges</span>(((oldNode, node) <span style=color:#f92672>-&gt;</span> 
</span></span><span style=display:flex><span>                             System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;the value [%s] of [%s] has been changed to [%s]%n&#34;</span>,
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>new</span> String(oldNode.<span style=color:#a6e22e>getData</span>()), oldNode.<span style=color:#a6e22e>getPath</span>(), <span style=color:#66d9ef>new</span> String(node.<span style=color:#a6e22e>getData</span>()))))
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>forDeletes</span>(node <span style=color:#f92672>-&gt;</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[%s] has been deleted!%n&#34;</span>, node.<span style=color:#a6e22e>getPath</span>()))
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>        curatorCache.<span style=color:#a6e22e>listenable</span>().<span style=color:#a6e22e>addListener</span>(listener);
</span></span><span style=display:flex><span>        curatorCache.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=7zookeeper-集群>7、Zookeeper 集群<a hidden class=anchor aria-hidden=true href=#7zookeeper-集群>#</a></h2><h3 id=71角色>7.1、角色<a hidden class=anchor aria-hidden=true href=#71角色>#</a></h3><p>Zookeeper 集群中包含三种角色</p><ul><li>Leader：主节点，主要负责写数据，当然也可以读</li><li>Follower：从节点，只负责读数据，可以参与 Leader 的选举</li><li>Observer：观察者，只负责读数据，不参与 Leader 的选举</li></ul><h3 id=72zoocfg>7.2、zoo.cfg<a hidden class=anchor aria-hidden=true href=#72zoocfg>#</a></h3><p>Zookeeper 配置文件 zoo.cfg 中的各参数含义：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><strong>tickTime</strong></td><td>通信心跳时间，ZK中的一个时间单元。ZK中所有时间都是以这个时间单元为基础，进行整数倍配置的。</td></tr><tr><td><strong>initLimit</strong></td><td>Follower在启动过程中，会从Leader同步所有最新数据，然后确定自己能够对外服务的起始状态。Leader允许Follower在 initLimit 时间内完成这个工作。</td></tr><tr><td><strong>syncLimit</strong></td><td>在运行过程中，Leader负责与ZK集群中所有机器进行通信，例如通过一些心跳检测机制，来检测机器的存活状态。如果Leader发出心跳包在syncLimit之后，还没有从Follower那里收到响应，那么就认为这个Follower已经不在线了。</td></tr><tr><td><strong>dataDir</strong></td><td>存储快照文件snapshot的目录。默认情况下，事务日志也会存储在这里。</td></tr><tr><td><strong>clientPort</strong></td><td>客户端连接server的端口，即对外服务端口，默认2181。</td></tr></tbody></table><h3 id=73多主机搭建>7.3、多主机搭建<a hidden class=anchor aria-hidden=true href=#73多主机搭建>#</a></h3><p>Zookeeper 集群至少由3个ZooKeeper节点组成.</p><p>在每台 Zookeeper 服务器上的 dataDir 目录下创建名为 myid 的文件，文件中写入一个全局唯一的数字代表其编号。</p><p>在每台 Zookeeper 服务器上的 zoo.cfg 中添加如下配置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>server.1<span style=color:#f92672>=</span>hostname1:2888:3888
</span></span><span style=display:flex><span>server.2<span style=color:#f92672>=</span>hostname2:2888:3888
</span></span><span style=display:flex><span>server.3<span style=color:#f92672>=</span>hostname3:2888:3888
</span></span></code></pre></div><p>格式为 server.A=B:C:D</p><ul><li>A：Zookeeper 服务器编号，为 myid 中的数字。</li><li>B：Zookeeper 服务器的机器名或 ip 地址</li><li>C：Leader 和 Follower 交换信息的端口</li><li>D：Leader 下线后， Follower 之间重新选举 Leader 的端口</li></ul><p>之后将所有 Zookeeper 服务器启动即可。</p><h3 id=74docker-搭建>7.4、docker 搭建<a hidden class=anchor aria-hidden=true href=#74docker-搭建>#</a></h3><p>同一个docoker-compose中定义的<code>service</code>是直接可以通信的,docker-compose在启动后会自动创建默认的<code>default</code>网络用于内部通信。</p><ol><li>创建名为 docker-compose.yml 的文件，内容如下</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#39;3.1&#39;</span>                 <span style=color:#75715e># 这是 compose 的 version</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>zoo1</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>zookeeper:latest</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>restart</span>: <span style=color:#ae81ff>always</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>hostname</span>: <span style=color:#ae81ff>zoo1</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>2181</span>:<span style=color:#ae81ff>2181</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>environment</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>ZOO_MY_ID</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>ZOO_SERVERS</span>: <span style=color:#ae81ff>server.1=0.0.0.0:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=zoo3:2888:3888;2181</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>zoo2</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>zookeeper:latest</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>restart</span>: <span style=color:#ae81ff>always</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>hostname</span>: <span style=color:#ae81ff>zoo2</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>2182</span>:<span style=color:#ae81ff>2181</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>environment</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>ZOO_MY_ID</span>: <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>ZOO_SERVERS</span>: <span style=color:#ae81ff>server.1=zoo1:2888:3888;2181 server.2=0.0.0.0:2888:3888;2181 server.3=zoo3:2888:3888;2181</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>zoo3</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>zookeeper:latest</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>restart</span>: <span style=color:#ae81ff>always</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>hostname</span>: <span style=color:#ae81ff>zoo3</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>2183</span>:<span style=color:#ae81ff>2181</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>environment</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>ZOO_MY_ID</span>: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>ZOO_SERVERS</span>: <span style=color:#ae81ff>server.1=zoo1:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=0.0.0.0:2888:3888;2181</span>
</span></span></code></pre></div><ol start=2><li><p>在 docker-compose.yml 所在目录下运行如下命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>COMPOSE_PROJECT_NAME<span style=color:#f92672>=</span>zookeeper_cluster docker-compose up -d   <span style=color:#75715e># zookeeper_cluster 为自定义的工程名称</span>
</span></span></code></pre></div></li><li><p>使用 docker ps 查看发现集群已启动。</p></li><li><p>在容器内，通过 <code>zkCli.sh -server localhost:2181</code>连接本节点，或通过 <code>zkCli.sh -server localhost:2181,localhost:2182,localhost:2183</code>连接集群</p></li></ol><h2 id=8niobio>8、NIO、BIO<a hidden class=anchor aria-hidden=true href=#8niobio>#</a></h2><ul><li><p>NIO</p><ul><li>在 2181 端口，使用 NIO 模型与客户端建立连接</li><li>客户端开始 Watch 时，使用 NIO 等待 Zookeeper 服务器的回调</li></ul></li><li><p>BIO</p><p>集群选举时，多个节点之间投票通信端口，使用 BIO 通信</p></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/kafka/kafka%E5%9F%BA%E7%A1%80/><span class=title>« Prev</span><br><span>Kafka基础</span>
</a><a class=next href=https://ethereal-lu.github.io/posts/linux/swap/><span class=title>Next »</span><br><span>swap</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>