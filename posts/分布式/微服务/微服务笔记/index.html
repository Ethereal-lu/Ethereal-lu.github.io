<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>微服务学习笔记 | lu</title>
<meta name=keywords content><meta name=description content="1、微服务架构介绍
1.1、微服务概念
微服务就是将一个单体架构的应用按业务划分为一个个独立运行的程序即服务，他们之间通过 HTTP 协议进行通信（也可以采用消息队列来通信，如 RabbotMQ、Kafaka 等），可以采用不同的编程语言，使用不同的存储技术，自动化部署（如Jenkins）减少人为控制，降低出错概率。服务数量越多，管理起来越复杂，因此采用集中化管理。例如 Eureka，Zookeeper 等都是比较常见的服务集中化管理框架。
微服务是一种架构风格。有两个特点：

职责单一：一个微服务解决一个业务问题（注意是一个业务问题而不是一个接口）。
面向服务：将自己的业务能力封装并对外提供服务，这是继承SOA的核心思想，一个微服务本身也可能调用其它的微服务。

1.2、微服务设计原则


AKF 拆分原则


前后端分离原则


无状态服务
状态：如果一个数据需要被多个服务共享，才能完成一笔交易，那么这个数据被称为状态。进而依赖这个状态数据的服务被称为有状态服务，反之称为无状态服务。
例如对空调的设置：1、若空调遥控器发送加一或减一的指令，空调根据现在的温度计算并调整温度，则空调提供的是有状态服务，状态是空调当前温度。2、若空调遥控器发送的是加一或减一之后的温度数值，空调根据接收到的温度数值设置温度，则空调提供的是无状态服务。


Restful 通信风格


2、Eureka 注册中心
应用微服务化之后，首先遇到的第一个问题就是服务发现问题，一个微服务如何发现其他微服务呢？最简单的方式就是每个微服务里面配置其他微服务的地址，但是当微服务数量众多的时候，这样做明显不现实。所以需要使用到微服务架构中的一个最重要的组件：服务注册中心，所有服务都注册到服务注册中心，同时也可以从服务注册中心获取当前可用的服务清单。
2.1、注册中心概念
注册中心可以理解为微服务架构中的“通讯录”。它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其他服务时，就到这里找到服务的地址，进行调用。
张三办了张新的电话卡并将号码告诉我，我将其名字和号码的映射保存进通讯录。              -- 服务注册
我想给张三打电话，于是在通讯录中根据其名字找到张三，然后根据映射到的电话号码拨打       -- 服务发现
---------------------------------------------------------
上例中我和张三分别代表一个微服务，通讯录是独立于我和张三的服务注册中心
总结：服务注册中心的作用就是服务的注册和服务的发现。
2.2、Eureka 入门案例
1、创建一个 SpringBoot 项目并引入web、test和下方两个依赖 。
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-dependencies</artifactId>
    <version>2020.0.4</version>
    <type>pom</type>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
    <version>3.0.4</version>
</dependency>
2、application.yaml 如下
server:
  port: 8761               # 官方文档使用的端口

spring:
  application:
    name: eureka-server    # 应用名称

# 配置 eureka-server 注册中心
eureka:
  instance:
    hostname: localhost              # 主机名，默认根据操作系统的主机名获取
  client:
    # 下方值为 false 的两项，只有当自身为单节点的注册中心时才需要设置为 false 。
    # 单节点指的是只有一个注册中心，不是只有一个微服务。
    # 当自身是微服务或者是集群中的注册中心之一时无需设置，使用默认 true。
    register-with-eureka: false      # 是否将自己注册到注册中心，默认为 true
    fetch-registry: false            # 是否从注册中心获取服务注册信息，默认 true
    service-url:                     # 注册中心对外暴露的注册地址
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
3、启动类前添加 @EnableEurekaServer 注解"><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AC%94%E8%AE%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity="sha256-1yREUm1+y9sAFUOKf6iQVKZYv3WdBULi5d+BzpS0k+4=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AC%94%E8%AE%B0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="lu"><meta property="og:title" content="微服务学习笔记"><meta property="og:description" content="1、微服务架构介绍 1.1、微服务概念 微服务就是将一个单体架构的应用按业务划分为一个个独立运行的程序即服务，他们之间通过 HTTP 协议进行通信（也可以采用消息队列来通信，如 RabbotMQ、Kafaka 等），可以采用不同的编程语言，使用不同的存储技术，自动化部署（如Jenkins）减少人为控制，降低出错概率。服务数量越多，管理起来越复杂，因此采用集中化管理。例如 Eureka，Zookeeper 等都是比较常见的服务集中化管理框架。
微服务是一种架构风格。有两个特点：
职责单一：一个微服务解决一个业务问题（注意是一个业务问题而不是一个接口）。 面向服务：将自己的业务能力封装并对外提供服务，这是继承SOA的核心思想，一个微服务本身也可能调用其它的微服务。 1.2、微服务设计原则 AKF 拆分原则
前后端分离原则
无状态服务
状态：如果一个数据需要被多个服务共享，才能完成一笔交易，那么这个数据被称为状态。进而依赖这个状态数据的服务被称为有状态服务，反之称为无状态服务。
例如对空调的设置：1、若空调遥控器发送加一或减一的指令，空调根据现在的温度计算并调整温度，则空调提供的是有状态服务，状态是空调当前温度。2、若空调遥控器发送的是加一或减一之后的温度数值，空调根据接收到的温度数值设置温度，则空调提供的是无状态服务。
Restful 通信风格
2、Eureka 注册中心 应用微服务化之后，首先遇到的第一个问题就是服务发现问题，一个微服务如何发现其他微服务呢？最简单的方式就是每个微服务里面配置其他微服务的地址，但是当微服务数量众多的时候，这样做明显不现实。所以需要使用到微服务架构中的一个最重要的组件：服务注册中心，所有服务都注册到服务注册中心，同时也可以从服务注册中心获取当前可用的服务清单。
2.1、注册中心概念 注册中心可以理解为微服务架构中的“通讯录”。它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其他服务时，就到这里找到服务的地址，进行调用。
张三办了张新的电话卡并将号码告诉我，我将其名字和号码的映射保存进通讯录。 -- 服务注册 我想给张三打电话，于是在通讯录中根据其名字找到张三，然后根据映射到的电话号码拨打 -- 服务发现 --------------------------------------------------------- 上例中我和张三分别代表一个微服务，通讯录是独立于我和张三的服务注册中心 总结：服务注册中心的作用就是服务的注册和服务的发现。
2.2、Eureka 入门案例 1、创建一个 SpringBoot 项目并引入web、test和下方两个依赖 。
<dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-dependencies</artifactId> <version>2020.0.4</version> <type>pom</type> <scope>runtime</scope> </dependency> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId> <version>3.0.4</version> </dependency> 2、application.yaml 如下
server: port: 8761 # 官方文档使用的端口 spring: application: name: eureka-server # 应用名称 # 配置 eureka-server 注册中心 eureka: instance: hostname: localhost # 主机名，默认根据操作系统的主机名获取 client: # 下方值为 false 的两项，只有当自身为单节点的注册中心时才需要设置为 false 。 # 单节点指的是只有一个注册中心，不是只有一个微服务。 # 当自身是微服务或者是集群中的注册中心之一时无需设置，使用默认 true。 register-with-eureka: false # 是否将自己注册到注册中心，默认为 true fetch-registry: false # 是否从注册中心获取服务注册信息，默认 true service-url: # 注册中心对外暴露的注册地址 defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ 3、启动类前添加 @EnableEurekaServer 注解"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-10-25T17:42:15+00:00"><meta property="article:modified_time" content="2021-10-25T17:42:15+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="微服务学习笔记"><meta name=twitter:description content="1、微服务架构介绍
1.1、微服务概念
微服务就是将一个单体架构的应用按业务划分为一个个独立运行的程序即服务，他们之间通过 HTTP 协议进行通信（也可以采用消息队列来通信，如 RabbotMQ、Kafaka 等），可以采用不同的编程语言，使用不同的存储技术，自动化部署（如Jenkins）减少人为控制，降低出错概率。服务数量越多，管理起来越复杂，因此采用集中化管理。例如 Eureka，Zookeeper 等都是比较常见的服务集中化管理框架。
微服务是一种架构风格。有两个特点：

职责单一：一个微服务解决一个业务问题（注意是一个业务问题而不是一个接口）。
面向服务：将自己的业务能力封装并对外提供服务，这是继承SOA的核心思想，一个微服务本身也可能调用其它的微服务。

1.2、微服务设计原则


AKF 拆分原则


前后端分离原则


无状态服务
状态：如果一个数据需要被多个服务共享，才能完成一笔交易，那么这个数据被称为状态。进而依赖这个状态数据的服务被称为有状态服务，反之称为无状态服务。
例如对空调的设置：1、若空调遥控器发送加一或减一的指令，空调根据现在的温度计算并调整温度，则空调提供的是有状态服务，状态是空调当前温度。2、若空调遥控器发送的是加一或减一之后的温度数值，空调根据接收到的温度数值设置温度，则空调提供的是无状态服务。


Restful 通信风格


2、Eureka 注册中心
应用微服务化之后，首先遇到的第一个问题就是服务发现问题，一个微服务如何发现其他微服务呢？最简单的方式就是每个微服务里面配置其他微服务的地址，但是当微服务数量众多的时候，这样做明显不现实。所以需要使用到微服务架构中的一个最重要的组件：服务注册中心，所有服务都注册到服务注册中心，同时也可以从服务注册中心获取当前可用的服务清单。
2.1、注册中心概念
注册中心可以理解为微服务架构中的“通讯录”。它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其他服务时，就到这里找到服务的地址，进行调用。
张三办了张新的电话卡并将号码告诉我，我将其名字和号码的映射保存进通讯录。              -- 服务注册
我想给张三打电话，于是在通讯录中根据其名字找到张三，然后根据映射到的电话号码拨打       -- 服务发现
---------------------------------------------------------
上例中我和张三分别代表一个微服务，通讯录是独立于我和张三的服务注册中心
总结：服务注册中心的作用就是服务的注册和服务的发现。
2.2、Eureka 入门案例
1、创建一个 SpringBoot 项目并引入web、test和下方两个依赖 。
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-dependencies</artifactId>
    <version>2020.0.4</version>
    <type>pom</type>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
    <version>3.0.4</version>
</dependency>
2、application.yaml 如下
server:
  port: 8761               # 官方文档使用的端口

spring:
  application:
    name: eureka-server    # 应用名称

# 配置 eureka-server 注册中心
eureka:
  instance:
    hostname: localhost              # 主机名，默认根据操作系统的主机名获取
  client:
    # 下方值为 false 的两项，只有当自身为单节点的注册中心时才需要设置为 false 。
    # 单节点指的是只有一个注册中心，不是只有一个微服务。
    # 当自身是微服务或者是集群中的注册中心之一时无需设置，使用默认 true。
    register-with-eureka: false      # 是否将自己注册到注册中心，默认为 true
    fetch-registry: false            # 是否从注册中心获取服务注册信息，默认 true
    service-url:                     # 注册中心对外暴露的注册地址
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
3、启动类前添加 @EnableEurekaServer 注解"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ethereal-lu.github.io/posts/"},{"@type":"ListItem","position":2,"name":"微服务学习笔记","item":"https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"微服务学习笔记","name":"微服务学习笔记","description":"1、微服务架构介绍 1.1、微服务概念 微服务就是将一个单体架构的应用按业务划分为一个个独立运行的程序即服务，他们之间通过 HTTP 协议进行通信（也可以采用消息队列来通信，如 RabbotMQ、Kafaka 等），可以采用不同的编程语言，使用不同的存储技术，自动化部署（如Jenkins）减少人为控制，降低出错概率。服务数量越多，管理起来越复杂，因此采用集中化管理。例如 Eureka，Zookeeper 等都是比较常见的服务集中化管理框架。\n微服务是一种架构风格。有两个特点：\n职责单一：一个微服务解决一个业务问题（注意是一个业务问题而不是一个接口）。 面向服务：将自己的业务能力封装并对外提供服务，这是继承SOA的核心思想，一个微服务本身也可能调用其它的微服务。 1.2、微服务设计原则 AKF 拆分原则\n前后端分离原则\n无状态服务\n状态：如果一个数据需要被多个服务共享，才能完成一笔交易，那么这个数据被称为状态。进而依赖这个状态数据的服务被称为有状态服务，反之称为无状态服务。\n例如对空调的设置：1、若空调遥控器发送加一或减一的指令，空调根据现在的温度计算并调整温度，则空调提供的是有状态服务，状态是空调当前温度。2、若空调遥控器发送的是加一或减一之后的温度数值，空调根据接收到的温度数值设置温度，则空调提供的是无状态服务。\nRestful 通信风格\n2、Eureka 注册中心 应用微服务化之后，首先遇到的第一个问题就是服务发现问题，一个微服务如何发现其他微服务呢？最简单的方式就是每个微服务里面配置其他微服务的地址，但是当微服务数量众多的时候，这样做明显不现实。所以需要使用到微服务架构中的一个最重要的组件：服务注册中心，所有服务都注册到服务注册中心，同时也可以从服务注册中心获取当前可用的服务清单。\n2.1、注册中心概念 注册中心可以理解为微服务架构中的“通讯录”。它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其他服务时，就到这里找到服务的地址，进行调用。\n张三办了张新的电话卡并将号码告诉我，我将其名字和号码的映射保存进通讯录。 -- 服务注册 我想给张三打电话，于是在通讯录中根据其名字找到张三，然后根据映射到的电话号码拨打 -- 服务发现 --------------------------------------------------------- 上例中我和张三分别代表一个微服务，通讯录是独立于我和张三的服务注册中心 总结：服务注册中心的作用就是服务的注册和服务的发现。\n2.2、Eureka 入门案例 1、创建一个 SpringBoot 项目并引入web、test和下方两个依赖 。\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2020.0.4\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-server\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2、application.yaml 如下\nserver: port: 8761 # 官方文档使用的端口 spring: application: name: eureka-server # 应用名称 # 配置 eureka-server 注册中心 eureka: instance: hostname: localhost # 主机名，默认根据操作系统的主机名获取 client: # 下方值为 false 的两项，只有当自身为单节点的注册中心时才需要设置为 false 。 # 单节点指的是只有一个注册中心，不是只有一个微服务。 # 当自身是微服务或者是集群中的注册中心之一时无需设置，使用默认 true。 register-with-eureka: false # 是否将自己注册到注册中心，默认为 true fetch-registry: false # 是否从注册中心获取服务注册信息，默认 true service-url: # 注册中心对外暴露的注册地址 defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ 3、启动类前添加 @EnableEurekaServer 注解\n","keywords":[],"articleBody":"1、微服务架构介绍 1.1、微服务概念 微服务就是将一个单体架构的应用按业务划分为一个个独立运行的程序即服务，他们之间通过 HTTP 协议进行通信（也可以采用消息队列来通信，如 RabbotMQ、Kafaka 等），可以采用不同的编程语言，使用不同的存储技术，自动化部署（如Jenkins）减少人为控制，降低出错概率。服务数量越多，管理起来越复杂，因此采用集中化管理。例如 Eureka，Zookeeper 等都是比较常见的服务集中化管理框架。\n微服务是一种架构风格。有两个特点：\n职责单一：一个微服务解决一个业务问题（注意是一个业务问题而不是一个接口）。 面向服务：将自己的业务能力封装并对外提供服务，这是继承SOA的核心思想，一个微服务本身也可能调用其它的微服务。 1.2、微服务设计原则 AKF 拆分原则\n前后端分离原则\n无状态服务\n状态：如果一个数据需要被多个服务共享，才能完成一笔交易，那么这个数据被称为状态。进而依赖这个状态数据的服务被称为有状态服务，反之称为无状态服务。\n例如对空调的设置：1、若空调遥控器发送加一或减一的指令，空调根据现在的温度计算并调整温度，则空调提供的是有状态服务，状态是空调当前温度。2、若空调遥控器发送的是加一或减一之后的温度数值，空调根据接收到的温度数值设置温度，则空调提供的是无状态服务。\nRestful 通信风格\n2、Eureka 注册中心 应用微服务化之后，首先遇到的第一个问题就是服务发现问题，一个微服务如何发现其他微服务呢？最简单的方式就是每个微服务里面配置其他微服务的地址，但是当微服务数量众多的时候，这样做明显不现实。所以需要使用到微服务架构中的一个最重要的组件：服务注册中心，所有服务都注册到服务注册中心，同时也可以从服务注册中心获取当前可用的服务清单。\n2.1、注册中心概念 注册中心可以理解为微服务架构中的“通讯录”。它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其他服务时，就到这里找到服务的地址，进行调用。\n张三办了张新的电话卡并将号码告诉我，我将其名字和号码的映射保存进通讯录。 -- 服务注册 我想给张三打电话，于是在通讯录中根据其名字找到张三，然后根据映射到的电话号码拨打 -- 服务发现 --------------------------------------------------------- 上例中我和张三分别代表一个微服务，通讯录是独立于我和张三的服务注册中心 总结：服务注册中心的作用就是服务的注册和服务的发现。\n2.2、Eureka 入门案例 1、创建一个 SpringBoot 项目并引入web、test和下方两个依赖 。\norg.springframework.cloud spring-cloud-dependencies 2020.0.4 pom runtime org.springframework.cloud spring-cloud-starter-netflix-eureka-server 3.0.4 2、application.yaml 如下\nserver: port: 8761 # 官方文档使用的端口 spring: application: name: eureka-server # 应用名称 # 配置 eureka-server 注册中心 eureka: instance: hostname: localhost # 主机名，默认根据操作系统的主机名获取 client: # 下方值为 false 的两项，只有当自身为单节点的注册中心时才需要设置为 false 。 # 单节点指的是只有一个注册中心，不是只有一个微服务。 # 当自身是微服务或者是集群中的注册中心之一时无需设置，使用默认 true。 register-with-eureka: false # 是否将自己注册到注册中心，默认为 true fetch-registry: false # 是否从注册中心获取服务注册信息，默认 true service-url: # 注册中心对外暴露的注册地址 defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ 3、启动类前添加 @EnableEurekaServer 注解\n@EnableEurekaServer @SpringBootApplication public class EurekaServerApplication { public static void main(String[] args) { SpringApplication.run(EurekaServerApplication.class); } } 4、启动后访问 http://localhost:8761/ 便会显示 eureka 页面。\n2.3、高可用 eureka 注册中心搭建 2.3.1、搭建注册中心 创建两个 2.2 的注册中心，url不能相同，即若两个注册中心在同一台主机上，则端口号不能相同，若在不同主机上端口号可以相同。两个注册中心只有 yaml 主配置文件不同，分别如下，其他相同。\n# server01 server: port: 8761 # 端口 spring: application: name: eureka # 应用名称(集群下相同） # 配置 eureka-server 注册中心 eureka: instance: hostname: server01 # 主机名，默认根据操作系统的主机名获取 client: # 将服务注册中心地址指向另一个服务中心 service-url: # 注册中心对外暴露的注册地址 defaultZone: http://localhost:8762/eureka/ # ------------------------------------------------ # server02 server: port: 8762 # 端口 spring: application: name: eureka # 应用名称(集群下相同） # 配置 eureka-server 注册中心 eureka: instance: hostname: server02 # 主机名，默认根据操作系统的主机名获取 client: # 将服务注册中心地址指向另一个服务中心 service-url: # 注册中心对外暴露的注册地址 defaultZone: http://localhost:8761/eureka/ 注意：两个注册中心要同时启动，否则在 springboot 启动后无法检测到另一个注册中心使得 eureka 抛异常。\n此时再访问 http://localhost:8761/ 或 http://localhost:8762/ 就会看到两个注册中心。\neureka 实例可以作为服务提供者也可以作为注册中心。其默认ID为 “主机名:应用名:端口”，如“localhost:eureka:8761 ”。可以通过下方配置将其设置为ip:port 。一般都使用 ip：port 的方式。\neureka: instance: prefer-ip-address: true # 是否使用 ip 注册地址 instance-id: ${spring.cloud.client.ip-address}:${server.port} # ip:port 2.3.2、搭建 service-provider 1、新建 SpringBoot 项目并引入依赖\norg.springframework.cloud spring-cloud-starter-netflix-eureka-client 2、主配置文件如下\nserver: port: 7070 # 微服务的端口 spring: application: name: service-provider # 应用名称 # 配置 eureka 注册中心 eureka: instance: prefer-ip-address: true # 是否使用 ip 注册地址 instance-id: ${spring.cloud.client.ip-address}:${server.port} # ip:port client: service-url: # 设置服务注册中心地址，即 将微服务注册到哪里 defaultZone: http://localhost:8761/eureka/, http://localhost:8762/eureka/ 3、创建 entity、service、impl、controller 任意实现一个功能接口。\n4、可以正常访问该微服务提供的接口\n5、访问 http://localhost:8761 可以看到两个注册中心和一个名为 service-provider 的微服务。\n2.3.3、搭建 service-consumer 1、新建 SpringBoot 项目并引入依赖\norg.springframework.cloud spring-cloud-starter-netflix-eureka-client 2、主配置文件如下\n由于该纯粹的消费者没有注册到注册中心，故访问 http://localhost:8761 时不会显示该消费者的信息。\nserver: port: 9090 spring: application: name: service-consumer # 应用名称 # 配置 eureka 注册中心 eureka: client: # 是否将自己注册到注册中心，默认为 true。此处只作为消费者调用微服务，并不提供服务，故不注册。 register-with-eureka: false # 表示 eureka client 间隔多久到注册中心获取注册信息，默认 30 秒。 registry-fetch-interval-seconds: 10 service-url: # 设置服务注册中心地址，即 去哪里寻找微服务 defaultZone: http://localhost:8761/eureka/, http://localhost:8762/eureka/ 3、服务消费者有三种访问服务的方法：DiscoveryClient、LoadBalancerClient、@LoadBalanced。这三种方法从左到右依次越来越方便使用。下方只展示第三种使用方法。\n主启动类 @SpringBootApplication public class ServiceConsumerApplication { public static void main(String[] args) { SpringApplication.run(ServiceConsumerApplication.class, args); } // SpringMVC 没有集成 RestTemplate ，所以这里需要手动添加到 IOC 容器中。 @Bean @LoadBalanced // 负载均衡注解 public RestTemplate restTemplate() { return new RestTemplate(); } } serviceImpl类 @Service public class OrderServiceImpl implements OrderService { // RestTemplate 简化了发起 HTTP 请求以及处理响应的过程，并且支持 REST 。 @Autowired private RestTemplate restTemplate; @Override public Order selectOrderById(Integer id) { return new Order(id, \"1\", \"China\", 76598D, selectProductList()); } private List\u003cProduct\u003e selectProductList() { // service-provider 的某 Controller 下 @GetMapping(\"/product/list\") 提供服务。 // 由于返回结果为泛型，故只能使用 exchange 方法。ResponseEntity 封装了状态码、返回体等。 ResponseEntity\u003cList\u003cProduct\u003e\u003e responseEntity = restTemplate.exchange( \"http://service-provider/product/list\", // 服务名 + 路径 HttpMethod.GET, null, new ParameterizedTypeReference\u003c\u003e() {}); return responseEntity.getBody(); // getBody() 返回 返回体 } } 其他的 pojo 和 controller 都很常规。至此，完整的 Eureka 微服务体系完成。\n2.4、Eureka 架构原理 Replicate 表示多个注册中心之间的数据同步。\n2.5、CAP 原则 C 为保证数据一致性，是强一致性，即任何时候读取的都是最新的数据，类似于数据库的当前读；\nA 为服务高可用即快速响应；\nP 为分区容错，是分布式的固有属性。\n任何时候，只能在 CP , AP , CA 中三选一，不可能同时满足三个。\nCA 不能实现分布式。一般用于规模小，不打算扩展的应用。MySQL\nAP 不能实现一致性。一般是前几步操作满足快速响应，后续实现一致性。金融领域绝对不允许使用AP。\nCP 不能实现快速响应。分布式数据库，如 Redis、MongoDB 等。\n2.6、Eureka 自我保护 2.6.1、启动自我保护条件 一般情况下，服务在 Eureka 上注册后，会每 30 秒发送一个心跳包，Eureka 通过心跳来判断服务是否健康，同时定期删除超过 90 秒没有发送心跳的服务。\n但是 Eureka 收不到心跳不只是微服务自身的原因，还有可能是微服务与 Eureka 之间的网络故障引起。\n因此 Eureka 会在运行期间去统计心跳失败比例是否在 15 分钟之内低于 85%，如果低于 85% Eureka 会将这些服务保护起来，同时提示一个警告。这种算法就是 Eureka 的自我保护模式。\n2.6.2、如何关闭自我保护 eureka: server: enable-self-preservation: false # true 开启自我保护机制（默认），false 关闭 eviction-interval-timer-in-ms: 60000 # 清理间隔（毫秒） 2.7、eureka 优雅停服 配置优雅停服后，无需关闭自我保护。\n1、在服务提供者 service-provider 中添加依赖\norg.springframework.boot spring-boot-starter-actuator 2、在 service-provider 的配置文件中添加下方配置\n# 度量指标监控与健康检查 management: endpoints: web: exposure: include: shutdown # 开启 shutdown 端点访问 endpoint: shutdown: enabled: true # 开启 shutdown 实现优雅停服 配置完成后，使用 POST 访问 http://localhost:7070/actuator/shutdown 即可实现停止服务器。\n2.8、eureka 安全认证 只有经过授权才可以在注册中心注册服务或拉取服务。\n1、在所有的注册中心添加依赖\norg.springframework.boot spring-boot-starter-security 2、在所有的注册中心配置安全认证\nspring: # 安全认证 security: user: name: root password: root 3、在所有的注册中心、服务提供者、服务消费者重新配置注册中心地址\n# 配置 eureka 注册中心 eureka: client: service-url: # 这里有疑问，全部设置为静态的 name:password@url 太不方便了吧 defaultZone: http://root:root@localhost:8761/eureka/, http://root:root@localhost:8762/eureka/ 仅配置完这些，访问 http://http://localhost:8761/ 并登陆后会发现没有任何注册中心和服务，这是因为都被 CSRF 拦截了。\n4、过滤 CSRF\neureka 会自动化配置 CSRF 防御机制， Spring Security 认为 POST , PUT , DELETE 都是有风险的，如果这些 method 发送时没有带上 CSRF token 就会被拦截并返回 403。\n方案一：使 CSRF 忽略 /eureka/** 的所有请求。\n在所有注册中心的 config 包中添加如下配置类。\n@EnableWebSecurity public class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { super.configure(http); // 加这句是为了访问 eureka 注册中心和 /actuator 时安全控制 http.csrf().ignoringAntMatchers(\"/eureka/**\"); // 使 csrf 忽略 /eureka/** } } 方案二：禁用 CSRF 防御机制\n在所有注册中心的 config 包中添加如下配置类。\n@EnableWebSecurity public class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { // 直接 disable 会把安全验证也禁用掉。 http.csrf().disable().authorizeRequests() .anyRequest() .authenticated() .and() .httpBasic(); } } 3、Ribbon 3.1、Ribbon 的概念 Ribbon 是一个基于 HTTP 和 TCP 的客户端负载均衡工具，它不需要像注册中心、网关那样独立部署，但是几乎存在于每个 Spring Cloud 微服务中。 Feign 提供的声明式服务调用也是基于 Ribbon 实现的。\nRibbon 提供了一套微服务的负载均衡解决方案。\n负载均衡即当多个节点提供相同的服务时，选择其中一个提供服务，使得服务器整体的负载平衡。\n3.2、负载均衡分类 业界主流负载均衡分为两类：\n集中式负载均衡（服务器负载均衡），即在 consumer 和 provider 之间使用独立的负载均衡设施，如 Nginx 进程内负载均衡（客户端负载均衡），即将负载均衡逻辑集成到 consumer ，如 Ribbon 3.3、Ribbon 负载均衡策略 3.3.1、轮询策略（默认） 对应类名：RoundRobinRule\n原理：即按顺序选取下一个\n3.3.2、权重轮询策略 对应类名：WeightedResponseTimeRule\n原理：响应时间越快的被选中的概率越大\n3.3.3、随机策略 对应类名：RandomRule\n原理：随便选一个\n3.3.4、最少并发数策略 对应类名：BestAvailableRule\n原理：找并发数最少的 provider\n3.3.5、重试策略 对应类名：RetryRule\n原理：轮询策略的加强版，如果失败会重新尝试其他节点。\n3.3.6、可用性敏感策略 对应类名：AvailabilityFilteringRule\n原理：过滤掉连接失败和高繁忙的节点\n3.3.7、区域敏感性策略 对应类名：ZoneAvoidanceRule\n原理：对一个区域考察，丢弃不可用区域的 provider。\n3.4、Ribbon 入门案例 Ribbon 对于集群的服务采用的负载均衡策略默认为轮询模式。\n在 eureka 项目的基础上复制一份 service-provider 命名为 service-provider02 ，将 service-provider02 的端口设置为7071，应用名依然为 service-provider 。即现在存在提供完全相同服务的两个站点。将注册中心和服务提供者都启动后显示如下：\n可以看到有两个集群，一个是由两个注册中心组成的集群，一个是由微服务组成的集群。\n当 service-consumer 调用 service-provider 时就会在微服务集群中按顺序轮询访问节点。\n3.5、Ribbon 负载均衡策略设置 3.5.1、全局 在启动类或配置类中注入负载均衡策略对象。所有服务请求都使用该策略。例如：在启动类添加如下代码。\n@Bean public RandomRule randomRule() { return new RandomRule(); } 3.5.2、局部 在 service-consumer 的配置文件中添加如下：\n# 负载均衡策略 # service-provider 为调用的微服务的名称 service-provider: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 3.6、Ribbon 点对点直连 点对点直连是指绕过注册中心，直接连接服务提供者获取服务。一般在测试阶段使用较多，在测试阶段每次都要所有全部启动太麻烦，点对点直连可以不用启动注册中心。\n1、将 service-consumer 中 eureka 的依赖和配置都注释掉，并引入依赖\norg.springframework.cloud spring-cloud-starter-netflix-ribbon 2.2.9.RELEASE 2、在 service-consumer 的主配置文件中添加如下配置\n# 负载均衡策略 # service-provider 为调用的微服务的名称 service-provider: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 制定具体的 provider 列表，多个用逗号隔开 listOfServers: http://localhost:7070, http://localhost:7071 # 关闭 eureka 实现点对点直连 ribbon: eureka: enabled: false 配置完成后只启动 service-provider 和 service-consumer ，此时 service-consumer 依然可以正常访问 service-provider。\n4、Feign 4.1、Feign 的概念 Feign 是 SpringCloud Netflix 组件中的一个轻量级 RESTful 的 HTTP 客户端，实现了负载均衡和Rest 调用的开源框架，封装了 Ribbon 和 RestTemplate ，实现了 WebService 的面向接口编程，进一步降低了项目的耦合度。\nFeign内置了 Ribbon ，因此客户端可以负载均衡地调用服务注册中心的服务。\n在 2.2.3 节提及了三种消费者调用服务的方法，Feign 其实就是一种比它们更简单的调用方法。\nFeign 是一种声明式、模板化的 HTTP 客户端\nFeign 的使用方式是：使用 Feign 的注解定义接口，调用这个接口就可以调用服务注册中心的服务。\n4.2、Feign 入门案例 保留 Eureka 项目中的所有注册中心和所有 service-provider，并只保留下 Eureka 的依赖与配置，且将多余的安全认证、健康检查等依赖与配置全部删除。\nFeign 的基本使用步骤：\n服务消费者添加 Feign 依赖； 创建业务层接口，添加 @FeignClient 注解声明需要调用的服务； 业务层抽象方法使用 SpringMVC 注解配置服务地址及参数； 启动类添加 @EnableFeignClients注解激活 Feign 组件。 按照上面步骤举例：\n1、创建 feign-consumer 模块\n2、在 feign-consumer 中添加依赖\norg.springframework.cloud spring-cloud-starter-netflix-eureka-client org.springframework.cloud spring-cloud-starter-openfeign 3、在 feign-consumer 的主配置文件中添加配置\nserver: port: 9090 spring: application: name: feign-consumer # 配置 eureka 注册中心 eureka: client: # 是否将自己注册到注册中心，默认为 true。此处只作为消费者调用微服务，并不提供服务，故不注册。 register-with-eureka: false # 表示 eureka client 间隔多久到注册中心获取注册信息，默认 30 秒。 registry-fetch-interval-seconds: 10 service-url: # 设置服务注册中心地址，即 去哪里寻找微服务 defaultZone: http://localhost:8761/eureka/, http://localhost:8762/eureka/ 4、 feign-consumer 的逻辑为 OrderController 调用 OrderService，OrderService 的实现类 OrderServiceImpl 中远程调用 service-provider 提供的服务完成业务逻辑。实现远程调用的方式为新建一个接口且由 @FeignClient修饰，该接口会调用远程服务，其不需要实现类。下方代码中名称为 service-provider 的服务在 /product/list 路径下提供了 OrderServiceImpl 所需的服务。\n// 声明需要调用的服务 ， 括号内的值为 服务名 @FeignClient(\"service-provider\") public interface ProductService { // 配置需要调用的服务路径及参数，这里也可以使用 @PathVariable 等注解。 @GetMapping(\"/product/list\") List\u003cProduct\u003e selectProductList(); // 调用该方法就会远程调用相应服务 } 5、 OrderServiceImpl 代码如下\n@Service public class OrderServiceImpl implements OrderService { @Autowired private ProductService productService; // 由 @FeignClient 修饰的接口 @Override public Order selectOrderById(Integer id) { return new Order(id, \"1\", \"China\", 76598D, productService.selectProductList()); } } 6、在启动类添加 @EnableFeignClients 注解启动 Feign 组件。\n@EnableFeignClients @SpringBootApplication public class FeignConsumerApplication { public static void main(String[] args) { SpringApplication.run(FeignConsumerApplication.class, args); } } 完成上述步骤就可以正常访问了。\n4.3、Feign 负载均衡 Feign 封装了 Ribbon 自然也就集成了负载均衡功能，默认采用轮询策略。修改负载均衡策略的方法与 Ribbon 相同。\n4.3.1、全局 在启动类或配置类中注入负载均衡策略对象。所有服务请求都使用该策略。例如：在启动类添加如下代码。\n@Bean public RandomRule randomRule() { return new RandomRule(); } 4.3.2、局部 在 service-consumer 的主配置文件中添加如下：\n# 负载均衡策略 # service-provider 为调用的微服务的名称 service-provider: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 4.4、Feign 请求传参 GET ——\u003e 使用 @PathVariable或@RequestParam接收参数。\nPOST ——-\u003e 使用@RequestBody注解接收请求参数。\n// 声明需要调用的服务 ， 括号内的值为 服务名 @FeignClient(\"service-provider\") public interface ProductService { // 配置需要调用的服务路径及参数 @GetMapping(\"/product/list\") List\u003cProduct\u003e selectProductList(); // 这里是调用 selectProductById 方法并向其传参，再根据参入的参数进行远程调用，感觉和平时使用相反 @GetMapping(\"/product/{id}\") Product selectProductById(@PathVariable(\"id\") Integer id); // @RequestBody 是将接收到的json解析为对象，这里是将 product 参数传递到 service-provider // 所以 @RequestBody 只需在 service-provider ，这里不用 @RequestBody。 @PostMapping(\"/product/add\") Response\u003cDefaultVo\u003e addProduct(Product product); } 4.5、Feign 性能调优 4.5.1、gzip 压缩 gzip 是一种数据格式，采用 deflate 算法压缩数据，当压缩一个纯文本（html、css等）时能减少 70% 空间，显然网络数据经过 gzip 压缩后的传输更快。\nHTTP协议关于压缩传输的规定：\n1、客户端向服务器请求中带有: Accept-Encoding:gzip ，deflate 字段，向服务器表示客户端支持的压缩格式(gzip 或者deflate)，如果不发送该消息头，服务端默认是不会压缩的。\n2、服务端在收到请求之后，如果发现请求头中含有Accept-Encoding 字段，并且支持该类型压缩，就会对响应报文压缩之后返回给客户端，并且携带Content- Encoding:gzip消息头，表示响应报文是根据该格式进行压缩的。\n3、客户端接收到请求之后，先判断是否有Content-Encoding 消息头，如果有，按该格式解压报文。否则按正常报文处理。\n局部开启 gzip 压缩\n# service-consumer 的主配置文件添加下方配置 # 局部开启 gzip 压缩，即只开启 service-provider 和 service-consumer 之间的 gzip 压缩， # 不开启浏览器与 service-consumer 之间的压缩。 # feign gzip 压缩配置 feign: compression: request: enabled: true # 请求开启 gzip 压缩 mime-types: text/xml, application/xml, application/json # 压缩支持的 MIME TYPE，默认支持 min-request-size: 512 # 压缩数据的最小阈值，默认 2048，即只有响应数据大于该值才执行压缩 response: enabled: true # 响应开启 gzip 压缩 全局开启 gzip 压缩\n# service-consumer 的主配置文件添加下方配置 # 全局开启 gzip 压缩，即 service-provider 和 service-consumer 之间以及 # 浏览器与 service-consumer 之间都开启 gzip 压缩。 server: port: 9090 compression: enabled: true # 下方这句可以不写，默认都支持 mime-types: application/json, application/xml, text/html, text/xml, text/plain 4.5.2、HTTP 连接池 两台服务器之间建立 HTTP 连接的过程很复杂，而微服务之间远程调用可能比较频繁却又只传输少量数据，因此大部分时间被浪费在建立连接上。\n采用 HTTP 连接池可以节省大量的 3 次握手 4 次挥手，从而提升吞吐量。\nFeign 的 HTTP 客户端支持 3 种框架：HttpURLConnection、HttpClient、OkHttp。默认是 HttpURLConnection，但 HttpURLConnection 是 JDK 自带的，不支持 HTTP 连接池，需要手写。\nHttpClient 支持 HTTP 连接池且使得 HTTP 请求简化，HttpClient 还支持通过 get 请求传递对象参数，因此推荐使用 HttpClient 。\nHttpClient 使用步骤如下：\n1、在 service-consumer 中引入依赖\norg.apache.httpcomponents httpclient io.github.openfeign feign-httpclient 11.0 2、在 service-consumer 的主配置文件中添加如下配置\nfeign: httpclient: enabled: true # 开启 httpclient 只要完成上述步骤，我们在代码层面不需要做任何改变，就已经开始使用 HTTP 连接池了。\n5、Nacos Nacos 也是注册中心，是阿里的产品，比 Eureka 的功能更丰富。\nEureka 的注册中心需要自己创建，Nacos 的注册中心独立出来需要下载，安装并开启后可直接使用。\n5.1、Nacos 使用指南 5.1.1、开启注册中心 1、在 https://github.com/alibaba/nacos/releases/tag/1.4.2 下载 nacos ，选择 1.xx 版本。\n2、进入 nacos 的 bin 目录，打开 cmd，输入 startup.cmd -m standalone以单节点模式开启 nacos 。\n5.1.2、配置微服务 1、在父工程中引入依赖，用以控制阿里系列产品的版本。\ncom.alibaba.cloud spring-cloud-alibaba-dependencies 2.2.6.RELEASE pom import 2、在微服务中引入依赖\ncom.alibaba.cloud spring-cloud-starter-alibaba-nacos-discovery 3、在微服务的主配置文件配置注册中心地址\nserver: port: 7070 spring: application: name: service-provider # 应用名称 cloud: nacos: server-addr: localhost:8848 # nacos 注册中心地址 # discovery: 这里只有是纯消费者才需要配置 # register-enabled: false # 纯消费者不用注册到注册中心 4、访问 http://localhost:8848/nacos/index.html ，用户名和密码都是 nacos ，登陆进去即可查看注册中心。\n5.2、Nacos 服务分级存储模型 一个服务可以有多个实例，出于容灾考虑将这些实例分散于不同的城市（地区）。Nacos 将处于同一个城市的所有实例组成一个集群，存储模型如下图：一级为服务（Userservice）、二级为集群(Beijing)、三级为实例(运行该服务的某台主机)。\n![Nacos 服务分级存储模型](Nacos 服务分级存储模型.jpg)\n服务跨集群调用问题\n由于集群间距离太远，传输延时很高，因此一个服务调用另一个服务时，应该尽可能地调用本地集群中的服务，只有当本地集群中的服务不可用时才去跨集群调用服务。\n配置服务集群属性\nspring: application: name: service-provider # 应用名称 cloud: nacos: server-addr: localhost:8848 # nacos 注册中心地址 discovery: cluster-name: Beijing # 集群名称 由于 nacos 集成 ribbon 以实现负载均衡，因此仅配置集群名称后服务间调用仍然采用 ribbon 默认的轮询策略，故需要在调用者的主配置文件中修改 ribbon 的负载均衡规则来实现集群内优先调用。\n# service-provider 是被调用的微服务的名称 service-provider: ribbon: NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # 负载均衡规则 NacosRule 会优先访问本地集群中的服务，只有本地集群内该服务的所有实例都不能使用后才会跨集群访问，同时报出跨集群访问的警告，在确定访问的集群后会在集群内的多个实例之间采用随机的方式访问。\n5.3、根据权重负载均衡 由于设备更新出现设备间性能差异问题，性能好的设备应该承担更多访问压力，此时可以配置实例的权重，权重越大被访问的频率越高。（权重一般在 0 ~ 1 之间，默认为 1）\n配置方法：进入 nacos 控制台 -》服务管理 -》 服务列表 -》点击服务的详情 -》点击具体实例中的编辑 -》输入权重。\n在控制台配置完就可以了，源代码无需做任何改变。\n改变权重和改变策略是对负载均衡的不同层面的配置。\n配置权重是在被调用者的 nacos 控制台配置。\n配置负载均衡策略是在调用者的主配置文件配置。\n改变权重是改变访问的频率，访问策略仍然是在调用者的配置文件中配置的策略。如上方配置负载均衡策略为 NacosRule 后，访问时仍然是尽可能地访问本地集群中的实例，只是在本地集群中的众多实例中选择时选择权重更大的概率高一点。\n如果把权重设置为 0 ，则该实例完全不会被访问，基于此可以实现服务的平滑升级。即一个服务有多个实例，先把一个实例的权重设为 0，然后升级重启，再改回 1，之后对其他实例逐个进行此操作。\n5.4、环境隔离 namespace nacos 即是服务注册中心也是数据中心。\nnacos 的隔离级别从上往下依次是 namespace 、group、service/data、集群、实例。\nnamespace是最外层的隔离。\n产品的开发环境、测试环境、发布环境等由 namespace 层隔离。功能衔接较紧密的服务（如订单和支付）可以划分到一个 group、之后的三层在存储模型中已经写过。\n以上的这些隔离级别都是 nacos 提供的功能，可以使用但不强制使用。\n配置环境隔离\n默认的 namespac 为 自动生成的 public。可以在 nacos 控制台的命名空间中新建命名空间，新建完成会自动生成命名空间 ID，之后在被调用者的主配置文件中配置命名空间。\nspring: cloud: nacos: server-addr: localhost:8848 # nacos 注册中心地址 discovery: namespace: 56df4de5-b390-4799-9ce4-0002dfb14872 # 命名空间 ID 之后重启该服务即可。隶属于不同命名空间中的服务之间相互不可见，因此不能相互调用。\n5.5、nacos 和 eureka 的区别 两者都是注册中心，注册中心的基本功能就是服务提供者向注册中心注册信息，服务消费者从注册中心定期拉取这些信息，然后服务消费者远程访问服务提供者提供的服务。\n![nacos 细节](nacos 细节.jpg)\n健康检查：eureka 中所有实例都定期发送心跳，注册中心根据心跳检测是否存活。nacos 将实例分为临时实例和非临时实例，临时实例和 eureka 相同都是检测心跳，若没有心跳则直接删除。非临时实例不发送心跳，而是注册中心定期主动询问是否存活，若不存活也不删除而是等待其再次恢复。\n消息更新：eureka 只有服务消费者定期从注册中心拉取信息。而 nacos 除了每 30 秒拉取一次外，为了防止在拉取期间服务停掉导致的错误，当服务提供者的信息改变（如死亡）时会主动向服务消费者推送变更的信息。\nnacos 集群默认采用 AP 方式，当集群中存在非临时实例时，采用 CP 方式。 eureka 只有 AP 方式。\n设置非临时实例\nnacos 默认所有实例都是临时实例。非临时实例需要在主配置文件中配置。非临时实例对服务器的压力较大。\nspring: cloud: nacos: server-addr: localhost:8848 # nacos 注册中心地址 discovery: ephemeral: false # 非临时实例 5.6、nacos 配置管理 一个项目可能有成百上千的微服务组成，有一些微服务的部分配置是相同的，如果这些配置要更改则要对每个微服务都修改，然后重新部署，这样不仅费时还可能对整个业务造成影响。\n可以将这些相同的配置摘取出来统一配置管理，微服务读取统一配置和本地配置组成完整配置。当统一配置改变时可以通知各微服务，让其读取新配置，这样就可以实现配置热更新。\n5.6.1、统一配置管理实现 一、新建统一配置\n打开 nacos 控制台 -》配置管理 -》配置列表 -》点加号进入新建配置\nData ID 必须唯一，一般为 微服务名 - 环境.yaml。例如 userservice-dev.yaml。group 默认，格式选 yaml。并不是所有配置都复制上去，只添加有热更新需求的配置（如关键参数、运行时需要调整的参数）。\n二、发现配置管理地址\n不涉及统一配置管理时，springboot 启动顺序为 启动 springboot -》 读取本地 application.yaml 配置文件 -》 创建 IOC 容器 -》 加载 bean。\n添加统一配置管理后，springboot 启动顺序为 启动 springboot -》读取统一配置管理的配置文件 -》读取本地 application.yaml 配置文件 -》 创建 IOC 容器 -》 加载 bean。\n如果把统一配置管理的地址等信息配置到本地 application.yaml 配置文件时，则按照上述启动顺序我们无法在读取统一配置管理的配置文件前知道其地址在哪里。springboot 提供一个 bootstrap.yaml 文件，其启动顺序非常靠前，因此可以把统一配置管理的地址信息放在该文件中。具体做法如下：\n1、引入 nacos 的配置管理客户端依赖\ncom.alibaba.cloud spring-cloud-starter-alibaba-nacos-config 2、在微服务的 resources 目录下新建 bootstrap.yaml 文件，这是引导文件，优先级高于 application.yaml。\n# bootstrap.yaml spring: application: name: service-provider # 应用名称 profiles: active: dev # 开发环境 cloud: nacos: server-addr: localhost:8848 # nacos 注册中心地址 config: file-extension: yaml # 文件名后缀 config: import: - optional:nacos:application.yaml # 将 nacos 统一配置的 application.yaml 拉到本地 上方在控制台新建配置时，Data ID 的命名规范即为 应用名称-开发环境.yaml，因此该文件中的信息恰好能唯一地指定配置文件。配置文件的地址即为 nacos 注册中心地址也已经配置。\n3、把 application.yaml 中与 bootstrap.yaml 重复的配置删除并启动服务即可。\n对程序而言，统一配置和本地配置没有任何区别，例如都可以使用 @Value(\"${xxx.xxx}\")来读取配置的信息。\n5.6.2、统一配置自动刷新 完成 5.6.1 的步骤后还需要添加本节的步骤以实现配置的自动刷新。\n假设统一配置文件中包含有下方配置\npattern: dateformat: yyyy-MM-dd HH:mm:ss # 配置日期格式 根据配置注入的两种不同方式，自动刷新也有两种不同实现方式。\n方式一： @Value(\"${xxx.xxx}\") 使用这种方式注入配置时，在使用该种方式的的类前添加 @RefreshScope 注解。\n@Service @RefreshScope public class ProductServiceImpl implements ProductService { @Value(\"${pattern.dateformat}\") private String dateformat; public void print() { System.out.println(LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat))); } } 方式二： @ConfigurationProperties(prefix = \"xxx\") 使用这种方式注入配置时，专门创建一个类来接收配置的注入。推荐使用这种方式\n@Data @Component @ConfigurationProperties(prefix = \"pattern\") public class PatternProperties { private String dateformat; } 使用方法如下：\n@Service public class ProductServiceImpl implements ProductService { @Autowired private PatternProperties patternProperties; public void print() { System.out.println(LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat()))); } } 5.6.3、多环境配置共享 有些参数在开发、测试等环境中都一样，则可以将这些参数摘取出来生成一个配置文件，使其可以在多个环境中共享。\n微服务在启动时会从 nacos 读取多个配置文件：\n[spring.application.name]-[spring.profiles.active].yaml。该配置文件与环境有关，不适配的环境不会加载。 [spring.application.name].yaml。该配置文件与环境无关，任何环境都会加载。 因此可以将相同的参数抽取到 [spring.application.name].yaml 文件中。\n当多个配置文件中含有相同配置项时，配置文件优先级如下，最终结果以优先级高的配置文件为准。\n[spring.application.name]-[spring.profiles.active].yaml \u003e [spring.application.name].yaml \u003e 本地 application.yaml\n5.7、nacos 集群搭建 ![nacos 集群](nacos 集群.jpg)\n上图对 nacos 集群框架简要介绍，部署有三个 nacos 节点，由 nginx 对多个节点负载均衡。\n1、进入 %NACOS_HOME%/conf，将 cluster.conf.example 重命名为 cluster.conf。然后在该文件的末尾加上集群中各节点的ip加端口。如下：\n127.0.0.1:8845\r127.0.0.1:8846\r127.0.0.1:8847 2、将整个 nacos 文件夹复制三份，进入各自的 /conf/application.properties ，将 server.port 分别改为 8845、8846、8847。\n3、在 application.properties 文件中，将下方项都取消注释，并按具体情况做适当修改。如果多个节点连接的同一个数据库，则可以将这一步提前到复制多份文件之前进行。\nspring.datasource.platform # 使用的数据库 db.num # 数据库个数 db.url.0 # url db.user.0 # 用户名 db.password.0 # 密码 4、将多个节点分别启动，即进入各自的 bin 目录，打开cmd运行 startup.cmd\n5、安装 Nginx，打开 conf/nginx.conf 文件，在 http 块的任意区域添加下方配置\nupstream nacos-cluster {\rserver 127.0.0.1:8845;\rserver 127.0.0.1:8846;\rserver 127.0.0.1:8847;\r}\rserver {\rlisten 80;\rserver_name localhost;\rlocation /nacos {\rproxy_pass http://nacos-cluster;\r}\r} 6、启动 Nginx\n7、访问 http://localhost/nacos 即可进入 nacos 控制台，这是 Nginx 负载均衡之后的某个 nacos 节点。\n8、在微服务的配置文件中将注册中心地址改为 localhost:80，启动后即可成功注册。\n6、网关 Gateway 6.1、网关概述 外部浏览器对微服务进行的任何访问请求都必须经过网关。\n网关本身也是一个微服务，因此需要将自己注册进注册中心。\n网关的功能：\n身份认证和权限校验 服务路由和负载均衡 请求限流 网关的技术实现：\n在springcloud中，网关的实现有两种方式\nzuul 。基于 Servlet 实现，属于阻塞式编程。老旧 gateway 。基于 spring5 中的提供的 webflux，属于响应式编程，性能更好。用这个 6.2、搭建网关 1、新建 module 并引入依赖\norg.springframework.cloud spring-cloud-starter-gateway com.alibaba.cloud spring-cloud-starter-alibaba-nacos-discovery 2、服务注册及路由配置\n由于网关本身也是一个微服务，因此需要将自己注册进注册中心。配置如下：\nserver: port: 10010 # 网关端口 spring: application: name: gateway # 服务名称 cloud: nacos: server-addr: localhost:8848 # 注册中心地址 gateway: routes: - id: user-service # 路由 id，自定义，全局唯一 # uri: http://127.0.0.1:8081 # 固定死地址，不推荐使用 # 路由的目标地址，lb 表示负载均衡，后面接服务名。表示由注册中心具体分配服务实例 uri: lb://userservice predicates: # 路由断言，就是判断请求路径是否符合下方路径规则，如果符合就将其路由到uri处理 - Path=/user/** # 表示任何以 /user 开头的路径都由本条路由规则处理 # 可以配置多个路由规则 - id: role-service uri: lb://roleservice predicates: - Path=/role/** 在 routes 下还可以配置过滤器 filter。\n请求发过来后，网关会在 routes 中从上往下依次寻找第一个符合规则的路由处理，如果都没有则报 404。\n6.3、路由断言工厂 在配置文件中写的断言规则只是字符串，这些字符串会被 Predicate Factory 读取并处理，转变为路由判断条件。\n像这样的断言工厂在 spring cloud gateway 中有十几个。\n![Predicate 工厂](Predicate 工厂.jpg)\n绝大部分时候都是使用 Path。\n6.4、过滤器 GatewayFilter 是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的结果做处理。\nspring cloud gateway 提供了 31 中不同的过滤器，可以进行各种各样的过滤操作，具体使用时再看官网。下面以 添加请求头过滤器 举例：\n6.4.1、针对具体路由的过滤器 spring: cloud: gateway: routes: - id: role-service uri: lb://roleservice predicates: - Path=/role/** filters: # 可以配置多个过滤器组成过滤器链 - AddRequestHeader=name,gaolu # 添加请求头。逗号前为键，逗号后为值。 小知识：在 controller 的服务接口中可以通过 @RequestHeader 来获取请求头的值。\n@GetMapping(\"/product/list\") public List\u003cProduct\u003e selectProductList(@RequestHeader(value = \"name\", required = false) String name) { return productService.selectProductList(name); } 如上，就可以获取请求头键为 name 的值为 gaolu 。\n6.4.2、默认过滤器 如果想要将某些过滤器对所有请求都奏效，可以在任意一个微服务中添加下方配置实现。\nspring: cloud: gateway: default-filters: # 默认过滤器，会对所有的路由请求都生效 - AddRequestHeader=name,gaolu # 添加请求头，可以有多个 6.4.3、全局过滤器 全局过滤器与默认过滤器的功能类似，都是作用于进入网关的所有请求和响应。区别是默认过滤器仅仅是在配置文件中选择了一种或几种 springcloud 提供的过滤器，我们无法改变其实现逻辑。如果想要使用自己的过滤器，就需要通过全局过滤器实现。\n全局过滤器的定义方式是实现 GlobalFilter 接口。\n可以用全局过滤器拦截并判断请求的信息。使用举例如下：\n@Order(-1) // 可以设置多个全局过滤器，通过@Order规定这些过滤器执行的顺序。数字越小优先级越高。必须有 @Component public class AuthorizeFilter implements GlobalFilter { @Override public Mono\u003cVoid\u003e filter(ServerWebExchange exchange, GatewayFilterChain chain) { ServerHttpRequest request = exchange.getRequest(); MultiValueMap\u003cString, String\u003e params = request.getQueryParams(); // url中的所有参数 String authorize = params.getFirst(\"authorize\"); if (\"admin\".equals(authorize)) // 如果身份验证通过则执行下一个过滤器 return chain.filter(exchange); exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED); // 设置响应码 return exchange.getResponse().setComplete(); // 终止 } } 6.4.4、过滤器执行顺序 请求进入网关后会遇到三类过滤器：当前路由过滤器，默认过滤器和全局过滤器。\n当请求进入网关后，这三个过滤器会组成过滤器链，依次按照过滤器链的顺序执行每个过滤器。\n每个过滤器都必须指定一个 int 类型的 order 值表示执行顺序，值越小越先执行。\n路由过滤器和默认过滤器的 order 值根据在配置文件中声明的顺序由 springcloud 从小到大排列，从 1 开始。\n全局过滤器过滤器由我们手动通过 @Order 赋予。\n排序时先看 order 值，从小到大执行，当 order 的值相同时，按照 默认过滤器 -\u003e 路由过滤器 -\u003e 全局过滤器的顺序执行。\n6.5、跨域问题 跨域：域名不一致就是跨域。\n浏览器禁止请求的发起者和服务端发生跨域 ajax 请求，这些请求会被浏览器拦截。\n网关跨域处理采用的 CORS 方案，只需要配置文件中配置即可。\nspring: cloud: gateway: globalcors: # 全局跨域处理 add-to-simple-url-handler-mapping: true # 解决 option 请求被拦截的问题 cors-configurations: '[/**]': # 所有的跨域请求都需要符合以下规则 allowedOrigins: # 允许哪些网站的跨域 - \"http://localhost:8090\" - \"http://www.lu.com\" allowedMethods: # 允许跨域请求的方式 - \"GET\" - \"POST\" - \"DELETE\" - \"PUT\" - \"OPTION\" allowedHeaders: \"*\" # 允许在请求中携带的头信息 allowCredentials: true # 是否允许携带 cookie maxAge: 360000 # 本次跨域的有效期 123\n","wordCount":"2156","inLanguage":"en","datePublished":"2021-10-25T17:42:15Z","dateModified":"2021-10-25T17:42:15Z","author":{"@type":"Person","name":"lu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"lu","logo":{"@type":"ImageObject","url":"https://ethereal-lu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="lu (Alt + H)">lu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethereal-lu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ethereal-lu.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">微服务学习笔记</h1><div class=post-meta><span title='2021-10-25 17:42:15 +0000 UTC'>2021-10-25</span>&nbsp;·&nbsp;2156 words&nbsp;·&nbsp;lu</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1微服务架构介绍httpsmartinfowlercomarticlesmicroserviceshtml>1、<a href=https://martinfowler.com/articles/microservices.html>微服务架构介绍</a></a><ul><li><a href=#11微服务概念>1.1、微服务概念</a></li><li><a href=#12微服务设计原则>1.2、微服务设计原则</a></li></ul></li><li><a href=#2eureka-注册中心>2、Eureka 注册中心</a><ul><li><a href=#21注册中心概念>2.1、注册中心概念</a></li><li><a href=#22eureka-入门案例>2.2、Eureka 入门案例</a></li><li><a href=#23高可用-eureka-注册中心搭建>2.3、高可用 eureka 注册中心搭建</a></li><li><a href=#24eureka-架构原理>2.4、Eureka 架构原理</a></li><li><a href=#25cap-原则>2.5、CAP 原则</a></li><li><a href=#26eureka-自我保护>2.6、Eureka 自我保护</a></li><li><a href=#27eureka-优雅停服>2.7、eureka 优雅停服</a></li><li><a href=#28eureka-安全认证>2.8、eureka 安全认证</a></li></ul></li><li><a href=#3ribbon>3、Ribbon</a><ul><li><a href=#31ribbon-的概念>3.1、Ribbon 的概念</a></li><li><a href=#32负载均衡分类>3.2、负载均衡分类</a></li><li><a href=#33ribbon-负载均衡策略>3.3、Ribbon 负载均衡策略</a></li><li><a href=#34ribbon-入门案例>3.4、Ribbon 入门案例</a></li><li><a href=#35ribbon-负载均衡策略设置>3.5、Ribbon 负载均衡策略设置</a></li><li><a href=#36ribbon-点对点直连>3.6、Ribbon 点对点直连</a></li></ul></li><li><a href=#4feign>4、Feign</a><ul><li><a href=#41feign-的概念>4.1、Feign 的概念</a></li><li><a href=#42feign-入门案例>4.2、Feign 入门案例</a></li><li><a href=#43feign-负载均衡>4.3、Feign 负载均衡</a></li><li><a href=#44feign-请求传参>4.4、Feign 请求传参</a></li><li><a href=#45feign-性能调优>4.5、Feign 性能调优</a></li></ul></li><li><a href=#5nacos>5、Nacos</a><ul><li><a href=#51nacos-使用指南>5.1、Nacos 使用指南</a></li><li><a href=#52nacos-服务分级存储模型>5.2、Nacos 服务分级存储模型</a></li><li><a href=#53根据权重负载均衡>5.3、根据权重负载均衡</a></li><li><a href=#54环境隔离-namespace>5.4、环境隔离 namespace</a></li><li><a href=#55nacos-和-eureka-的区别>5.5、nacos 和 eureka 的区别</a></li><li><a href=#56nacos-配置管理>5.6、nacos 配置管理</a></li><li><a href=#57nacos-集群搭建>5.7、nacos 集群搭建</a></li></ul></li><li><a href=#6网关-gateway>6、网关 Gateway</a><ul><li><a href=#61网关概述>6.1、网关概述</a></li><li><a href=#62搭建网关>6.2、搭建网关</a></li><li><a href=#63路由断言工厂>6.3、路由断言工厂</a></li><li><a href=#64过滤器>6.4、过滤器</a></li><li><a href=#65跨域问题>6.5、跨域问题</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=1微服务架构介绍httpsmartinfowlercomarticlesmicroserviceshtml>1、<a href=https://martinfowler.com/articles/microservices.html>微服务架构介绍</a><a hidden class=anchor aria-hidden=true href=#1微服务架构介绍httpsmartinfowlercomarticlesmicroserviceshtml>#</a></h2><h3 id=11微服务概念>1.1、微服务概念<a hidden class=anchor aria-hidden=true href=#11微服务概念>#</a></h3><p>微服务就是将一个单体架构的应用按业务划分为一个个独立运行的程序即服务，他们之间通过 HTTP 协议进行通信（也可以采用消息队列来通信，如 RabbotMQ、Kafaka 等），可以采用不同的编程语言，使用不同的存储技术，自动化部署（如Jenkins）减少人为控制，降低出错概率。服务数量越多，管理起来越复杂，因此采用集中化管理。例如 Eureka，Zookeeper 等都是比较常见的服务集中化管理框架。</p><p>微服务是一种架构风格。有两个特点：</p><ul><li>职责单一：一个微服务解决一个业务问题（注意是一个业务问题而不是一个接口）。</li><li>面向服务：将自己的业务能力封装并对外提供服务，这是继承SOA的核心思想，一个微服务本身也可能调用其它的微服务。</li></ul><h3 id=12微服务设计原则>1.2、微服务设计原则<a hidden class=anchor aria-hidden=true href=#12微服务设计原则>#</a></h3><ul><li><p>AKF 拆分原则</p></li><li><p>前后端分离原则</p></li><li><p>无状态服务</p><p>状态：如果一个数据需要被多个服务共享，才能完成一笔交易，那么这个数据被称为状态。进而依赖这个状态数据的服务被称为有状态服务，反之称为无状态服务。</p><p>例如对空调的设置：1、若空调遥控器发送加一或减一的指令，空调根据现在的温度计算并调整温度，则空调提供的是有状态服务，状态是空调当前温度。2、若空调遥控器发送的是加一或减一之后的温度数值，空调根据接收到的温度数值设置温度，则空调提供的是无状态服务。</p></li><li><p>Restful 通信风格</p></li></ul><h2 id=2eureka-注册中心>2、Eureka 注册中心<a hidden class=anchor aria-hidden=true href=#2eureka-注册中心>#</a></h2><p>应用微服务化之后，首先遇到的第一个问题就是服务发现问题，一个微服务如何发现其他微服务呢？最简单的方式就是每个微服务里面配置其他微服务的地址，但是当微服务数量众多的时候，这样做明显不现实。所以需要使用到微服务架构中的一个最重要的组件：<strong>服务注册中心</strong>，所有服务都注册到服务注册中心，同时也可以从服务注册中心获取当前可用的服务清单。</p><h3 id=21注册中心概念>2.1、注册中心概念<a hidden class=anchor aria-hidden=true href=#21注册中心概念>#</a></h3><p>注册中心可以理解为微服务架构中的“通讯录”。它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其他服务时，就到这里找到服务的地址，进行调用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ae81ff>张三办了张新的电话卡并将号码告诉我，我将其名字和号码的映射保存进通讯录。              -- 服务注册</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>我想给张三打电话，于是在通讯录中根据其名字找到张三，然后根据映射到的电话号码拨打       -- 服务发现</span>
</span></span><span style=display:flex><span>---------------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#ae81ff>上例中我和张三分别代表一个微服务，通讯录是独立于我和张三的服务注册中心</span>
</span></span></code></pre></div><p>总结：服务注册中心的作用就是<strong>服务的注册</strong>和<strong>服务的发现</strong>。</p><h3 id=22eureka-入门案例>2.2、Eureka 入门案例<a hidden class=anchor aria-hidden=true href=#22eureka-入门案例>#</a></h3><p>1、创建一个 SpringBoot 项目并引入web、test和下方两个依赖 。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.cloud<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>spring-cloud-dependencies<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;version&gt;</span>2020.0.4<span style=color:#f92672>&lt;/version&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;type&gt;</span>pom<span style=color:#f92672>&lt;/type&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;scope&gt;</span>runtime<span style=color:#f92672>&lt;/scope&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.cloud<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>spring-cloud-starter-netflix-eureka-server<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;version&gt;</span>3.0.4<span style=color:#f92672>&lt;/version&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>2、application.yaml 如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>server</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>port</span>: <span style=color:#ae81ff>8761</span>               <span style=color:#75715e># 官方文档使用的端口</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>application</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>eureka-server   </span> <span style=color:#75715e># 应用名称</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 配置 eureka-server 注册中心</span>
</span></span><span style=display:flex><span><span style=color:#f92672>eureka</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>instance</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>hostname</span>: <span style=color:#ae81ff>localhost             </span> <span style=color:#75715e># 主机名，默认根据操作系统的主机名获取</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>client</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># 下方值为 false 的两项，只有当自身为单节点的注册中心时才需要设置为 false 。</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 单节点指的是只有一个注册中心，不是只有一个微服务。</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 当自身是微服务或者是集群中的注册中心之一时无需设置，使用默认 true。</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>register-with-eureka</span>: <span style=color:#66d9ef>false</span>      <span style=color:#75715e># 是否将自己注册到注册中心，默认为 true</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>fetch-registry</span>: <span style=color:#66d9ef>false</span>            <span style=color:#75715e># 是否从注册中心获取服务注册信息，默认 true</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>service-url</span>:                     <span style=color:#75715e># 注册中心对外暴露的注册地址</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>defaultZone</span>: <span style=color:#ae81ff>http://${eureka.instance.hostname}:${server.port}/eureka/</span>
</span></span></code></pre></div><p>3、启动类前添加 @EnableEurekaServer 注解</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@EnableEurekaServer</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SpringBootApplication</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EurekaServerApplication</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        SpringApplication.<span style=color:#a6e22e>run</span>(EurekaServerApplication.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>4、启动后访问 http://localhost:8761/ 便会显示 eureka 页面。</p><h3 id=23高可用-eureka-注册中心搭建>2.3、高可用 eureka 注册中心搭建<a hidden class=anchor aria-hidden=true href=#23高可用-eureka-注册中心搭建>#</a></h3><h4 id=231搭建注册中心>2.3.1、搭建注册中心<a hidden class=anchor aria-hidden=true href=#231搭建注册中心>#</a></h4><p>创建两个 2.2 的注册中心，url不能相同，即若两个注册中心在同一台主机上，则端口号不能相同，若在不同主机上端口号可以相同。两个注册中心只有 yaml 主配置文件不同，分别如下，其他相同。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># server01</span>
</span></span><span style=display:flex><span><span style=color:#f92672>server</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>port</span>: <span style=color:#ae81ff>8761</span>               <span style=color:#75715e># 端口</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>application</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>eureka          </span> <span style=color:#75715e># 应用名称(集群下相同）</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 配置 eureka-server 注册中心</span>
</span></span><span style=display:flex><span><span style=color:#f92672>eureka</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>instance</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>hostname</span>: <span style=color:#ae81ff>server01             </span> <span style=color:#75715e># 主机名，默认根据操作系统的主机名获取</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>client</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># 将服务注册中心地址指向另一个服务中心</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>service-url</span>:                     <span style=color:#75715e># 注册中心对外暴露的注册地址</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>defaultZone</span>: <span style=color:#ae81ff>http://localhost:8762/eureka/</span>
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span><span style=color:#75715e># ------------------------------------------------</span>
</span></span><span style=display:flex><span><span style=color:#75715e># server02</span>
</span></span><span style=display:flex><span><span style=color:#f92672>server</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>port</span>: <span style=color:#ae81ff>8762</span>               <span style=color:#75715e># 端口</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>application</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>eureka          </span> <span style=color:#75715e># 应用名称(集群下相同）</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 配置 eureka-server 注册中心</span>
</span></span><span style=display:flex><span><span style=color:#f92672>eureka</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>instance</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>hostname</span>: <span style=color:#ae81ff>server02             </span> <span style=color:#75715e># 主机名，默认根据操作系统的主机名获取</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>client</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># 将服务注册中心地址指向另一个服务中心</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>service-url</span>:                     <span style=color:#75715e># 注册中心对外暴露的注册地址</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>defaultZone</span>: <span style=color:#ae81ff>http://localhost:8761/eureka/</span>
</span></span></code></pre></div><p>注意：两个注册中心要同时启动，否则在 springboot 启动后无法检测到另一个注册中心使得 eureka 抛异常。</p><p>此时再访问 http://localhost:8761/ 或 http://localhost:8762/ 就会看到两个注册中心。</p><p>eureka 实例可以作为服务提供者也可以作为注册中心。其默认ID为 “主机名:应用名:端口”，如“<a href=http://server01:8761/actuator/info>localhost:eureka:8761</a> ”。可以通过下方配置将其设置为ip:port 。一般都使用 ip：port 的方式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>eureka</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>instance</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>prefer-ip-address</span>: <span style=color:#66d9ef>true</span>                                        <span style=color:#75715e># 是否使用 ip 注册地址</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>instance-id</span>: <span style=color:#ae81ff>${spring.cloud.client.ip-address}:${server.port} </span> <span style=color:#75715e># ip:port</span>
</span></span></code></pre></div><h4 id=232搭建-service-provider>2.3.2、搭建 service-provider<a hidden class=anchor aria-hidden=true href=#232搭建-service-provider>#</a></h4><p>1、新建 SpringBoot 项目并引入依赖</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.cloud<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>spring-cloud-starter-netflix-eureka-client<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>2、主配置文件如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>server</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>port</span>: <span style=color:#ae81ff>7070</span>                        <span style=color:#75715e># 微服务的端口</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>application</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>service-provider         </span> <span style=color:#75715e># 应用名称</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 配置 eureka 注册中心</span>
</span></span><span style=display:flex><span><span style=color:#f92672>eureka</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>instance</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>prefer-ip-address</span>: <span style=color:#66d9ef>true</span>         <span style=color:#75715e># 是否使用 ip 注册地址</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>instance-id</span>: <span style=color:#ae81ff>${spring.cloud.client.ip-address}:${server.port} </span> <span style=color:#75715e># ip:port</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>client</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>service-url</span>:           <span style=color:#75715e># 设置服务注册中心地址，即 将微服务注册到哪里</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>defaultZone</span>: <span style=color:#ae81ff>http://localhost:8761/eureka/, http://localhost:8762/eureka/</span>
</span></span></code></pre></div><p>3、创建 entity、service、impl、controller 任意实现一个功能接口。</p><p>4、可以正常访问该微服务提供的接口</p><p>5、访问 http://localhost:8761 可以看到两个注册中心和一个名为 service-provider 的微服务。</p><h4 id=233搭建-service-consumer>2.3.3、搭建 service-consumer<a hidden class=anchor aria-hidden=true href=#233搭建-service-consumer>#</a></h4><p>1、新建 SpringBoot 项目并引入依赖</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.cloud<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>spring-cloud-starter-netflix-eureka-client<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>2、主配置文件如下</p><p>由于该纯粹的消费者没有注册到注册中心，故访问 http://localhost:8761 时不会显示该消费者的信息。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>server</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>port</span>: <span style=color:#ae81ff>9090</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>application</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>service-consumer        </span> <span style=color:#75715e># 应用名称</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 配置 eureka 注册中心</span>
</span></span><span style=display:flex><span><span style=color:#f92672>eureka</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>client</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># 是否将自己注册到注册中心，默认为 true。此处只作为消费者调用微服务，并不提供服务，故不注册。</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>register-with-eureka</span>: <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 表示 eureka client 间隔多久到注册中心获取注册信息，默认 30 秒。</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>registry-fetch-interval-seconds</span>: <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>service-url</span>:               <span style=color:#75715e># 设置服务注册中心地址，即 去哪里寻找微服务</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>defaultZone</span>: <span style=color:#ae81ff>http://localhost:8761/eureka/, http://localhost:8762/eureka/</span>
</span></span></code></pre></div><p>3、服务消费者有三种访问服务的方法：DiscoveryClient、LoadBalancerClient、@LoadBalanced。这三种方法从左到右依次越来越方便使用。下方只展示第三种使用方法。</p><ul><li>主启动类</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@SpringBootApplication</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ServiceConsumerApplication</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        SpringApplication.<span style=color:#a6e22e>run</span>(ServiceConsumerApplication.<span style=color:#a6e22e>class</span>, args);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// SpringMVC 没有集成 RestTemplate ，所以这里需要手动添加到 IOC 容器中。</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@LoadBalanced</span>   <span style=color:#75715e>// 负载均衡注解</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> RestTemplate <span style=color:#a6e22e>restTemplate</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> RestTemplate();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>serviceImpl类</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OrderServiceImpl</span> <span style=color:#66d9ef>implements</span> OrderService {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// RestTemplate 简化了发起 HTTP 请求以及处理响应的过程，并且支持 REST 。</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> RestTemplate restTemplate;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Order <span style=color:#a6e22e>selectOrderById</span>(Integer id) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Order(id, <span style=color:#e6db74>&#34;1&#34;</span>, <span style=color:#e6db74>&#34;China&#34;</span>, 76598D, selectProductList());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> List<span style=color:#f92672>&lt;</span>Product<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>selectProductList</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// service-provider 的某 Controller 下 @GetMapping(&#34;/product/list&#34;) 提供服务。</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 由于返回结果为泛型，故只能使用 exchange 方法。ResponseEntity 封装了状态码、返回体等。</span>
</span></span><span style=display:flex><span>        ResponseEntity<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&lt;</span>Product<span style=color:#f92672>&gt;&gt;</span> responseEntity <span style=color:#f92672>=</span> restTemplate.<span style=color:#a6e22e>exchange</span>(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;http://service-provider/product/list&#34;</span>,  <span style=color:#75715e>// 服务名 + 路径</span>
</span></span><span style=display:flex><span>                HttpMethod.<span style=color:#a6e22e>GET</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> ParameterizedTypeReference<span style=color:#f92672>&lt;&gt;</span>() {});
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> responseEntity.<span style=color:#a6e22e>getBody</span>();   <span style=color:#75715e>// getBody() 返回 返回体</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其他的 pojo 和 controller 都很常规。至此，完整的 Eureka 微服务体系完成。</p><h3 id=24eureka-架构原理>2.4、Eureka 架构原理<a hidden class=anchor aria-hidden=true href=#24eureka-架构原理>#</a></h3><p><img alt=eureka架构图 loading=lazy src=/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AC%94%E8%AE%B0/eureka%E6%9E%B6%E6%9E%84%E5%9B%BE.png></p><p>Replicate 表示多个注册中心之间的数据同步。</p><h3 id=25cap-原则>2.5、CAP 原则<a hidden class=anchor aria-hidden=true href=#25cap-原则>#</a></h3><p>C 为保证数据一致性，是强一致性，即任何时候读取的都是最新的数据，类似于数据库的当前读；</p><p>A 为服务高可用即快速响应；</p><p>P 为分区容错，是分布式的固有属性。</p><p>任何时候，只能在 CP , AP , CA 中三选一，不可能同时满足三个。</p><p>CA 不能实现分布式。一般用于规模小，不打算扩展的应用。MySQL</p><p>AP 不能实现一致性。一般是前几步操作满足快速响应，后续实现一致性。金融领域绝对不允许使用AP。</p><p>CP 不能实现快速响应。分布式数据库，如 Redis、MongoDB 等。</p><h3 id=26eureka-自我保护>2.6、Eureka 自我保护<a hidden class=anchor aria-hidden=true href=#26eureka-自我保护>#</a></h3><h4 id=261启动自我保护条件>2.6.1、启动自我保护条件<a hidden class=anchor aria-hidden=true href=#261启动自我保护条件>#</a></h4><p>一般情况下，服务在 Eureka 上注册后，会每 30 秒发送一个心跳包，Eureka 通过心跳来判断服务是否健康，同时定期删除超过 90 秒没有发送心跳的服务。</p><p>但是 Eureka 收不到心跳不只是微服务自身的原因，还有可能是微服务与 Eureka 之间的网络故障引起。</p><p>因此 Eureka 会在运行期间去统计心跳失败比例是否在 15 分钟之内低于 85%，如果低于 85% Eureka 会将这些服务保护起来，同时提示一个警告。这种算法就是 Eureka 的自我保护模式。</p><h4 id=262如何关闭自我保护>2.6.2、如何关闭自我保护<a hidden class=anchor aria-hidden=true href=#262如何关闭自我保护>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>eureka</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>server</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>enable-self-preservation</span>: <span style=color:#66d9ef>false</span>         <span style=color:#75715e># true 开启自我保护机制（默认），false 关闭</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>eviction-interval-timer-in-ms</span>: <span style=color:#ae81ff>60000</span>    <span style=color:#75715e># 清理间隔（毫秒）</span>
</span></span></code></pre></div><h3 id=27eureka-优雅停服>2.7、eureka 优雅停服<a hidden class=anchor aria-hidden=true href=#27eureka-优雅停服>#</a></h3><p>配置优雅停服后，无需关闭自我保护。</p><p>1、在服务提供者 service-provider 中添加依赖</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.boot<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>spring-boot-starter-actuator<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>2、在 service-provider 的配置文件中添加下方配置</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#75715e># 度量指标监控与健康检查</span>
</span></span><span style=display:flex><span><span style=color:#f92672>management</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>endpoints</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>web</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>exposure</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>include</span>: <span style=color:#ae81ff>shutdown   </span> <span style=color:#75715e># 开启 shutdown 端点访问</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>endpoint</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>shutdown</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>enabled</span>: <span style=color:#66d9ef>true</span>          <span style=color:#75715e># 开启 shutdown 实现优雅停服</span>
</span></span></code></pre></div><p>配置完成后，使用 POST 访问 http://localhost:7070/actuator/shutdown 即可实现停止服务器。</p><h3 id=28eureka-安全认证>2.8、eureka 安全认证<a hidden class=anchor aria-hidden=true href=#28eureka-安全认证>#</a></h3><p>只有经过授权才可以在注册中心注册服务或拉取服务。</p><p>1、在所有的注册中心添加依赖</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.boot<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>spring-boot-starter-security<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>2、在所有的注册中心配置安全认证</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span>  <span style=color:#75715e># 安全认证</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>security</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>user</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>root</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>password</span>: <span style=color:#ae81ff>root</span>
</span></span></code></pre></div><p>3、在所有的注册中心、服务提供者、服务消费者重新配置注册中心地址</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># 配置 eureka 注册中心</span>
</span></span><span style=display:flex><span><span style=color:#f92672>eureka</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>client</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>service-url</span>:              <span style=color:#75715e># 这里有疑问，全部设置为静态的 name:password@url 太不方便了吧</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>defaultZone</span>: <span style=color:#ae81ff>http://root:root@localhost:8761/eureka/, http://root:root@localhost:8762/eureka/</span>
</span></span></code></pre></div><p>仅配置完这些，访问 http://http://localhost:8761/ 并登陆后会发现没有任何注册中心和服务，这是因为都被 CSRF 拦截了。</p><p>4、过滤 CSRF</p><p>eureka 会自动化配置 CSRF 防御机制， Spring Security 认为 POST , PUT , DELETE 都是有风险的，如果这些 method 发送时没有带上 CSRF token 就会被拦截并返回 403。</p><p>方案一：使 CSRF 忽略 /eureka/** 的所有请求。</p><p>在所有注册中心的 config 包中添加如下配置类。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@EnableWebSecurity</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WebSecurityConfig</span> <span style=color:#66d9ef>extends</span> WebSecurityConfigurerAdapter {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>configure</span>(HttpSecurity http) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>configure</span>(http);  <span style=color:#75715e>// 加这句是为了访问 eureka 注册中心和 /actuator 时安全控制</span>
</span></span><span style=display:flex><span>        http.<span style=color:#a6e22e>csrf</span>().<span style=color:#a6e22e>ignoringAntMatchers</span>(<span style=color:#e6db74>&#34;/eureka/**&#34;</span>);  <span style=color:#75715e>// 使 csrf 忽略 /eureka/**</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>方案二：禁用 CSRF 防御机制</p><p>在所有注册中心的 config 包中添加如下配置类。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@EnableWebSecurity</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WebSecurityConfig</span> <span style=color:#66d9ef>extends</span> WebSecurityConfigurerAdapter {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>configure</span>(HttpSecurity http) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 直接 disable 会把安全验证也禁用掉。</span>
</span></span><span style=display:flex><span>        http.<span style=color:#a6e22e>csrf</span>().<span style=color:#a6e22e>disable</span>().<span style=color:#a6e22e>authorizeRequests</span>()
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>anyRequest</span>()
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>authenticated</span>()
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>and</span>()
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>httpBasic</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=3ribbon>3、Ribbon<a hidden class=anchor aria-hidden=true href=#3ribbon>#</a></h2><h3 id=31ribbon-的概念>3.1、Ribbon 的概念<a hidden class=anchor aria-hidden=true href=#31ribbon-的概念>#</a></h3><p>Ribbon 是一个基于 HTTP 和 TCP 的客户端负载均衡工具，它不需要像注册中心、网关那样独立部署，但是几乎存在于每个 Spring Cloud 微服务中。 Feign 提供的声明式服务调用也是基于 Ribbon 实现的。</p><p>Ribbon 提供了一套微服务的负载均衡解决方案。</p><p>负载均衡即当多个节点提供相同的服务时，选择其中一个提供服务，使得服务器整体的负载平衡。</p><h3 id=32负载均衡分类>3.2、负载均衡分类<a hidden class=anchor aria-hidden=true href=#32负载均衡分类>#</a></h3><p>业界主流负载均衡分为两类：</p><ul><li>集中式负载均衡（服务器负载均衡），即在 consumer 和 provider 之间使用独立的负载均衡设施，如 Nginx</li><li>进程内负载均衡（客户端负载均衡），即将负载均衡逻辑集成到 consumer ，如 Ribbon</li></ul><h3 id=33ribbon-负载均衡策略>3.3、Ribbon 负载均衡策略<a hidden class=anchor aria-hidden=true href=#33ribbon-负载均衡策略>#</a></h3><h4 id=331轮询策略默认>3.3.1、轮询策略（默认）<a hidden class=anchor aria-hidden=true href=#331轮询策略默认>#</a></h4><p>对应类名：RoundRobinRule</p><p>原理：即按顺序选取下一个</p><h4 id=332权重轮询策略>3.3.2、权重轮询策略<a hidden class=anchor aria-hidden=true href=#332权重轮询策略>#</a></h4><p>对应类名：WeightedResponseTimeRule</p><p>原理：响应时间越快的被选中的概率越大</p><h4 id=333随机策略>3.3.3、随机策略<a hidden class=anchor aria-hidden=true href=#333随机策略>#</a></h4><p>对应类名：RandomRule</p><p>原理：随便选一个</p><h4 id=334最少并发数策略>3.3.4、最少并发数策略<a hidden class=anchor aria-hidden=true href=#334最少并发数策略>#</a></h4><p>对应类名：BestAvailableRule</p><p>原理：找并发数最少的 provider</p><h4 id=335重试策略>3.3.5、重试策略<a hidden class=anchor aria-hidden=true href=#335重试策略>#</a></h4><p>对应类名：RetryRule</p><p>原理：轮询策略的加强版，如果失败会重新尝试其他节点。</p><h4 id=336可用性敏感策略>3.3.6、可用性敏感策略<a hidden class=anchor aria-hidden=true href=#336可用性敏感策略>#</a></h4><p>对应类名：AvailabilityFilteringRule</p><p>原理：过滤掉连接失败和高繁忙的节点</p><h4 id=337区域敏感性策略>3.3.7、区域敏感性策略<a hidden class=anchor aria-hidden=true href=#337区域敏感性策略>#</a></h4><p>对应类名：ZoneAvoidanceRule</p><p>原理：对一个区域考察，丢弃不可用区域的 provider。</p><h3 id=34ribbon-入门案例>3.4、Ribbon 入门案例<a hidden class=anchor aria-hidden=true href=#34ribbon-入门案例>#</a></h3><p>Ribbon 对于集群的服务采用的负载均衡策略默认为轮询模式。</p><p>在 eureka 项目的基础上复制一份 service-provider 命名为 service-provider02 ，将 service-provider02 的端口设置为7071，应用名依然为 service-provider 。即现在存在提供完全相同服务的两个站点。将注册中心和服务提供者都启动后显示如下：</p><p><img alt=服务集群 loading=lazy src=/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AC%94%E8%AE%B0/%E6%9C%8D%E5%8A%A1%E9%9B%86%E7%BE%A4.jpg></p><p>可以看到有两个集群，一个是由两个注册中心组成的集群，一个是由微服务组成的集群。</p><p>当 service-consumer 调用 service-provider 时就会在微服务集群中按顺序轮询访问节点。</p><h3 id=35ribbon-负载均衡策略设置>3.5、Ribbon 负载均衡策略设置<a hidden class=anchor aria-hidden=true href=#35ribbon-负载均衡策略设置>#</a></h3><h4 id=351全局>3.5.1、全局<a hidden class=anchor aria-hidden=true href=#351全局>#</a></h4><p>在启动类或配置类中注入负载均衡策略对象。所有服务请求都使用该策略。例如：在启动类添加如下代码。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> RandomRule <span style=color:#a6e22e>randomRule</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> RandomRule();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=352局部>3.5.2、局部<a hidden class=anchor aria-hidden=true href=#352局部>#</a></h4><p>在 service-consumer 的配置文件中添加如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#75715e># 负载均衡策略</span>
</span></span><span style=display:flex><span><span style=color:#75715e># service-provider 为调用的微服务的名称</span>
</span></span><span style=display:flex><span><span style=color:#f92672>service-provider</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>ribbon</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>NFLoadBalancerRuleClassName</span>: <span style=color:#ae81ff>com.netflix.loadbalancer.RandomRule</span>
</span></span></code></pre></div><h3 id=36ribbon-点对点直连>3.6、Ribbon 点对点直连<a hidden class=anchor aria-hidden=true href=#36ribbon-点对点直连>#</a></h3><p>点对点直连是指绕过注册中心，直接连接服务提供者获取服务。一般在测试阶段使用较多，在测试阶段每次都要所有全部启动太麻烦，点对点直连可以不用启动注册中心。</p><p>1、将 service-consumer 中 eureka 的依赖和配置都注释掉，并引入依赖</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.cloud<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>spring-cloud-starter-netflix-ribbon<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;version&gt;</span>2.2.9.RELEASE<span style=color:#f92672>&lt;/version&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>2、在 service-consumer 的主配置文件中添加如下配置</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#75715e># 负载均衡策略</span>
</span></span><span style=display:flex><span><span style=color:#75715e># service-provider 为调用的微服务的名称</span>
</span></span><span style=display:flex><span><span style=color:#f92672>service-provider</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>ribbon</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>NFLoadBalancerRuleClassName</span>: <span style=color:#ae81ff>com.netflix.loadbalancer.RandomRule</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 制定具体的 provider 列表，多个用逗号隔开</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>listOfServers</span>: <span style=color:#ae81ff>http://localhost:7070, http://localhost:7071</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 关闭 eureka 实现点对点直连</span>
</span></span><span style=display:flex><span><span style=color:#f92672>ribbon</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>eureka</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>enabled</span>: <span style=color:#66d9ef>false</span>
</span></span></code></pre></div><p>配置完成后只启动 service-provider 和 service-consumer ，此时 service-consumer 依然可以正常访问 service-provider。</p><h2 id=4feign>4、Feign<a hidden class=anchor aria-hidden=true href=#4feign>#</a></h2><h3 id=41feign-的概念>4.1、Feign 的概念<a hidden class=anchor aria-hidden=true href=#41feign-的概念>#</a></h3><p>Feign 是 SpringCloud Netflix 组件中的一个轻量级 RESTful 的 HTTP 客户端，实现了负载均衡和Rest 调用的开源框架，封装了 Ribbon 和 RestTemplate ，实现了 WebService 的面向接口编程，进一步降低了项目的耦合度。</p><p>Feign内置了 Ribbon ，因此客户端可以负载均衡地调用服务注册中心的服务。</p><p>在 2.2.3 节提及了三种消费者调用服务的方法，Feign 其实就是一种比它们更简单的调用方法。</p><p>Feign 是一种声明式、模板化的 HTTP 客户端</p><p>Feign 的使用方式是：使用 Feign 的注解定义接口，调用这个接口就可以调用服务注册中心的服务。</p><h3 id=42feign-入门案例>4.2、Feign 入门案例<a hidden class=anchor aria-hidden=true href=#42feign-入门案例>#</a></h3><p>保留 Eureka 项目中的所有注册中心和所有 service-provider，并只保留下 Eureka 的依赖与配置，且将多余的安全认证、健康检查等依赖与配置全部删除。</p><p>Feign 的基本使用步骤：</p><ul><li>服务消费者添加 Feign 依赖；</li><li>创建业务层接口，添加 <code>@FeignClient</code> 注解声明需要调用的服务；</li><li>业务层抽象方法使用 SpringMVC 注解配置服务地址及参数；</li><li>启动类添加 <code>@EnableFeignClients</code>注解激活 Feign 组件。</li></ul><p>按照上面步骤举例：</p><p>1、创建 feign-consumer 模块</p><p>2、在 feign-consumer 中添加依赖</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.cloud<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>spring-cloud-starter-netflix-eureka-client<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.cloud<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>spring-cloud-starter-openfeign<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>3、在 feign-consumer 的主配置文件中添加配置</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>server</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>port</span>: <span style=color:#ae81ff>9090</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>application</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>feign-consumer</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 配置 eureka 注册中心</span>
</span></span><span style=display:flex><span><span style=color:#f92672>eureka</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>client</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># 是否将自己注册到注册中心，默认为 true。此处只作为消费者调用微服务，并不提供服务，故不注册。</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>register-with-eureka</span>: <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 表示 eureka client 间隔多久到注册中心获取注册信息，默认 30 秒。</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>registry-fetch-interval-seconds</span>: <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>service-url</span>:               <span style=color:#75715e># 设置服务注册中心地址，即 去哪里寻找微服务</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>defaultZone</span>: <span style=color:#ae81ff>http://localhost:8761/eureka/, http://localhost:8762/eureka/</span>
</span></span></code></pre></div><p>4、 feign-consumer 的逻辑为 OrderController 调用 OrderService，OrderService 的实现类 OrderServiceImpl 中远程调用 service-provider 提供的服务完成业务逻辑。实现远程调用的方式为新建一个接口且由 <code>@FeignClient</code>修饰，该接口会调用远程服务，其不需要实现类。下方代码中名称为 service-provider 的服务在 /product/list 路径下提供了 OrderServiceImpl 所需的服务。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 声明需要调用的服务 ， 括号内的值为 服务名</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@FeignClient</span>(<span style=color:#e6db74>&#34;service-provider&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ProductService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 配置需要调用的服务路径及参数，这里也可以使用 @PathVariable 等注解。</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@GetMapping</span>(<span style=color:#e6db74>&#34;/product/list&#34;</span>)
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>Product<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>selectProductList</span>();   <span style=color:#75715e>// 调用该方法就会远程调用相应服务</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>5、 OrderServiceImpl 代码如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OrderServiceImpl</span> <span style=color:#66d9ef>implements</span> OrderService {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> ProductService productService;   <span style=color:#75715e>// 由 @FeignClient 修饰的接口</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Order <span style=color:#a6e22e>selectOrderById</span>(Integer id) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Order(id, <span style=color:#e6db74>&#34;1&#34;</span>, <span style=color:#e6db74>&#34;China&#34;</span>, 76598D,
</span></span><span style=display:flex><span>                productService.<span style=color:#a6e22e>selectProductList</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>6、在启动类添加 @EnableFeignClients 注解启动 Feign 组件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@EnableFeignClients</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SpringBootApplication</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FeignConsumerApplication</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        SpringApplication.<span style=color:#a6e22e>run</span>(FeignConsumerApplication.<span style=color:#a6e22e>class</span>, args);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>完成上述步骤就可以正常访问了。</p><h3 id=43feign-负载均衡>4.3、Feign 负载均衡<a hidden class=anchor aria-hidden=true href=#43feign-负载均衡>#</a></h3><p>Feign 封装了 Ribbon 自然也就集成了负载均衡功能，默认采用轮询策略。修改负载均衡策略的方法与 Ribbon 相同。</p><h4 id=431全局>4.3.1、全局<a hidden class=anchor aria-hidden=true href=#431全局>#</a></h4><p>在启动类或配置类中注入负载均衡策略对象。所有服务请求都使用该策略。例如：在启动类添加如下代码。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> RandomRule <span style=color:#a6e22e>randomRule</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> RandomRule();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=432局部>4.3.2、局部<a hidden class=anchor aria-hidden=true href=#432局部>#</a></h4><p>在 service-consumer 的主配置文件中添加如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#75715e># 负载均衡策略</span>
</span></span><span style=display:flex><span><span style=color:#75715e># service-provider 为调用的微服务的名称</span>
</span></span><span style=display:flex><span><span style=color:#f92672>service-provider</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>ribbon</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>NFLoadBalancerRuleClassName</span>: <span style=color:#ae81ff>com.netflix.loadbalancer.RandomRule</span>
</span></span></code></pre></div><h3 id=44feign-请求传参>4.4、Feign 请求传参<a hidden class=anchor aria-hidden=true href=#44feign-请求传参>#</a></h3><ul><li><p>GET &mdash;&mdash;> 使用 <code>@PathVariable</code>或<code>@RequestParam</code>接收参数。</p></li><li><p>POST &mdash;&mdash;-> 使用<code>@RequestBody</code>注解接收请求参数。</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 声明需要调用的服务 ， 括号内的值为 服务名</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@FeignClient</span>(<span style=color:#e6db74>&#34;service-provider&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ProductService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 配置需要调用的服务路径及参数</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@GetMapping</span>(<span style=color:#e6db74>&#34;/product/list&#34;</span>)
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>Product<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>selectProductList</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 这里是调用 selectProductById 方法并向其传参，再根据参入的参数进行远程调用，感觉和平时使用相反</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@GetMapping</span>(<span style=color:#e6db74>&#34;/product/{id}&#34;</span>)
</span></span><span style=display:flex><span>    Product <span style=color:#a6e22e>selectProductById</span>(<span style=color:#a6e22e>@PathVariable</span>(<span style=color:#e6db74>&#34;id&#34;</span>) Integer id);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// @RequestBody 是将接收到的json解析为对象，这里是将 product 参数传递到 service-provider </span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 所以 @RequestBody 只需在 service-provider ，这里不用 @RequestBody。</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@PostMapping</span>(<span style=color:#e6db74>&#34;/product/add&#34;</span>)
</span></span><span style=display:flex><span>    Response<span style=color:#f92672>&lt;</span>DefaultVo<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>addProduct</span>(Product product);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=45feign-性能调优>4.5、Feign 性能调优<a hidden class=anchor aria-hidden=true href=#45feign-性能调优>#</a></h3><h4 id=451gzip-压缩>4.5.1、gzip 压缩<a hidden class=anchor aria-hidden=true href=#451gzip-压缩>#</a></h4><p>gzip 是一种数据格式，采用 deflate 算法压缩数据，当压缩一个纯文本（html、css等）时能减少 70% 空间，显然网络数据经过 gzip 压缩后的传输更快。</p><p>HTTP协议关于压缩传输的规定：</p><p>1、客户端向服务器请求中带有: Accept-Encoding:gzip ，deflate 字段，向服务器表示客户端支持的压缩格式(gzip 或者deflate)，如果不发送该消息头，服务端默认是不会压缩的。</p><p>2、服务端在收到请求之后，如果发现请求头中含有Accept-Encoding 字段，并且支持该类型压缩，就会对响应报文压缩之后返回给客户端，并且携带Content- Encoding:gzip消息头，表示响应报文是根据该格式进行压缩的。</p><p>3、客户端接收到请求之后，先判断是否有Content-Encoding 消息头，如果有，按该格式解压报文。否则按正常报文处理。</p><p><strong>局部开启 gzip 压缩</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#75715e># service-consumer 的主配置文件添加下方配置</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 局部开启 gzip 压缩，即只开启 service-provider 和 service-consumer 之间的 gzip 压缩，</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 不开启浏览器与 service-consumer 之间的压缩。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># feign gzip 压缩配置</span>
</span></span><span style=display:flex><span><span style=color:#f92672>feign</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>compression</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>request</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>enabled</span>: <span style=color:#66d9ef>true</span>                                            <span style=color:#75715e># 请求开启 gzip 压缩</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>mime-types</span>: <span style=color:#ae81ff>text/xml, application/xml, application/json </span> <span style=color:#75715e># 压缩支持的 MIME TYPE，默认支持</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>min-request-size</span>: <span style=color:#ae81ff>512</span>  <span style=color:#75715e># 压缩数据的最小阈值，默认 2048，即只有响应数据大于该值才执行压缩</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>response</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>enabled</span>: <span style=color:#66d9ef>true</span>                                            <span style=color:#75715e># 响应开启 gzip 压缩</span>
</span></span></code></pre></div><p><strong>全局开启 gzip 压缩</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#75715e># service-consumer 的主配置文件添加下方配置</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 全局开启 gzip 压缩，即 service-provider 和 service-consumer 之间以及</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 浏览器与 service-consumer 之间都开启 gzip 压缩。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>server</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>port</span>: <span style=color:#ae81ff>9090</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>compression</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>enabled</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 下方这句可以不写，默认都支持</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>mime-types</span>: <span style=color:#ae81ff>application/json, application/xml, text/html, text/xml, text/plain</span>
</span></span></code></pre></div><h4 id=452http-连接池>4.5.2、HTTP 连接池<a hidden class=anchor aria-hidden=true href=#452http-连接池>#</a></h4><p>两台服务器之间建立 HTTP 连接的过程很复杂，而微服务之间远程调用可能比较频繁却又只传输少量数据，因此大部分时间被浪费在建立连接上。</p><p>采用 HTTP 连接池可以节省大量的 3 次握手 4 次挥手，从而提升吞吐量。</p><p>Feign 的 HTTP 客户端支持 3 种框架：HttpURLConnection、HttpClient、OkHttp。默认是 HttpURLConnection，但 HttpURLConnection 是 JDK 自带的，不支持 HTTP 连接池，需要手写。</p><p>HttpClient 支持 HTTP 连接池且使得 HTTP 请求简化，HttpClient 还支持通过 get 请求传递对象参数，因此推荐使用 HttpClient 。</p><p>HttpClient 使用步骤如下：</p><p>1、在 service-consumer 中引入依赖</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#75715e>&lt;!-- 这个依赖已经被 Spring Cloud 集成，可以不用添加 --&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>org.apache.httpcomponents<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>httpclient<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>io.github.openfeign<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>feign-httpclient<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;version&gt;</span>11.0<span style=color:#f92672>&lt;/version&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>2、在 service-consumer 的主配置文件中添加如下配置</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>feign</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>httpclient</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>enabled</span>: <span style=color:#66d9ef>true</span>   <span style=color:#75715e># 开启 httpclient</span>
</span></span></code></pre></div><p>只要完成上述步骤，我们在代码层面不需要做任何改变，就已经开始使用 HTTP 连接池了。</p><h2 id=5nacos>5、Nacos<a hidden class=anchor aria-hidden=true href=#5nacos>#</a></h2><p>Nacos 也是注册中心，是阿里的产品，比 Eureka 的功能更丰富。</p><p>Eureka 的注册中心需要自己创建，Nacos 的注册中心独立出来需要下载，安装并开启后可直接使用。</p><h3 id=51nacos-使用指南>5.1、Nacos 使用指南<a hidden class=anchor aria-hidden=true href=#51nacos-使用指南>#</a></h3><h4 id=511开启注册中心>5.1.1、开启注册中心<a hidden class=anchor aria-hidden=true href=#511开启注册中心>#</a></h4><p>1、在 <a href=https://github.com/alibaba/nacos/releases/tag/1.4.2>https://github.com/alibaba/nacos/releases/tag/1.4.2</a> 下载 nacos ，选择 1.xx 版本。</p><p>2、进入 nacos 的 bin 目录，打开 cmd，输入 <code>startup.cmd -m standalone</code>以单节点模式开启 nacos 。</p><h4 id=512配置微服务>5.1.2、配置微服务<a hidden class=anchor aria-hidden=true href=#512配置微服务>#</a></h4><p>1、在父工程中引入依赖，用以控制阿里系列产品的版本。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;dependencyManagement&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;dependencies&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;groupId&gt;</span>com.alibaba.cloud<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;artifactId&gt;</span>spring-cloud-alibaba-dependencies<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;version&gt;</span>2.2.6.RELEASE<span style=color:#f92672>&lt;/version&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;type&gt;</span>pom<span style=color:#f92672>&lt;/type&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;scope&gt;</span>import<span style=color:#f92672>&lt;/scope&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/dependencies&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependencyManagement&gt;</span>
</span></span></code></pre></div><p>2、在微服务中引入依赖</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>com.alibaba.cloud<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>3、在微服务的主配置文件配置注册中心地址</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>server</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>port</span>: <span style=color:#ae81ff>7070</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>application</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>service-provider         </span> <span style=color:#75715e># 应用名称</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>cloud</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>nacos</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>server-addr</span>: <span style=color:#ae81ff>localhost:8848  </span> <span style=color:#75715e># nacos 注册中心地址</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># discovery:                这里只有是纯消费者才需要配置</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># register-enabled: false   # 纯消费者不用注册到注册中心</span>
</span></span></code></pre></div><p>4、访问 http://localhost:8848/nacos/index.html ，用户名和密码都是 nacos ，登陆进去即可查看注册中心。</p><h3 id=52nacos-服务分级存储模型>5.2、Nacos 服务分级存储模型<a hidden class=anchor aria-hidden=true href=#52nacos-服务分级存储模型>#</a></h3><p>一个服务可以有多个实例，出于容灾考虑将这些实例分散于不同的城市（地区）。Nacos 将处于同一个城市的所有实例组成一个集群，存储模型如下图：一级为服务（Userservice）、二级为集群(Beijing)、三级为实例(运行该服务的某台主机)。</p><p>![Nacos 服务分级存储模型](Nacos 服务分级存储模型.jpg)</p><p><strong>服务跨集群调用问题</strong></p><p>由于集群间距离太远，传输延时很高，因此一个服务调用另一个服务时，应该尽可能地调用本地集群中的服务，只有当本地集群中的服务不可用时才去跨集群调用服务。</p><p><strong>配置服务集群属性</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>application</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>service-provider         </span> <span style=color:#75715e># 应用名称</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>cloud</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>nacos</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>server-addr</span>: <span style=color:#ae81ff>localhost:8848  </span> <span style=color:#75715e># nacos 注册中心地址</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>discovery</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>cluster-name</span>: <span style=color:#ae81ff>Beijing      </span> <span style=color:#75715e># 集群名称</span>
</span></span></code></pre></div><p>由于 nacos 集成 ribbon 以实现负载均衡，因此仅配置集群名称后服务间调用仍然采用 ribbon 默认的轮询策略，故需要在调用者的主配置文件中修改 ribbon 的负载均衡规则来实现集群内优先调用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#75715e># service-provider 是被调用的微服务的名称</span>
</span></span><span style=display:flex><span><span style=color:#f92672>service-provider</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>ribbon</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>NFLoadBalancerRuleClassName</span>: <span style=color:#ae81ff>com.alibaba.cloud.nacos.ribbon.NacosRule </span> <span style=color:#75715e># 负载均衡规则</span>
</span></span></code></pre></div><p>NacosRule 会优先访问本地集群中的服务，只有本地集群内该服务的所有实例都不能使用后才会跨集群访问，同时报出跨集群访问的警告，在确定访问的集群后会在集群内的多个实例之间采用随机的方式访问。</p><h3 id=53根据权重负载均衡>5.3、根据权重负载均衡<a hidden class=anchor aria-hidden=true href=#53根据权重负载均衡>#</a></h3><p>由于设备更新出现设备间性能差异问题，性能好的设备应该承担更多访问压力，此时可以配置实例的权重，权重越大被访问的频率越高。（权重一般在 0 ~ 1 之间，默认为 1）</p><p>配置方法：进入 nacos 控制台 -》服务管理 -》 服务列表 -》点击服务的详情 -》点击具体实例中的编辑 -》输入权重。</p><p>在控制台配置完就可以了，源代码无需做任何改变。</p><p>改变权重和改变策略是对负载均衡的不同层面的配置。</p><ul><li><p>配置权重是在被调用者的 nacos 控制台配置。</p></li><li><p>配置负载均衡策略是在调用者的主配置文件配置。</p></li></ul><p>改变权重是改变访问的频率，访问策略仍然是在调用者的配置文件中配置的策略。如上方配置负载均衡策略为 NacosRule 后，访问时仍然是尽可能地访问本地集群中的实例，只是在本地集群中的众多实例中选择时选择权重更大的概率高一点。</p><p>如果把权重设置为 0 ，则该实例完全不会被访问，基于此可以实现服务的平滑升级。即一个服务有多个实例，先把一个实例的权重设为 0，然后升级重启，再改回 1，之后对其他实例逐个进行此操作。</p><h3 id=54环境隔离-namespace>5.4、环境隔离 namespace<a hidden class=anchor aria-hidden=true href=#54环境隔离-namespace>#</a></h3><p>nacos 即是服务注册中心也是数据中心。</p><p>nacos 的隔离级别从上往下依次是 namespace 、group、service/data、集群、实例。</p><p>namespace是最外层的隔离。</p><p>产品的开发环境、测试环境、发布环境等由 namespace 层隔离。功能衔接较紧密的服务（如订单和支付）可以划分到一个 group、之后的三层在存储模型中已经写过。</p><p>以上的这些隔离级别都是 nacos 提供的功能，可以使用但不强制使用。</p><p><strong>配置环境隔离</strong></p><p>默认的 namespac 为 自动生成的 public。可以在 nacos 控制台的命名空间中新建命名空间，新建完成会自动生成命名空间 ID，之后在被调用者的主配置文件中配置命名空间。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>cloud</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>nacos</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>server-addr</span>: <span style=color:#ae81ff>localhost:8848  </span> <span style=color:#75715e># nacos 注册中心地址</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>discovery</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>56df4de5-b390-4799-9ce4-0002dfb14872 </span> <span style=color:#75715e># 命名空间 ID </span>
</span></span></code></pre></div><p>之后重启该服务即可。隶属于不同命名空间中的服务之间相互不可见，因此不能相互调用。</p><h3 id=55nacos-和-eureka-的区别>5.5、nacos 和 eureka 的区别<a hidden class=anchor aria-hidden=true href=#55nacos-和-eureka-的区别>#</a></h3><p>两者都是注册中心，注册中心的基本功能就是服务提供者向注册中心注册信息，服务消费者从注册中心定期拉取这些信息，然后服务消费者远程访问服务提供者提供的服务。</p><p>![nacos 细节](nacos 细节.jpg)</p><p><strong>健康检查</strong>：eureka 中所有实例都定期发送心跳，注册中心根据心跳检测是否存活。nacos 将实例分为临时实例和非临时实例，临时实例和 eureka 相同都是检测心跳，若没有心跳则直接删除。非临时实例不发送心跳，而是注册中心定期主动询问是否存活，若不存活也不删除而是等待其再次恢复。</p><p><strong>消息更新</strong>：eureka 只有服务消费者定期从注册中心拉取信息。而 nacos 除了每 30 秒拉取一次外，为了防止在拉取期间服务停掉导致的错误，当服务提供者的信息改变（如死亡）时会主动向服务消费者推送变更的信息。</p><p>nacos 集群默认采用 AP 方式，当集群中存在非临时实例时，采用 CP 方式。 eureka 只有 AP 方式。</p><p><strong>设置非临时实例</strong></p><p>nacos 默认所有实例都是临时实例。非临时实例需要在主配置文件中配置。非临时实例对服务器的压力较大。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>cloud</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>nacos</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>server-addr</span>: <span style=color:#ae81ff>localhost:8848  </span> <span style=color:#75715e># nacos 注册中心地址</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>discovery</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>ephemeral</span>: <span style=color:#66d9ef>false</span>            <span style=color:#75715e># 非临时实例</span>
</span></span></code></pre></div><h3 id=56nacos-配置管理>5.6、nacos 配置管理<a hidden class=anchor aria-hidden=true href=#56nacos-配置管理>#</a></h3><p>一个项目可能有成百上千的微服务组成，有一些微服务的部分配置是相同的，如果这些配置要更改则要对每个微服务都修改，然后重新部署，这样不仅费时还可能对整个业务造成影响。</p><p>可以将这些相同的配置摘取出来统一配置管理，微服务读取统一配置和本地配置组成完整配置。当统一配置改变时可以通知各微服务，让其读取新配置，这样就可以实现配置热更新。</p><h4 id=561统一配置管理实现>5.6.1、统一配置管理实现<a hidden class=anchor aria-hidden=true href=#561统一配置管理实现>#</a></h4><p>一、<strong>新建统一配置</strong></p><p>打开 nacos 控制台 -》配置管理 -》配置列表 -》点加号进入新建配置</p><p>Data ID 必须唯一，一般为 微服务名 - 环境.yaml。例如 userservice-dev.yaml。group 默认，格式选 yaml。并不是所有配置都复制上去，只添加有热更新需求的配置（如关键参数、运行时需要调整的参数）。</p><p>二、<strong>发现配置管理地址</strong></p><p>不涉及统一配置管理时，springboot 启动顺序为 启动 springboot -》 读取本地 application.yaml 配置文件 -》 创建 IOC 容器 -》 加载 bean。</p><p>添加统一配置管理后，springboot 启动顺序为 启动 springboot -》读取统一配置管理的配置文件 -》读取本地 application.yaml 配置文件 -》 创建 IOC 容器 -》 加载 bean。</p><p>如果把统一配置管理的地址等信息配置到本地 application.yaml 配置文件时，则按照上述启动顺序我们无法在读取统一配置管理的配置文件前知道其地址在哪里。springboot 提供一个 bootstrap.yaml 文件，其启动顺序非常靠前，因此可以把统一配置管理的地址信息放在该文件中。具体做法如下：</p><p>1、引入 nacos 的配置管理客户端依赖</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>com.alibaba.cloud<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>spring-cloud-starter-alibaba-nacos-config<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>2、在微服务的 resources 目录下新建 bootstrap.yaml 文件，这是引导文件，优先级高于 application.yaml。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#75715e># bootstrap.yaml </span>
</span></span><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>application</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>service-provider         </span> <span style=color:#75715e># 应用名称</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>profiles</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>active</span>: <span style=color:#ae81ff>dev                    </span> <span style=color:#75715e># 开发环境</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>cloud</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>nacos</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>server-addr</span>: <span style=color:#ae81ff>localhost:8848  </span> <span style=color:#75715e># nacos 注册中心地址</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>config</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>file-extension</span>: <span style=color:#ae81ff>yaml       </span> <span style=color:#75715e># 文件名后缀</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>config</span>:
</span></span><span style=display:flex><span>  	<span style=color:#f92672>import</span>:
</span></span><span style=display:flex><span>  	  - <span style=color:#ae81ff>optional:nacos:application.yaml     </span> <span style=color:#75715e># 将 nacos 统一配置的 application.yaml 拉到本地</span>
</span></span></code></pre></div><p>上方在控制台新建配置时，Data ID 的命名规范即为 应用名称-开发环境.yaml，因此该文件中的信息恰好能唯一地指定配置文件。配置文件的地址即为 nacos 注册中心地址也已经配置。</p><p>3、把 application.yaml 中与 bootstrap.yaml 重复的配置删除并启动服务即可。</p><p>对程序而言，统一配置和本地配置没有任何区别，例如都可以使用 @Value("${xxx.xxx}")来读取配置的信息。</p><h4 id=562统一配置自动刷新>5.6.2、统一配置自动刷新<a hidden class=anchor aria-hidden=true href=#562统一配置自动刷新>#</a></h4><p>完成 5.6.1 的步骤后还需要添加本节的步骤以实现配置的自动刷新。</p><p>假设统一配置文件中包含有下方配置</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>pattern</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>dateformat</span>: <span style=color:#ae81ff>yyyy-MM-dd HH:mm:ss </span> <span style=color:#75715e># 配置日期格式</span>
</span></span></code></pre></div><p>根据配置注入的两种不同方式，自动刷新也有两种不同实现方式。</p><ul><li>方式一： @Value("${xxx.xxx}")</li></ul><p>使用这种方式注入配置时，在使用该种方式的的类前添加 @RefreshScope 注解。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@RefreshScope</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ProductServiceImpl</span> <span style=color:#66d9ef>implements</span> ProductService {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Value</span>(<span style=color:#e6db74>&#34;${pattern.dateformat}&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String dateformat;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print</span>() {
</span></span><span style=display:flex><span>    	System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(LocalDateTime.<span style=color:#a6e22e>now</span>().<span style=color:#a6e22e>format</span>(DateTimeFormatter.<span style=color:#a6e22e>ofPattern</span>(dateformat)));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>方式二： <code>@ConfigurationProperties(prefix = "xxx")</code></li></ul><p>使用这种方式注入配置时，专门创建一个类来接收配置的注入。<strong>推荐使用这种方式</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Data</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Component</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@ConfigurationProperties</span>(prefix <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;pattern&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PatternProperties</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String dateformat;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用方法如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ProductServiceImpl</span> <span style=color:#66d9ef>implements</span> ProductService {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> PatternProperties patternProperties;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(LocalDateTime.<span style=color:#a6e22e>now</span>().<span style=color:#a6e22e>format</span>(DateTimeFormatter.<span style=color:#a6e22e>ofPattern</span>(patternProperties.<span style=color:#a6e22e>getDateformat</span>())));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=563多环境配置共享>5.6.3、多环境配置共享<a hidden class=anchor aria-hidden=true href=#563多环境配置共享>#</a></h4><p>有些参数在开发、测试等环境中都一样，则可以将这些参数摘取出来生成一个配置文件，使其可以在多个环境中共享。</p><p>微服务在启动时会从 nacos 读取多个配置文件：</p><ul><li>[spring.application.name]-[spring.profiles.active].yaml。该配置文件与环境有关，不适配的环境不会加载。</li><li>[spring.application.name].yaml。该配置文件与环境无关，任何环境都会加载。</li></ul><p>因此可以将相同的参数抽取到 [spring.application.name].yaml 文件中。</p><p>当多个配置文件中含有相同配置项时，配置文件优先级如下，最终结果以优先级高的配置文件为准。</p><p>[spring.application.name]-[spring.profiles.active].yaml > [spring.application.name].yaml > 本地 application.yaml</p><h3 id=57nacos-集群搭建>5.7、nacos 集群搭建<a hidden class=anchor aria-hidden=true href=#57nacos-集群搭建>#</a></h3><p>![nacos 集群](nacos 集群.jpg)</p><p>上图对 nacos 集群框架简要介绍，部署有三个 nacos 节点，由 nginx 对多个节点负载均衡。</p><p>1、进入 %NACOS_HOME%/conf，将 cluster.conf.example 重命名为 cluster.conf。然后在该文件的末尾加上集群中各节点的ip加端口。如下：</p><pre tabindex=0><code>127.0.0.1:8845
127.0.0.1:8846
127.0.0.1:8847
</code></pre><p>2、将整个 nacos 文件夹复制三份，进入各自的 /conf/application.properties ，将 server.port 分别改为 8845、8846、8847。</p><p>3、在 application.properties 文件中，将下方项都取消注释，并按具体情况做适当修改。如果多个节点连接的同一个数据库，则可以将这一步提前到复制多份文件之前进行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>spring<span style=color:#f92672>.</span>datasource<span style=color:#f92672>.</span>platform    <span style=color:#75715e># 使用的数据库</span>
</span></span><span style=display:flex><span>db<span style=color:#f92672>.</span>num                        <span style=color:#75715e># 数据库个数</span>
</span></span><span style=display:flex><span>db<span style=color:#f92672>.</span>url<span style=color:#ae81ff>.0</span>                      <span style=color:#75715e># url</span>
</span></span><span style=display:flex><span>db<span style=color:#f92672>.</span>user<span style=color:#ae81ff>.0</span>                     <span style=color:#75715e># 用户名</span>
</span></span><span style=display:flex><span>db<span style=color:#f92672>.</span>password<span style=color:#ae81ff>.0</span>                 <span style=color:#75715e># 密码</span>
</span></span></code></pre></div><p>4、将多个节点分别启动，即进入各自的 bin 目录，打开cmd运行 <code>startup.cmd</code></p><p>5、安装 Nginx，打开 conf/nginx.conf 文件，在 http 块的任意区域添加下方配置</p><pre tabindex=0><code>upstream  nacos-cluster {
    server 127.0.0.1:8845;
    server 127.0.0.1:8846;
    server 127.0.0.1:8847;
}
server {
    listen       80;
    server_name  localhost;
    location /nacos {
        proxy_pass http://nacos-cluster;
    }
}
</code></pre><p>6、启动 Nginx</p><p>7、访问 http://localhost/nacos 即可进入 nacos 控制台，这是 Nginx 负载均衡之后的某个 nacos 节点。</p><p>8、在微服务的配置文件中将注册中心地址改为 localhost:80，启动后即可成功注册。</p><h2 id=6网关-gateway>6、网关 Gateway<a hidden class=anchor aria-hidden=true href=#6网关-gateway>#</a></h2><h3 id=61网关概述>6.1、网关概述<a hidden class=anchor aria-hidden=true href=#61网关概述>#</a></h3><p>外部浏览器对微服务进行的任何访问请求都必须经过网关。</p><p>网关本身也是一个微服务，因此需要将自己注册进注册中心。</p><p>网关的<strong>功能</strong>：</p><ul><li>身份认证和权限校验</li><li>服务路由和负载均衡</li><li>请求限流</li></ul><p>网关的<strong>技术实现</strong>：</p><p>在springcloud中，网关的实现有两种方式</p><ul><li>zuul 。基于 Servlet 实现，属于阻塞式编程。老旧</li><li>gateway 。基于 spring5 中的提供的 webflux，属于响应式编程，性能更好。<strong>用这个</strong></li></ul><h3 id=62搭建网关>6.2、搭建网关<a hidden class=anchor aria-hidden=true href=#62搭建网关>#</a></h3><p>1、新建 module 并引入依赖</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.cloud<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>spring-cloud-starter-gateway<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>com.alibaba.cloud<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>2、服务注册及路由配置</p><p>由于网关本身也是一个微服务，因此需要将自己注册进注册中心。配置如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>server</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>port</span>: <span style=color:#ae81ff>10010</span>          <span style=color:#75715e># 网关端口</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>application</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>gateway     </span> <span style=color:#75715e># 服务名称</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>cloud</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>nacos</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>server-addr</span>: <span style=color:#ae81ff>localhost:8848   </span> <span style=color:#75715e># 注册中心地址</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>gateway</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>routes</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>id</span>: <span style=color:#ae81ff>user-service          </span> <span style=color:#75715e># 路由 id，自定义，全局唯一</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e># uri: http://127.0.0.1:8081  # 固定死地址，不推荐使用</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e># 路由的目标地址，lb 表示负载均衡，后面接服务名。表示由注册中心具体分配服务实例</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>uri</span>: <span style=color:#ae81ff>lb://userservice</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>predicates</span>: <span style=color:#75715e># 路由断言，就是判断请求路径是否符合下方路径规则，如果符合就将其路由到uri处理</span>
</span></span><span style=display:flex><span>            - <span style=color:#ae81ff>Path=/user/**   </span> <span style=color:#75715e># 表示任何以 /user 开头的路径都由本条路由规则处理</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 可以配置多个路由规则</span>
</span></span><span style=display:flex><span>        - <span style=color:#f92672>id</span>: <span style=color:#ae81ff>role-service</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>uri</span>: <span style=color:#ae81ff>lb://roleservice</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>predicates</span>:
</span></span><span style=display:flex><span>            - <span style=color:#ae81ff>Path=/role/**</span>
</span></span></code></pre></div><p>在 routes 下还可以配置过滤器 filter。</p><p>请求发过来后，网关会在 routes 中从上往下依次寻找第一个符合规则的路由处理，如果都没有则报 404。</p><h3 id=63路由断言工厂>6.3、路由断言工厂<a hidden class=anchor aria-hidden=true href=#63路由断言工厂>#</a></h3><p>在配置文件中写的断言规则只是字符串，这些字符串会被 Predicate Factory 读取并处理，转变为路由判断条件。</p><p>像这样的断言工厂在 spring cloud gateway 中有十几个。</p><p>![Predicate 工厂](Predicate 工厂.jpg)</p><p>绝大部分时候都是使用 Path。</p><h3 id=64过滤器>6.4、过滤器<a hidden class=anchor aria-hidden=true href=#64过滤器>#</a></h3><p>GatewayFilter 是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的结果做处理。</p><p>spring cloud gateway 提供了 31 中不同的过滤器，可以进行各种各样的过滤操作，具体使用时再看官网。下面以 添加请求头过滤器 举例：</p><h4 id=641针对具体路由的过滤器>6.4.1、针对具体路由的过滤器<a hidden class=anchor aria-hidden=true href=#641针对具体路由的过滤器>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>cloud</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>gateway</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>routes</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>id</span>: <span style=color:#ae81ff>role-service</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>uri</span>: <span style=color:#ae81ff>lb://roleservice</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>predicates</span>:
</span></span><span style=display:flex><span>            - <span style=color:#ae81ff>Path=/role/**</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>filters</span>:  <span style=color:#75715e># 可以配置多个过滤器组成过滤器链</span>
</span></span><span style=display:flex><span>            - <span style=color:#ae81ff>AddRequestHeader=name,gaolu  </span> <span style=color:#75715e># 添加请求头。逗号前为键，逗号后为值。</span>
</span></span></code></pre></div><p>小知识：在 controller 的服务接口中可以通过 @RequestHeader 来获取请求头的值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#a6e22e>@GetMapping</span>(<span style=color:#e6db74>&#34;/product/list&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> List<span style=color:#f92672>&lt;</span>Product<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>selectProductList</span>(<span style=color:#a6e22e>@RequestHeader</span>(value <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;name&#34;</span>, required <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>) String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> productService.<span style=color:#a6e22e>selectProductList</span>(name);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>如上，就可以获取请求头键为 name 的值为 gaolu 。</p><h4 id=642默认过滤器>6.4.2、默认过滤器<a hidden class=anchor aria-hidden=true href=#642默认过滤器>#</a></h4><p>如果想要将某些过滤器对所有请求都奏效，可以在任意一个微服务中添加下方配置实现。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>cloud</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>gateway</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>default-filters</span>:   <span style=color:#75715e># 默认过滤器，会对所有的路由请求都生效</span>
</span></span><span style=display:flex><span>        - <span style=color:#ae81ff>AddRequestHeader=name,gaolu   </span> <span style=color:#75715e># 添加请求头，可以有多个</span>
</span></span></code></pre></div><h4 id=643全局过滤器>6.4.3、全局过滤器<a hidden class=anchor aria-hidden=true href=#643全局过滤器>#</a></h4><p>全局过滤器与默认过滤器的功能类似，都是作用于进入网关的所有请求和响应。区别是默认过滤器仅仅是在配置文件中选择了一种或几种 springcloud 提供的过滤器，我们无法改变其实现逻辑。如果想要使用自己的过滤器，就需要通过全局过滤器实现。</p><p>全局过滤器的定义方式是实现 GlobalFilter 接口。</p><p><img alt=GlobalFilter loading=lazy src=/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AC%94%E8%AE%B0/GlobalFilter.jpg></p><p>可以用全局过滤器拦截并判断请求的信息。使用举例如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Order</span>(<span style=color:#f92672>-</span>1) <span style=color:#75715e>// 可以设置多个全局过滤器，通过@Order规定这些过滤器执行的顺序。数字越小优先级越高。必须有</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Component</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AuthorizeFilter</span> <span style=color:#66d9ef>implements</span> GlobalFilter {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Mono<span style=color:#f92672>&lt;</span>Void<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>filter</span>(ServerWebExchange exchange, GatewayFilterChain chain) {
</span></span><span style=display:flex><span>        ServerHttpRequest request <span style=color:#f92672>=</span> exchange.<span style=color:#a6e22e>getRequest</span>();
</span></span><span style=display:flex><span>        MultiValueMap<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> params <span style=color:#f92672>=</span> request.<span style=color:#a6e22e>getQueryParams</span>();  <span style=color:#75715e>// url中的所有参数</span>
</span></span><span style=display:flex><span>        String authorize <span style=color:#f92672>=</span> params.<span style=color:#a6e22e>getFirst</span>(<span style=color:#e6db74>&#34;authorize&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#e6db74>&#34;admin&#34;</span>.<span style=color:#a6e22e>equals</span>(authorize))                   <span style=color:#75715e>// 如果身份验证通过则执行下一个过滤器</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> chain.<span style=color:#a6e22e>filter</span>(exchange);
</span></span><span style=display:flex><span>        exchange.<span style=color:#a6e22e>getResponse</span>().<span style=color:#a6e22e>setStatusCode</span>(HttpStatus.<span style=color:#a6e22e>UNAUTHORIZED</span>);    <span style=color:#75715e>// 设置响应码</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> exchange.<span style=color:#a6e22e>getResponse</span>().<span style=color:#a6e22e>setComplete</span>();                      <span style=color:#75715e>// 终止</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=644过滤器执行顺序>6.4.4、过滤器执行顺序<a hidden class=anchor aria-hidden=true href=#644过滤器执行顺序>#</a></h4><p>请求进入网关后会遇到三类过滤器：当前路由过滤器，默认过滤器和全局过滤器。</p><p>当请求进入网关后，这三个过滤器会组成过滤器链，依次按照过滤器链的顺序执行每个过滤器。</p><p>每个过滤器都必须指定一个 int 类型的 order 值表示执行顺序，值越小越先执行。</p><p>路由过滤器和默认过滤器的 order 值根据在配置文件中声明的顺序由 springcloud 从小到大排列，从 1 开始。</p><p>全局过滤器过滤器由我们手动通过 @Order 赋予。</p><p>排序时先看 order 值，从小到大执行，当 order 的值相同时，按照 默认过滤器 -> 路由过滤器 -> 全局过滤器的顺序执行。</p><h3 id=65跨域问题>6.5、跨域问题<a hidden class=anchor aria-hidden=true href=#65跨域问题>#</a></h3><p>跨域：域名不一致就是跨域。</p><p>浏览器禁止请求的发起者和服务端发生跨域 ajax 请求，这些请求会被浏览器拦截。</p><p>网关跨域处理采用的 CORS 方案，只需要配置文件中配置即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>cloud</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>gateway</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>globalcors</span>:                                 <span style=color:#75715e># 全局跨域处理</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>add-to-simple-url-handler-mapping</span>: <span style=color:#66d9ef>true</span>   <span style=color:#75715e># 解决 option 请求被拦截的问题</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>cors-configurations</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#39;[/**]&#39;</span>:                                <span style=color:#75715e># 所有的跨域请求都需要符合以下规则</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>allowedOrigins</span>:                       <span style=color:#75715e># 允许哪些网站的跨域</span>
</span></span><span style=display:flex><span>              - <span style=color:#e6db74>&#34;http://localhost:8090&#34;</span>
</span></span><span style=display:flex><span>              - <span style=color:#e6db74>&#34;http://www.lu.com&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>allowedMethods</span>:                       <span style=color:#75715e># 允许跨域请求的方式</span>
</span></span><span style=display:flex><span>              - <span style=color:#e6db74>&#34;GET&#34;</span>
</span></span><span style=display:flex><span>              - <span style=color:#e6db74>&#34;POST&#34;</span>
</span></span><span style=display:flex><span>              - <span style=color:#e6db74>&#34;DELETE&#34;</span>
</span></span><span style=display:flex><span>              - <span style=color:#e6db74>&#34;PUT&#34;</span>
</span></span><span style=display:flex><span>              - <span style=color:#e6db74>&#34;OPTION&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>allowedHeaders</span>: <span style=color:#e6db74>&#34;*&#34;</span>                   <span style=color:#75715e># 允许在请求中携带的头信息</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>allowCredentials</span>: <span style=color:#66d9ef>true</span>                <span style=color:#75715e># 是否允许携带 cookie</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>maxAge</span>: <span style=color:#ae81ff>360000</span>                        <span style=color:#75715e># 本次跨域的有效期</span>
</span></span></code></pre></div><p>123</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/feign%E5%8F%91%E8%B5%B7https%E8%AF%B7%E6%B1%82/><span class=title>« Prev</span><br><span>feign发起https请求</span>
</a><a class=next href=https://ethereal-lu.github.io/posts/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/><span class=title>Next »</span><br><span>设计模式</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>