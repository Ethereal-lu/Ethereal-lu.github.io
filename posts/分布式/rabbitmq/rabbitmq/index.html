<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>RabbitMQ基础 | lu</title>
<meta name=keywords content><meta name=description content="一、概述
1.1、什么是消息队列
消息：指的是两个应用间传递的数据。数据的类型有很多种形式，可能只包含文本字符串，也可能包含嵌入对象。
消息协议：为了让消息发送者和消息接收者都能够明白消息所承载的信息，它们就需要按照一种统一的格式描述消息。
消息队列：（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message。
消息从发送者到接收者的方式也有两种。
一种为即时消息通讯，也就是说消息从一端发出后（消息发送者）立即就可以达到另一端（消息接收者），这种方式的具体实现就是RPC（当然单纯的http通讯也满足这个定义）；
另一种为延迟消息通讯，即消息从某一端发出后，首先进入一个容器进行临时存储，当达到某种条件后，再由这个容器发送给另一端。 这个容器的一种具体实现就是消息队列，如RabbitMQ。
1.2、为什么使用消息队列

应用解耦：不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个；
流量削峰：如数据库只能同时处理一万条请求，如果来了两万条请求就执行一万条，将剩余一万条放在消息队列顺序执行。
异步处理：A 调用 B 处理数据，但 B 处理时间很长；A可以不用等，当B执行完将结果放在消息队列，再由消息队列将结果给A，这样就不用轮询或提供回调函数了。
广播
最终一致性

1.3、mqtt 与 MQ 的区别
mqtt：一种通信协议，类似人类交谈中的汉语、英语、俄语中的一种语言规范
MQ：一种通信通道，也叫消息队列，类似人类交谈中的用电话、email、微信的一种通信方式
json：一种内容格式，类似人类交谈中的排比句等方式
1.4、RPC 执行流程
RPC（Remote Procedure Call）远程过程调用协议，一种通过网络从远程计算机上请求服务，而不需要了解底层网络技术的协议。其主要目的是做到不同服务间调用方法像同一服务间调用本地方法一样。
当业务需要强一致性，关注业务逻辑的处理结果，则 RPC 比消息队列更合适。
强一致性指不论在任何时候读取的都是最新的数据，最终一致性是允许可以在一段时间内每个结点的数据不一致，但是经过一段时间每个结点的数据必须一致，它强调的是最终数据的一致性。

客户端处理过程中调用client sub，就像调用本地方法一样，传入参数
client sub将参数编组为消息，然后通过系统调用向服务端发送消息
服务端将接收到的数据包传递给server sub
server sub将接收到的数据解组为参数
server sub再调用服务端的过程，过程执行的结果以反方向的相同步骤响应给客户端

以 Google 的 grpc 为例：先在 proto 文件中声明接口，包括方法名、参数和返回值，然后使用工具生成 go 可以用的库；服务端创建 grpc 服务实例并将本地实现的服务注册进该实例中，然后监听本地端口，收到请求后就执行本地方法并将结果返回；客户端创建 grpc 客户端实例，然后调用 proto 中声明的方法即可获得结果。
1.5、MQ 分类

ActiveMQ：老、较少使用
Kafka：大数据实时计算和日志采集方面卓越
RocketMQ：阿里开源产品
RabbitMQ：主流

二、RabbitMQ介绍
2.1、RabbitMQ 简介
RabbitMQ是一个在AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。"><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/rabbitmq/rabbitmq/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/rabbitmq/rabbitmq/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/rabbitmq/rabbitmq/"><meta property="og:site_name" content="lu"><meta property="og:title" content="RabbitMQ基础"><meta property="og:description" content="一、概述 1.1、什么是消息队列 消息：指的是两个应用间传递的数据。数据的类型有很多种形式，可能只包含文本字符串，也可能包含嵌入对象。
消息协议：为了让消息发送者和消息接收者都能够明白消息所承载的信息，它们就需要按照一种统一的格式描述消息。
消息队列：（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message。
消息从发送者到接收者的方式也有两种。 一种为即时消息通讯，也就是说消息从一端发出后（消息发送者）立即就可以达到另一端（消息接收者），这种方式的具体实现就是RPC（当然单纯的http通讯也满足这个定义）； 另一种为延迟消息通讯，即消息从某一端发出后，首先进入一个容器进行临时存储，当达到某种条件后，再由这个容器发送给另一端。 这个容器的一种具体实现就是消息队列，如RabbitMQ。
1.2、为什么使用消息队列 应用解耦：不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个； 流量削峰：如数据库只能同时处理一万条请求，如果来了两万条请求就执行一万条，将剩余一万条放在消息队列顺序执行。 异步处理：A 调用 B 处理数据，但 B 处理时间很长；A可以不用等，当B执行完将结果放在消息队列，再由消息队列将结果给A，这样就不用轮询或提供回调函数了。 广播 最终一致性 1.3、mqtt 与 MQ 的区别 mqtt：一种通信协议，类似人类交谈中的汉语、英语、俄语中的一种语言规范 MQ：一种通信通道，也叫消息队列，类似人类交谈中的用电话、email、微信的一种通信方式 json：一种内容格式，类似人类交谈中的排比句等方式
1.4、RPC 执行流程 RPC（Remote Procedure Call）远程过程调用协议，一种通过网络从远程计算机上请求服务，而不需要了解底层网络技术的协议。其主要目的是做到不同服务间调用方法像同一服务间调用本地方法一样。
当业务需要强一致性，关注业务逻辑的处理结果，则 RPC 比消息队列更合适。
强一致性指不论在任何时候读取的都是最新的数据，最终一致性是允许可以在一段时间内每个结点的数据不一致，但是经过一段时间每个结点的数据必须一致，它强调的是最终数据的一致性。
客户端处理过程中调用client sub，就像调用本地方法一样，传入参数 client sub将参数编组为消息，然后通过系统调用向服务端发送消息 服务端将接收到的数据包传递给server sub server sub将接收到的数据解组为参数 server sub再调用服务端的过程，过程执行的结果以反方向的相同步骤响应给客户端 以 Google 的 grpc 为例：先在 proto 文件中声明接口，包括方法名、参数和返回值，然后使用工具生成 go 可以用的库；服务端创建 grpc 服务实例并将本地实现的服务注册进该实例中，然后监听本地端口，收到请求后就执行本地方法并将结果返回；客户端创建 grpc 客户端实例，然后调用 proto 中声明的方法即可获得结果。
1.5、MQ 分类 ActiveMQ：老、较少使用 Kafka：大数据实时计算和日志采集方面卓越 RocketMQ：阿里开源产品 RabbitMQ：主流 二、RabbitMQ介绍 2.1、RabbitMQ 简介 RabbitMQ是一个在AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-07T14:42:15+00:00"><meta property="article:modified_time" content="2022-04-07T14:42:15+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="RabbitMQ基础"><meta name=twitter:description content="一、概述
1.1、什么是消息队列
消息：指的是两个应用间传递的数据。数据的类型有很多种形式，可能只包含文本字符串，也可能包含嵌入对象。
消息协议：为了让消息发送者和消息接收者都能够明白消息所承载的信息，它们就需要按照一种统一的格式描述消息。
消息队列：（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message。
消息从发送者到接收者的方式也有两种。
一种为即时消息通讯，也就是说消息从一端发出后（消息发送者）立即就可以达到另一端（消息接收者），这种方式的具体实现就是RPC（当然单纯的http通讯也满足这个定义）；
另一种为延迟消息通讯，即消息从某一端发出后，首先进入一个容器进行临时存储，当达到某种条件后，再由这个容器发送给另一端。 这个容器的一种具体实现就是消息队列，如RabbitMQ。
1.2、为什么使用消息队列

应用解耦：不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个；
流量削峰：如数据库只能同时处理一万条请求，如果来了两万条请求就执行一万条，将剩余一万条放在消息队列顺序执行。
异步处理：A 调用 B 处理数据，但 B 处理时间很长；A可以不用等，当B执行完将结果放在消息队列，再由消息队列将结果给A，这样就不用轮询或提供回调函数了。
广播
最终一致性

1.3、mqtt 与 MQ 的区别
mqtt：一种通信协议，类似人类交谈中的汉语、英语、俄语中的一种语言规范
MQ：一种通信通道，也叫消息队列，类似人类交谈中的用电话、email、微信的一种通信方式
json：一种内容格式，类似人类交谈中的排比句等方式
1.4、RPC 执行流程
RPC（Remote Procedure Call）远程过程调用协议，一种通过网络从远程计算机上请求服务，而不需要了解底层网络技术的协议。其主要目的是做到不同服务间调用方法像同一服务间调用本地方法一样。
当业务需要强一致性，关注业务逻辑的处理结果，则 RPC 比消息队列更合适。
强一致性指不论在任何时候读取的都是最新的数据，最终一致性是允许可以在一段时间内每个结点的数据不一致，但是经过一段时间每个结点的数据必须一致，它强调的是最终数据的一致性。

客户端处理过程中调用client sub，就像调用本地方法一样，传入参数
client sub将参数编组为消息，然后通过系统调用向服务端发送消息
服务端将接收到的数据包传递给server sub
server sub将接收到的数据解组为参数
server sub再调用服务端的过程，过程执行的结果以反方向的相同步骤响应给客户端

以 Google 的 grpc 为例：先在 proto 文件中声明接口，包括方法名、参数和返回值，然后使用工具生成 go 可以用的库；服务端创建 grpc 服务实例并将本地实现的服务注册进该实例中，然后监听本地端口，收到请求后就执行本地方法并将结果返回；客户端创建 grpc 客户端实例，然后调用 proto 中声明的方法即可获得结果。
1.5、MQ 分类

ActiveMQ：老、较少使用
Kafka：大数据实时计算和日志采集方面卓越
RocketMQ：阿里开源产品
RabbitMQ：主流

二、RabbitMQ介绍
2.1、RabbitMQ 简介
RabbitMQ是一个在AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ethereal-lu.github.io/posts/"},{"@type":"ListItem","position":2,"name":"RabbitMQ基础","item":"https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/rabbitmq/rabbitmq/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"RabbitMQ基础","name":"RabbitMQ基础","description":"一、概述 1.1、什么是消息队列 消息：指的是两个应用间传递的数据。数据的类型有很多种形式，可能只包含文本字符串，也可能包含嵌入对象。\n消息协议：为了让消息发送者和消息接收者都能够明白消息所承载的信息，它们就需要按照一种统一的格式描述消息。\n消息队列：（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message。\n消息从发送者到接收者的方式也有两种。 一种为即时消息通讯，也就是说消息从一端发出后（消息发送者）立即就可以达到另一端（消息接收者），这种方式的具体实现就是RPC（当然单纯的http通讯也满足这个定义）； 另一种为延迟消息通讯，即消息从某一端发出后，首先进入一个容器进行临时存储，当达到某种条件后，再由这个容器发送给另一端。 这个容器的一种具体实现就是消息队列，如RabbitMQ。\n1.2、为什么使用消息队列 应用解耦：不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个； 流量削峰：如数据库只能同时处理一万条请求，如果来了两万条请求就执行一万条，将剩余一万条放在消息队列顺序执行。 异步处理：A 调用 B 处理数据，但 B 处理时间很长；A可以不用等，当B执行完将结果放在消息队列，再由消息队列将结果给A，这样就不用轮询或提供回调函数了。 广播 最终一致性 1.3、mqtt 与 MQ 的区别 mqtt：一种通信协议，类似人类交谈中的汉语、英语、俄语中的一种语言规范 MQ：一种通信通道，也叫消息队列，类似人类交谈中的用电话、email、微信的一种通信方式 json：一种内容格式，类似人类交谈中的排比句等方式\n1.4、RPC 执行流程 RPC（Remote Procedure Call）远程过程调用协议，一种通过网络从远程计算机上请求服务，而不需要了解底层网络技术的协议。其主要目的是做到不同服务间调用方法像同一服务间调用本地方法一样。\n当业务需要强一致性，关注业务逻辑的处理结果，则 RPC 比消息队列更合适。\n强一致性指不论在任何时候读取的都是最新的数据，最终一致性是允许可以在一段时间内每个结点的数据不一致，但是经过一段时间每个结点的数据必须一致，它强调的是最终数据的一致性。\n客户端处理过程中调用client sub，就像调用本地方法一样，传入参数 client sub将参数编组为消息，然后通过系统调用向服务端发送消息 服务端将接收到的数据包传递给server sub server sub将接收到的数据解组为参数 server sub再调用服务端的过程，过程执行的结果以反方向的相同步骤响应给客户端 以 Google 的 grpc 为例：先在 proto 文件中声明接口，包括方法名、参数和返回值，然后使用工具生成 go 可以用的库；服务端创建 grpc 服务实例并将本地实现的服务注册进该实例中，然后监听本地端口，收到请求后就执行本地方法并将结果返回；客户端创建 grpc 客户端实例，然后调用 proto 中声明的方法即可获得结果。\n1.5、MQ 分类 ActiveMQ：老、较少使用 Kafka：大数据实时计算和日志采集方面卓越 RocketMQ：阿里开源产品 RabbitMQ：主流 二、RabbitMQ介绍 2.1、RabbitMQ 简介 RabbitMQ是一个在AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。\n","keywords":[],"articleBody":"一、概述 1.1、什么是消息队列 消息：指的是两个应用间传递的数据。数据的类型有很多种形式，可能只包含文本字符串，也可能包含嵌入对象。\n消息协议：为了让消息发送者和消息接收者都能够明白消息所承载的信息，它们就需要按照一种统一的格式描述消息。\n消息队列：（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message。\n消息从发送者到接收者的方式也有两种。 一种为即时消息通讯，也就是说消息从一端发出后（消息发送者）立即就可以达到另一端（消息接收者），这种方式的具体实现就是RPC（当然单纯的http通讯也满足这个定义）； 另一种为延迟消息通讯，即消息从某一端发出后，首先进入一个容器进行临时存储，当达到某种条件后，再由这个容器发送给另一端。 这个容器的一种具体实现就是消息队列，如RabbitMQ。\n1.2、为什么使用消息队列 应用解耦：不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个； 流量削峰：如数据库只能同时处理一万条请求，如果来了两万条请求就执行一万条，将剩余一万条放在消息队列顺序执行。 异步处理：A 调用 B 处理数据，但 B 处理时间很长；A可以不用等，当B执行完将结果放在消息队列，再由消息队列将结果给A，这样就不用轮询或提供回调函数了。 广播 最终一致性 1.3、mqtt 与 MQ 的区别 mqtt：一种通信协议，类似人类交谈中的汉语、英语、俄语中的一种语言规范 MQ：一种通信通道，也叫消息队列，类似人类交谈中的用电话、email、微信的一种通信方式 json：一种内容格式，类似人类交谈中的排比句等方式\n1.4、RPC 执行流程 RPC（Remote Procedure Call）远程过程调用协议，一种通过网络从远程计算机上请求服务，而不需要了解底层网络技术的协议。其主要目的是做到不同服务间调用方法像同一服务间调用本地方法一样。\n当业务需要强一致性，关注业务逻辑的处理结果，则 RPC 比消息队列更合适。\n强一致性指不论在任何时候读取的都是最新的数据，最终一致性是允许可以在一段时间内每个结点的数据不一致，但是经过一段时间每个结点的数据必须一致，它强调的是最终数据的一致性。\n客户端处理过程中调用client sub，就像调用本地方法一样，传入参数 client sub将参数编组为消息，然后通过系统调用向服务端发送消息 服务端将接收到的数据包传递给server sub server sub将接收到的数据解组为参数 server sub再调用服务端的过程，过程执行的结果以反方向的相同步骤响应给客户端 以 Google 的 grpc 为例：先在 proto 文件中声明接口，包括方法名、参数和返回值，然后使用工具生成 go 可以用的库；服务端创建 grpc 服务实例并将本地实现的服务注册进该实例中，然后监听本地端口，收到请求后就执行本地方法并将结果返回；客户端创建 grpc 客户端实例，然后调用 proto 中声明的方法即可获得结果。\n1.5、MQ 分类 ActiveMQ：老、较少使用 Kafka：大数据实时计算和日志采集方面卓越 RocketMQ：阿里开源产品 RabbitMQ：主流 二、RabbitMQ介绍 2.1、RabbitMQ 简介 RabbitMQ是一个在AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。\n2.2、AMQP AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。\n2.3、相关概念 Broker：简单来说就是消息队列服务器实体。\nExchange：消息交换机，它指定消息按什么规则，路由到哪个队列。\nQueue：消息队列载体，每个消息都会被投入到一个或多个队列。\nBinding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。\nRouting Key：路由关键字，exchange根据这个关键字进行消息投递。\nvhost：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。\nproducer：消息生产者，就是投递消息的程序。\nconsumer：消息消费者，就是接受消息的程序。\nchannel：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。\n三、初体验 3.1、开启 rabbitmq 拉镜像并启动，映射 15672 端口\ndocker pull rabbitmq:management 进入容器，添加用户。这些操作全部可以在web界面上进行\nrabbitmqctl add_user admin admin // 添加用户\rrabbitmqctl set_user_tars admin administsrstor // 设置角色\rrabbitmqctl set_permissions admin \".*\" \".*\" \".*\" // 设置权限 3.2、java 使用 rabbitmq 初体验 使用默认交换机，即空字符串“”时，创建一个queue时,默认的都会有一个和新建queue同名的routingKey绑定到这个默认的exchange上去\n引包 com.rabbitmq amqp-client 5.14.2 commons-io commons-io 2.11.0 Producer 发布者 public class Producer { public static final String QUEUE_NAME = \"hello\"; public static void main(String[] args) throws IOException, TimeoutException { // 连接工厂 ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\"192.168.36.128\"); // java 连接 rabbitmq 的端口是 5672 .大坑。所以docker 也必须暴露 5672 端口。 factory.setPort(5672); factory.setUsername(\"admin\"); factory.setPassword(\"admin\"); factory.setConnectionTimeout(50000); // 连接 Connection connection = factory.newConnection(); // 获取信道 Channel channel = connection.createChannel(); /** * 声明一个队列，参数如下： * 1、name: 队列名称 * 2、durable: 是否持久化 * 3、exclusive: 是否排外的。如果设置为true，定义为排他队列。则只有创建者可以使用此队列。也就是private私有的。 * 4、autoDelete: 是否自动删除。也就是临时队列。当最后一个消费者断开连接后，会自动删除。 * 5、其他参数 * */ channel.queueDeclare(QUEUE_NAME, false, false, false, null); String message = \"Hello World\"; // 发送消息 参数：1.交换机，这里使用默认交换机 2.Routing Key 3. 其他参数 4.消息 channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes(StandardCharsets.UTF_8)); } } Consumer 消费者 public class Consumer { public static final String QUEUE_NAME = \"hello\"; public static void main(String[] args) throws IOException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\"192.168.36.128\"); factory.setPort(5672); factory.setUsername(\"guest\"); factory.setPassword(\"guest\"); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); // 发布者已经声明了队列，消费者就无需声明 // channel.queueDeclare(QUEUE_NAME, false, true, false, null); // 参数：1.队列名 2.是否使用自动应答 3.成功消费的回调 4.失败消费的回调 DeliverCallback deliverCallback = (consumerTag, message) -\u003e System.out.println(\"成功消费：\" + new String(message.getBody())); CancelCallback cancelCallback = (consumerTag) -\u003e System.out.println(\"失败消费\"); channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback); } } 四、工作队列 将工作封装成一个个消息发送到队列，然后由多个后台线程一起处理这些消息，从而避免同时处理大量消息。\n当多个消费者订阅同一个队列时，rabbitmq 默认使用轮询的方式将消息发送给消费者，同样保证每个消息只能被一个消费者消费。\n4.1、消息应答 消费者接收到消息后，突然宕机导致工作并没有完成，此时mq已经将消息删除，导致消息丢失。为避免该事件，引入消息应答机制：消费者在接收到消息并且处理完成该消息后，告诉 rabbitmq 它已经正确处理了，此时 mq 可以放心删除该消息。\n4.1.1、自动应答 消费者接收到消息后，自动告诉rabbitmq服务该消息已完成，实际上消费者也仅仅是接受到了消息，有可能还没有执行完成。\n当消息大量传递，消费者来不及处理导致消息积压，内存耗尽，就会被操作系统杀死，所以这种方式只适用于消费者可以高效处理的情况。所以不推荐使用自动应答。\n4.1.2、手动应答 当autoAck 参数为 false 时，对于 RabbitMQ 服务器端而言，队列中的消息分成了两部分：一部分是等待投递给消费者的消息；一部分是已经投递给消费者，但是还没有收到消费者确认信号的消息。如果 RabbitMQ 服务器端一直没有收到消费者的确认信号，并且消费此消息的消费者已经断开连接，则服务器端会安排该消息重新进入队列，等待投递给下一个消费者（也可能还是原来的那个消费者）。\nRabbitMQ 不会为未确认的消息设置过期时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费者的连接是否已经断开，这个设置的原因是 RabbitMQ 允许消费者消费一条消息的时间可以很久很久。\nchannel.basicAck(); // 肯定确认 channel.basicNack(); // 否定确认 channel.basicReject(); // 否定确认，比 basicNack 少了批量处理的参数 批量应答类似于 TCP 传输的累计确认，即若队列接收到消费者对于 8 号消息的确认，则认为消费者已经成功处理了 1 ~ 8 号消息，尽管之前可能没有收到来自 1~7 号的确认。但是不建议使用批量应答，当有多个消费者时，若消费者1处理 3 号消息，但还没有处理完就宕机了，此时消费者 2 已经处理完了 5 号消息并批量应答，就会造成 3 号消息的丢失。而 TCP 由于是点对点协议，因此没有这种情况的发生。\n4.1.3、消息自动重新入队 如果消费者由于某些原因失去连接(其通道关闭，连接关闭或 TCP 连接丢失，宕机)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。\npublic class Consumer { public static void main(String[] args) throws IOException, TimeoutException { Channel channel = RabbitMqUtil.getChannel(); DeliverCallback deliverCallback = (consumerTag, message) -\u003e { System.out.println(\"成功消费：\" + new String(message.getBody())); // 手动应答，且取消批量应答 channel.basicAck(message.getEnvelope().getDeliveryTag(), false); }; CancelCallback cancelCallback = (consumerTag) -\u003e System.out.println(\"失败消费\"); // 取消自动应答 channel.basicConsume(HELLO, false, deliverCallback, cancelCallback); } } 4.2、持久化 rabbitmq 服务器退出或宕机时，存在于内存中的队列和消息就会丢失，因此需要将队列和消息持久化。\n4.2.1、队列持久化 channel.queueDeclare(QUEUE_NAME, true, false, false, null); // 第二个参数为 durable: 是否持久化 声明队列时将其设置为持久化即可，但是若想要将一个已经存在的非持久化队列修改为持久化，需要先删除原有队列，再创建新队列，否则报错。\n4.2.2、消息持久化 channel.basicPublish(\"\", HELLO, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes()); 发布消息时，将消息属性设为持久化，此处设置为文本持久化。但是还不能保证消息不会完全丢失，当 mq 存入磁盘之前就宕机了，仍然会导致消息丢失，可以通过发布确认确保不丢失。\n设置了队列和消息的持久化之后，当broker服务重启的之后，消息依旧存在。单只设置队列持久化，重启之后消息会丢失；单只设置消息的持久化，重启之后队列消失，既而消息也丢失。单单设置消息持久化而不设置队列的持久化显得毫无意义。\n4.3、公平分发 rabbitmq 默认采用轮询分发。当多个消费者的处理性能相差很多时，若采用轮询分发会降低吞吐率，因此应该使用公平分发。\n// 消费者端设置 channel.basicQos(int prefetch_count); 一句话表示就是 prefetch_count 表示当前信道能存在的最多的未ack的消息个数\n每个 channe 都会记录自己 prefetch_count 的值，同时记录的还有该channel未ack的消息个数。\n当rabbitmq要将队列中的一条消息投递给消费者时，会遍历该队列上的消费者列表，选一个合适的消费者，然后将消息投递出去，投递的时候是在同一时刻将大量消息投递进去，使其直接变满。其中挑选消费者的一个依据就是看消费者对应的channel上未ack的消息数是否达到设置的prefetch_count个数，如果未ack的消息数达到了prefetch_count的个数，则不符合要求。当挑选到合适的消费者后，中断后续的遍历。当消费者对消息进行ack后，会修改该消费者对应channel中未ack的消息数，这样队列又可以将消息投递给该消费者。\n注：prefetch_count 必须在手动应答时才生效，如果是自动应答还是轮询。\nprefetch_count 默认为 0 ，即轮询分发。\n五、发布确认 当队列将消息保存在磁盘之后，向发布者发送确认消息，如此能确保 mq 将消息持久化了。\nchannel.confirmSelect(); // 发布者端设置，开启发布确认 如果设置了持久化，则必须保存到磁盘之后才会确认，否则，收到消息就直接确认。\n5.1、单个确认发布 每发一条消息，必须收到确认才会发送下一条消息。速度慢。\nboolean confirm = channel.waitForConfirms(); // 每次发送消息后都要判断 confirm 为 true 才能发送下一条消息 5.2、批量确认发布 发布一批消息后一起确认，可以提高吞吐率，但是若出现故障，不知道是哪一条消息的问题。\nint batch = 100; for (int i = 0; i \u003c 1000; i++) { String message = i + \"Hello World\"; channel.basicPublish(\"\", HELLO, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes()); if (i % batch == 0) // 手动批量😀 channel.waitForConfirms(); } 5.3、异步确认发布 效率和可靠新都能保障。通过回调函数达到消息可靠传输。\n发布的消息封装在一个 map 中，key 为消息的序号，value 为消息的值。发布者无需担心消息是否接收成功，只管发送即可，broke 会对 map 中的每一条消息处理，如果接收成功，则向发送者回复收到，否则向发送者回复未收到。对每一条消息都回复。\npublic class ProduceAsync { public static void main(String[] args) throws IOException, TimeoutException { Channel channel = RabbitMqUtil.getChannel(); channel.queueDeclare(HELLO, true, false, false, null); // 开启发布确认 channel.confirmSelect(); // 此处逻辑为：先将所有消息记录下来，在确认回调中删除掉已确认的，剩下的既是未确认的。 // 之所以没有在未确认回调中直接添加数据，是因为回调函数只能获取到序号，无法获取消息体。 ConcurrentSkipListMap\u003cLong, Object\u003e information = new ConcurrentSkipListMap\u003c\u003e(); // 消息接受成功回调函数 ConfirmCallback ackCallback = (deliveryTag, multiple) -\u003e { // 批量操作 if (multiple) { // 此处 confirmed 是 outstandingConfirms 的视图，对 confirm 的操作会影响到 outstandingConfirm。 // 因此，这一步的结果是删除掉所有已确认的消息 ConcurrentNavigableMap\u003cLong, Object\u003e confirmed = information.headMap(deliveryTag); confirmed.clear(); } else { information.remove(deliveryTag); } }; // 消息接受失败回调函数 ConfirmCallback nackCallback = (deliveryTag, multiple) -\u003e {}; // 监听器，异步通知。这里会开辟一个线程负责监听并回调。 // 这里只是将未确认的消息保存了下来，这些消息该如何处理？直接使用吗？ channel.addConfirmListener(ackCallback, nackCallback); for (int i = 0; i \u003c 100; i++) { String message = \"hello\" + i; information.put(channel.getNextPublishSeqNo(), message); channel.basicPublish(\"\", HELLO, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes()); } } } 六、交换机 生产者生产的消息不会直接发送到队列，只能发给交换机。交换机的工作有两个，一是接收来自生产者的消息，二是将他们推入队列。交换机必须确切知道该如何处理接收到的消息，是将其发送到特定的一个或多个队列还是丢弃。这些都由交换机的类型决定。类型如下：\nDirect Exchange：直连交换机，根据Routing Key(路由键)进行投递到不同队列。（默认） Fanout Exchange：扇形交换机，采用广播模式，根据绑定的交换机，路由到与之对应的所有队列。 Topic Exchange：主题交换机，对路由键进行模式匹配后进行投递，符号#表示0个或多个词，*表示一个词。 Header Exchange：头交换机，不处理路由键。而是根据发送的消息内容中的headers属性进行匹配。（基本废弃） 若想要改变一个交换机的类型，需要先删除原有交换机，再创建新交换机，否则报错。\n6.1、绑定（binding） Binding 就是 Exchange 和 Queue 之间的桥梁。Exchange 根据绑定关系将数据发送给 Queue 。\n6.2、Fanout Exchange Fanout Exchange 与 Routing_Key 没有任何关系，即 Exchange 会向所有与它绑定的队列广播消息，尽管某些队列使用的 Routing_Key 发布者指定的 Routing_Key 不同，也会发送。\npublic class Producer { public static final String EXCHANGE_NAME = \"first_exchange\"; public static final String ROUTING_KEY = \"first_routing_key\"; public static void main(String[] args) throws IOException, TimeoutException { Channel channel = RabbitMqUtil.getChannel(); // 声明交换机，类型为 FANOUT 广播类型 channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT); Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String message = sc.next(); // 发送消息到指定的交换机并指明使用的 ROUTING_KEY channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, null, message.getBytes(StandardCharsets.UTF_8)); } } } public class Consumer1 { public static void main(String[] args) throws IOException, TimeoutException { Channel channel = RabbitMqUtil.getChannel(); // 声明一个临时队列，消费者断开就自动删除 String queueName = channel.queueDeclare().getQueue(); // 绑定 channel.queueBind(queueName, EXCHANGE_NAME, ROUTING_KEY); DeliverCallback deliverCallback = (consumerTag, message) -\u003e System.out.println(\"Consumer1: \" + new String(message.getBody())); channel.basicConsume(queueName, true, deliverCallback, (consumerTag, message) -\u003e {}); } } public class Consumer2 {} // Consumer2 与 Consumer1 完全相同 6.3、Direct Exchange Direct Exchange 仅会向与它通过特定的 Routing_Key 绑定的队列发送消息，这个特定的 Routing_Key 就是发布者指定的 Routing_Key。\n6.4、Topic Exchange Topic Exchange 中，可以使用带有通配符的 Routing_Key 将 Exchange 和 Queue 进行绑定。\n在该模式中，发布者指定的 Routing_Key 必须以点号隔开的单词列表，如 com.lu.mq\n#匹配 0 个或多个词，*表示 1 个词。注意是点与点之间的完成的词，不是字母。如 com.*.mq、 com.#\npublic class Producer { public static final String EXCHANGE_NAME = \"third_exchange\"; public static final String ROUTING_KEY = \"com.lu.mq\"; public static void main(String[] args) throws IOException, TimeoutException { Channel channel = RabbitMqUtil.getChannel(); // 声明交换机，类型为 TOPIC 主题类型 channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC); Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String message = sc.next(); channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, null, message.getBytes(StandardCharsets.UTF_8)); } } } public class Consumer1 { public static void main(String[] args) throws IOException, TimeoutException { Channel channel = RabbitMqUtil.getChannel(); String queueName = channel.queueDeclare().getQueue(); channel.queueBind(queueName, EXCHANGE_NAME, \"com.#\"); DeliverCallback deliverCallback = (consumerTag, message) -\u003e System.out.println(\"Consumer1: \" + new String(message.getBody())); channel.basicConsume(queueName, true, deliverCallback, (consumerTag, message) -\u003e {}); } } public class Consumer2 { public static void main(String[] args) throws IOException, TimeoutException { Channel channel = RabbitMqUtil.getChannel(); String queueName = channel.queueDeclare().getQueue(); // 一个队列可以通过不同的 Routing_Key 绑定一个或多个交换机 channel.queueBind(queueName, EXCHANGE_NAME, \"com.*.mq\"); channel.queueBind(queueName, EXCHANGE_NAME, \"com.lu.*\"); DeliverCallback deliverCallback = (consumerTag, message) -\u003e System.out.println(\"Consumer2: \" + new String(message.getBody())); channel.basicConsume(queueName, true, deliverCallback, (consumerTag, message) -\u003e {}); } } 七、死信队列 没有被消费者消费的消息叫做死信，存放死信的队列叫做死信队列。\n有点类似于阻塞队列，条件不满足就阻塞，直到条件满足被唤醒。\n应用场景：消息消费发生异常时，放入死信队列，以防止消息丢失；用户下单未支付，超时后将订单放入死信队列。\n7.1、死信的来源 消息 TTL 过期 TTL是Time To Live的缩写，也就是生存时间。 RabbitMQ支持消息的过期时间，在消息发送时可以进行指定，仅作用于该消息 RabbitMQ支持为每个队列设置消息的超时时间，从消息入队列开始计算，如果超时消息会自动清除，作用于整个队列 队列已满 消息被拒绝（reject、nack）且 requeue = false 7.2、消息 TTL 过期 // 交换机和队列的声明放在哪里都可以 public class Consumer1 { public static final String NORMAL_EXCHANGE = \"normal_exchange\"; public static final String DEAD_EXCHANGE = \"dead_exchange\"; public static final String NORMAL_QUEUE = \"normal_queue\"; public static final String DEAD_QUEUE = \"dead_queue\"; public static final String NORMAL_ROUTING_KEY = \"normal_routing_key\"; public static final String DEAD_ROUTING_KEY = \"dead_routing_key\"; public static void main(String[] args) throws IOException, TimeoutException { Channel channel = RabbitMqUtil.getChannel(); channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT); channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT); Map\u003cString, Object\u003e arguments = new HashMap\u003c\u003e(); arguments.put(\"x-dead-letter-exchange\", DEAD_EXCHANGE); // 指定死信消息应该发送给哪个死信交换机 arguments.put(\"x-dead-letter-routing-key\", DEAD_ROUTING_KEY); // 设置死信交换机到死信队列的路由 channel.queueDeclare(NORMAL_QUEUE, false, false, false, arguments); channel.queueDeclare(DEAD_QUEUE, false, false, false, null); channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, NORMAL_ROUTING_KEY); channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, DEAD_ROUTING_KEY); DeliverCallback deliverCallback = (consumerTag, message) -\u003e System.out.println(\"Consumer1: \" + new String(message.getBody())); channel.basicConsume(NORMAL_QUEUE, true, deliverCallback, (consumerTag, message) -\u003e {}); } } public class Producer { public static void main(String[] args) throws IOException, TimeoutException { Channel channel = RabbitMqUtil.getChannel(); AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().expiration(\"10000\").build(); for (int i = 0; i \u003c 10; i++) { String message = \"hello\" + i; channel.basicPublish(NORMAL_EXCHANGE, NORMAL_ROUTING_KEY, properties, message.getBytes()); } } } // 消费死信 public class Consumer2 { public static void main(String[] args) throws IOException, TimeoutException { Channel channel = RabbitMqUtil.getChannel(); DeliverCallback deliverCallback = (consumerTag, message) -\u003e System.out.println(\"Consumer2: \" + new String(message.getBody())); channel.basicConsume(DEAD_QUEUE, true, deliverCallback, (consumerTag, message) -\u003e {}); } } 7.3、队列已满 在 consumer1 的 arguments 中设置队列长度，且将生产者的过期时间取消即可。\narguments.put(\"x-max-length\", 6); // 设置队列长度 7.4、消息被拒绝 在 consumer1 中关闭自动应答并手动发送拒绝 ack 即可。\n八、延迟队列 8.1、概念 延迟队列其实就是第七章中由于 ttl 过期导致的死信队列的演化。\n所谓的延时消息，是指消息被发送以后，并不想让消费者立刻获取，而是等待特定的时间后，消费者才能获取这个消息进行消费。\n和定时任务的区别：\n定时任务有明确的触发时间，延时任务没有 定时任务有执行周期，而延时任务在某事件触发一段时间内执行，没有执行周期 定时任务一般执行的批处理操作是多个任务，而延时任务一般是单个任务 8.2、使用场景 在订单系统中，订单如果30分钟之内没有支付成功，那么这个订单将被关闭；生成订单60s之后给用户发通知短信；这时就可以使用延时队列来处理这些订单。 用户注册成功后，若 15 天未登录则邮箱提醒。 用户希望通过手机远程遥控家里的智能设备在指定的时间进行工作。这时就可以将用户指令发送到延时队列，当指令的时间到了之后再将它推送到智能设备 订单7天自动确认收货，在我们签收商品后，物流系统会在7天后延时发送一个消息给支付系统，通知支付系统将款打给商家 预定会议后，在开会 10 分钟前通知与会人员。 8.3、延迟队列实现 由于队列先进先出的特性，只有当过期的消息到达队首，才会被丢弃或进入死信队列。所以当使用 Rabbitmq 做延迟队列来实现一个业务时，需要确保业务上的消息的延迟时间一致。若有不同的延迟时间，就必须为每种不同的延迟时间建立不同的队列。\n不推荐使用，若要通过 Rabbitmq 使用延迟队列应该使用插件\n上图中，X 为普通交换机，Y为死信交换机。QA 和 QB 队列分别延迟 10s 和 40s，QC 队列不设置延迟。QD 为死信队列。\nspring boot引入依赖\norg.springframework.boot spring-boot-starter-amqp 主配置文件配置服务器\nspring: rabbitmq: host: 192.168.36.128 port: 5672 username: guest password: guest 写配置类\n@Configuration public class TtlQueueConfig { // 交换机 public static final String X_EXCHANGE = \"X\"; public static final String DEAD_LETTER_Y_EXCHANGE = \"Y\"; // 队列 public static final String QUEUE_A = \"QA\"; public static final String QUEUE_B = \"QB\"; public static final String QUEUE_C = \"QC\"; public static final String DEAD_LETTER_QUEUE_D = \"QD\"; // 队列 A B 的过期时间 public static final Integer QUEUE_A_TTL = 10000; public static final Integer QUEUE_B_TTL = 40000; // 路由 public static final String XA_ROUTING_KEY = \"XA\"; public static final String XB_ROUTING_KEY = \"XB\"; public static final String XC_ROUTING_KEY = \"XC\"; public static final String DEAD_LETTER_ROUTING_KEY = \"YD\"; // 声明交换机 @Bean public DirectExchange xExchange() { return new DirectExchange(X_EXCHANGE); } @Bean public DirectExchange yExchange() { return new DirectExchange(DEAD_LETTER_Y_EXCHANGE); } // 声明队列并配置死信交换机 @Bean public Queue queueA() { Map\u003cString, Object\u003e arguments = new HashMap\u003c\u003e(); arguments.put(\"x-dead-letter-exchange\", DEAD_LETTER_Y_EXCHANGE); arguments.put(\"x-dead-letter-routing-key\", DEAD_LETTER_ROUTING_KEY); arguments.put(\"x-message-ttl\", QUEUE_A_TTL); return QueueBuilder.durable(QUEUE_A).withArguments(arguments).build(); } @Bean public Queue queueB() { Map\u003cString, Object\u003e arguments = new HashMap\u003c\u003e(); arguments.put(\"x-dead-letter-exchange\", DEAD_LETTER_Y_EXCHANGE); arguments.put(\"x-dead-letter-routing-key\", DEAD_LETTER_ROUTING_KEY); arguments.put(\"x-message-ttl\", QUEUE_B_TTL); return QueueBuilder.durable(QUEUE_B).withArguments(arguments).build(); } @Bean public Queue queueC() { Map\u003cString, Object\u003e arguments = new HashMap\u003c\u003e(); arguments.put(\"x-dead-letter-exchange\", DEAD_LETTER_Y_EXCHANGE); arguments.put(\"x-dead-letter-routing-key\", DEAD_LETTER_ROUTING_KEY); return QueueBuilder.durable(QUEUE_C).withArguments(arguments).build(); } @Bean public Queue queueD() { return QueueBuilder.durable(DEAD_LETTER_QUEUE_D).build(); } // 绑定 @Bean public Binding queueABindingX(@Qualifier(\"queueA\") Queue queueA, @Qualifier(\"xExchange\") DirectExchange xExchange) { return BindingBuilder.bind(queueA).to(xExchange).with(XA_ROUTING_KEY); } @Bean public Binding queueBBindingX(@Qualifier(\"queueB\") Queue queueB, @Qualifier(\"xExchange\") DirectExchange xExchange) { return BindingBuilder.bind(queueB).to(xExchange).with(XB_ROUTING_KEY); } @Bean public Binding queueCBindingX(@Qualifier(\"queueC\") Queue queueC, @Qualifier(\"xExchange\") DirectExchange xExchange) { return BindingBuilder.bind(queueC).to(xExchange).with(XC_ROUTING_KEY); } @Bean public Binding queueDBindingY(@Qualifier(\"queueD\") Queue queueD, @Qualifier(\"yExchange\") DirectExchange yExchange) { return BindingBuilder.bind(queueD).to(yExchange).with(DEAD_LETTER_ROUTING_KEY); } } 发送者与接受者\n// Controller 接收 web 的参数并发送到 mq @RestController public class SendMsgController { @Autowired private RabbitTemplate rabbitTemplate; @GetMapping(\"/ttl/msg/{message}\") public void sendMessage(@PathVariable String message) { rabbitTemplate.convertAndSend(\"X\", \"XA\", \"10s \" + message); // 向队列A发消息 rabbitTemplate.convertAndSend(\"X\", \"XB\", \"40s \" + message); // 向队列B发消息 } @GetMapping(\"/ttl/msg/{message}/{ttlTime}\") public void sendMessage(@PathVariable String message, @PathVariable String ttlTime) { rabbitTemplate.convertAndSend(\"X\", \"XC\", message, msg -\u003e { msg.getMessageProperties().setExpiration(ttlTime); return msg; }); } } // 接收死信队列的消息 @Component public class DeadLetterConsumer { @RabbitListener(queues = \"QD\") public void receiveD(Message message) { String msg = new String(message.getBody()); System.out.println(\"receive message \" + msg); } } 8.4、延迟队列插件 对队列设置 TTL 会导致系统需要很多的队列，使系统复杂。对消息设置 TTL 由于消息积压会导致不在队首的消息不能及时进入死信队列。为弥补不足，引入插件来实现延迟队列。\n# 由于 mq 容器内没有 wget ，故先在主机下载插件 wget https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/download/3.10.0/rabbitmq_delayed_message_exchange-3.10.0.ez # 复制到容器中的插件目录， mq 是容器名 docker cp rabbitmq_delayed_message_exchange-3.10.0.ez mq:/opt/rabbitmq/plugin # 进入容器启用插件 rabbitmq-plugins enable rabbitmq_delayed_message_exchange 成功启动之后，进入 web 控制台的 exchanges，添加交换机，type 栏中多了一个 x-delayed-message 选项。\n基于插件的延迟队列不需要专门设置过期队列\n@Configuration public class DelayQueueConfig { public static final String DELAYED_QUEUE = \"delayed_queue\"; public static final String DELAYED_EXCHANGE = \"delayed_exchange\"; public static final String DELAYED_ROUTING_KEY = \"delayed_routing_key\"; @Bean public CustomExchange delayedExchange() { Map\u003cString, Object\u003e arguments = new HashMap\u003c\u003e(); arguments.put(\"x-delayed-message\", \"direct\"); // 延迟交换机的类型为直连类型 /* * 1. 交换机名称 * 2. 交换机类型 * 3. 是否需要持久化 * 4. 是否自动删除 * 5. 其他参数 */ return new CustomExchange(DELAYED_EXCHANGE, \"x-delayed-message\", true, false, arguments); } @Bean public Queue delayedQueue() { return QueueBuilder.durable(DELAYED_QUEUE).build(); } @Bean public Binding delayedBinding(@Qualifier(\"delayedQueue\") Queue delayedQueue, @Qualifier(\"delayedExchange\") CustomExchange delayedExchange) { return BindingBuilder.bind(delayedQueue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs(); } } 使用时传入消息和过期时间。\n九、高级发布确认 发布确认机制包括两个部分\n1、交换机确认: 保证 Producer 生产的消息成功投递到交换机上而不发生丢失\n2、消息的回退: 保证交换机成功将消息路由到队列上而不发生消息\n9.1、发布确认+消息回退 交换机确认：交换机接收到消息后，会直接给消息生产者发送确认消息。但如果发现消息不可路由就会直接丢弃该消息，此时生产者无法感知消息已被丢弃。\n消息回退：交换机向队列传递过程中不可达的消息返回给生产者。\n即交换机确认保证发布者到交换机的消息不丢失，消息回退保证交换机到队列的消息不丢失。\n开启发布确认模式+消息回退\nspring: rabbitmq: publisher-returns: true # 开启消息回退 publisher-confirm-type: correlated # correlated：开启发布确认，异步确认 # none：禁用发布确认 # simple：同步确认，单个确认。可以通过 rabbitTemplate 调用 waitForConfirms() 方法控制逻辑。 自定义回调函数\n@Component public class MyConfirmCallback implements RabbitTemplate.ConfirmCallback, RabbitTemplate.ReturnsCallback { @Autowired private RabbitTemplate rabbitTemplate; // 该注解的作用：对象创建完成并完成注入之后执行。即执行顺序为： Construct -\u003e Autowired -\u003e PostConstruct @PostConstruct public void init() { rabbitTemplate.setConfirmCallback(this); rabbitTemplate.setReturnsCallback(this); } /** * 若交换机接收消息成功 * @param correlationData 消息的 ID 及相关信息 * @param ack b = true * @param s s = null * * 若交换机接收消息失败（宕机或网络连接失败等) * @param correlationData 消息的 ID 及相关信息 * @param ack b = false * @param s s = 失败的原因 */ @Override public void confirm(CorrelationData correlationData, boolean ack, String s) { if (ack) System.out.println(correlationData.getId()); else System.out.println(s + \" \" + correlationData.getId()); } // 消息回退 @Override public void returnedMessage(ReturnedMessage returned) { System.out.printf(\"message %s, backed by exchange %s, reason by %s, routing key is %s%n\", new String(returned.getMessage().getBody()), returned.getExchange(), returned.getReplyText(), returned.getRoutingKey()); } } 发送者\n@GetMapping(\"/confirm/msg/{msg}\") public void sendMsg(@PathVariable String msg) { // 回调函数中的 CorrelationData 需要在这里定义，可以指定消息的序号和需要返回的消息。此处模拟了一个序号 CorrelationData correlationData = new CorrelationData(\"1\"); // 交换机不存在，由发布确认保证回调 MyConfirmCallback 中的 confirm 方法 rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE + \"12\", ConfirmConfig.CONFIRM_ROUTING_KEY, msg, correlationData); // 路由不可达，由消息回退保证回调 MyConfirmCallback 中的 returnedMessage 方法 rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE, ConfirmConfig.CONFIRM_ROUTING_KEY + \"12\", msg, correlationData); } 9.2、备份交换机 交换机到队列的路由不可达时可以将消息投放给备份交换机。备份交换机将消息广播给两个队列，分别用作消息的备份与检测报警。\n注意：如果消息无法到达交换机，则直接会由发布确认机制回调交换机不可达函数，消息将不会进入备份交换机。\n如果同时开启了备份交换和消息回退，备份交换机的优先级更高。\n@Component public class ConfirmConfig { public static final String CONFIRM_QUEUE = \"confirm_queue\"; public static final String CONFIRM_EXCHANGE = \"confirm_exchange\"; public static final String CONFIRM_ROUTING_KEY = \"confirm_routing_key\"; public static final String BACKUP_QUEUE = \"backup_queue\"; public static final String WARNING_QUEUE = \"warning_queue\"; public static final String BACKUP_EXCHANGE = \"backup_exchange\"; // 声明交换机 @Bean public DirectExchange confirmExchange() { // 指定备份交换机 return ExchangeBuilder.directExchange(CONFIRM_EXCHANGE) .alternate(BACKUP_EXCHANGE).build(); } @Bean public FanoutExchange backupExchange() { return new FanoutExchange(BACKUP_EXCHANGE); } // 声明队列 @Bean public Queue confirmQueue() { return QueueBuilder.durable(CONFIRM_QUEUE).build(); } @Bean public Queue backupQueue() { return QueueBuilder.durable(BACKUP_QUEUE).build(); } @Bean public Queue warningQueue() { return QueueBuilder.durable(WARNING_QUEUE).build(); } // 绑定 @Bean public Binding confirmBinding(@Qualifier(\"confirmQueue\") Queue confirmQueue, @Qualifier(\"confirmExchange\") DirectExchange confirmExchange) { return BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY); } @Bean public Binding backToBackBinding(@Qualifier(\"backupQueue\") Queue backupQueue, @Qualifier(\"backupExchange\") FanoutExchange backupExchange) { return BindingBuilder.bind(backupQueue).to(backupExchange); } @Bean public Binding warningToBackBinding(@Qualifier(\"warningQueue\") Queue warningQueue, @Qualifier(\"backupExchange\") FanoutExchange backupExchange) { return BindingBuilder.bind(warningQueue).to(backupExchange); } } // 监听报警队列 @Component public class WarningConsumer { @RabbitListener(queues = ConfirmConfig.WARNING_QUEUE) public void receiveWarningMsg(Message message) { System.out.printf(\"warning! message {%s} does not execute success. \", new String(message.getBody())); } } 十、相关知识点 10.1、幂等性 在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简之：一个请求，不管重复来多少次，结果是不会改变的。\n消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断，故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息；注意，RabbitMQ 这种消息重试(补偿)机制是默认的。\n@RabbitListener 底层使用 AOP 进行异常通知拦截，如果程序没有抛出异常信息，那么就会自动提交事务；如果 AOP 异常通知拦截有捕获到异常信息的话，就会自动实现重试(补偿)机制，同时，这个补偿机制的消息会缓存到 RabbitMQ 服务器端进行存放，一直重试到不抛出异常为止。\n解决方式：\n为每个消息分配全局唯一ID，消费前通过 redis 的 setnx 命令写入消息的ID，若写入成功就消费，否则丢弃，此时不论是否消费都应发送ack。\n10.2、优先级队列 队列的特点是先进先出，但是有些场景下需要对队列中的消息赋予优先级，使得优先级高的消息越快被消费。优先级队列底层是大顶堆。\n由于种种原因，RabbitMQ到目前为止，官方还没有实现优先级队列，只实现了Consumer的优先级处理。即每次对队列中的消息按优先级排序后取出优先级最高的消息。\n当然，在消费端速度大于生产端速度，且broker中没有消息堆积的话，对发送的消息设置优先级也没什么实际意义，没机会排序。\n队列声明时指定最大优先级\n@Bean public Queue confirmQueue() { return QueueBuilder.durable(CONFIRM_QUEUE).maxPriority(10).build(); } 发送消息时指定消息的优先级\nrabbitTemplate.convertAndSend(\"X\", \"XC\", message, msg -\u003e { msg.getMessageProperties().setPriority(5); return msg; }); 10.3、惰性队列 惰性队列即收到消息后直接存放在磁盘中，内存中不存，消费者每次取消息时，都需要将消息加载到内存再发送给消费者，所以很慢。\n持久化是将消息即存在内存又存在磁盘，消费者去内存取。\n消费者处理消息很慢或无法处理消息使得队列积压了大量消息时可以采用惰性队列，释放内存。\n面试题\n","wordCount":"2148","inLanguage":"en","datePublished":"2022-04-07T14:42:15Z","dateModified":"2022-04-07T14:42:15Z","author":{"@type":"Person","name":"lu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/rabbitmq/rabbitmq/"},"publisher":{"@type":"Organization","name":"lu","logo":{"@type":"ImageObject","url":"https://ethereal-lu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="lu (Alt + H)">lu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethereal-lu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ethereal-lu.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">RabbitMQ基础</h1><div class=post-meta><span title='2022-04-07 14:42:15 +0000 UTC'>2022-04-07</span>&nbsp;·&nbsp;2148 words&nbsp;·&nbsp;lu</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#一概述>一、概述</a><ul><li><a href=#11什么是消息队列>1.1、什么是消息队列</a></li><li><a href=#12为什么使用消息队列>1.2、为什么使用消息队列</a></li><li><a href=#13mqtt-与-mq-的区别>1.3、mqtt 与 MQ 的区别</a></li><li><a href=#14rpc-执行流程>1.4、RPC 执行流程</a></li><li><a href=#15mq-分类>1.5、MQ 分类</a></li></ul></li><li><a href=#二rabbitmq介绍>二、RabbitMQ介绍</a><ul><li><a href=#21rabbitmq-简介>2.1、RabbitMQ 简介</a></li><li><a href=#22amqp>2.2、AMQP</a></li><li><a href=#23相关概念>2.3、相关概念</a></li></ul></li><li><a href=#三初体验>三、初体验</a><ul><li><a href=#31开启-rabbitmq>3.1、开启 rabbitmq</a></li><li><a href=#32java-使用-rabbitmq-初体验>3.2、java 使用 rabbitmq 初体验</a></li></ul></li><li><a href=#四工作队列>四、工作队列</a><ul><li><a href=#41消息应答>4.1、消息应答</a></li><li><a href=#42持久化>4.2、持久化</a></li><li><a href=#43公平分发>4.3、公平分发</a></li></ul></li><li><a href=#五发布确认>五、发布确认</a><ul><li><a href=#51单个确认发布>5.1、单个确认发布</a></li><li><a href=#52批量确认发布>5.2、批量确认发布</a></li><li><a href=#53异步确认发布>5.3、异步确认发布</a></li></ul></li><li><a href=#六交换机>六、交换机</a><ul><li><a href=#61绑定binding>6.1、绑定（binding）</a></li><li><a href=#62fanout-exchange>6.2、Fanout Exchange</a></li><li><a href=#63direct-exchange>6.3、Direct Exchange</a></li><li><a href=#64topic-exchange>6.4、Topic Exchange</a></li></ul></li><li><a href=#七死信队列>七、死信队列</a><ul><li><a href=#71死信的来源>7.1、死信的来源</a></li><li><a href=#72消息-ttl-过期>7.2、消息 TTL 过期</a></li><li><a href=#73队列已满>7.3、队列已满</a></li><li><a href=#74消息被拒绝>7.4、消息被拒绝</a></li></ul></li><li><a href=#八延迟队列>八、延迟队列</a><ul><li><a href=#81概念>8.1、概念</a></li><li><a href=#82使用场景>8.2、使用场景</a></li><li><a href=#83延迟队列实现>8.3、延迟队列实现</a></li><li><a href=#84延迟队列插件>8.4、延迟队列插件</a></li></ul></li><li><a href=#九高级发布确认>九、高级发布确认</a><ul><li><a href=#91发布确认消息回退>9.1、发布确认+消息回退</a></li><li><a href=#92备份交换机>9.2、备份交换机</a></li></ul></li><li><a href=#十相关知识点>十、相关知识点</a><ul><li><a href=#101幂等性>10.1、幂等性</a></li><li><a href=#102优先级队列>10.2、优先级队列</a></li><li><a href=#103惰性队列>10.3、惰性队列</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=一概述>一、概述<a hidden class=anchor aria-hidden=true href=#一概述>#</a></h2><h3 id=11什么是消息队列>1.1、什么是消息队列<a hidden class=anchor aria-hidden=true href=#11什么是消息队列>#</a></h3><p><strong>消息</strong>：指的是两个应用间传递的数据。数据的类型有很多种形式，可能只包含文本字符串，也可能包含嵌入对象。</p><p><strong>消息协议</strong>：为了让消息发送者和消息接收者都能够明白消息所承载的信息，它们就需要按照一种统一的格式描述消息。</p><p><strong>消息队列</strong>：（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message。</p><p>消息从发送者到接收者的方式也有两种。
一种为即时消息通讯，也就是说消息从一端发出后（消息发送者）立即就可以达到另一端（消息接收者），这种方式的具体实现就是RPC（当然单纯的http通讯也满足这个定义）；
另一种为延迟消息通讯，即消息从某一端发出后，首先进入一个容器进行临时存储，当达到某种条件后，再由这个容器发送给另一端。 这个容器的一种具体实现就是消息队列，如RabbitMQ。</p><h3 id=12为什么使用消息队列>1.2、为什么使用消息队列<a hidden class=anchor aria-hidden=true href=#12为什么使用消息队列>#</a></h3><ul><li>应用解耦：不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个；</li><li>流量削峰：如数据库只能同时处理一万条请求，如果来了两万条请求就执行一万条，将剩余一万条放在消息队列顺序执行。</li><li>异步处理：A 调用 B 处理数据，但 B 处理时间很长；A可以不用等，当B执行完将结果放在消息队列，再由消息队列将结果给A，这样就不用轮询或提供回调函数了。</li><li>广播</li><li>最终一致性</li></ul><h3 id=13mqtt-与-mq-的区别>1.3、mqtt 与 MQ 的区别<a hidden class=anchor aria-hidden=true href=#13mqtt-与-mq-的区别>#</a></h3><p><strong>mqtt</strong>：一种通信协议，类似人类交谈中的汉语、英语、俄语中的一种语言规范
<strong>MQ</strong>：一种通信通道，也叫消息队列，类似人类交谈中的用电话、email、微信的一种通信方式
<strong>json</strong>：一种内容格式，类似人类交谈中的排比句等方式</p><h3 id=14rpc-执行流程>1.4、RPC 执行流程<a hidden class=anchor aria-hidden=true href=#14rpc-执行流程>#</a></h3><p>RPC（Remote Procedure Call）远程过程调用协议，一种通过网络从远程计算机上请求服务，而不需要了解底层网络技术的协议。其主要目的是做到不同服务间调用方法像同一服务间调用本地方法一样。</p><p>当业务需要强一致性，关注业务逻辑的处理结果，则 RPC 比消息队列更合适。</p><p>强一致性指不论在任何时候读取的都是最新的数据，最终一致性是允许可以在一段时间内每个结点的数据不一致，但是经过一段时间每个结点的数据必须一致，它强调的是最终数据的一致性。</p><ol><li>客户端处理过程中调用client sub，就像调用本地方法一样，传入参数</li><li>client sub将参数编组为消息，然后通过系统调用向服务端发送消息</li><li>服务端将接收到的数据包传递给server sub</li><li>server sub将接收到的数据解组为参数</li><li>server sub再调用服务端的过程，过程执行的结果以反方向的相同步骤响应给客户端</li></ol><p>以 Google 的 grpc 为例：先在 proto 文件中声明接口，包括方法名、参数和返回值，然后使用工具生成 go 可以用的库；服务端创建 grpc 服务实例并将本地实现的服务注册进该实例中，然后监听本地端口，收到请求后就执行本地方法并将结果返回；客户端创建 grpc 客户端实例，然后调用 proto 中声明的方法即可获得结果。</p><h3 id=15mq-分类>1.5、MQ 分类<a hidden class=anchor aria-hidden=true href=#15mq-分类>#</a></h3><ul><li>ActiveMQ：老、较少使用</li><li>Kafka：大数据实时计算和日志采集方面卓越</li><li>RocketMQ：阿里开源产品</li><li>RabbitMQ：主流</li></ul><h2 id=二rabbitmq介绍>二、RabbitMQ介绍<a hidden class=anchor aria-hidden=true href=#二rabbitmq介绍>#</a></h2><h3 id=21rabbitmq-简介>2.1、RabbitMQ 简介<a hidden class=anchor aria-hidden=true href=#21rabbitmq-简介>#</a></h3><p>RabbitMQ是一个在AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。</p><h3 id=22amqp>2.2、AMQP<a hidden class=anchor aria-hidden=true href=#22amqp>#</a></h3><p>AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准<strong>高级消息队列协议</strong>,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。</p><h3 id=23相关概念>2.3、相关概念<a hidden class=anchor aria-hidden=true href=#23相关概念>#</a></h3><p><strong>Broker</strong>：简单来说就是消息队列服务器实体。</p><p><strong>Exchange</strong>：消息交换机，它指定消息按什么规则，路由到哪个队列。</p><p><strong>Queue</strong>：消息队列载体，每个消息都会被投入到一个或多个队列。</p><p><strong>Binding</strong>：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。</p><p><strong>Routing Key</strong>：路由关键字，exchange根据这个关键字进行消息投递。</p><p><strong>vhost</strong>：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。</p><p><strong>producer</strong>：消息生产者，就是投递消息的程序。</p><p><strong>consumer</strong>：消息消费者，就是接受消息的程序。</p><p><strong>channel</strong>：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。</p><p><img alt=RabbitMQ结构 loading=lazy src=/posts/%E5%88%86%E5%B8%83%E5%BC%8F/rabbitmq/rabbitmq/RabbitMQ%E7%BB%93%E6%9E%84.png></p><h2 id=三初体验>三、初体验<a hidden class=anchor aria-hidden=true href=#三初体验>#</a></h2><h3 id=31开启-rabbitmq>3.1、开启 rabbitmq<a hidden class=anchor aria-hidden=true href=#31开启-rabbitmq>#</a></h3><ol><li><p>拉镜像并启动，映射 15672 端口</p><pre tabindex=0><code>docker pull rabbitmq:management
</code></pre></li><li><p>进入容器，添加用户。这些操作全部可以在web界面上进行</p><pre tabindex=0><code>rabbitmqctl add_user admin admin                        // 添加用户
rabbitmqctl set_user_tars admin administsrstor          // 设置角色
rabbitmqctl set_permissions admin &#34;.*&#34; &#34;.*&#34; &#34;.*&#34;        // 设置权限
</code></pre></li></ol><h3 id=32java-使用-rabbitmq-初体验>3.2、java 使用 rabbitmq 初体验<a hidden class=anchor aria-hidden=true href=#32java-使用-rabbitmq-初体验>#</a></h3><p>使用默认交换机，即空字符串“”时，创建一个queue时,默认的都会有一个和新建queue同名的routingKey绑定到这个默认的exchange上去</p><ol><li>引包</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;dependencies&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;groupId&gt;</span>com.rabbitmq<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;artifactId&gt;</span>amqp-client<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;version&gt;</span>5.14.2<span style=color:#f92672>&lt;/version&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;groupId&gt;</span>commons-io<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;artifactId&gt;</span>commons-io<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;version&gt;</span>2.11.0<span style=color:#f92672>&lt;/version&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependencies&gt;</span>
</span></span></code></pre></div><ol start=2><li>Producer 发布者</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Producer</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String QUEUE_NAME <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> IOException, TimeoutException {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 连接工厂</span>
</span></span><span style=display:flex><span>        ConnectionFactory factory <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConnectionFactory();
</span></span><span style=display:flex><span>        factory.<span style=color:#a6e22e>setHost</span>(<span style=color:#e6db74>&#34;192.168.36.128&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// java 连接 rabbitmq 的端口是 5672 .大坑。所以docker 也必须暴露 5672 端口。</span>
</span></span><span style=display:flex><span>        factory.<span style=color:#a6e22e>setPort</span>(5672);
</span></span><span style=display:flex><span>        factory.<span style=color:#a6e22e>setUsername</span>(<span style=color:#e6db74>&#34;admin&#34;</span>);
</span></span><span style=display:flex><span>        factory.<span style=color:#a6e22e>setPassword</span>(<span style=color:#e6db74>&#34;admin&#34;</span>);
</span></span><span style=display:flex><span>        factory.<span style=color:#a6e22e>setConnectionTimeout</span>(50000);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 连接</span>
</span></span><span style=display:flex><span>        Connection connection <span style=color:#f92672>=</span> factory.<span style=color:#a6e22e>newConnection</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取信道</span>
</span></span><span style=display:flex><span>        Channel channel <span style=color:#f92672>=</span> connection.<span style=color:#a6e22e>createChannel</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>/** 
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 声明一个队列，参数如下：
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 1、name:    队列名称
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 2、durable: 是否持久化
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 3、exclusive: 是否排外的。如果设置为true，定义为排他队列。则只有创建者可以使用此队列。也就是private私有的。
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 4、autoDelete: 是否自动删除。也就是临时队列。当最后一个消费者断开连接后，会自动删除。
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 5、其他参数
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * */</span>
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>queueDeclare</span>(QUEUE_NAME, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>        String message <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hello World&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 发送消息  参数：1.交换机，这里使用默认交换机 2.Routing Key 3. 其他参数  4.消息</span>
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>basicPublish</span>(<span style=color:#e6db74>&#34;&#34;</span>, QUEUE_NAME, <span style=color:#66d9ef>null</span>, message.<span style=color:#a6e22e>getBytes</span>(StandardCharsets.<span style=color:#a6e22e>UTF_8</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>Consumer 消费者</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Consumer</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String QUEUE_NAME <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> IOException, TimeoutException {
</span></span><span style=display:flex><span>        ConnectionFactory factory <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConnectionFactory();
</span></span><span style=display:flex><span>        factory.<span style=color:#a6e22e>setHost</span>(<span style=color:#e6db74>&#34;192.168.36.128&#34;</span>);
</span></span><span style=display:flex><span>        factory.<span style=color:#a6e22e>setPort</span>(5672);
</span></span><span style=display:flex><span>        factory.<span style=color:#a6e22e>setUsername</span>(<span style=color:#e6db74>&#34;guest&#34;</span>);
</span></span><span style=display:flex><span>        factory.<span style=color:#a6e22e>setPassword</span>(<span style=color:#e6db74>&#34;guest&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Connection connection <span style=color:#f92672>=</span> factory.<span style=color:#a6e22e>newConnection</span>();
</span></span><span style=display:flex><span>        Channel channel <span style=color:#f92672>=</span> connection.<span style=color:#a6e22e>createChannel</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 发布者已经声明了队列，消费者就无需声明</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// channel.queueDeclare(QUEUE_NAME, false, true, false, null);</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 参数：1.队列名 2.是否使用自动应答 3.成功消费的回调 4.失败消费的回调</span>
</span></span><span style=display:flex><span>        DeliverCallback deliverCallback <span style=color:#f92672>=</span> (consumerTag,  message) <span style=color:#f92672>-&gt;</span> 
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;成功消费：&#34;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>new</span> String(message.<span style=color:#a6e22e>getBody</span>()));
</span></span><span style=display:flex><span>        CancelCallback cancelCallback <span style=color:#f92672>=</span> (consumerTag) <span style=color:#f92672>-&gt;</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;失败消费&#34;</span>);
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>basicConsume</span>(QUEUE_NAME, <span style=color:#66d9ef>true</span>, deliverCallback, cancelCallback);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=四工作队列>四、工作队列<a hidden class=anchor aria-hidden=true href=#四工作队列>#</a></h2><p>将工作封装成一个个消息发送到队列，然后由多个后台线程一起处理这些消息，从而避免同时处理大量消息。</p><p>当多个消费者订阅同一个队列时，rabbitmq 默认使用轮询的方式将消息发送给消费者，同样保证每个消息只能被一个消费者消费。</p><h3 id=41消息应答>4.1、消息应答<a hidden class=anchor aria-hidden=true href=#41消息应答>#</a></h3><p>消费者接收到消息后，突然宕机导致工作并没有完成，此时mq已经将消息删除，导致消息丢失。为避免该事件，引入<strong>消息应答</strong>机制：消费者在接收到消息并且处理完成该消息后，告诉 rabbitmq 它已经正确处理了，此时 mq 可以放心删除该消息。</p><h4 id=411自动应答>4.1.1、自动应答<a hidden class=anchor aria-hidden=true href=#411自动应答>#</a></h4><p>消费者接收到消息后，自动告诉rabbitmq服务该消息已完成，实际上消费者也仅仅是接受到了消息，有可能还没有执行完成。</p><p>当消息大量传递，消费者来不及处理导致消息积压，内存耗尽，就会被操作系统杀死，所以这种方式只适用于消费者可以高效处理的情况。所以不推荐使用自动应答。</p><h4 id=412手动应答>4.1.2、手动应答<a hidden class=anchor aria-hidden=true href=#412手动应答>#</a></h4><p>当autoAck 参数为 false 时，对于 RabbitMQ 服务器端而言，队列中的消息分成了两部分：一部分是等待投递给消费者的消息；一部分是已经投递给消费者，但是还没有收到消费者确认信号的消息。如果 RabbitMQ 服务器端一直没有收到消费者的确认信号，并且消费此消息的消费者已经断开连接，则服务器端会安排该消息重新进入队列，等待投递给下一个消费者（也可能还是原来的那个消费者）。</p><p>RabbitMQ <strong>不会</strong>为未确认的消息<strong>设置过期时间</strong>，它判断此消息是否需要重新投递给消费者的唯一依据是消费者的连接是否已经断开，这个设置的原因是 RabbitMQ 允许消费者消费一条消息的时间可以很久很久。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>channel.<span style=color:#a6e22e>basicAck</span>();       <span style=color:#75715e>// 肯定确认</span>
</span></span><span style=display:flex><span>channel.<span style=color:#a6e22e>basicNack</span>();      <span style=color:#75715e>// 否定确认</span>
</span></span><span style=display:flex><span>channel.<span style=color:#a6e22e>basicReject</span>();    <span style=color:#75715e>// 否定确认，比 basicNack 少了批量处理的参数</span>
</span></span></code></pre></div><p>批量应答类似于 TCP 传输的累计确认，即若队列接收到消费者对于 8 号消息的确认，则认为消费者已经成功处理了 1 ~ 8 号消息，尽管之前可能没有收到来自 1~7 号的确认。但是<strong>不建议使用批量应答</strong>，当有多个消费者时，若消费者1处理 3 号消息，但还没有处理完就宕机了，此时消费者 2 已经处理完了 5 号消息并批量应答，就会造成 3 号消息的丢失。而 TCP 由于是点对点协议，因此没有这种情况的发生。</p><h4 id=413消息自动重新入队>4.1.3、消息自动重新入队<a hidden class=anchor aria-hidden=true href=#413消息自动重新入队>#</a></h4><p>如果消费者由于某些原因失去连接(其通道关闭，连接关闭或 TCP 连接丢失，宕机)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Consumer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> IOException, TimeoutException {
</span></span><span style=display:flex><span>        Channel channel <span style=color:#f92672>=</span> RabbitMqUtil.<span style=color:#a6e22e>getChannel</span>();
</span></span><span style=display:flex><span>        DeliverCallback deliverCallback <span style=color:#f92672>=</span> (consumerTag,  message) <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;成功消费：&#34;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>new</span> String(message.<span style=color:#a6e22e>getBody</span>()));
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 手动应答，且取消批量应答</span>
</span></span><span style=display:flex><span>            channel.<span style=color:#a6e22e>basicAck</span>(message.<span style=color:#a6e22e>getEnvelope</span>().<span style=color:#a6e22e>getDeliveryTag</span>(), <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        CancelCallback cancelCallback <span style=color:#f92672>=</span> (consumerTag) <span style=color:#f92672>-&gt;</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;失败消费&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 取消自动应答</span>
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>basicConsume</span>(HELLO, <span style=color:#66d9ef>false</span>, deliverCallback, cancelCallback);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=42持久化>4.2、持久化<a hidden class=anchor aria-hidden=true href=#42持久化>#</a></h3><p>rabbitmq 服务器退出或宕机时，存在于内存中的队列和消息就会丢失，因此需要将队列和消息持久化。</p><h4 id=421队列持久化>4.2.1、队列持久化<a hidden class=anchor aria-hidden=true href=#421队列持久化>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>channel.<span style=color:#a6e22e>queueDeclare</span>(QUEUE_NAME, <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>null</span>);   <span style=color:#75715e>// 第二个参数为 durable: 是否持久化</span>
</span></span></code></pre></div><p>声明队列时将其设置为持久化即可，但是若想要将一个已经存在的非持久化队列修改为持久化，需要先删除原有队列，再创建新队列，否则报错。</p><h4 id=422消息持久化>4.2.2、消息持久化<a hidden class=anchor aria-hidden=true href=#422消息持久化>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>channel.<span style=color:#a6e22e>basicPublish</span>(<span style=color:#e6db74>&#34;&#34;</span>, HELLO, MessageProperties.<span style=color:#a6e22e>PERSISTENT_TEXT_PLAIN</span>, message.<span style=color:#a6e22e>getBytes</span>());
</span></span></code></pre></div><p>发布消息时，将消息属性设为持久化，此处设置为文本持久化。但是还不能保证消息不会完全丢失，当 mq 存入磁盘之前就宕机了，仍然会导致消息丢失，可以通过发布确认确保不丢失。</p><p>设置了队列和消息的持久化之后，当broker服务重启的之后，消息依旧存在。单只设置队列持久化，重启之后消息会丢失；单只设置消息的持久化，重启之后队列消失，既而消息也丢失。单单设置消息持久化而不设置队列的持久化显得毫无意义。</p><h3 id=43公平分发>4.3、公平分发<a hidden class=anchor aria-hidden=true href=#43公平分发>#</a></h3><p>rabbitmq 默认采用轮询分发。当多个消费者的处理性能相差很多时，若采用轮询分发会降低吞吐率，因此应该使用公平分发。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 消费者端设置</span>
</span></span><span style=display:flex><span>channel.<span style=color:#a6e22e>basicQos</span>(<span style=color:#66d9ef>int</span> prefetch_count);
</span></span></code></pre></div><p>一句话表示就是 prefetch_count 表示当前信道能存在的最多的未ack的消息个数</p><p>每个 channe 都会记录自己 prefetch_count 的值，同时记录的还有该channel未ack的消息个数。</p><p>当rabbitmq要将队列中的一条消息投递给消费者时，会遍历该队列上的消费者列表，选一个合适的消费者，然后将消息投递出去，投递的时候是在同一时刻将大量消息投递进去，使其直接变满。其中挑选消费者的一个依据就是看消费者对应的channel上未ack的消息数是否达到设置的prefetch_count个数，如果未ack的消息数达到了prefetch_count的个数，则不符合要求。当挑选到合适的消费者后，中断后续的遍历。当消费者对消息进行ack后，会修改该消费者对应channel中未ack的消息数，这样队列又可以将消息投递给该消费者。</p><p>注：prefetch_count 必须在手动应答时才生效，如果是自动应答还是轮询。</p><p>prefetch_count 默认为 0 ，即轮询分发。</p><h2 id=五发布确认>五、发布确认<a hidden class=anchor aria-hidden=true href=#五发布确认>#</a></h2><p>当队列将消息保存在磁盘之后，向发布者发送确认消息，如此能确保 mq 将消息持久化了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>channel.<span style=color:#a6e22e>confirmSelect</span>();  <span style=color:#75715e>// 发布者端设置，开启发布确认</span>
</span></span></code></pre></div><p>如果设置了持久化，则必须保存到磁盘之后才会确认，否则，收到消息就直接确认。</p><h3 id=51单个确认发布>5.1、单个确认发布<a hidden class=anchor aria-hidden=true href=#51单个确认发布>#</a></h3><p>每发一条消息，必须收到确认才会发送下一条消息。速度慢。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>boolean</span> confirm <span style=color:#f92672>=</span> channel.<span style=color:#a6e22e>waitForConfirms</span>();   <span style=color:#75715e>// 每次发送消息后都要判断 confirm 为 true 才能发送下一条消息</span>
</span></span></code></pre></div><h3 id=52批量确认发布>5.2、批量确认发布<a hidden class=anchor aria-hidden=true href=#52批量确认发布>#</a></h3><p>发布一批消息后一起确认，可以提高吞吐率，但是若出现故障，不知道是哪一条消息的问题。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>int</span> batch <span style=color:#f92672>=</span> 100;
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 1000; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    String message <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;Hello World&#34;</span>;
</span></span><span style=display:flex><span>    channel.<span style=color:#a6e22e>basicPublish</span>(<span style=color:#e6db74>&#34;&#34;</span>, HELLO, MessageProperties.<span style=color:#a6e22e>PERSISTENT_TEXT_PLAIN</span>, message.<span style=color:#a6e22e>getBytes</span>());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>%</span> batch <span style=color:#f92672>==</span> 0)    <span style=color:#75715e>// 手动批量😀</span>
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>waitForConfirms</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=53异步确认发布>5.3、异步确认发布<a hidden class=anchor aria-hidden=true href=#53异步确认发布>#</a></h3><p>效率和可靠新都能保障。通过回调函数达到消息可靠传输。</p><p>发布的消息封装在一个 map 中，key 为消息的序号，value 为消息的值。发布者无需担心消息是否接收成功，只管发送即可，broke 会对 map 中的每一条消息处理，如果接收成功，则向发送者回复收到，否则向发送者回复未收到。对每一条消息都回复。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ProduceAsync</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> IOException, TimeoutException {
</span></span><span style=display:flex><span>        Channel channel <span style=color:#f92672>=</span> RabbitMqUtil.<span style=color:#a6e22e>getChannel</span>();
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>queueDeclare</span>(HELLO, <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 开启发布确认</span>
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>confirmSelect</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 此处逻辑为：先将所有消息记录下来，在确认回调中删除掉已确认的，剩下的既是未确认的。</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 之所以没有在未确认回调中直接添加数据，是因为回调函数只能获取到序号，无法获取消息体。</span>
</span></span><span style=display:flex><span>        ConcurrentSkipListMap<span style=color:#f92672>&lt;</span>Long, Object<span style=color:#f92672>&gt;</span> information <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConcurrentSkipListMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 消息接受成功回调函数</span>
</span></span><span style=display:flex><span>        ConfirmCallback ackCallback <span style=color:#f92672>=</span> (deliveryTag, multiple) <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 批量操作</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (multiple) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 此处 confirmed 是 outstandingConfirms 的视图，对 confirm 的操作会影响到 outstandingConfirm。</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 因此，这一步的结果是删除掉所有已确认的消息</span>
</span></span><span style=display:flex><span>                ConcurrentNavigableMap<span style=color:#f92672>&lt;</span>Long, Object<span style=color:#f92672>&gt;</span> confirmed <span style=color:#f92672>=</span> information.<span style=color:#a6e22e>headMap</span>(deliveryTag);
</span></span><span style=display:flex><span>                confirmed.<span style=color:#a6e22e>clear</span>();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                information.<span style=color:#a6e22e>remove</span>(deliveryTag);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 消息接受失败回调函数</span>
</span></span><span style=display:flex><span>        ConfirmCallback nackCallback <span style=color:#f92672>=</span> (deliveryTag, multiple) <span style=color:#f92672>-&gt;</span> {};
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 监听器，异步通知。这里会开辟一个线程负责监听并回调。</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 这里只是将未确认的消息保存了下来，这些消息该如何处理？直接使用吗？</span>
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>addConfirmListener</span>(ackCallback, nackCallback);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 100; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            String message <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello&#34;</span> <span style=color:#f92672>+</span> i;
</span></span><span style=display:flex><span>            information.<span style=color:#a6e22e>put</span>(channel.<span style=color:#a6e22e>getNextPublishSeqNo</span>(), message);
</span></span><span style=display:flex><span>            channel.<span style=color:#a6e22e>basicPublish</span>(<span style=color:#e6db74>&#34;&#34;</span>, HELLO, MessageProperties.<span style=color:#a6e22e>PERSISTENT_TEXT_PLAIN</span>, message.<span style=color:#a6e22e>getBytes</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=六交换机>六、交换机<a hidden class=anchor aria-hidden=true href=#六交换机>#</a></h2><p>生产者生产的消息不会直接发送到队列，只能发给交换机。交换机的工作有两个，一是接收来自生产者的消息，二是将他们推入队列。交换机必须确切知道该如何处理接收到的消息，是将其发送到特定的一个或多个队列还是丢弃。这些都由交换机的类型决定。类型如下：</p><ul><li>Direct Exchange：直连交换机，根据Routing Key(路由键)进行投递到不同队列。（默认）</li><li>Fanout Exchange：扇形交换机，采用广播模式，根据绑定的交换机，路由到与之对应的所有队列。</li><li>Topic Exchange：主题交换机，对路由键进行模式匹配后进行投递，符号<code>#</code>表示0个或多个词，<code>*</code>表示一个词。</li><li>Header Exchange：头交换机，不处理路由键。而是根据发送的消息内容中的headers属性进行匹配。（基本废弃）</li></ul><p>若想要改变一个交换机的类型，需要先删除原有交换机，再创建新交换机，否则报错。</p><h3 id=61绑定binding>6.1、绑定（binding）<a hidden class=anchor aria-hidden=true href=#61绑定binding>#</a></h3><p>Binding 就是 Exchange 和 Queue 之间的桥梁。Exchange 根据绑定关系将数据发送给 Queue 。</p><h3 id=62fanout-exchange>6.2、Fanout Exchange<a hidden class=anchor aria-hidden=true href=#62fanout-exchange>#</a></h3><p>Fanout Exchange 与 Routing_Key 没有任何关系，即 Exchange 会向<strong>所有</strong>与它绑定的队列广播消息，尽管某些队列使用的 Routing_Key 发布者指定的 Routing_Key 不同，也会发送。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Producer</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String EXCHANGE_NAME <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;first_exchange&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String ROUTING_KEY <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;first_routing_key&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> IOException, TimeoutException {
</span></span><span style=display:flex><span>        Channel channel <span style=color:#f92672>=</span> RabbitMqUtil.<span style=color:#a6e22e>getChannel</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 声明交换机，类型为 FANOUT 广播类型</span>
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>exchangeDeclare</span>(EXCHANGE_NAME, BuiltinExchangeType.<span style=color:#a6e22e>FANOUT</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Scanner sc <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Scanner(System.<span style=color:#a6e22e>in</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (sc.<span style=color:#a6e22e>hasNext</span>()) {
</span></span><span style=display:flex><span>            String message <span style=color:#f92672>=</span> sc.<span style=color:#a6e22e>next</span>();
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 发送消息到指定的交换机并指明使用的 ROUTING_KEY</span>
</span></span><span style=display:flex><span>            channel.<span style=color:#a6e22e>basicPublish</span>(EXCHANGE_NAME, ROUTING_KEY, <span style=color:#66d9ef>null</span>, message.<span style=color:#a6e22e>getBytes</span>(StandardCharsets.<span style=color:#a6e22e>UTF_8</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Consumer1</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> IOException, TimeoutException {
</span></span><span style=display:flex><span>        Channel channel <span style=color:#f92672>=</span> RabbitMqUtil.<span style=color:#a6e22e>getChannel</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 声明一个临时队列，消费者断开就自动删除</span>
</span></span><span style=display:flex><span>        String queueName <span style=color:#f92672>=</span> channel.<span style=color:#a6e22e>queueDeclare</span>().<span style=color:#a6e22e>getQueue</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 绑定</span>
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>queueBind</span>(queueName, EXCHANGE_NAME, ROUTING_KEY);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        DeliverCallback deliverCallback <span style=color:#f92672>=</span> (consumerTag, message) <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Consumer1: &#34;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>new</span> String(message.<span style=color:#a6e22e>getBody</span>()));
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>basicConsume</span>(queueName, <span style=color:#66d9ef>true</span>, deliverCallback, (consumerTag, message) <span style=color:#f92672>-&gt;</span> {});
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Consumer2</span> {}  <span style=color:#75715e>// Consumer2 与 Consumer1 完全相同</span>
</span></span></code></pre></div><h3 id=63direct-exchange>6.3、Direct Exchange<a hidden class=anchor aria-hidden=true href=#63direct-exchange>#</a></h3><p>Direct Exchange 仅会向与它通过特定的 Routing_Key 绑定的队列发送消息，这个特定的 Routing_Key 就是发布者指定的 Routing_Key。</p><h3 id=64topic-exchange>6.4、Topic Exchange<a hidden class=anchor aria-hidden=true href=#64topic-exchange>#</a></h3><p>Topic Exchange 中，可以使用带有通配符的 Routing_Key 将 Exchange 和 Queue 进行绑定。</p><p>在该模式中，发布者指定的 Routing_Key 必须以点号隔开的单词列表，如 com.lu.mq</p><p><code>#</code>匹配 0 个或多个词，<code>*</code>表示 1 个词。注意是点与点之间的完成的词，不是字母。如 com.*.mq、 com.#</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Producer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String EXCHANGE_NAME <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;third_exchange&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String ROUTING_KEY <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;com.lu.mq&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> IOException, TimeoutException {
</span></span><span style=display:flex><span>        Channel channel <span style=color:#f92672>=</span> RabbitMqUtil.<span style=color:#a6e22e>getChannel</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 声明交换机，类型为 TOPIC 主题类型</span>
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>exchangeDeclare</span>(EXCHANGE_NAME, BuiltinExchangeType.<span style=color:#a6e22e>TOPIC</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Scanner sc <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Scanner(System.<span style=color:#a6e22e>in</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (sc.<span style=color:#a6e22e>hasNext</span>()) {
</span></span><span style=display:flex><span>            String message <span style=color:#f92672>=</span> sc.<span style=color:#a6e22e>next</span>();
</span></span><span style=display:flex><span>            channel.<span style=color:#a6e22e>basicPublish</span>(EXCHANGE_NAME, ROUTING_KEY, <span style=color:#66d9ef>null</span>, message.<span style=color:#a6e22e>getBytes</span>(StandardCharsets.<span style=color:#a6e22e>UTF_8</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Consumer1</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> IOException, TimeoutException {
</span></span><span style=display:flex><span>        Channel channel <span style=color:#f92672>=</span> RabbitMqUtil.<span style=color:#a6e22e>getChannel</span>();
</span></span><span style=display:flex><span>        String queueName <span style=color:#f92672>=</span> channel.<span style=color:#a6e22e>queueDeclare</span>().<span style=color:#a6e22e>getQueue</span>();
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>queueBind</span>(queueName, EXCHANGE_NAME, <span style=color:#e6db74>&#34;com.#&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        DeliverCallback deliverCallback <span style=color:#f92672>=</span> (consumerTag, message) <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Consumer1: &#34;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>new</span> String(message.<span style=color:#a6e22e>getBody</span>()));
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>basicConsume</span>(queueName, <span style=color:#66d9ef>true</span>, deliverCallback, (consumerTag, message) <span style=color:#f92672>-&gt;</span> {});
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Consumer2</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> IOException, TimeoutException {
</span></span><span style=display:flex><span>        Channel channel <span style=color:#f92672>=</span> RabbitMqUtil.<span style=color:#a6e22e>getChannel</span>();
</span></span><span style=display:flex><span>        String queueName <span style=color:#f92672>=</span> channel.<span style=color:#a6e22e>queueDeclare</span>().<span style=color:#a6e22e>getQueue</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 一个队列可以通过不同的 Routing_Key 绑定一个或多个交换机</span>
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>queueBind</span>(queueName, EXCHANGE_NAME, <span style=color:#e6db74>&#34;com.*.mq&#34;</span>);
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>queueBind</span>(queueName, EXCHANGE_NAME, <span style=color:#e6db74>&#34;com.lu.*&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        DeliverCallback deliverCallback <span style=color:#f92672>=</span> (consumerTag, message) <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Consumer2: &#34;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>new</span> String(message.<span style=color:#a6e22e>getBody</span>()));
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>basicConsume</span>(queueName, <span style=color:#66d9ef>true</span>, deliverCallback, (consumerTag, message) <span style=color:#f92672>-&gt;</span> {});
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=七死信队列>七、死信队列<a hidden class=anchor aria-hidden=true href=#七死信队列>#</a></h2><p>没有被消费者消费的消息叫做死信，存放死信的队列叫做死信队列。</p><p>有点类似于阻塞队列，条件不满足就阻塞，直到条件满足被唤醒。</p><p>应用场景：消息消费发生异常时，放入死信队列，以防止消息丢失；用户下单未支付，超时后将订单放入死信队列。</p><h3 id=71死信的来源>7.1、死信的来源<a hidden class=anchor aria-hidden=true href=#71死信的来源>#</a></h3><ul><li>消息 TTL 过期<ul><li>TTL是<code>Time To Live</code>的缩写，也就是生存时间。</li><li>RabbitMQ支持消息的过期时间，在消息发送时可以进行指定，仅作用于该消息</li><li>RabbitMQ支持为每个队列设置消息的超时时间，从消息入队列开始计算，如果超时消息会自动清除，作用于整个队列</li></ul></li><li>队列已满</li><li>消息被拒绝（reject、nack）且 requeue = false</li></ul><h3 id=72消息-ttl-过期>7.2、消息 TTL 过期<a hidden class=anchor aria-hidden=true href=#72消息-ttl-过期>#</a></h3><p><img alt=死信队列 loading=lazy src=/posts/%E5%88%86%E5%B8%83%E5%BC%8F/rabbitmq/rabbitmq/%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97.png></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 交换机和队列的声明放在哪里都可以</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Consumer1</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String NORMAL_EXCHANGE <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;normal_exchange&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String DEAD_EXCHANGE <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;dead_exchange&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String NORMAL_QUEUE <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;normal_queue&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String DEAD_QUEUE <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;dead_queue&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String NORMAL_ROUTING_KEY <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;normal_routing_key&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String DEAD_ROUTING_KEY <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;dead_routing_key&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> IOException, TimeoutException {
</span></span><span style=display:flex><span>        Channel channel <span style=color:#f92672>=</span> RabbitMqUtil.<span style=color:#a6e22e>getChannel</span>();
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>exchangeDeclare</span>(NORMAL_EXCHANGE, BuiltinExchangeType.<span style=color:#a6e22e>DIRECT</span>);
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>exchangeDeclare</span>(DEAD_EXCHANGE, BuiltinExchangeType.<span style=color:#a6e22e>DIRECT</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Map<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span> arguments <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        arguments.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;x-dead-letter-exchange&#34;</span>, DEAD_EXCHANGE);  <span style=color:#75715e>// 指定死信消息应该发送给哪个死信交换机</span>
</span></span><span style=display:flex><span>        arguments.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;x-dead-letter-routing-key&#34;</span>, DEAD_ROUTING_KEY);  <span style=color:#75715e>// 设置死信交换机到死信队列的路由</span>
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>queueDeclare</span>(NORMAL_QUEUE, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>, arguments);
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>queueDeclare</span>(DEAD_QUEUE, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>queueBind</span>(NORMAL_QUEUE, NORMAL_EXCHANGE, NORMAL_ROUTING_KEY);
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>queueBind</span>(DEAD_QUEUE, DEAD_EXCHANGE, DEAD_ROUTING_KEY);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        DeliverCallback deliverCallback <span style=color:#f92672>=</span> (consumerTag, message) <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Consumer1: &#34;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>new</span> String(message.<span style=color:#a6e22e>getBody</span>()));
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>basicConsume</span>(NORMAL_QUEUE, <span style=color:#66d9ef>true</span>, deliverCallback, (consumerTag, message) <span style=color:#f92672>-&gt;</span> {});
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Producer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> IOException, TimeoutException {
</span></span><span style=display:flex><span>        Channel channel <span style=color:#f92672>=</span> RabbitMqUtil.<span style=color:#a6e22e>getChannel</span>();
</span></span><span style=display:flex><span>        AMQP.<span style=color:#a6e22e>BasicProperties</span> properties <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AMQP.<span style=color:#a6e22e>BasicProperties</span>().<span style=color:#a6e22e>builder</span>().<span style=color:#a6e22e>expiration</span>(<span style=color:#e6db74>&#34;10000&#34;</span>).<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 10; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            String message <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello&#34;</span> <span style=color:#f92672>+</span> i;
</span></span><span style=display:flex><span>            channel.<span style=color:#a6e22e>basicPublish</span>(NORMAL_EXCHANGE, NORMAL_ROUTING_KEY, properties, message.<span style=color:#a6e22e>getBytes</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 消费死信</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Consumer2</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> IOException, TimeoutException {
</span></span><span style=display:flex><span>        Channel channel <span style=color:#f92672>=</span> RabbitMqUtil.<span style=color:#a6e22e>getChannel</span>();
</span></span><span style=display:flex><span>        DeliverCallback deliverCallback <span style=color:#f92672>=</span> (consumerTag, message) <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Consumer2: &#34;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>new</span> String(message.<span style=color:#a6e22e>getBody</span>()));
</span></span><span style=display:flex><span>        channel.<span style=color:#a6e22e>basicConsume</span>(DEAD_QUEUE, <span style=color:#66d9ef>true</span>, deliverCallback, (consumerTag, message) <span style=color:#f92672>-&gt;</span> {});
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=73队列已满>7.3、队列已满<a hidden class=anchor aria-hidden=true href=#73队列已满>#</a></h3><p>在 consumer1 的 arguments 中设置队列长度，且将生产者的过期时间取消即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>arguments.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;x-max-length&#34;</span>, 6);   <span style=color:#75715e>// 设置队列长度</span>
</span></span></code></pre></div><h3 id=74消息被拒绝>7.4、消息被拒绝<a hidden class=anchor aria-hidden=true href=#74消息被拒绝>#</a></h3><p>在 consumer1 中关闭自动应答并手动发送拒绝 ack 即可。</p><h2 id=八延迟队列>八、延迟队列<a hidden class=anchor aria-hidden=true href=#八延迟队列>#</a></h2><h3 id=81概念>8.1、概念<a hidden class=anchor aria-hidden=true href=#81概念>#</a></h3><p>延迟队列其实就是第七章中由于 ttl 过期导致的死信队列的演化。</p><p>所谓的延时消息，是指消息被发送以后，并不想让消费者立刻获取，而是等待特定的时间后，消费者才能获取这个消息进行消费。</p><p>和定时任务的区别：</p><ol><li>定时任务有明确的触发时间，延时任务没有</li><li>定时任务有执行周期，而延时任务在某事件触发一段时间内执行，没有执行周期</li><li>定时任务一般执行的批处理操作是多个任务，而延时任务一般是单个任务</li></ol><h3 id=82使用场景>8.2、使用场景<a hidden class=anchor aria-hidden=true href=#82使用场景>#</a></h3><ul><li>在订单系统中，订单如果30分钟之内没有支付成功，那么这个订单将被关闭；生成订单60s之后给用户发通知短信；这时就可以使用延时队列来处理这些订单。</li><li>用户注册成功后，若 15 天未登录则邮箱提醒。</li><li>用户希望通过手机远程遥控家里的智能设备在指定的时间进行工作。这时就可以将用户指令发送到延时队列，当指令的时间到了之后再将它推送到智能设备</li><li>订单7天自动确认收货，在我们签收商品后，物流系统会在7天后延时发送一个消息给支付系统，通知支付系统将款打给商家</li><li>预定会议后，在开会 10 分钟前通知与会人员。</li></ul><h3 id=83延迟队列实现>8.3、延迟队列实现<a hidden class=anchor aria-hidden=true href=#83延迟队列实现>#</a></h3><p>由于队列先进先出的特性，只有当过期的消息到达队首，才会被丢弃或进入死信队列。所以当使用 Rabbitmq 做延迟队列来实现一个业务时，需要确保业务上的消息的延迟时间一致。若有不同的延迟时间，就必须为每种不同的延迟时间建立不同的队列。</p><p><strong>不推荐使用，若要通过 Rabbitmq 使用延迟队列应该使用插件</strong></p><p><img alt=延迟队列架构 loading=lazy src=/posts/%E5%88%86%E5%B8%83%E5%BC%8F/rabbitmq/rabbitmq/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E6%9E%B6%E6%9E%84.png></p><p>上图中，X 为普通交换机，Y为死信交换机。QA 和 QB 队列分别延迟 10s 和 40s，QC 队列不设置延迟。QD 为死信队列。</p><ol><li><p>spring boot引入依赖</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.boot<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>spring-boot-starter-amqp<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span></code></pre></div></li><li><p>主配置文件配置服务器</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>rabbitmq</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>host</span>: <span style=color:#ae81ff>192.168.36.128</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>port</span>: <span style=color:#ae81ff>5672</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>username</span>: <span style=color:#ae81ff>guest</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>password</span>: <span style=color:#ae81ff>guest</span>
</span></span></code></pre></div></li><li><p>写配置类</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Configuration</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TtlQueueConfig</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 交换机</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String X_EXCHANGE <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;X&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String DEAD_LETTER_Y_EXCHANGE <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Y&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 队列</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String QUEUE_A <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;QA&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String QUEUE_B <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;QB&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String QUEUE_C <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;QC&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String DEAD_LETTER_QUEUE_D <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;QD&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 队列 A B 的过期时间</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Integer QUEUE_A_TTL <span style=color:#f92672>=</span> 10000;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Integer QUEUE_B_TTL <span style=color:#f92672>=</span> 40000;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 路由</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String XA_ROUTING_KEY <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;XA&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String XB_ROUTING_KEY <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;XB&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String XC_ROUTING_KEY <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;XC&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String DEAD_LETTER_ROUTING_KEY <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;YD&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 声明交换机</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> DirectExchange <span style=color:#a6e22e>xExchange</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> DirectExchange(X_EXCHANGE);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> DirectExchange <span style=color:#a6e22e>yExchange</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> DirectExchange(DEAD_LETTER_Y_EXCHANGE);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 声明队列并配置死信交换机</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Queue <span style=color:#a6e22e>queueA</span>() {
</span></span><span style=display:flex><span>        Map<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span> arguments <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        arguments.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;x-dead-letter-exchange&#34;</span>, DEAD_LETTER_Y_EXCHANGE);
</span></span><span style=display:flex><span>        arguments.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;x-dead-letter-routing-key&#34;</span>, DEAD_LETTER_ROUTING_KEY);
</span></span><span style=display:flex><span>        arguments.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;x-message-ttl&#34;</span>, QUEUE_A_TTL);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> QueueBuilder.<span style=color:#a6e22e>durable</span>(QUEUE_A).<span style=color:#a6e22e>withArguments</span>(arguments).<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Queue <span style=color:#a6e22e>queueB</span>() {
</span></span><span style=display:flex><span>        Map<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span> arguments <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        arguments.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;x-dead-letter-exchange&#34;</span>, DEAD_LETTER_Y_EXCHANGE);
</span></span><span style=display:flex><span>        arguments.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;x-dead-letter-routing-key&#34;</span>, DEAD_LETTER_ROUTING_KEY);
</span></span><span style=display:flex><span>        arguments.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;x-message-ttl&#34;</span>, QUEUE_B_TTL);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> QueueBuilder.<span style=color:#a6e22e>durable</span>(QUEUE_B).<span style=color:#a6e22e>withArguments</span>(arguments).<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Queue <span style=color:#a6e22e>queueC</span>() {
</span></span><span style=display:flex><span>        Map<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span> arguments <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        arguments.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;x-dead-letter-exchange&#34;</span>, DEAD_LETTER_Y_EXCHANGE);
</span></span><span style=display:flex><span>        arguments.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;x-dead-letter-routing-key&#34;</span>, DEAD_LETTER_ROUTING_KEY);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> QueueBuilder.<span style=color:#a6e22e>durable</span>(QUEUE_C).<span style=color:#a6e22e>withArguments</span>(arguments).<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Queue <span style=color:#a6e22e>queueD</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> QueueBuilder.<span style=color:#a6e22e>durable</span>(DEAD_LETTER_QUEUE_D).<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 绑定</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Binding <span style=color:#a6e22e>queueABindingX</span>(<span style=color:#a6e22e>@Qualifier</span>(<span style=color:#e6db74>&#34;queueA&#34;</span>) Queue queueA, 
</span></span><span style=display:flex><span>                                  <span style=color:#a6e22e>@Qualifier</span>(<span style=color:#e6db74>&#34;xExchange&#34;</span>) DirectExchange xExchange) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> BindingBuilder.<span style=color:#a6e22e>bind</span>(queueA).<span style=color:#a6e22e>to</span>(xExchange).<span style=color:#a6e22e>with</span>(XA_ROUTING_KEY);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Binding <span style=color:#a6e22e>queueBBindingX</span>(<span style=color:#a6e22e>@Qualifier</span>(<span style=color:#e6db74>&#34;queueB&#34;</span>) Queue queueB,
</span></span><span style=display:flex><span>                                  <span style=color:#a6e22e>@Qualifier</span>(<span style=color:#e6db74>&#34;xExchange&#34;</span>) DirectExchange xExchange) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> BindingBuilder.<span style=color:#a6e22e>bind</span>(queueB).<span style=color:#a6e22e>to</span>(xExchange).<span style=color:#a6e22e>with</span>(XB_ROUTING_KEY);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Binding <span style=color:#a6e22e>queueCBindingX</span>(<span style=color:#a6e22e>@Qualifier</span>(<span style=color:#e6db74>&#34;queueC&#34;</span>) Queue queueC,
</span></span><span style=display:flex><span>                                  <span style=color:#a6e22e>@Qualifier</span>(<span style=color:#e6db74>&#34;xExchange&#34;</span>) DirectExchange xExchange) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> BindingBuilder.<span style=color:#a6e22e>bind</span>(queueC).<span style=color:#a6e22e>to</span>(xExchange).<span style=color:#a6e22e>with</span>(XC_ROUTING_KEY);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Binding <span style=color:#a6e22e>queueDBindingY</span>(<span style=color:#a6e22e>@Qualifier</span>(<span style=color:#e6db74>&#34;queueD&#34;</span>) Queue queueD,
</span></span><span style=display:flex><span>                                  <span style=color:#a6e22e>@Qualifier</span>(<span style=color:#e6db74>&#34;yExchange&#34;</span>) DirectExchange yExchange) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> BindingBuilder.<span style=color:#a6e22e>bind</span>(queueD).<span style=color:#a6e22e>to</span>(yExchange).<span style=color:#a6e22e>with</span>(DEAD_LETTER_ROUTING_KEY);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>发送者与接受者</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Controller 接收 web 的参数并发送到 mq</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@RestController</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SendMsgController</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> RabbitTemplate rabbitTemplate;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@GetMapping</span>(<span style=color:#e6db74>&#34;/ttl/msg/{message}&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sendMessage</span>(<span style=color:#a6e22e>@PathVariable</span> String message) {
</span></span><span style=display:flex><span>        rabbitTemplate.<span style=color:#a6e22e>convertAndSend</span>(<span style=color:#e6db74>&#34;X&#34;</span>, <span style=color:#e6db74>&#34;XA&#34;</span>, <span style=color:#e6db74>&#34;10s &#34;</span> <span style=color:#f92672>+</span> message);  <span style=color:#75715e>// 向队列A发消息</span>
</span></span><span style=display:flex><span>        rabbitTemplate.<span style=color:#a6e22e>convertAndSend</span>(<span style=color:#e6db74>&#34;X&#34;</span>, <span style=color:#e6db74>&#34;XB&#34;</span>, <span style=color:#e6db74>&#34;40s &#34;</span> <span style=color:#f92672>+</span> message);  <span style=color:#75715e>// 向队列B发消息</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@GetMapping</span>(<span style=color:#e6db74>&#34;/ttl/msg/{message}/{ttlTime}&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sendMessage</span>(<span style=color:#a6e22e>@PathVariable</span> String message, <span style=color:#a6e22e>@PathVariable</span> String ttlTime) {
</span></span><span style=display:flex><span>        rabbitTemplate.<span style=color:#a6e22e>convertAndSend</span>(<span style=color:#e6db74>&#34;X&#34;</span>, <span style=color:#e6db74>&#34;XC&#34;</span>, message, msg  <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            msg.<span style=color:#a6e22e>getMessageProperties</span>().<span style=color:#a6e22e>setExpiration</span>(ttlTime);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> msg;
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 接收死信队列的消息</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Component</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DeadLetterConsumer</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@RabbitListener</span>(queues <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;QD&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>receiveD</span>(Message message) {
</span></span><span style=display:flex><span>        String msg <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> String(message.<span style=color:#a6e22e>getBody</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;receive message &#34;</span> <span style=color:#f92672>+</span> msg);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ol><h3 id=84延迟队列插件>8.4、延迟队列插件<a hidden class=anchor aria-hidden=true href=#84延迟队列插件>#</a></h3><p>对队列设置 TTL 会导致系统需要很多的队列，使系统复杂。对消息设置 TTL 由于消息积压会导致不在队首的消息不能及时进入死信队列。为弥补不足，引入插件来实现延迟队列。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 由于 mq 容器内没有 wget ，故先在主机下载插件</span>
</span></span><span style=display:flex><span>wget https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/download/3.10.0/rabbitmq_delayed_message_exchange-3.10.0.ez
</span></span><span style=display:flex><span><span style=color:#75715e># 复制到容器中的插件目录， mq 是容器名</span>
</span></span><span style=display:flex><span>docker cp rabbitmq_delayed_message_exchange-3.10.0.ez mq:/opt/rabbitmq/plugin
</span></span><span style=display:flex><span><span style=color:#75715e># 进入容器启用插件</span>
</span></span><span style=display:flex><span>rabbitmq-plugins enable rabbitmq_delayed_message_exchange
</span></span></code></pre></div><p>成功启动之后，进入 web 控制台的 exchanges，添加交换机，type 栏中多了一个 x-delayed-message 选项。</p><p><img alt=基于插件的延迟队列 loading=lazy src=/posts/%E5%88%86%E5%B8%83%E5%BC%8F/rabbitmq/rabbitmq/%E5%9F%BA%E4%BA%8E%E6%8F%92%E4%BB%B6%E7%9A%84%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97.png></p><p>基于插件的延迟队列不需要专门设置过期队列</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Configuration</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DelayQueueConfig</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String DELAYED_QUEUE <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;delayed_queue&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String DELAYED_EXCHANGE <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;delayed_exchange&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String DELAYED_ROUTING_KEY <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;delayed_routing_key&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> CustomExchange <span style=color:#a6e22e>delayedExchange</span>() {
</span></span><span style=display:flex><span>        Map<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span> arguments <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        arguments.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;x-delayed-message&#34;</span>, <span style=color:#e6db74>&#34;direct&#34;</span>);  <span style=color:#75715e>// 延迟交换机的类型为直连类型</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 1. 交换机名称
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 2. 交换机类型
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 3. 是否需要持久化
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 4. 是否自动删除
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 5. 其他参数
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> CustomExchange(DELAYED_EXCHANGE, <span style=color:#e6db74>&#34;x-delayed-message&#34;</span>, <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>false</span>, arguments);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Queue <span style=color:#a6e22e>delayedQueue</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> QueueBuilder.<span style=color:#a6e22e>durable</span>(DELAYED_QUEUE).<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Binding <span style=color:#a6e22e>delayedBinding</span>(<span style=color:#a6e22e>@Qualifier</span>(<span style=color:#e6db74>&#34;delayedQueue&#34;</span>) Queue delayedQueue,
</span></span><span style=display:flex><span>                                  <span style=color:#a6e22e>@Qualifier</span>(<span style=color:#e6db74>&#34;delayedExchange&#34;</span>) CustomExchange delayedExchange) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> BindingBuilder.<span style=color:#a6e22e>bind</span>(delayedQueue).<span style=color:#a6e22e>to</span>(delayedExchange).<span style=color:#a6e22e>with</span>(DELAYED_ROUTING_KEY).<span style=color:#a6e22e>noargs</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用时传入消息和过期时间。</p><h2 id=九高级发布确认>九、高级发布确认<a hidden class=anchor aria-hidden=true href=#九高级发布确认>#</a></h2><p>发布确认机制包括两个部分</p><p>1、交换机确认: 保证 Producer 生产的消息成功投递到交换机上而不发生丢失</p><p>2、消息的回退: 保证交换机成功将消息路由到队列上而不发生消息</p><h3 id=91发布确认消息回退>9.1、发布确认+消息回退<a hidden class=anchor aria-hidden=true href=#91发布确认消息回退>#</a></h3><p>交换机确认：交换机接收到消息后，会直接给消息生产者发送确认消息。但如果发现消息不可路由就会直接丢弃该消息，此时生产者无法感知消息已被丢弃。</p><p>消息回退：交换机向队列传递过程中不可达的消息返回给生产者。</p><p>即交换机确认保证发布者到交换机的消息不丢失，消息回退保证交换机到队列的消息不丢失。</p><ol><li><p>开启发布确认模式+消息回退</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>rabbitmq</span>:
</span></span><span style=display:flex><span>  	<span style=color:#f92672>publisher-returns</span>: <span style=color:#66d9ef>true</span>    <span style=color:#75715e># 开启消息回退</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>publisher-confirm-type</span>: <span style=color:#ae81ff>correlated</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># correlated：开启发布确认，异步确认</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># none：禁用发布确认</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># simple：同步确认，单个确认。可以通过 rabbitTemplate 调用 waitForConfirms() 方法控制逻辑。</span>
</span></span></code></pre></div></li><li><p>自定义回调函数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Component</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyConfirmCallback</span> <span style=color:#66d9ef>implements</span> RabbitTemplate.<span style=color:#a6e22e>ConfirmCallback</span>, RabbitTemplate.<span style=color:#a6e22e>ReturnsCallback</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> RabbitTemplate rabbitTemplate;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 该注解的作用：对象创建完成并完成注入之后执行。即执行顺序为： Construct -&gt; Autowired -&gt; PostConstruct</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@PostConstruct</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init</span>() {
</span></span><span style=display:flex><span>        rabbitTemplate.<span style=color:#a6e22e>setConfirmCallback</span>(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>        rabbitTemplate.<span style=color:#a6e22e>setReturnsCallback</span>(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 若交换机接收消息成功
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param correlationData 消息的 ID 及相关信息
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param ack b = true
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param s s = null
</span></span></span><span style=display:flex><span><span style=color:#75715e>     *
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 若交换机接收消息失败（宕机或网络连接失败等)
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param correlationData 消息的 ID 及相关信息
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param ack b = false
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param s s = 失败的原因
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>confirm</span>(CorrelationData correlationData, <span style=color:#66d9ef>boolean</span> ack, String s) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (ack) System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(correlationData.<span style=color:#a6e22e>getId</span>());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(s <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> correlationData.<span style=color:#a6e22e>getId</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 消息回退</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>returnedMessage</span>(ReturnedMessage returned) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;message %s, backed by exchange %s, reason by %s, routing key is %s%n&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> String(returned.<span style=color:#a6e22e>getMessage</span>().<span style=color:#a6e22e>getBody</span>()), returned.<span style=color:#a6e22e>getExchange</span>(),
</span></span><span style=display:flex><span>                returned.<span style=color:#a6e22e>getReplyText</span>(), returned.<span style=color:#a6e22e>getRoutingKey</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>发送者</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@GetMapping</span>(<span style=color:#e6db74>&#34;/confirm/msg/{msg}&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sendMsg</span>(<span style=color:#a6e22e>@PathVariable</span> String msg) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 回调函数中的 CorrelationData 需要在这里定义，可以指定消息的序号和需要返回的消息。此处模拟了一个序号</span>
</span></span><span style=display:flex><span>        CorrelationData correlationData <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CorrelationData(<span style=color:#e6db74>&#34;1&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 交换机不存在，由发布确认保证回调 MyConfirmCallback 中的 confirm 方法</span>
</span></span><span style=display:flex><span>        rabbitTemplate.<span style=color:#a6e22e>convertAndSend</span>(ConfirmConfig.<span style=color:#a6e22e>CONFIRM_EXCHANGE</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;12&#34;</span>, 
</span></span><span style=display:flex><span>                                      ConfirmConfig.<span style=color:#a6e22e>CONFIRM_ROUTING_KEY</span>, msg, correlationData);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 路由不可达，由消息回退保证回调 MyConfirmCallback 中的 returnedMessage 方法</span>
</span></span><span style=display:flex><span>        rabbitTemplate.<span style=color:#a6e22e>convertAndSend</span>(ConfirmConfig.<span style=color:#a6e22e>CONFIRM_EXCHANGE</span>, 
</span></span><span style=display:flex><span>                                      ConfirmConfig.<span style=color:#a6e22e>CONFIRM_ROUTING_KEY</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;12&#34;</span>, msg, correlationData);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div></li></ol><h3 id=92备份交换机>9.2、备份交换机<a hidden class=anchor aria-hidden=true href=#92备份交换机>#</a></h3><p>交换机到队列的路由不可达时可以将消息投放给备份交换机。备份交换机将消息广播给两个队列，分别用作消息的备份与检测报警。</p><p>注意：如果消息无法到达交换机，则直接会由发布确认机制回调交换机不可达函数，消息将不会进入备份交换机。</p><p>如果同时开启了备份交换和消息回退，备份交换机的优先级更高。</p><p><img alt=备份交换机 loading=lazy src=/posts/%E5%88%86%E5%B8%83%E5%BC%8F/rabbitmq/rabbitmq/%E5%A4%87%E4%BB%BD%E4%BA%A4%E6%8D%A2%E6%9C%BA.png></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Component</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ConfirmConfig</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String CONFIRM_QUEUE <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;confirm_queue&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String CONFIRM_EXCHANGE <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;confirm_exchange&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String CONFIRM_ROUTING_KEY <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;confirm_routing_key&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String BACKUP_QUEUE <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;backup_queue&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String WARNING_QUEUE <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;warning_queue&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String BACKUP_EXCHANGE <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;backup_exchange&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 声明交换机</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> DirectExchange <span style=color:#a6e22e>confirmExchange</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 指定备份交换机</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ExchangeBuilder.<span style=color:#a6e22e>directExchange</span>(CONFIRM_EXCHANGE)
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>alternate</span>(BACKUP_EXCHANGE).<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> FanoutExchange <span style=color:#a6e22e>backupExchange</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> FanoutExchange(BACKUP_EXCHANGE);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 声明队列</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Queue <span style=color:#a6e22e>confirmQueue</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> QueueBuilder.<span style=color:#a6e22e>durable</span>(CONFIRM_QUEUE).<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Queue <span style=color:#a6e22e>backupQueue</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> QueueBuilder.<span style=color:#a6e22e>durable</span>(BACKUP_QUEUE).<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Queue <span style=color:#a6e22e>warningQueue</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> QueueBuilder.<span style=color:#a6e22e>durable</span>(WARNING_QUEUE).<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 绑定</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Binding <span style=color:#a6e22e>confirmBinding</span>(<span style=color:#a6e22e>@Qualifier</span>(<span style=color:#e6db74>&#34;confirmQueue&#34;</span>) Queue confirmQueue,
</span></span><span style=display:flex><span>                                  <span style=color:#a6e22e>@Qualifier</span>(<span style=color:#e6db74>&#34;confirmExchange&#34;</span>) DirectExchange confirmExchange) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> BindingBuilder.<span style=color:#a6e22e>bind</span>(confirmQueue).<span style=color:#a6e22e>to</span>(confirmExchange).<span style=color:#a6e22e>with</span>(CONFIRM_ROUTING_KEY);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Binding <span style=color:#a6e22e>backToBackBinding</span>(<span style=color:#a6e22e>@Qualifier</span>(<span style=color:#e6db74>&#34;backupQueue&#34;</span>) Queue backupQueue,
</span></span><span style=display:flex><span>                                     <span style=color:#a6e22e>@Qualifier</span>(<span style=color:#e6db74>&#34;backupExchange&#34;</span>) FanoutExchange backupExchange) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> BindingBuilder.<span style=color:#a6e22e>bind</span>(backupQueue).<span style=color:#a6e22e>to</span>(backupExchange);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Binding <span style=color:#a6e22e>warningToBackBinding</span>(<span style=color:#a6e22e>@Qualifier</span>(<span style=color:#e6db74>&#34;warningQueue&#34;</span>) Queue warningQueue,
</span></span><span style=display:flex><span>                                        <span style=color:#a6e22e>@Qualifier</span>(<span style=color:#e6db74>&#34;backupExchange&#34;</span>) FanoutExchange backupExchange) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> BindingBuilder.<span style=color:#a6e22e>bind</span>(warningQueue).<span style=color:#a6e22e>to</span>(backupExchange);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 监听报警队列</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Component</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WarningConsumer</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@RabbitListener</span>(queues <span style=color:#f92672>=</span> ConfirmConfig.<span style=color:#a6e22e>WARNING_QUEUE</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>receiveWarningMsg</span>(Message message) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;warning! message {%s} does not execute success. &#34;</span>, <span style=color:#66d9ef>new</span> String(message.<span style=color:#a6e22e>getBody</span>()));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=十相关知识点>十、相关知识点<a hidden class=anchor aria-hidden=true href=#十相关知识点>#</a></h2><h3 id=101幂等性>10.1、幂等性<a hidden class=anchor aria-hidden=true href=#101幂等性>#</a></h3><p>在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简之：<strong>一个请求，不管重复来多少次，结果是不会改变的。</strong></p><p>消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断，故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息；注意，RabbitMQ 这种消息重试(补偿)机制是默认的。</p><p>@RabbitListener 底层使用 AOP 进行异常通知拦截，如果程序没有抛出异常信息，那么就会自动提交事务；如果 AOP 异常通知拦截有捕获到异常信息的话，就会自动实现重试(补偿)机制，同时，这个补偿机制的消息会缓存到 RabbitMQ 服务器端进行存放，一直重试到不抛出异常为止。</p><p>解决方式：</p><p>为每个消息分配全局唯一ID，消费前通过 redis 的 setnx 命令写入消息的ID，若写入成功就消费，否则丢弃，此时不论是否消费都应发送ack。</p><h3 id=102优先级队列>10.2、优先级队列<a hidden class=anchor aria-hidden=true href=#102优先级队列>#</a></h3><p>队列的特点是先进先出，但是有些场景下需要对队列中的消息赋予优先级，使得优先级高的消息越快被消费。优先级队列底层是大顶堆。</p><p>由于种种原因，RabbitMQ到目前为止，官方<strong>还没有实现优先级队列</strong>，只实现了Consumer的优先级处理。即每次对队列中的消息按优先级排序后取出优先级最高的消息。</p><p>当然，在消费端速度大于生产端速度，且broker中没有消息堆积的话，对发送的消息设置优先级也没什么实际意义，没机会排序。</p><ol><li><p>队列声明时指定最大优先级</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> Queue <span style=color:#a6e22e>confirmQueue</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> QueueBuilder.<span style=color:#a6e22e>durable</span>(CONFIRM_QUEUE).<span style=color:#a6e22e>maxPriority</span>(10).<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>发送消息时指定消息的优先级</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>rabbitTemplate.<span style=color:#a6e22e>convertAndSend</span>(<span style=color:#e6db74>&#34;X&#34;</span>, <span style=color:#e6db74>&#34;XC&#34;</span>, message, msg  <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>    msg.<span style=color:#a6e22e>getMessageProperties</span>().<span style=color:#a6e22e>setPriority</span>(5);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> msg;
</span></span><span style=display:flex><span>});
</span></span></code></pre></div></li></ol><h3 id=103惰性队列>10.3、惰性队列<a hidden class=anchor aria-hidden=true href=#103惰性队列>#</a></h3><p>惰性队列即收到消息后直接存放在磁盘中，内存中不存，消费者每次取消息时，都需要将消息加载到内存再发送给消费者，所以很慢。</p><p>持久化是将消息即存在内存又存在磁盘，消费者去内存取。</p><p>消费者处理消息很慢或无法处理消息使得队列积压了大量消息时可以采用惰性队列，释放内存。</p><p><a href=https://blog.csdn.net/m0_48795607/article/details/116064045>面试题</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A0%81/><span class=title>« Prev</span><br><span>编码</span>
</a><a class=next href=https://ethereal-lu.github.io/posts/linux/ubuntu%E7%9A%84ufw%E4%B8%8Eiptables/><span class=title>Next »</span><br><span>ubuntu的ufw与iptables</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>