<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>零碎算法 | lu</title>
<meta name=keywords content><meta name=description content='不大于 num 的最大值
给定整数 num，使用数组 arr 中的元素组成不大于 num 的最大数；1 <= arr[i] <= 9。例如 arr = {1, 2, 4, 9}，num = 2533，则返回 2499。
**整体思路：**每次都选择恰好等于当前值的元素，若顺利遍历完则所选元素组成的数等于给定值；若遍历到某个值时数组中的所有元素都大于该值，则需要回溯，将前一个元素减小；若遍历到某个值时数组中不存在等于当前值的元素，则选择较小的元素，并将之后所有元素全部置为数组中的最大值。
import java.util.Arrays;

class Solution {
    
    public int findMax(int[] arr, int num) {
        Arrays.sort(arr);
        int n = String.valueOf(num).length();
        int ret = dfs(arr, num, 0, 0, n);
        // 这里 ret < 0 是递归的最外层返回 -1，说明数位相同没有答案，必须少一位。
        if (ret < 0) {
            ret = 0;
            while (ret < num) ret = ret * 10 + arr[arr.length - 1];
            ret /= 10;
            // 这里 ret 如果为 0，说明数组中的数不可能组成答案。
            ret = ret == 0 ? -1 : ret;
        }
        return ret;
    }

    // 只负责处理第一个数位相同的情况，因为数位不相同的情况只有一种，很简单，交给主函数处理即可。
    private int dfs(int[] arr, int num, int target, int index, int n) {
        if (index == n) {
            if (target <= num) return target;
            return -1;
        }
        int curr = Integer.parseInt(String.valueOf(num).charAt(index) + "");
        // arr[i] 为不大于 curr 的最大值
        int i = arr.length - 1;
        for (; i >= 0 && arr[i] > curr; i--);
        // i < 0 表示所有值都大于 curr。不正确，回退。
        if (i < 0) return -1;
        int ret = -1;
        // arr[i] == curr, 继续往后走。
        if (arr[i] == curr) {
            ret = dfs(arr, num, target * 10 + arr[i], index + 1, n);
            if (ret > 0) return ret;
        }
        // arr[i] < curr，则后续所有值直接取最大值即可。
        if (arr[i] < curr || i > 0) {
            // 如果 arr[i] == curr 且走到这里，说明当前选择 arr[i] 走不通，选择更小的 arr[i - 1];
            if (arr[i] == curr) i--;
            target = target * 10 + arr[i];
            while (target < num) target = target * 10 + arr[arr.length - 1];
            ret = target / 10;
        }
        return ret;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.findMax(new int[]{1, 2, 4, 9}, 2533));
    }
}
右侧小于当前元素的个数
给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。如：nums = [5,2,6,1]，返回 [2,1,1,0]'><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9B%B6%E7%A2%8E%E7%AE%97%E6%B3%95/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9B%B6%E7%A2%8E%E7%AE%97%E6%B3%95/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9B%B6%E7%A2%8E%E7%AE%97%E6%B3%95/"><meta property="og:site_name" content="lu"><meta property="og:title" content="零碎算法"><meta property="og:description" content='不大于 num 的最大值 给定整数 num，使用数组 arr 中的元素组成不大于 num 的最大数；1 <= arr[i] <= 9。例如 arr = {1, 2, 4, 9}，num = 2533，则返回 2499。
**整体思路：**每次都选择恰好等于当前值的元素，若顺利遍历完则所选元素组成的数等于给定值；若遍历到某个值时数组中的所有元素都大于该值，则需要回溯，将前一个元素减小；若遍历到某个值时数组中不存在等于当前值的元素，则选择较小的元素，并将之后所有元素全部置为数组中的最大值。
import java.util.Arrays; class Solution { public int findMax(int[] arr, int num) { Arrays.sort(arr); int n = String.valueOf(num).length(); int ret = dfs(arr, num, 0, 0, n); // 这里 ret < 0 是递归的最外层返回 -1，说明数位相同没有答案，必须少一位。 if (ret < 0) { ret = 0; while (ret < num) ret = ret * 10 + arr[arr.length - 1]; ret /= 10; // 这里 ret 如果为 0，说明数组中的数不可能组成答案。 ret = ret == 0 ? -1 : ret; } return ret; } // 只负责处理第一个数位相同的情况，因为数位不相同的情况只有一种，很简单，交给主函数处理即可。 private int dfs(int[] arr, int num, int target, int index, int n) { if (index == n) { if (target <= num) return target; return -1; } int curr = Integer.parseInt(String.valueOf(num).charAt(index) + ""); // arr[i] 为不大于 curr 的最大值 int i = arr.length - 1; for (; i >= 0 && arr[i] > curr; i--); // i < 0 表示所有值都大于 curr。不正确，回退。 if (i < 0) return -1; int ret = -1; // arr[i] == curr, 继续往后走。 if (arr[i] == curr) { ret = dfs(arr, num, target * 10 + arr[i], index + 1, n); if (ret > 0) return ret; } // arr[i] < curr，则后续所有值直接取最大值即可。 if (arr[i] < curr || i > 0) { // 如果 arr[i] == curr 且走到这里，说明当前选择 arr[i] 走不通，选择更小的 arr[i - 1]; if (arr[i] == curr) i--; target = target * 10 + arr[i]; while (target < num) target = target * 10 + arr[arr.length - 1]; ret = target / 10; } return ret; } public static void main(String[] args) { Solution solution = new Solution(); System.out.println(solution.findMax(new int[]{1, 2, 4, 9}, 2533)); } } 右侧小于当前元素的个数 给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。如：nums = [5,2,6,1]，返回 [2,1,1,0]'><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-22T11:12:41+00:00"><meta property="article:modified_time" content="2022-05-22T11:12:41+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="零碎算法"><meta name=twitter:description content='不大于 num 的最大值
给定整数 num，使用数组 arr 中的元素组成不大于 num 的最大数；1 <= arr[i] <= 9。例如 arr = {1, 2, 4, 9}，num = 2533，则返回 2499。
**整体思路：**每次都选择恰好等于当前值的元素，若顺利遍历完则所选元素组成的数等于给定值；若遍历到某个值时数组中的所有元素都大于该值，则需要回溯，将前一个元素减小；若遍历到某个值时数组中不存在等于当前值的元素，则选择较小的元素，并将之后所有元素全部置为数组中的最大值。
import java.util.Arrays;

class Solution {
    
    public int findMax(int[] arr, int num) {
        Arrays.sort(arr);
        int n = String.valueOf(num).length();
        int ret = dfs(arr, num, 0, 0, n);
        // 这里 ret < 0 是递归的最外层返回 -1，说明数位相同没有答案，必须少一位。
        if (ret < 0) {
            ret = 0;
            while (ret < num) ret = ret * 10 + arr[arr.length - 1];
            ret /= 10;
            // 这里 ret 如果为 0，说明数组中的数不可能组成答案。
            ret = ret == 0 ? -1 : ret;
        }
        return ret;
    }

    // 只负责处理第一个数位相同的情况，因为数位不相同的情况只有一种，很简单，交给主函数处理即可。
    private int dfs(int[] arr, int num, int target, int index, int n) {
        if (index == n) {
            if (target <= num) return target;
            return -1;
        }
        int curr = Integer.parseInt(String.valueOf(num).charAt(index) + "");
        // arr[i] 为不大于 curr 的最大值
        int i = arr.length - 1;
        for (; i >= 0 && arr[i] > curr; i--);
        // i < 0 表示所有值都大于 curr。不正确，回退。
        if (i < 0) return -1;
        int ret = -1;
        // arr[i] == curr, 继续往后走。
        if (arr[i] == curr) {
            ret = dfs(arr, num, target * 10 + arr[i], index + 1, n);
            if (ret > 0) return ret;
        }
        // arr[i] < curr，则后续所有值直接取最大值即可。
        if (arr[i] < curr || i > 0) {
            // 如果 arr[i] == curr 且走到这里，说明当前选择 arr[i] 走不通，选择更小的 arr[i - 1];
            if (arr[i] == curr) i--;
            target = target * 10 + arr[i];
            while (target < num) target = target * 10 + arr[arr.length - 1];
            ret = target / 10;
        }
        return ret;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.findMax(new int[]{1, 2, 4, 9}, 2533));
    }
}
右侧小于当前元素的个数
给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。如：nums = [5,2,6,1]，返回 [2,1,1,0]'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ethereal-lu.github.io/posts/"},{"@type":"ListItem","position":2,"name":"零碎算法","item":"https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9B%B6%E7%A2%8E%E7%AE%97%E6%B3%95/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"零碎算法","name":"零碎算法","description":"不大于 num 的最大值 给定整数 num，使用数组 arr 中的元素组成不大于 num 的最大数；1 \u0026lt;= arr[i] \u0026lt;= 9。例如 arr = {1, 2, 4, 9}，num = 2533，则返回 2499。\n**整体思路：**每次都选择恰好等于当前值的元素，若顺利遍历完则所选元素组成的数等于给定值；若遍历到某个值时数组中的所有元素都大于该值，则需要回溯，将前一个元素减小；若遍历到某个值时数组中不存在等于当前值的元素，则选择较小的元素，并将之后所有元素全部置为数组中的最大值。\nimport java.util.Arrays; class Solution { public int findMax(int[] arr, int num) { Arrays.sort(arr); int n = String.valueOf(num).length(); int ret = dfs(arr, num, 0, 0, n); // 这里 ret \u0026lt; 0 是递归的最外层返回 -1，说明数位相同没有答案，必须少一位。 if (ret \u0026lt; 0) { ret = 0; while (ret \u0026lt; num) ret = ret * 10 + arr[arr.length - 1]; ret /= 10; // 这里 ret 如果为 0，说明数组中的数不可能组成答案。 ret = ret == 0 ? -1 : ret; } return ret; } // 只负责处理第一个数位相同的情况，因为数位不相同的情况只有一种，很简单，交给主函数处理即可。 private int dfs(int[] arr, int num, int target, int index, int n) { if (index == n) { if (target \u0026lt;= num) return target; return -1; } int curr = Integer.parseInt(String.valueOf(num).charAt(index) + \u0026#34;\u0026#34;); // arr[i] 为不大于 curr 的最大值 int i = arr.length - 1; for (; i \u0026gt;= 0 \u0026amp;\u0026amp; arr[i] \u0026gt; curr; i--); // i \u0026lt; 0 表示所有值都大于 curr。不正确，回退。 if (i \u0026lt; 0) return -1; int ret = -1; // arr[i] == curr, 继续往后走。 if (arr[i] == curr) { ret = dfs(arr, num, target * 10 + arr[i], index + 1, n); if (ret \u0026gt; 0) return ret; } // arr[i] \u0026lt; curr，则后续所有值直接取最大值即可。 if (arr[i] \u0026lt; curr || i \u0026gt; 0) { // 如果 arr[i] == curr 且走到这里，说明当前选择 arr[i] 走不通，选择更小的 arr[i - 1]; if (arr[i] == curr) i--; target = target * 10 + arr[i]; while (target \u0026lt; num) target = target * 10 + arr[arr.length - 1]; ret = target / 10; } return ret; } public static void main(String[] args) { Solution solution = new Solution(); System.out.println(solution.findMax(new int[]{1, 2, 4, 9}, 2533)); } } 右侧小于当前元素的个数 给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。如：nums = [5,2,6,1]，返回 [2,1,1,0]\n","keywords":[],"articleBody":"不大于 num 的最大值 给定整数 num，使用数组 arr 中的元素组成不大于 num 的最大数；1 \u003c= arr[i] \u003c= 9。例如 arr = {1, 2, 4, 9}，num = 2533，则返回 2499。\n**整体思路：**每次都选择恰好等于当前值的元素，若顺利遍历完则所选元素组成的数等于给定值；若遍历到某个值时数组中的所有元素都大于该值，则需要回溯，将前一个元素减小；若遍历到某个值时数组中不存在等于当前值的元素，则选择较小的元素，并将之后所有元素全部置为数组中的最大值。\nimport java.util.Arrays; class Solution { public int findMax(int[] arr, int num) { Arrays.sort(arr); int n = String.valueOf(num).length(); int ret = dfs(arr, num, 0, 0, n); // 这里 ret \u003c 0 是递归的最外层返回 -1，说明数位相同没有答案，必须少一位。 if (ret \u003c 0) { ret = 0; while (ret \u003c num) ret = ret * 10 + arr[arr.length - 1]; ret /= 10; // 这里 ret 如果为 0，说明数组中的数不可能组成答案。 ret = ret == 0 ? -1 : ret; } return ret; } // 只负责处理第一个数位相同的情况，因为数位不相同的情况只有一种，很简单，交给主函数处理即可。 private int dfs(int[] arr, int num, int target, int index, int n) { if (index == n) { if (target \u003c= num) return target; return -1; } int curr = Integer.parseInt(String.valueOf(num).charAt(index) + \"\"); // arr[i] 为不大于 curr 的最大值 int i = arr.length - 1; for (; i \u003e= 0 \u0026\u0026 arr[i] \u003e curr; i--); // i \u003c 0 表示所有值都大于 curr。不正确，回退。 if (i \u003c 0) return -1; int ret = -1; // arr[i] == curr, 继续往后走。 if (arr[i] == curr) { ret = dfs(arr, num, target * 10 + arr[i], index + 1, n); if (ret \u003e 0) return ret; } // arr[i] \u003c curr，则后续所有值直接取最大值即可。 if (arr[i] \u003c curr || i \u003e 0) { // 如果 arr[i] == curr 且走到这里，说明当前选择 arr[i] 走不通，选择更小的 arr[i - 1]; if (arr[i] == curr) i--; target = target * 10 + arr[i]; while (target \u003c num) target = target * 10 + arr[arr.length - 1]; ret = target / 10; } return ret; } public static void main(String[] args) { Solution solution = new Solution(); System.out.println(solution.findMax(new int[]{1, 2, 4, 9}, 2533)); } } 右侧小于当前元素的个数 给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。如：nums = [5,2,6,1]，返回 [2,1,1,0]\n线段树适用的场景为单点修改，区间查询。\n整体思路：\n用桶表示数组中的每一个数，桶中记录这些数字出现的次数。假设nums = {5, 5, 2, 3, 6}，那么遍历这个序列得到的桶是这样的：\nindex -\u003e 1 2 3 4 5 6 7 8 9\rvalue -\u003e 0 1 1 0 2 1 0 0 0 初始桶中元素全部为 0，从后往前遍历序列数组，每次把遍历到的当前元素所在桶的值加 1，然后求出当前桶之前的全部桶的值之和就是在之前已经遍历过的所有数中有多少个数小于当前值。\n由于数组中值的值域非常大，所以不能为整个值域都放一个桶。将原数组去重并排序，我们记录下数组中每个值与排序之后的下标的映射关系，之后从后往前遍历数组时，根据该映射表找到当前值对应的下标，并将下标所在的桶的值加 1，然后求出下标之前的所有桶之和即为当前位置的答案。\n如此转换后，对每个值所在桶加 1，即为单点修改；查询之前全部桶之和即为区间查询。所以可以使用线段树了。\n**注：**逆序对的题与该题完全一样。逆序对也就是求每个数之后有几个数小于当前数。解法也毫无差别。\nclass Solution { // 数组表示的线段树 private int[] sengment; public List\u003cInteger\u003e countSmaller(int[] nums) { // 对原数组排序 int[] sorted = Arrays.stream(nums).distinct().sorted().toArray(); // 存储值与排序后下标的映射关系 Map\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e(); for (int i = 0; i \u003c sorted.length; i++) { map.put(sorted[i], i); } List\u003cInteger\u003e ret = new ArrayList\u003c\u003e(); sengment = new int[sorted.length * 4]; for (int i = nums.length - 1; i \u003e= 0; i--) { // 用 map 找出当前值对应的下标，并将下标所在桶的值加 1 update(0, 0, sorted.length - 1, map.get(nums[i])); // 特殊处理，数组中最小的数的后边小于其的个数为 0，防止下方search方法参数异常 if (map.get(nums[i]) == 0) { ret.add(0); continue; } // 当前值之前全部桶之和 ret.add(search(0, 0, sorted.length - 1, 0, map.get(nums[i]) - 1)); } Collections.reverse(ret); return ret; } // 单点修改 private void update(int node, int left, int right, int index) { if (left == right) { sengment[node]++; return; } int mid = (left + right) / 2; if (mid \u003c index) update(node * 2 + 2, mid + 1, right, index); else update(node * 2 + 1, left, mid, index); sengment[node] = sengment[node * 2 + 1] + sengment[node * 2 + 2]; } // 区间查询 private int search(int node, int left, int right, int lboard, int rboard) { if (left == lboard \u0026\u0026 right == rboard) return sengment[node]; int mid = (left + right) / 2; if (lboard \u003e mid) return search(node * 2 + 2, mid + 1, right, lboard, rboard); else if (rboard \u003c= mid) return search(node * 2 + 1, left, mid, lboard, rboard); else return search(node * 2 + 1, left, mid, lboard, mid) + search(node * 2 + 2, mid + 1, right, mid + 1, rboard); } } O(1)查找的链表 现有一个队列，对其执行三种操作：1、在左侧添加一个元素；2、在右侧添加一个元素；3、查找一个元素并得到该元素到队列左侧的距离。\n使用Map，键为元素，值为虚拟的下标Index。初始假定下标为 0，之后每次添加元素时使用 left 和 right 维护最小和最大的下标，这样查找元素时即可直接获取到边界的距离。\npublic class Solution { // ops 为 op 和 value 的二维数组， // op = 0 表示向左侧添加值；op = 1 表示向右侧添加值；op = 2 表示查找值 // 返回结果：每次查找值时都将该值到左边界的距离添加到结果集 public List\u003cInteger\u003e func(int[][] ops) { List\u003cInteger\u003e ret = new ArrayList\u003c\u003e(); // 键为 value，值为虚拟下标 HashMap\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e(); int left = 0, right = 1; for (int[] op : ops) { if (op[0] == 0) { map.put(op[1], left); left--; } else if (op[0] == 1) { map.put(op[1], right); right++; } else { int index = map.get(op[1]); ret.add(index - left); } } return ret; } } 买卖股票的最好时机 假设你有一个数组prices，长度为n，其中prices[i]是某只股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益，你最多可以对该股票有两笔交易操作，一笔交易代表着一次买入与一次卖出，但是再次购买前必须卖出之前的股票\npublic class Solution { public int maxProfit (int[] prices) { int n = prices.length; // 第二维即题解中的 5 个状态 // 0（不买入）；1（买入一次）；2（买一次卖一次）；3（买一次，卖一次，再买一次）；4（买两次卖两次） int[][] dp = new int[n][5]; // 第一天买入 dp[0][1] = -prices[0]; // 第一天买入，再卖出，再买入 dp[0][3] = -prices[0]; // 因为 0（不买入）；2（买一次卖一次）；4（买两次卖两次）都是 0，故无需显示赋初值 for (int i = 1; i \u003c n; i++) { // 一直不买一直是 0 dp[i][0] = dp[i - 1][0]; // 之前买一次；或之前未买，今天买；取大值 dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]); dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]); dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]); } return Arrays.stream(dp[n - 1]).max().getAsInt(); } } Dijkstra 力扣743 网络延迟时间\n有 n 个网络节点，标记为 1 到 n。给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。\npublic int networkDelayTime (int[][] times, int n, int k) { // map 邻接表实现图 Map\u003cInteger, List\u003cint[]\u003e\u003e map = new HashMap\u003c\u003e(); for (int i = 0; i \u003c times.length; i++) { if (!map.containsKey(times[i][0])) map.put(times[i][0], new ArrayList\u003c\u003e()); map.get(times[i][0]).add(times[i]); } // 结果集，节点为键，到原点的距离为值 Map\u003cInteger, Integer\u003e retList = new HashMap\u003c\u003e(); // 优先队列，保证每一轮是从距离原点最近的点开始扩散 PriorityQueue\u003cint[]\u003e queue = new PriorityQueue\u003c\u003e((o1, o2) -\u003e o1[1] - o2[1]); queue.offer(new int[]{k, 0}); retList.put(k, 0); while (!queue.isEmpty()) { // 节点--节点到原点的距离 int[] curr = queue.poll(); // 在有向图中，出度为 0 的点不在邻接表中 if (!map.containsKey(curr[0])) continue; for (int[] item: map.get(curr[0])) { if (!retList.containsKey(item[1]) || retList.get(item[1]) \u003e curr[1] + item[2]) { queue.offer(new int[]{item[1], curr[1] + item[2]}); retList.put(item[1], curr[1] + item[2]); } } } return retList.size() \u003c n ? -1 : retList.values().stream().max(Integer::compareTo).get().intValue(); } ","wordCount":"934","inLanguage":"en","datePublished":"2022-05-22T11:12:41Z","dateModified":"2022-05-22T11:12:41Z","author":{"@type":"Person","name":"lu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9B%B6%E7%A2%8E%E7%AE%97%E6%B3%95/"},"publisher":{"@type":"Organization","name":"lu","logo":{"@type":"ImageObject","url":"https://ethereal-lu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="lu (Alt + H)">lu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethereal-lu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ethereal-lu.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">零碎算法</h1><div class=post-meta><span title='2022-05-22 11:12:41 +0000 UTC'>2022-05-22</span>&nbsp;·&nbsp;934 words&nbsp;·&nbsp;lu</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#不大于-num-的最大值>不大于 num 的最大值</a></li><li><a href=#右侧小于当前元素的个数>右侧小于当前元素的个数</a></li><li><a href=#o1查找的链表>O(1)查找的链表</a></li><li><a href=#买卖股票的最好时机>买卖股票的最好时机</a></li><li><a href=#dijkstra>Dijkstra</a></li></ul></nav></div></details></div><div class=post-content><h2 id=不大于-num-的最大值>不大于 num 的最大值<a hidden class=anchor aria-hidden=true href=#不大于-num-的最大值>#</a></h2><p>给定整数 num，使用数组 arr 中的元素组成不大于 num 的最大数；1 &lt;= arr[i] &lt;= 9。例如 arr = {1, 2, 4, 9}，num = 2533，则返回 2499。</p><p>**整体思路：**每次都选择恰好等于当前值的元素，若顺利遍历完则所选元素组成的数等于给定值；若遍历到某个值时数组中的所有元素都大于该值，则需要回溯，将前一个元素减小；若遍历到某个值时数组中不存在等于当前值的元素，则选择较小的元素，并将之后所有元素全部置为数组中的最大值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Arrays;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>findMax</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> arr, <span style=color:#66d9ef>int</span> num) {
</span></span><span style=display:flex><span>        Arrays.<span style=color:#a6e22e>sort</span>(arr);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> String.<span style=color:#a6e22e>valueOf</span>(num).<span style=color:#a6e22e>length</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> ret <span style=color:#f92672>=</span> dfs(arr, num, 0, 0, n);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 这里 ret &lt; 0 是递归的最外层返回 -1，说明数位相同没有答案，必须少一位。</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (ret <span style=color:#f92672>&lt;</span> 0) {
</span></span><span style=display:flex><span>            ret <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (ret <span style=color:#f92672>&lt;</span> num) ret <span style=color:#f92672>=</span> ret <span style=color:#f92672>*</span> 10 <span style=color:#f92672>+</span> arr<span style=color:#f92672>[</span>arr.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> 1<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            ret <span style=color:#f92672>/=</span> 10;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 这里 ret 如果为 0，说明数组中的数不可能组成答案。</span>
</span></span><span style=display:flex><span>            ret <span style=color:#f92672>=</span> ret <span style=color:#f92672>==</span> 0 <span style=color:#f92672>?</span> <span style=color:#f92672>-</span>1 : ret;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 只负责处理第一个数位相同的情况，因为数位不相同的情况只有一种，很简单，交给主函数处理即可。</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> arr, <span style=color:#66d9ef>int</span> num, <span style=color:#66d9ef>int</span> target, <span style=color:#66d9ef>int</span> index, <span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (index <span style=color:#f92672>==</span> n) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (target <span style=color:#f92672>&lt;=</span> num) <span style=color:#66d9ef>return</span> target;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>1;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> curr <span style=color:#f92672>=</span> Integer.<span style=color:#a6e22e>parseInt</span>(String.<span style=color:#a6e22e>valueOf</span>(num).<span style=color:#a6e22e>charAt</span>(index) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// arr[i] 为不大于 curr 的最大值</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> arr.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> 1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (; i <span style=color:#f92672>&gt;=</span> 0 <span style=color:#f92672>&amp;&amp;</span> arr<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>&gt;</span> curr; i<span style=color:#f92672>--</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// i &lt; 0 表示所有值都大于 curr。不正确，回退。</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&lt;</span> 0) <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> ret <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>1;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// arr[i] == curr, 继续往后走。</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (arr<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>==</span> curr) {
</span></span><span style=display:flex><span>            ret <span style=color:#f92672>=</span> dfs(arr, num, target <span style=color:#f92672>*</span> 10 <span style=color:#f92672>+</span> arr<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>, index <span style=color:#f92672>+</span> 1, n);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (ret <span style=color:#f92672>&gt;</span> 0) <span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// arr[i] &lt; curr，则后续所有值直接取最大值即可。</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (arr<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>&lt;</span> curr <span style=color:#f92672>||</span> i <span style=color:#f92672>&gt;</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果 arr[i] == curr 且走到这里，说明当前选择 arr[i] 走不通，选择更小的 arr[i - 1];</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (arr<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>==</span> curr) i<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>            target <span style=color:#f92672>=</span> target <span style=color:#f92672>*</span> 10 <span style=color:#f92672>+</span> arr<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (target <span style=color:#f92672>&lt;</span> num) target <span style=color:#f92672>=</span> target <span style=color:#f92672>*</span> 10 <span style=color:#f92672>+</span> arr<span style=color:#f92672>[</span>arr.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> 1<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            ret <span style=color:#f92672>=</span> target <span style=color:#f92672>/</span> 10;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Solution solution <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Solution();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(solution.<span style=color:#a6e22e>findMax</span>(<span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span>{1, 2, 4, 9}, 2533));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=右侧小于当前元素的个数>右侧小于当前元素的个数<a hidden class=anchor aria-hidden=true href=#右侧小于当前元素的个数>#</a></h2><p>给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。如：nums = [5,2,6,1]，返回 [2,1,1,0]</p><p>线段树适用的场景为<strong>单点修改，区间查询</strong>。</p><p><strong>整体思路：</strong></p><p>用桶表示数组中的每一个数，桶中记录这些数字出现的次数。假设nums = {5, 5, 2, 3, 6}，那么遍历这个序列得到的桶是这样的：</p><pre tabindex=0><code>index  -&gt;  1 2 3 4 5 6 7 8 9
value  -&gt;  0 1 1 0 2 1 0 0 0
</code></pre><p>初始桶中元素全部为 0，从后往前遍历序列数组，每次把遍历到的当前元素所在桶的值加 1，然后求出当前桶之前的全部桶的值之和就是在之前已经遍历过的所有数中有多少个数小于当前值。</p><p>由于数组中值的值域非常大，所以不能为整个值域都放一个桶。将原数组去重并排序，我们记录下数组中每个值与排序之后的下标的映射关系，之后从后往前遍历数组时，根据该映射表找到当前值对应的下标，并将下标所在的桶的值加 1，然后求出下标之前的所有桶之和即为当前位置的答案。</p><p>如此转换后，对每个值所在桶加 1，即为单点修改；查询之前全部桶之和即为区间查询。所以可以使用线段树了。</p><p>**注：**逆序对的题与该题完全一样。逆序对也就是求每个数之后有几个数小于当前数。解法也毫无差别。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 数组表示的线段树</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> sengment;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>countSmaller</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> nums) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 对原数组排序</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> sorted <span style=color:#f92672>=</span> Arrays.<span style=color:#a6e22e>stream</span>(nums).<span style=color:#a6e22e>distinct</span>().<span style=color:#a6e22e>sorted</span>().<span style=color:#a6e22e>toArray</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 存储值与排序后下标的映射关系</span>
</span></span><span style=display:flex><span>        Map<span style=color:#f92672>&lt;</span>Integer, Integer<span style=color:#f92672>&gt;</span> map <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> sorted.<span style=color:#a6e22e>length</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            map.<span style=color:#a6e22e>put</span>(sorted<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>, i);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> ret <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        sengment <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>sorted.<span style=color:#a6e22e>length</span> <span style=color:#f92672>*</span> 4<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> nums.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> 1; i <span style=color:#f92672>&gt;=</span> 0; i<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 用 map 找出当前值对应的下标，并将下标所在桶的值加 1</span>
</span></span><span style=display:flex><span>            update(0, 0, sorted.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> 1, map.<span style=color:#a6e22e>get</span>(nums<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>));
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 特殊处理，数组中最小的数的后边小于其的个数为 0，防止下方search方法参数异常</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (map.<span style=color:#a6e22e>get</span>(nums<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>) <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>                ret.<span style=color:#a6e22e>add</span>(0);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 当前值之前全部桶之和</span>
</span></span><span style=display:flex><span>            ret.<span style=color:#a6e22e>add</span>(search(0, 0, sorted.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> 1, 0, map.<span style=color:#a6e22e>get</span>(nums<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>) <span style=color:#f92672>-</span> 1));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Collections.<span style=color:#a6e22e>reverse</span>(ret);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 单点修改</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>int</span> node, <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right, <span style=color:#66d9ef>int</span> index) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (left <span style=color:#f92672>==</span> right) {
</span></span><span style=display:flex><span>            sengment<span style=color:#f92672>[</span>node<span style=color:#f92672>]++</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (left <span style=color:#f92672>+</span> right) <span style=color:#f92672>/</span> 2;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (mid <span style=color:#f92672>&lt;</span> index) 
</span></span><span style=display:flex><span>            update(node <span style=color:#f92672>*</span> 2 <span style=color:#f92672>+</span> 2, mid <span style=color:#f92672>+</span> 1, right, index);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            update(node <span style=color:#f92672>*</span> 2 <span style=color:#f92672>+</span> 1, left, mid, index);
</span></span><span style=display:flex><span>        sengment<span style=color:#f92672>[</span>node<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> sengment<span style=color:#f92672>[</span>node <span style=color:#f92672>*</span> 2 <span style=color:#f92672>+</span> 1<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> sengment<span style=color:#f92672>[</span>node <span style=color:#f92672>*</span> 2 <span style=color:#f92672>+</span> 2<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 区间查询</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>search</span>(<span style=color:#66d9ef>int</span> node, <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right, <span style=color:#66d9ef>int</span> lboard, <span style=color:#66d9ef>int</span> rboard) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (left <span style=color:#f92672>==</span> lboard <span style=color:#f92672>&amp;&amp;</span> right <span style=color:#f92672>==</span> rboard) <span style=color:#66d9ef>return</span> sengment<span style=color:#f92672>[</span>node<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (left <span style=color:#f92672>+</span> right) <span style=color:#f92672>/</span> 2;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (lboard <span style=color:#f92672>&gt;</span> mid) <span style=color:#66d9ef>return</span> search(node <span style=color:#f92672>*</span> 2 <span style=color:#f92672>+</span> 2, mid <span style=color:#f92672>+</span> 1, right, lboard, rboard);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (rboard <span style=color:#f92672>&lt;=</span> mid) <span style=color:#66d9ef>return</span> search(node <span style=color:#f92672>*</span> 2 <span style=color:#f92672>+</span> 1, left, mid, lboard, rboard);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>return</span> search(node <span style=color:#f92672>*</span> 2 <span style=color:#f92672>+</span> 1, left, mid, lboard, mid) <span style=color:#f92672>+</span> 
</span></span><span style=display:flex><span>            search(node <span style=color:#f92672>*</span> 2 <span style=color:#f92672>+</span> 2, mid <span style=color:#f92672>+</span> 1, right, mid <span style=color:#f92672>+</span> 1, rboard);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=o1查找的链表>O(1)查找的链表<a hidden class=anchor aria-hidden=true href=#o1查找的链表>#</a></h2><p>现有一个队列，对其执行三种操作：1、在左侧添加一个元素；2、在右侧添加一个元素；3、查找一个元素并得到该元素到队列左侧的距离。</p><p>使用Map，键为元素，值为虚拟的下标Index。初始假定下标为 0，之后每次添加元素时使用 left 和 right 维护最小和最大的下标，这样查找元素时即可直接获取到边界的距离。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ops 为 op 和 value 的二维数组，</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// op = 0 表示向左侧添加值；op = 1 表示向右侧添加值；op = 2 表示查找值</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 返回结果：每次查找值时都将该值到左边界的距离添加到结果集</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>func</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[][]</span> ops) {
</span></span><span style=display:flex><span>        List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> ret <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 键为 value，值为虚拟下标</span>
</span></span><span style=display:flex><span>        HashMap<span style=color:#f92672>&lt;</span>Integer, Integer<span style=color:#f92672>&gt;</span> map <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> 0, right <span style=color:#f92672>=</span> 1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> op : ops) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (op<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>                map.<span style=color:#a6e22e>put</span>(op<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>, left);
</span></span><span style=display:flex><span>                left<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (op<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>==</span> 1) {
</span></span><span style=display:flex><span>                map.<span style=color:#a6e22e>put</span>(op<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>, right); 
</span></span><span style=display:flex><span>                right<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> index <span style=color:#f92672>=</span> map.<span style=color:#a6e22e>get</span>(op<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>                ret.<span style=color:#a6e22e>add</span>(index <span style=color:#f92672>-</span> left);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=买卖股票的最好时机>买卖股票的最好时机<a hidden class=anchor aria-hidden=true href=#买卖股票的最好时机>#</a></h2><p>假设你有一个数组prices，长度为n，其中prices[i]是某只股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益，你最多可以对该股票有两笔交易操作，一笔交易代表着一次买入与一次卖出，但是再次购买前必须卖出之前的股票</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>maxProfit</span> (<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> prices) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> prices.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 第二维即题解中的 5 个状态</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 0（不买入）；1（买入一次）；2（买一次卖一次）；3（买一次，卖一次，再买一次）；4（买两次卖两次）</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>[][]</span> dp <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>n<span style=color:#f92672>][</span>5<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 第一天买入</span>
</span></span><span style=display:flex><span>        dp<span style=color:#f92672>[</span>0<span style=color:#f92672>][</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>prices<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 第一天买入，再卖出，再买入</span>
</span></span><span style=display:flex><span>        dp<span style=color:#f92672>[</span>0<span style=color:#f92672>][</span>3<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>prices<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 因为 0（不买入）；2（买一次卖一次）；4（买两次卖两次）都是 0，故无需显示赋初值</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 一直不买一直是 0</span>
</span></span><span style=display:flex><span>            dp<span style=color:#f92672>[</span>i<span style=color:#f92672>][</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> dp<span style=color:#f92672>[</span>i <span style=color:#f92672>-</span> 1<span style=color:#f92672>][</span>0<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 之前买一次；或之前未买，今天买；取大值</span>
</span></span><span style=display:flex><span>            dp<span style=color:#f92672>[</span>i<span style=color:#f92672>][</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>max</span>(dp<span style=color:#f92672>[</span>i <span style=color:#f92672>-</span> 1<span style=color:#f92672>][</span>1<span style=color:#f92672>]</span>, dp<span style=color:#f92672>[</span>i <span style=color:#f92672>-</span> 1<span style=color:#f92672>][</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>-</span> prices<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>            dp<span style=color:#f92672>[</span>i<span style=color:#f92672>][</span>2<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>max</span>(dp<span style=color:#f92672>[</span>i <span style=color:#f92672>-</span> 1<span style=color:#f92672>][</span>2<span style=color:#f92672>]</span>, dp<span style=color:#f92672>[</span>i <span style=color:#f92672>-</span> 1<span style=color:#f92672>][</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> prices<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>            dp<span style=color:#f92672>[</span>i<span style=color:#f92672>][</span>3<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>max</span>(dp<span style=color:#f92672>[</span>i <span style=color:#f92672>-</span> 1<span style=color:#f92672>][</span>3<span style=color:#f92672>]</span>, dp<span style=color:#f92672>[</span>i <span style=color:#f92672>-</span> 1<span style=color:#f92672>][</span>2<span style=color:#f92672>]</span> <span style=color:#f92672>-</span> prices<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>            dp<span style=color:#f92672>[</span>i<span style=color:#f92672>][</span>4<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>max</span>(dp<span style=color:#f92672>[</span>i <span style=color:#f92672>-</span> 1<span style=color:#f92672>][</span>4<span style=color:#f92672>]</span>, dp<span style=color:#f92672>[</span>i <span style=color:#f92672>-</span> 1<span style=color:#f92672>][</span>3<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> prices<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Arrays.<span style=color:#a6e22e>stream</span>(dp<span style=color:#f92672>[</span>n <span style=color:#f92672>-</span> 1<span style=color:#f92672>]</span>).<span style=color:#a6e22e>max</span>().<span style=color:#a6e22e>getAsInt</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=dijkstra>Dijkstra<a hidden class=anchor aria-hidden=true href=#dijkstra>#</a></h2><p><a href=https://leetcode.cn/problems/network-delay-time/>力扣743 网络延迟时间</a></p><p>有 n 个网络节点，标记为 1 到 n。给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>networkDelayTime</span> (<span style=color:#66d9ef>int</span><span style=color:#f92672>[][]</span> times, <span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// map 邻接表实现图</span>
</span></span><span style=display:flex><span>    Map<span style=color:#f92672>&lt;</span>Integer, List<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>[]&gt;&gt;</span> map <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> times.<span style=color:#a6e22e>length</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>map.<span style=color:#a6e22e>containsKey</span>(times<span style=color:#f92672>[</span>i<span style=color:#f92672>][</span>0<span style=color:#f92672>]</span>)) 
</span></span><span style=display:flex><span>            map.<span style=color:#a6e22e>put</span>(times<span style=color:#f92672>[</span>i<span style=color:#f92672>][</span>0<span style=color:#f92672>]</span>, <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>());
</span></span><span style=display:flex><span>        map.<span style=color:#a6e22e>get</span>(times<span style=color:#f92672>[</span>i<span style=color:#f92672>][</span>0<span style=color:#f92672>]</span>).<span style=color:#a6e22e>add</span>(times<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 结果集，节点为键，到原点的距离为值</span>
</span></span><span style=display:flex><span>    Map<span style=color:#f92672>&lt;</span>Integer, Integer<span style=color:#f92672>&gt;</span> retList <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 优先队列，保证每一轮是从距离原点最近的点开始扩散</span>
</span></span><span style=display:flex><span>    PriorityQueue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>[]&gt;</span> queue <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> PriorityQueue<span style=color:#f92672>&lt;&gt;</span>((o1, o2) <span style=color:#f92672>-&gt;</span> o1<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>-</span> o2<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>    queue.<span style=color:#a6e22e>offer</span>(<span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span>{k, 0});
</span></span><span style=display:flex><span>    retList.<span style=color:#a6e22e>put</span>(k, 0);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>queue.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 节点--节点到原点的距离</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> curr <span style=color:#f92672>=</span> queue.<span style=color:#a6e22e>poll</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 在有向图中，出度为 0 的点不在邻接表中</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>map.<span style=color:#a6e22e>containsKey</span>(curr<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> item: map.<span style=color:#a6e22e>get</span>(curr<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>retList.<span style=color:#a6e22e>containsKey</span>(item<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>) <span style=color:#f92672>||</span> retList.<span style=color:#a6e22e>get</span>(item<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>) <span style=color:#f92672>&gt;</span> curr<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> item<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span>) {
</span></span><span style=display:flex><span>                queue.<span style=color:#a6e22e>offer</span>(<span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span>{item<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>, curr<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> item<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span>});
</span></span><span style=display:flex><span>                retList.<span style=color:#a6e22e>put</span>(item<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>, curr<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> item<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> retList.<span style=color:#a6e22e>size</span>() <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>?</span> <span style=color:#f92672>-</span>1 : retList.<span style=color:#a6e22e>values</span>().<span style=color:#a6e22e>stream</span>().<span style=color:#a6e22e>max</span>(Integer::compareTo).<span style=color:#a6e22e>get</span>().<span style=color:#a6e22e>intValue</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/><span class=title>« Prev</span><br><span>分布式锁</span>
</a><a class=next href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/><span class=title>Next »</span><br><span>分布式事务</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>