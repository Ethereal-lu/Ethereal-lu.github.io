<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>基础数据结构 | lu</title>
<meta name=keywords content><meta name=description content="1、总体注意事项
1.1、输入方式
两种输入方式，对于绝大多数时候，均选择Scanner作为输入。
import java.util.Scanner;

Scanner sc = new Scanner(System.in);
当输入数据很大时，选择 BufferedReader，但其只能以行作为单位读取，需要分割为字符串数组，再解析为其他类型。
import java.io.BufferedReader;
import java.io.InputStreamReader;

BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
1.2、读取
有些题目会有共包含 T 组案例，每组案例内 *** 操作，这种只需按 T 建循环即可。但有些题目没有指明共有 T 组案例，却在案例中包含了多组案例，此使必须在所有代码的外面包裹一层 while (sc.hasNext()) {...}，否则会出现虽然自测通过，但提交时却通过 0 组。
1.3、审题

当感觉找到一个比题目复杂度要求还低的方法时，一定要慎重考虑，这个方法真的对吗，能否覆盖所有情况，尽早换思路。
遇到与数字相关的题目，先看能不能找规律或化简，将题目转化为简单的模型再做。
与数字相关的题目，一定看是否为越界，注意用 long 和 double。

2、链表
2.1、链表反转
可以使用的方法有 栈、三指针法、头插法
使用头插法，因为对于一个区间的反转或者 k 个一组反转，使用头插法非常方便。
public ListNode reverseKGroup (ListNode head, int k) {
    ListNode pre = new ListNode(-1);
    pre.next = head;
    ListNode ret = pre, p = head;
    tag: while (p != null) {
        // 如果最后不够 k 个，则不反转
        for (int i = 0; i < k; i++) {
            if (p == null) break tag;
            p = p.next;
        }
        p = pre.next;
        // 使用头插法，注意：循环 k - 1 次。
        for (int i = 0; i < k - 1; i++) {
            ListNode temp = p.next;
            p.next = temp.next;
            temp.next = pre.next;
            pre.next = temp;
        }
        pre = p;
        p = p.next;
    }
    return ret.next;
}
2.2、LRU缓存
方法一：LinkedHashMap。"><meta name=author content="lu"><link rel=canonical href=http://localhost:1313/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity="sha256-1yREUm1+y9sAFUOKf6iQVKZYv3WdBULi5d+BzpS0k+4=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><meta property="og:site_name" content="lu"><meta property="og:title" content="基础数据结构"><meta property="og:description" content="1、总体注意事项 1.1、输入方式 两种输入方式，对于绝大多数时候，均选择Scanner作为输入。
import java.util.Scanner; Scanner sc = new Scanner(System.in); 当输入数据很大时，选择 BufferedReader，但其只能以行作为单位读取，需要分割为字符串数组，再解析为其他类型。
import java.io.BufferedReader; import java.io.InputStreamReader; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 1.2、读取 有些题目会有共包含 T 组案例，每组案例内 *** 操作，这种只需按 T 建循环即可。但有些题目没有指明共有 T 组案例，却在案例中包含了多组案例，此使必须在所有代码的外面包裹一层 while (sc.hasNext()) {...}，否则会出现虽然自测通过，但提交时却通过 0 组。
1.3、审题 当感觉找到一个比题目复杂度要求还低的方法时，一定要慎重考虑，这个方法真的对吗，能否覆盖所有情况，尽早换思路。 遇到与数字相关的题目，先看能不能找规律或化简，将题目转化为简单的模型再做。 与数字相关的题目，一定看是否为越界，注意用 long 和 double。 2、链表 2.1、链表反转 可以使用的方法有 栈、三指针法、头插法
使用头插法，因为对于一个区间的反转或者 k 个一组反转，使用头插法非常方便。
public ListNode reverseKGroup (ListNode head, int k) { ListNode pre = new ListNode(-1); pre.next = head; ListNode ret = pre, p = head; tag: while (p != null) { // 如果最后不够 k 个，则不反转 for (int i = 0; i < k; i++) { if (p == null) break tag; p = p.next; } p = pre.next; // 使用头插法，注意：循环 k - 1 次。 for (int i = 0; i < k - 1; i++) { ListNode temp = p.next; p.next = temp.next; temp.next = pre.next; pre.next = temp; } pre = p; p = p.next; } return ret.next; } 2.2、LRU缓存 方法一：LinkedHashMap。"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-26T11:12:41+00:00"><meta property="article:modified_time" content="2022-03-26T11:12:41+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="基础数据结构"><meta name=twitter:description content="1、总体注意事项
1.1、输入方式
两种输入方式，对于绝大多数时候，均选择Scanner作为输入。
import java.util.Scanner;

Scanner sc = new Scanner(System.in);
当输入数据很大时，选择 BufferedReader，但其只能以行作为单位读取，需要分割为字符串数组，再解析为其他类型。
import java.io.BufferedReader;
import java.io.InputStreamReader;

BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
1.2、读取
有些题目会有共包含 T 组案例，每组案例内 *** 操作，这种只需按 T 建循环即可。但有些题目没有指明共有 T 组案例，却在案例中包含了多组案例，此使必须在所有代码的外面包裹一层 while (sc.hasNext()) {...}，否则会出现虽然自测通过，但提交时却通过 0 组。
1.3、审题

当感觉找到一个比题目复杂度要求还低的方法时，一定要慎重考虑，这个方法真的对吗，能否覆盖所有情况，尽早换思路。
遇到与数字相关的题目，先看能不能找规律或化简，将题目转化为简单的模型再做。
与数字相关的题目，一定看是否为越界，注意用 long 和 double。

2、链表
2.1、链表反转
可以使用的方法有 栈、三指针法、头插法
使用头插法，因为对于一个区间的反转或者 k 个一组反转，使用头插法非常方便。
public ListNode reverseKGroup (ListNode head, int k) {
    ListNode pre = new ListNode(-1);
    pre.next = head;
    ListNode ret = pre, p = head;
    tag: while (p != null) {
        // 如果最后不够 k 个，则不反转
        for (int i = 0; i < k; i++) {
            if (p == null) break tag;
            p = p.next;
        }
        p = pre.next;
        // 使用头插法，注意：循环 k - 1 次。
        for (int i = 0; i < k - 1; i++) {
            ListNode temp = p.next;
            p.next = temp.next;
            temp.next = pre.next;
            pre.next = temp;
        }
        pre = p;
        p = p.next;
    }
    return ret.next;
}
2.2、LRU缓存
方法一：LinkedHashMap。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"基础数据结构","item":"http://localhost:1313/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"基础数据结构","name":"基础数据结构","description":"1、总体注意事项 1.1、输入方式 两种输入方式，对于绝大多数时候，均选择Scanner作为输入。\nimport java.util.Scanner; Scanner sc = new Scanner(System.in); 当输入数据很大时，选择 BufferedReader，但其只能以行作为单位读取，需要分割为字符串数组，再解析为其他类型。\nimport java.io.BufferedReader; import java.io.InputStreamReader; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 1.2、读取 有些题目会有共包含 T 组案例，每组案例内 *** 操作，这种只需按 T 建循环即可。但有些题目没有指明共有 T 组案例，却在案例中包含了多组案例，此使必须在所有代码的外面包裹一层 while (sc.hasNext()) {...}，否则会出现虽然自测通过，但提交时却通过 0 组。\n1.3、审题 当感觉找到一个比题目复杂度要求还低的方法时，一定要慎重考虑，这个方法真的对吗，能否覆盖所有情况，尽早换思路。 遇到与数字相关的题目，先看能不能找规律或化简，将题目转化为简单的模型再做。 与数字相关的题目，一定看是否为越界，注意用 long 和 double。 2、链表 2.1、链表反转 可以使用的方法有 栈、三指针法、头插法\n使用头插法，因为对于一个区间的反转或者 k 个一组反转，使用头插法非常方便。\npublic ListNode reverseKGroup (ListNode head, int k) { ListNode pre = new ListNode(-1); pre.next = head; ListNode ret = pre, p = head; tag: while (p != null) { // 如果最后不够 k 个，则不反转 for (int i = 0; i \u0026lt; k; i++) { if (p == null) break tag; p = p.next; } p = pre.next; // 使用头插法，注意：循环 k - 1 次。 for (int i = 0; i \u0026lt; k - 1; i++) { ListNode temp = p.next; p.next = temp.next; temp.next = pre.next; pre.next = temp; } pre = p; p = p.next; } return ret.next; } 2.2、LRU缓存 方法一：LinkedHashMap。\n","keywords":[],"articleBody":"1、总体注意事项 1.1、输入方式 两种输入方式，对于绝大多数时候，均选择Scanner作为输入。\nimport java.util.Scanner; Scanner sc = new Scanner(System.in); 当输入数据很大时，选择 BufferedReader，但其只能以行作为单位读取，需要分割为字符串数组，再解析为其他类型。\nimport java.io.BufferedReader; import java.io.InputStreamReader; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 1.2、读取 有些题目会有共包含 T 组案例，每组案例内 *** 操作，这种只需按 T 建循环即可。但有些题目没有指明共有 T 组案例，却在案例中包含了多组案例，此使必须在所有代码的外面包裹一层 while (sc.hasNext()) {...}，否则会出现虽然自测通过，但提交时却通过 0 组。\n1.3、审题 当感觉找到一个比题目复杂度要求还低的方法时，一定要慎重考虑，这个方法真的对吗，能否覆盖所有情况，尽早换思路。 遇到与数字相关的题目，先看能不能找规律或化简，将题目转化为简单的模型再做。 与数字相关的题目，一定看是否为越界，注意用 long 和 double。 2、链表 2.1、链表反转 可以使用的方法有 栈、三指针法、头插法\n使用头插法，因为对于一个区间的反转或者 k 个一组反转，使用头插法非常方便。\npublic ListNode reverseKGroup (ListNode head, int k) { ListNode pre = new ListNode(-1); pre.next = head; ListNode ret = pre, p = head; tag: while (p != null) { // 如果最后不够 k 个，则不反转 for (int i = 0; i \u003c k; i++) { if (p == null) break tag; p = p.next; } p = pre.next; // 使用头插法，注意：循环 k - 1 次。 for (int i = 0; i \u003c k - 1; i++) { ListNode temp = p.next; p.next = temp.next; temp.next = pre.next; pre.next = temp; } pre = p; p = p.next; } return ret.next; } 2.2、LRU缓存 方法一：LinkedHashMap。\n将 accessOrder 置为 true，并重写 removeEldestEntry 方法，LinkedHashMap 自动实现 LRU。但作为面试问题，这样做显然不行。\n方法二：HashMap + 双链表\nhttps://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/\n2.3、LFU 两个HashMap + 双链表\n一个 HashMap 存频次到双链表，一个存键到节点。即将链表按频次存储为多个链表。\n关于最小频次的维护：当取值时，必定会将某个节点从当前频次的链表移除，然后添加到 +1 的链表，此时看加1前的频次是否为最小频次，以及最小频次映射的链表是否为空，不为空则无需改变；若为空，则最小频次加 1；当存值时，如果值已经存在，则和取值的操作一样，否则，最小频次直接为1（不论是否需要换页）\n3、逆向思维 当遇到有两种变换方式的题目，从变换迭代中找规律，以逆向思维的方式从终点向起点反推。使用前提有以下两个：\n这两种变换都是向前推进的，如果有向后推进的变换，使用广度优先搜索。 从终点的前一步到终点，这一步的变换是固定的，有且只有一个，从而可以一直向前迭代。 下方题的两种变换分别是奇数和偶数，通过终点的奇偶可以唯一确定迭代路劲。\n扭蛋机_哔哩哔哩笔试题_牛客网 (nowcoder.com)\n下方题的终点状态，较大值一定是最后一步变换所得，且变换方式固定。\n力扣 780 到达终点\n4、树 4.1、按Z字形打印二叉树 层序遍历 + 栈；注意节点放入的顺序。如果不是打印，是返回，把 sout 换成 ArrayList 即可。\n/** * 按Z字形打印二叉树 * @param treeNode */ public void printTree(TreeNode treeNode) { if (treeNode != null) { Stack\u003cTreeNode\u003e oddStack = new Stack\u003cTreeNode\u003e(); // 奇数栈 Stack\u003cTreeNode\u003e evenStack = new Stack\u003cTreeNode\u003e(); // 偶数栈 int line = 1; // 表示第一行 oddStack.push(treeNode); // 根节点算奇数行, 先把根节点入奇数栈 TreeNode tempTreeNode = null; // 临时节点 while (!oddStack.isEmpty() || !evenStack.isEmpty()) { if (line%2 == 1) { // 奇数行 while (!oddStack.isEmpty()) { // 判断奇数栈是否为空 tempTreeNode = oddStack.pop(); // 奇数栈栈顶元素出栈 System.out.print(tempTreeNode.value +\", \"); if (tempTreeNode.left != null) { evenStack.push(tempTreeNode.left); // 偶数行左子节点先进栈 } if (tempTreeNode.right != null) { evenStack.push(tempTreeNode.right); // 偶数行右子节点后进栈 } } } else { // 偶数行 while (!evenStack.isEmpty()) { // 判断偶数栈是否为空 tempTreeNode = evenStack.pop(); // 偶数栈栈顶元素出栈 System.out.print(tempTreeNode.value +\", \"); if (tempTreeNode.right != null) { oddStack.push(tempTreeNode.right); // 奇数行右子节点先进栈 } if (tempTreeNode.left != null) { oddStack.push(tempTreeNode.left); // 奇数行左子节点后进栈 } } } line++; // 二叉树行加1 } } } 4.2、线段树 线段树是算法竞赛中常用的用来维护 区间信息 的数据结构。\n线段树 segmentTree 是一个二叉树，将每个长度不为 1 的区间划分成左右两个区间递归求解，把整个线段划分为一个树形结构，通过合并左右两区间信息来求得该区间的信息。这种数据结构可以方便的进行大部分的区间操作。\nhttps://leetcode-cn.com/problems/range-sum-query-mutable/solution/qu-yu-he-jian-suo-shu-zu-ke-xiu-gai-by-l-76xj/\n4.3、字典树 Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段：\n指向子节点的指针数组 children。 布尔字段 isEnd，表示该节点是否为字符串的结尾。 https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode-ti500/\n5、字符串 5.1、最长回文子串 中心扩展-》时间 O(n2),，空间O(1)。 Manacher 算法面试不做要求。\n// 该算法定义最小左和最大右是为了定位最长子串，如果只要求返回长度，则只定义一个 maxLenght 即可。 public int getLongestPalindrome (String A) { int minLeft = 0, maxRight = 0; char[] chs = A.toCharArray(); int len = chs.length; for (int i = 0; i \u003c len; i++) { int left = i, right = i; while (left \u003e= 0 \u0026\u0026 chs[left] == chs[i]) left--; while (right \u003c len \u0026\u0026 chs[right] == chs[i]) right++; while (left \u003e= 0 \u0026\u0026 right \u003c len \u0026\u0026 chs[left] == chs[right]) { left--; right++; } if (right - left \u003e maxRight - minLeft) { maxRight = right; minLeft = left; } } return maxRight - minLeft - 1; } 5.2、O(1)比较俩字符串是否包含公共字符 用位计算。假设单词只包含小写字符，用 0 ~ 25 表示每个字符。\nString str1, str2; int a, b; // 如 1 \u003c\u003c 5 为 100000，即任意一个字符，它会在二进制中固定表示一个位置，最大值 1 \u003c\u003c 25 小于 32 位，即 int 能存储下。 // 逐个字符进行或运算，即 将每个字符表示的位置添加到结果中 // 因此，结果的二进制表示中哪个位置为 1，表示该位置映射的字符存在于该字符串中。 for (char ch: str1.toCharArray()) a |= 1 \u003c\u003c (ch - 'a'); for (char ch: str2.toCharArray()) b |= 1 \u003c\u003c (ch - 'a'); // 逐位比较，若结果不为 0，表明一定有某个位置都为 1，即存在公共字符。 if (a \u0026 b == 0) 则 str1 和 str2 一定不存在公共字符 6、数组 6.1、排列组合 labuladong总结\n组合问题直接使用递归回溯方法，普通排列问题使用 next_permutation 算法，注意： next_permutation 算法对于有重复元素的不可复选全排列依然有效。特殊排列使用回溯，下方有。\n6.1.1、元素无重复不可复选 子集：固定向前遍历\n力扣 78 题 子集\n组合：固定向前遍历，注意添加条件即可\n力扣 77 题 组合\n特殊排列：给定数组长度为 n，求元素个数为 k 的排列\nclass Solution { List\u003cList\u003cInteger\u003e\u003e res = new ArrayList\u003cList\u003cInteger\u003e\u003e(); Deque\u003cInteger\u003e track = new ArrayDeque\u003cInteger\u003e(); boolean[] used; public List\u003cList\u003cInteger\u003e\u003e permute(int[] nums, int k) { used = new boolean[nums.length]; backtrack(0, k); return res; } public void backtrack(int[] nums, int k) { if (track.size() == k) { res.add(new ArrayList\u003cInteger\u003e(track)); return; } for (int i = 0; i \u003c nums.length; i++) { if (used[i]) continue; used[i] = true; track.addLast(nums[i]); backtrack(nums, k); track.removeLast(); used[i] = false; } } } 6.1.2、元素可重复不可复选 先排序，对重复元素直接跳过，注意为何这样能跳过。\n力扣 90 题 子集2\n力扣 40 题 组合总和2\n6.1.3、元素无重复可以复选 6.1.1 中通过固定向前来排除复选的可能，这里可以原地停留的方式保留复选。即在递归的时候，参数无需向前加一。\n力扣 39 题 组合总和\n6.1.4、简单组合的dp求解 从 n 个数中任意选 m 个数，有如下等式 $$ C^{m}n = C^{m}{n-1} + C^{m-1}_{n-1} $$ 因此，可以使用 dp 递推求得\n// 数组需为 (n + 1) * (n + 1) ，因为有 Cnn 的情况，当然非要用 m，也可以在循环中限制 j 最大为 m int[][] dp = new int[n + 1][n + 1]; // 边界条件：从 i 个数中选 0 个有一种方式 for (int i = 0; i \u003c= n; i++) { dp[i][0] = 1; } // 运用上方公式递推 for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= i; j++) { dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; } } 6.2、区间重叠问题 1、从重叠区间中找最大的不重叠的区间个数，使用贪心算法，先将数组按右端点升序排序，每次找满足条件且右端点最小的区间作为下一个合法区间即可。（只考虑不重叠区间即可，其他区间丢弃）\n2、满足所有区间的最优解\n2.1、牛客 主持人调度\n每个区间从开始到结束需要一个人负责，问所有区间最少需要几个人负责？（即一个人可以负责多个不重叠的区间）\n// 贪心 public int minmumNumberOfHost (int n, ArrayList\u003cArrayList\u003cInteger\u003e\u003e startEnd) { // write code here int[] start = new int[n]; int[] end = new int[n]; for (int i = 0; i \u003c n; i++) { start[i] = startEnd.get(i).get(0); end[i] = startEnd.get(i).get(1); } // 单独排序 Arrays.sort(start); Arrays.sort(end); // 对于每个左端点，看它之前是否有右端点，如果有就独占地使用右端点所在的区间的人负责该区间， // 否则就需要一个新人负责该区间 // ret 表示共需要多少人； j 表示剩余可以利用的右端点的最小值 int ret = 0, j = 0; for (int i = 0; i \u003c n; i++) { if (start[i] \u003e= end[j]) j++; else ret++; } return ret; } 2.2、每个区间由一个固定的人负责，问所有区间最少需要几个人负责？（即一个人只能负责一个区间，有些区间包含另一些区间，被包含的区间可以省略）\n3、其他类型的区间重叠问题直接使用 O(n2)的暴力破解。如计算重叠区间中重叠点的个数。\n6.3 约瑟夫问题 力扣 剑指 offer 62\nclass Solution { // 该题的 remain 是数字序列的下标，该题的序列值正好是从 0 开始，故直接返回 // 如果序列值是从 1 或其他数字开始，则得到最后的 remain 后，从原始序列中 // 找到该下标对应的值返回即可。 public int lastRemaining(int n, int m) { // 当序列只有一个数字时，保留下来的就是下标为 0 的数字 int remain = 0; // 从数字序列长度为 2 开始循环，迭代得到长度为 n 时的结果 for (int i = 2; i \u003c= n; i++) { // 序列长度为 i 时，将下标为（m - 1）的值删掉， // 则序列长度为 i - 1 时，序列下标为 (m, m + 1, ..., i, 0, 1, ..., m - 2) // 所以 （i - 1）时返回的 remain 在 i 时的真实下标为 (remain + m) % i remain = (remain + m) % i; } return remain; } } 7、单调栈 单调栈即栈中存放的数据都是单调递增或单调递减的。\n站在楼顶能看到多少栋楼，矮楼会被高楼遮住 public int[] findBuilding (int[] heights) { Stack\u003cInteger\u003e stack1 = new Stack\u003c\u003e(); int n = heights.length; int[] res = new int[n]; Arrays.fill(res,1); //最起码能看到自己所在的这栋楼 for(int i=0;i\u003cn-1;i++){ //首先向左边看 //只要当前楼大于等于前面遍历过的楼，就把前面的矮楼丢掉，因为我站在该楼右边是看不到的 while(!stack1.isEmpty() \u0026\u0026 heights[i]\u003e=stack1.peek()){ stack1.pop(); } stack1.push(heights[i]); //这里i+1才是核心，因为我已经通过while循环把比当前楼矮的都去掉了，所以栈里剩下的都比当前楼高 //也就是说当我站在该楼的右边一栋楼，栈里的楼我都能看到 res[i+1]+=stack1.size(); } Stack\u003cInteger\u003e stack2 = new Stack\u003c\u003e(); for(int i=n-1;i\u003e0;i--){ //然后向右边看 while(!stack2.isEmpty() \u0026\u0026 heights[i]\u003e=stack2.peek()){ stack2.pop(); } stack2.push(heights[i]); res[i-1]+=stack2.size(); //同理 } return res; } 8、动态规划 8.1、数位dp 太难了，暂时放弃。时间充裕了学习。\n9、水塘抽样 随机数索引\n水塘抽样\n","wordCount":"991","inLanguage":"en","datePublished":"2022-03-26T11:12:41Z","dateModified":"2022-03-26T11:12:41Z","author":{"@type":"Person","name":"lu"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},"publisher":{"@type":"Organization","name":"lu","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/categories/ title=categories><span>categories</span></a></li><li><a href=http://localhost:1313/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">基础数据结构</h1><div class=post-meta><span title='2022-03-26 11:12:41 +0000 UTC'>2022-03-26</span>&nbsp;·&nbsp;991 words&nbsp;·&nbsp;lu</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1总体注意事项>1、总体注意事项</a><ul><li><a href=#11输入方式>1.1、输入方式</a></li><li><a href=#12读取>1.2、读取</a></li><li><a href=#13审题>1.3、审题</a></li></ul></li><li><a href=#2链表>2、链表</a><ul><li><a href=#21链表反转>2.1、链表反转</a></li><li><a href=#22lru缓存>2.2、LRU缓存</a></li><li><a href=#23lfu>2.3、LFU</a></li></ul></li><li><a href=#3逆向思维>3、逆向思维</a></li><li><a href=#4树>4、树</a><ul><li><a href=#41按z字形打印二叉树>4.1、按Z字形打印二叉树</a></li><li><a href=#42线段树>4.2、线段树</a></li><li><a href=#43字典树>4.3、字典树</a></li></ul></li><li><a href=#5字符串>5、字符串</a><ul><li><a href=#51最长回文子串>5.1、最长回文子串</a></li><li><a href=#52o1比较俩字符串是否包含公共字符>5.2、O(1)比较俩字符串是否包含公共字符</a></li></ul></li><li><a href=#6数组>6、数组</a><ul><li><a href=#61排列组合>6.1、排列组合</a></li><li><a href=#62区间重叠问题>6.2、区间重叠问题</a></li><li><a href=#63-约瑟夫问题>6.3 约瑟夫问题</a></li></ul></li><li><a href=#7单调栈>7、单调栈</a></li><li><a href=#8动态规划>8、动态规划</a><ul><li><a href=#81数位dp>8.1、数位dp</a></li></ul></li><li><a href=#9水塘抽样>9、水塘抽样</a></li></ul></nav></div></details></div><div class=post-content><h2 id=1总体注意事项>1、总体注意事项<a hidden class=anchor aria-hidden=true href=#1总体注意事项>#</a></h2><h3 id=11输入方式>1.1、输入方式<a hidden class=anchor aria-hidden=true href=#11输入方式>#</a></h3><p>两种输入方式，对于绝大多数时候，均选择<code>Scanner</code>作为输入。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Scanner;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Scanner sc <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Scanner(System.<span style=color:#a6e22e>in</span>);
</span></span></code></pre></div><p>当输入数据很大时，选择 <code>BufferedReader</code>，但其只能以行作为单位读取，需要分割为字符串数组，再解析为其他类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.io.BufferedReader;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.io.InputStreamReader;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>BufferedReader br <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> BufferedReader(<span style=color:#66d9ef>new</span> InputStreamReader(System.<span style=color:#a6e22e>in</span>));
</span></span></code></pre></div><h3 id=12读取>1.2、读取<a hidden class=anchor aria-hidden=true href=#12读取>#</a></h3><p>有些题目会有共包含 T 组案例，每组案例内 *** 操作，这种只需按 T 建循环即可。但有些题目没有指明共有 T 组案例，却在案例中包含了多组案例，此使必须在所有代码的外面包裹一层 <code>while (sc.hasNext()) {...}</code>，否则会出现虽然自测通过，但提交时却通过 0 组。</p><h3 id=13审题>1.3、审题<a hidden class=anchor aria-hidden=true href=#13审题>#</a></h3><ul><li>当感觉找到一个比题目复杂度要求还低的方法时，一定要慎重考虑，这个方法真的对吗，能否覆盖所有情况，尽早换思路。</li><li>遇到与数字相关的题目，先看能不能找规律或化简，将题目转化为简单的模型再做。</li><li>与数字相关的题目，一定看是否为越界，注意用 long 和 double。</li></ul><h2 id=2链表>2、链表<a hidden class=anchor aria-hidden=true href=#2链表>#</a></h2><h3 id=21链表反转>2.1、链表反转<a hidden class=anchor aria-hidden=true href=#21链表反转>#</a></h3><p>可以使用的方法有 栈、三指针法、头插法</p><p>使用<strong>头插法</strong>，因为对于一个区间的反转或者 k 个一组反转，使用头插法非常方便。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> ListNode <span style=color:#a6e22e>reverseKGroup</span> (ListNode head, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>    ListNode pre <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListNode(<span style=color:#f92672>-</span>1);
</span></span><span style=display:flex><span>    pre.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>    ListNode ret <span style=color:#f92672>=</span> pre, p <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>    tag: <span style=color:#66d9ef>while</span> (p <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果最后不够 k 个，则不反转</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> k; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (p <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) <span style=color:#66d9ef>break</span> tag;
</span></span><span style=display:flex><span>            p <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        p <span style=color:#f92672>=</span> pre.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 使用头插法，注意：循环 k - 1 次。</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> k <span style=color:#f92672>-</span> 1; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            ListNode temp <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            p.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> temp.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            temp.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> pre.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>            pre.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> temp;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        pre <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>        p <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ret.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=22lru缓存>2.2、LRU缓存<a hidden class=anchor aria-hidden=true href=#22lru缓存>#</a></h3><p>方法一：LinkedHashMap。</p><p>将 accessOrder 置为 true，并重写 removeEldestEntry 方法，LinkedHashMap 自动实现 LRU。但作为面试问题，这样做显然不行。</p><p>方法二：HashMap + 双链表</p><p><a href=https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/>https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/</a></p><h3 id=23lfu>2.3、LFU<a hidden class=anchor aria-hidden=true href=#23lfu>#</a></h3><p>两个HashMap + 双链表</p><p>一个 HashMap 存频次到双链表，一个存键到节点。即将链表按频次存储为多个链表。</p><p>关于最小频次的维护：当取值时，必定会将某个节点从当前频次的链表移除，然后添加到 +1 的链表，此时看加1前的频次是否为最小频次，以及最小频次映射的链表是否为空，不为空则无需改变；若为空，则最小频次加 1；当存值时，如果值已经存在，则和取值的操作一样，否则，最小频次直接为1（不论是否需要换页）</p><h2 id=3逆向思维>3、逆向思维<a hidden class=anchor aria-hidden=true href=#3逆向思维>#</a></h2><p>当遇到有两种变换方式的题目，从变换迭代中找规律，以逆向思维的方式从终点向起点反推。使用前提有以下两个：</p><ul><li>这两种变换都是向前推进的，如果有向后推进的变换，使用广度优先搜索。</li><li>从终点的前一步到终点，这一步的变换是固定的，有且只有一个，从而可以一直向前迭代。</li></ul><p>下方题的两种变换分别是奇数和偶数，通过终点的奇偶可以唯一确定迭代路劲。</p><p><a href=https://www.nowcoder.com/questionTerminal/9d26441a396242a9a0f7d2106fc130c7>扭蛋机_哔哩哔哩笔试题_牛客网 (nowcoder.com)</a></p><p>下方题的终点状态，较大值一定是最后一步变换所得，且变换方式固定。</p><p><a href=https://leetcode-cn.com/problems/reaching-points/>力扣 780 到达终点</a></p><h2 id=4树>4、树<a hidden class=anchor aria-hidden=true href=#4树>#</a></h2><h3 id=41按z字形打印二叉树>4.1、按Z字形打印二叉树<a hidden class=anchor aria-hidden=true href=#41按z字形打印二叉树>#</a></h3><p>层序遍历 + 栈；注意节点放入的顺序。如果不是打印，是返回，把 sout 换成 ArrayList 即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 按Z字形打印二叉树
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param treeNode
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>printTree</span>(TreeNode treeNode) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (treeNode <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        Stack<span style=color:#f92672>&lt;</span>TreeNode<span style=color:#f92672>&gt;</span> oddStack  <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Stack<span style=color:#f92672>&lt;</span>TreeNode<span style=color:#f92672>&gt;</span>(); <span style=color:#75715e>// 奇数栈</span>
</span></span><span style=display:flex><span>        Stack<span style=color:#f92672>&lt;</span>TreeNode<span style=color:#f92672>&gt;</span> evenStack  <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Stack<span style=color:#f92672>&lt;</span>TreeNode<span style=color:#f92672>&gt;</span>(); <span style=color:#75715e>// 偶数栈</span>
</span></span><span style=display:flex><span>		    
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> line <span style=color:#f92672>=</span> 1; <span style=color:#75715e>// 表示第一行</span>
</span></span><span style=display:flex><span>			
</span></span><span style=display:flex><span>        oddStack.<span style=color:#a6e22e>push</span>(treeNode); <span style=color:#75715e>// 根节点算奇数行, 先把根节点入奇数栈</span>
</span></span><span style=display:flex><span>				
</span></span><span style=display:flex><span>        TreeNode tempTreeNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>; <span style=color:#75715e>// 临时节点</span>
</span></span><span style=display:flex><span>		    
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>oddStack.<span style=color:#a6e22e>isEmpty</span>() <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>evenStack.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (line<span style=color:#f92672>%</span>2 <span style=color:#f92672>==</span> 1) { <span style=color:#75715e>// 奇数行</span>
</span></span><span style=display:flex><span>					
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>oddStack.<span style=color:#a6e22e>isEmpty</span>()) { <span style=color:#75715e>// 判断奇数栈是否为空</span>
</span></span><span style=display:flex><span>                    tempTreeNode <span style=color:#f92672>=</span> oddStack.<span style=color:#a6e22e>pop</span>(); <span style=color:#75715e>// 奇数栈栈顶元素出栈</span>
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>print</span>(tempTreeNode.<span style=color:#a6e22e>value</span> <span style=color:#f92672>+</span><span style=color:#e6db74>&#34;, &#34;</span>);
</span></span><span style=display:flex><span>						
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (tempTreeNode.<span style=color:#a6e22e>left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                        evenStack.<span style=color:#a6e22e>push</span>(tempTreeNode.<span style=color:#a6e22e>left</span>); <span style=color:#75715e>// 偶数行左子节点先进栈</span>
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (tempTreeNode.<span style=color:#a6e22e>right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                        evenStack.<span style=color:#a6e22e>push</span>(tempTreeNode.<span style=color:#a6e22e>right</span>); <span style=color:#75715e>// 偶数行右子节点后进栈</span>
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> { <span style=color:#75715e>// 偶数行</span>
</span></span><span style=display:flex><span>					
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>evenStack.<span style=color:#a6e22e>isEmpty</span>()) { <span style=color:#75715e>// 判断偶数栈是否为空</span>
</span></span><span style=display:flex><span>                    tempTreeNode <span style=color:#f92672>=</span> evenStack.<span style=color:#a6e22e>pop</span>(); <span style=color:#75715e>// 偶数栈栈顶元素出栈</span>
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>print</span>(tempTreeNode.<span style=color:#a6e22e>value</span> <span style=color:#f92672>+</span><span style=color:#e6db74>&#34;, &#34;</span>);
</span></span><span style=display:flex><span>								
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (tempTreeNode.<span style=color:#a6e22e>right</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                        oddStack.<span style=color:#a6e22e>push</span>(tempTreeNode.<span style=color:#a6e22e>right</span>); <span style=color:#75715e>// 奇数行右子节点先进栈</span>
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (tempTreeNode.<span style=color:#a6e22e>left</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) { 
</span></span><span style=display:flex><span>                        oddStack.<span style=color:#a6e22e>push</span>(tempTreeNode.<span style=color:#a6e22e>left</span>); <span style=color:#75715e>// 奇数行左子节点后进栈</span>
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            line<span style=color:#f92672>++</span>; <span style=color:#75715e>// 二叉树行加1</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=42线段树>4.2、线段树<a hidden class=anchor aria-hidden=true href=#42线段树>#</a></h3><p>线段树是算法竞赛中常用的用来维护 <strong>区间信息</strong> 的数据结构。</p><p>线段树 segmentTree 是一个二叉树，将每个长度不为 1 的区间划分成左右两个区间递归求解，把整个线段划分为一个树形结构，通过合并左右两区间信息来求得该区间的信息。这种数据结构可以方便的进行大部分的区间操作。</p><p><a href=https://leetcode-cn.com/problems/range-sum-query-mutable/solution/qu-yu-he-jian-suo-shu-zu-ke-xiu-gai-by-l-76xj/>https://leetcode-cn.com/problems/range-sum-query-mutable/solution/qu-yu-he-jian-suo-shu-zu-ke-xiu-gai-by-l-76xj/</a></p><h3 id=43字典树>4.3、字典树<a hidden class=anchor aria-hidden=true href=#43字典树>#</a></h3><p>Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段：</p><ul><li>指向子节点的指针数组 children。</li><li>布尔字段 isEnd，表示该节点是否为字符串的结尾。</li></ul><p><a href=https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode-ti500/>https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode-ti500/</a></p><h2 id=5字符串>5、字符串<a hidden class=anchor aria-hidden=true href=#5字符串>#</a></h2><h3 id=51最长回文子串>5.1、最长回文子串<a hidden class=anchor aria-hidden=true href=#51最长回文子串>#</a></h3><p>中心扩展-》时间 O(n2),，空间O(1)。 Manacher 算法面试不做要求。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 该算法定义最小左和最大右是为了定位最长子串，如果只要求返回长度，则只定义一个 maxLenght 即可。</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getLongestPalindrome</span> (String A) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> minLeft <span style=color:#f92672>=</span> 0, maxRight <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span><span style=color:#f92672>[]</span> chs <span style=color:#f92672>=</span> A.<span style=color:#a6e22e>toCharArray</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> len <span style=color:#f92672>=</span> chs.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> len; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> i, right <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (left <span style=color:#f92672>&gt;=</span> 0 <span style=color:#f92672>&amp;&amp;</span> chs<span style=color:#f92672>[</span>left<span style=color:#f92672>]</span> <span style=color:#f92672>==</span> chs<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>) left<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (right <span style=color:#f92672>&lt;</span> len <span style=color:#f92672>&amp;&amp;</span> chs<span style=color:#f92672>[</span>right<span style=color:#f92672>]</span> <span style=color:#f92672>==</span> chs<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>) right<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (left <span style=color:#f92672>&gt;=</span> 0 <span style=color:#f92672>&amp;&amp;</span> right <span style=color:#f92672>&lt;</span> len <span style=color:#f92672>&amp;&amp;</span> chs<span style=color:#f92672>[</span>left<span style=color:#f92672>]</span> <span style=color:#f92672>==</span> chs<span style=color:#f92672>[</span>right<span style=color:#f92672>]</span>) {
</span></span><span style=display:flex><span>                left<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>                right<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (right <span style=color:#f92672>-</span> left <span style=color:#f92672>&gt;</span> maxRight <span style=color:#f92672>-</span> minLeft) {
</span></span><span style=display:flex><span>                maxRight <span style=color:#f92672>=</span> right;
</span></span><span style=display:flex><span>                minLeft <span style=color:#f92672>=</span> left;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> maxRight <span style=color:#f92672>-</span> minLeft <span style=color:#f92672>-</span> 1;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h3 id=52o1比较俩字符串是否包含公共字符>5.2、O(1)比较俩字符串是否包含公共字符<a hidden class=anchor aria-hidden=true href=#52o1比较俩字符串是否包含公共字符>#</a></h3><p>用位计算。假设单词只包含小写字符，用 0 ~ 25 表示每个字符。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>String str1, str2;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> a, b;
</span></span><span style=display:flex><span><span style=color:#75715e>// 如 1 &lt;&lt; 5 为 100000，即任意一个字符，它会在二进制中固定表示一个位置，最大值 1 &lt;&lt; 25 小于 32 位，即 int 能存储下。</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 逐个字符进行或运算，即 将每个字符表示的位置添加到结果中</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 因此，结果的二进制表示中哪个位置为 1，表示该位置映射的字符存在于该字符串中。</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>char</span> ch: str1.<span style=color:#a6e22e>toCharArray</span>()) a <span style=color:#f92672>|=</span> 1 <span style=color:#f92672>&lt;&lt;</span> (ch <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;a&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>char</span> ch: str2.<span style=color:#a6e22e>toCharArray</span>()) b <span style=color:#f92672>|=</span> 1 <span style=color:#f92672>&lt;&lt;</span> (ch <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;a&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 逐位比较，若结果不为 0，表明一定有某个位置都为 1，即存在公共字符。</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (a <span style=color:#f92672>&amp;</span> b <span style=color:#f92672>==</span> 0) 则 str1 和 str2 一定不存在公共字符
</span></span></code></pre></div><h2 id=6数组>6、数组<a hidden class=anchor aria-hidden=true href=#6数组>#</a></h2><h3 id=61排列组合>6.1、排列组合<a hidden class=anchor aria-hidden=true href=#61排列组合>#</a></h3><p><code>labuladong</code>总结</p><p>组合问题直接使用递归回溯方法，普通排列问题使用 next_permutation 算法，注意： next_permutation 算法对于有重复元素的不可复选全排列依然有效。特殊排列使用回溯，下方有。</p><h4 id=611元素无重复不可复选>6.1.1、元素无重复不可复选<a hidden class=anchor aria-hidden=true href=#611元素无重复不可复选>#</a></h4><p>子集：固定向前遍历</p><p><a href=https://leetcode-cn.com/problems/subsets/>力扣 78 题 子集</a></p><p>组合：固定向前遍历，注意添加条件即可</p><p><a href=https://leetcode-cn.com/problems/combinations/>力扣 77 题 组合</a></p><p>特殊排列：给定数组长度为 n，求元素个数为 k 的排列</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span> res <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>    Deque<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> track <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayDeque<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span><span style=color:#f92672>[]</span> used;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> List<span style=color:#f92672>&lt;</span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span> <span style=color:#a6e22e>permute</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> nums, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>        used <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>boolean</span><span style=color:#f92672>[</span>nums.<span style=color:#a6e22e>length</span><span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        backtrack(0, k);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>backtrack</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> nums, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (track.<span style=color:#a6e22e>size</span>() <span style=color:#f92672>==</span> k) {
</span></span><span style=display:flex><span>            res.<span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span>(track));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> nums.<span style=color:#a6e22e>length</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (used<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            used<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            track.<span style=color:#a6e22e>addLast</span>(nums<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>            backtrack(nums, k);
</span></span><span style=display:flex><span>            track.<span style=color:#a6e22e>removeLast</span>();
</span></span><span style=display:flex><span>            used<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=612元素可重复不可复选>6.1.2、元素可重复不可复选<a hidden class=anchor aria-hidden=true href=#612元素可重复不可复选>#</a></h4><p>先排序，对重复元素直接跳过，注意为何这样能跳过。</p><p><a href=https://leetcode-cn.com/problems/subsets-ii/>力扣 90 题 子集2</a></p><p><a href=https://leetcode-cn.com/problems/combination-sum-ii/>力扣 40 题 组合总和2</a></p><h4 id=613元素无重复可以复选>6.1.3、元素无重复可以复选<a hidden class=anchor aria-hidden=true href=#613元素无重复可以复选>#</a></h4><p>6.1.1 中通过固定向前来排除复选的可能，这里可以原地停留的方式保留复选。即在递归的时候，参数无需向前加一。</p><p><a href=https://leetcode-cn.com/problems/combination-sum/>力扣 39 题 组合总和</a></p><h4 id=614简单组合的dp求解>6.1.4、简单组合的dp求解<a hidden class=anchor aria-hidden=true href=#614简单组合的dp求解>#</a></h4><p>从 n 个数中任意选 m 个数，有如下等式
$$
C^{m}<em>n = C^{m}</em>{n-1} + C^{m-1}_{n-1}
$$
因此，可以使用 dp 递推求得</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 数组需为 (n + 1) * (n + 1) ，因为有 Cnn 的情况，当然非要用 m，也可以在循环中限制 j 最大为 m</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span><span style=color:#f92672>[][]</span> dp <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>n <span style=color:#f92672>+</span> 1<span style=color:#f92672>][</span>n <span style=color:#f92672>+</span> 1<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>// 边界条件：从 i 个数中选 0 个有一种方式</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;=</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    dp<span style=color:#f92672>[</span>i<span style=color:#f92672>][</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 1;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 运用上方公式递推</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1; i <span style=color:#f92672>&lt;=</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> 1; j <span style=color:#f92672>&lt;=</span> i; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        dp<span style=color:#f92672>[</span>i<span style=color:#f92672>][</span>j<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> dp<span style=color:#f92672>[</span>i <span style=color:#f92672>-</span> 1<span style=color:#f92672>][</span>j<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> dp<span style=color:#f92672>[</span>i <span style=color:#f92672>-</span> 1<span style=color:#f92672>][</span>j <span style=color:#f92672>-</span> 1<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=62区间重叠问题>6.2、区间重叠问题<a hidden class=anchor aria-hidden=true href=#62区间重叠问题>#</a></h3><p>1、从重叠区间中找最大的不重叠的区间个数，使用贪心算法，先将数组按右端点升序排序，每次找满足条件且右端点最小的区间作为下一个合法区间即可。（只考虑不重叠区间即可，其他区间丢弃）</p><p>2、满足所有区间的最优解</p><p>2.1、<a href="https://www.nowcoder.com/practice/4edf6e6d01554870a12f218c94e8a299?tpId=295&amp;tqId=1267319&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=%2Fexam%2Foj">牛客 主持人调度</a></p><p>每个区间从开始到结束需要一个人负责，问所有区间最少需要几个人负责？（即一个人可以负责多个不重叠的区间）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 贪心</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>minmumNumberOfHost</span> (<span style=color:#66d9ef>int</span> n, ArrayList<span style=color:#f92672>&lt;</span>ArrayList<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span> startEnd) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// write code here</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> start <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>n<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> end <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>n<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        start<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> startEnd.<span style=color:#a6e22e>get</span>(i).<span style=color:#a6e22e>get</span>(0);
</span></span><span style=display:flex><span>        end<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> startEnd.<span style=color:#a6e22e>get</span>(i).<span style=color:#a6e22e>get</span>(1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 单独排序</span>
</span></span><span style=display:flex><span>    Arrays.<span style=color:#a6e22e>sort</span>(start);
</span></span><span style=display:flex><span>    Arrays.<span style=color:#a6e22e>sort</span>(end);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 对于每个左端点，看它之前是否有右端点，如果有就独占地使用右端点所在的区间的人负责该区间，</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 否则就需要一个新人负责该区间</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ret 表示共需要多少人； j 表示剩余可以利用的右端点的最小值</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> ret <span style=color:#f92672>=</span> 0, j <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (start<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>&gt;=</span> end<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span>)
</span></span><span style=display:flex><span>            j<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            ret<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>2.2、每个区间由一个固定的人负责，问所有区间最少需要几个人负责？（即一个人只能负责一个区间，有些区间包含另一些区间，被包含的区间可以省略）</p><p>3、其他类型的区间重叠问题直接使用 O(n2)的暴力破解。如计算重叠区间中重叠点的个数。</p><h3 id=63-约瑟夫问题>6.3 约瑟夫问题<a hidden class=anchor aria-hidden=true href=#63-约瑟夫问题>#</a></h3><p><a href=https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/>力扣 剑指 offer 62</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 该题的 remain 是数字序列的下标，该题的序列值正好是从 0 开始，故直接返回</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果序列值是从 1 或其他数字开始，则得到最后的 remain 后，从原始序列中</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 找到该下标对应的值返回即可。</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lastRemaining</span>(<span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> m) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 当序列只有一个数字时，保留下来的就是下标为 0 的数字</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> remain <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 从数字序列长度为 2 开始循环，迭代得到长度为 n 时的结果</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 2; i <span style=color:#f92672>&lt;=</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 序列长度为 i 时，将下标为（m - 1）的值删掉，</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 则序列长度为 i - 1 时，序列下标为 (m, m + 1, ..., i, 0, 1, ..., m - 2)</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 所以 （i - 1）时返回的 remain 在 i 时的真实下标为 (remain + m) % i</span>
</span></span><span style=display:flex><span>            remain <span style=color:#f92672>=</span> (remain <span style=color:#f92672>+</span> m) <span style=color:#f92672>%</span> i;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> remain;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=7单调栈>7、单调栈<a hidden class=anchor aria-hidden=true href=#7单调栈>#</a></h2><p>单调栈即栈中存放的数据都是单调递增或单调递减的。</p><ul><li>站在楼顶能看到多少栋楼，矮楼会被高楼遮住</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> <span style=color:#a6e22e>findBuilding</span> (<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> heights) {
</span></span><span style=display:flex><span>    Stack<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> stack1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Stack<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> heights.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> res <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>n<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    Arrays.<span style=color:#a6e22e>fill</span>(res,1);       <span style=color:#75715e>//最起码能看到自己所在的这栋楼</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>0;i<span style=color:#f92672>&lt;</span>n<span style=color:#f92672>-</span>1;i<span style=color:#f92672>++</span>){   <span style=color:#75715e>//首先向左边看</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//只要当前楼大于等于前面遍历过的楼，就把前面的矮楼丢掉，因为我站在该楼右边是看不到的</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>stack1.<span style=color:#a6e22e>isEmpty</span>() <span style=color:#f92672>&amp;&amp;</span> heights<span style=color:#f92672>[</span>i<span style=color:#f92672>]&gt;=</span>stack1.<span style=color:#a6e22e>peek</span>()){
</span></span><span style=display:flex><span>            stack1.<span style=color:#a6e22e>pop</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        stack1.<span style=color:#a6e22e>push</span>(heights<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>//这里i+1才是核心，因为我已经通过while循环把比当前楼矮的都去掉了，所以栈里剩下的都比当前楼高</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//也就是说当我站在该楼的右边一栋楼，栈里的楼我都能看到</span>
</span></span><span style=display:flex><span>        res<span style=color:#f92672>[</span>i<span style=color:#f92672>+</span>1<span style=color:#f92672>]+=</span>stack1.<span style=color:#a6e22e>size</span>();  
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Stack<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> stack2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Stack<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>n<span style=color:#f92672>-</span>1;i<span style=color:#f92672>&gt;</span>0;i<span style=color:#f92672>--</span>){   <span style=color:#75715e>//然后向右边看</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>stack2.<span style=color:#a6e22e>isEmpty</span>() <span style=color:#f92672>&amp;&amp;</span> heights<span style=color:#f92672>[</span>i<span style=color:#f92672>]&gt;=</span>stack2.<span style=color:#a6e22e>peek</span>()){
</span></span><span style=display:flex><span>            stack2.<span style=color:#a6e22e>pop</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        stack2.<span style=color:#a6e22e>push</span>(heights<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>        res<span style=color:#f92672>[</span>i<span style=color:#f92672>-</span>1<span style=color:#f92672>]+=</span>stack2.<span style=color:#a6e22e>size</span>();  <span style=color:#75715e>//同理</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=8动态规划>8、动态规划<a hidden class=anchor aria-hidden=true href=#8动态规划>#</a></h2><h3 id=81数位dp>8.1、数位dp<a hidden class=anchor aria-hidden=true href=#81数位dp>#</a></h3><p>太难了，暂时放弃。时间充裕了学习。</p><h2 id=9水塘抽样>9、水塘抽样<a hidden class=anchor aria-hidden=true href=#9水塘抽样>#</a></h2><p><a href=https://leetcode-cn.com/problems/random-pick-index/solution/sui-ji-shu-suo-yin-by-leetcode-solution-ofsq/>随机数索引</a></p><p><a href=https://zhuanlan.zhihu.com/p/29178293>水塘抽样</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/java/java-%E8%BF%9B%E9%98%B6/concurrenthashmap/><span class=title>« Prev</span><br><span>ConcurrentHashMap</span>
</a><a class=next href=http://localhost:1313/posts/%E9%9D%A2%E7%BB%8F/%E9%9D%A2%E7%BB%8F-%E7%BE%8E%E5%9B%A2/><span class=title>Next »</span><br><span>面经-美团</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>