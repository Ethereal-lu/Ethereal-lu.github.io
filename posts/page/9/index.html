<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | lu</title>
<meta name=keywords content><meta name=description content="Posts - lu"><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://ethereal-lu.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/posts/"><meta property="og:site_name" content="lu"><meta property="og:title" content="Posts"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ethereal-lu.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="lu (Alt + H)">lu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://ethereal-lu.github.io/>Home</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SpringBoot学习笔记</h2></header><div class=entry-content><p>Spring Boot 是 Spring 的子项目，正如其名字，提供 Spring 的引导( Boot )的功能。
通过 Spring Boot ，开发者可以快速配置 Spring 项目，引入各种 Spring MVC、Spring Transaction、Spring AOP、等等框架，而无需不断重复编写繁重的 Spring 配置，降低了 Spring 的使用成本。
项目创建 新建 spring initializr 项目，在新建过程中引入 spring web 依赖 将所有的controller、pojo、dao等包创建在Application类的同名目录下（约定大于配置），创建在其他目录下会报错 在resources目录下创建banner.txt文件，可以在里面粘贴一些图片用于启动时展示 自动装配原理 父工程 spring-boot-dependencies 对springboot的所有依赖进行管理，其中就有依赖的版本控制，因此我们在pom.xml中引入依赖时，不需要指定版本
启动器：启动器都以spring-boot-starter打头，就是springboot的启动场景，如spring-boot-starter-web，就会帮我们自动导入web环境所有的依赖。springboot会将所有的功能场景变为一个个的启动器。我们要使用什么功能，只需要找到相对应的启动器并导入即可
主程序：
// @SpringBootApplication ：标注这个类是springboot的应用 @SpringBootApplication public class Springboot01HelloworldApplication { public static void main(String[] args) { // 启动springboot SpringApplication.run(Springboot01HelloworldApplication.class, args); } } @SpringBootApplication 是复合注解，主要包括 **@ComponentScan, @EnableAutoConfiguration, @SpringBootConfiguration**三个注解。
@SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) public @interface SpringBootApplication @ComponentScan 注解：组件扫描。 spring里有四大注解：@Service,@Repository,@Component,@Controller用来定义一个bean.@ComponentScan注解就是用来自动扫描被这些注解标识的类，最终生成ioc容器里的bean． @SpringBootConfiguration 注解：@SpringBootConfiguration继承自@Configuration，二者功能也一致，标注当前类是配置类， 并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。 @EnableAutoConfiguration 注解：从 classpath 中搜索所有的 META-INF/spring.factories 配置文件，然后将其中key为org.springframework.boot.autoconfigure.EnableAutoConfiguration 的 value 加载到spring容器中。 注解：
...</p></div><footer class=entry-footer><span title='2021-05-10 17:39:41 +0000 UTC'>2021-05-10</span>&nbsp;·&nbsp;1219 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to SpringBoot学习笔记" href=https://ethereal-lu.github.io/posts/java/springboot%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>mybatis学习笔记</h2></header><div class=entry-content><p>第一个MyBatis项目 先进入mysql创建mybatis数据库，并在其中创建user表，其中有字段值如实体类User中的属性 新建一个Maven项目，作为父项目，在其pom.xml配置文件中引入依赖（mysql驱动、junit、mybatis）。则其子模块中都继承了这些依赖。 在父项目下新建一个Maven子模块，在其main目录的resources下新建文件mybatis-config.xml作为配置文件，内容如下： &lt;?xml version="1.0" encoding="UTF-8" ?> &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"> &lt;!--核心配置文件--> &lt;configuration> &lt;!--下方这一句为引入外部属性文件，需在resources下创建jdbc.properties文件 也可以不引入外部属性文件而直接对4个value赋值--> &lt;properties resource="jdbc.properties"/> &lt;environments default="development"> &lt;environment id="development"> &lt;transactionManager type="JDBC"/> &lt;dataSource type="POOLED"> &lt;!--只需为下面四项赋值即可--> &lt;property name="driver" value="${jdbc.driveClass}"/> &lt;property name="url" value="${jdbc.url}"/> &lt;property name="username" value="${jdbc.username}"/> &lt;property name="password" value="${jdbc.password}"/> &lt;/dataSource> &lt;/environment> &lt;/environments> &lt;!--每一个sql映射文件Mapper.xml都需要在Mybatis的核心配置文件中的&lt;mappers>标签下注册， 否则就会报错Type interface com.lu.dao.UserDao is not known to the MapperRegistry.--> &lt;mappers> &lt;!--如果Mapper.xml在resources目录下，则直接写文件名即可，若在其他路径，则要写全路径，用/分割目录--> &lt;mapper resource="UserMapper.xml"/> &lt;/mappers> &lt;/configuration> jdbc.properties文件如下：其中jdbc.url字段特别容易引发错误
jdbc.driveClass=com.mysql.cj.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai jdbc.userName=root jdbc.password=gaolu666 创建获取sqlSession对象的工具类（类中代码如下）。 // sqlSessionFactory --> SqlSession public class MybatisUtils { private static final SqlSessionFactory sqlSessionFactory; // 用Mybatis的配置文件获取sqlSessionFactory对象 static { String resource = "mybatis-config.xml"; InputStream inputStream = null; try { inputStream = Resources.getResourceAsStream(resource); } catch (IOException e) { e.printStackTrace(); } sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } // 用sqlSessionFactory对象获取SqlSession对象 public static SqlSession getSqlSession() { return sqlSessionFactory.openSession(); } } 实现。创建实体类、UserDao接口以及Mapper配置文件UserMapper.xml（该文件代替JDBC中的UserDaoImpl实现类，但是仍然可以将该文件理解为UserDao的实现类），分别如下：【实体类要实现序列化接口】 // 实体类 public class User implements Serializable { private int id; private String name; private String passwd; ... // 省略部分为有参无参构造，getter、setter方法 } // UserDao接口 public interface UserDao { List&lt;User> getUserList(); // 根据ID查询用户 User getUserById(int id); // 添加用户 void addUser(User user); // 修改用户 void updateUser(User user); // 删除用户 void deleteUser(int id); } &lt;!--sql映射文件UserMapper.xml--> &lt;?xml version="1.0" encoding="UTF-8" ?> &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"> &lt;mapper namespace="com.lu.dao.UserDao"> &lt;!--namespace绑定一个Mapper（Dao）接口--> &lt;!--id对应绑定的接口中的一个方法名，resultType为返回值， 当该方法的返回值为集合时resultType对应集合泛型中的类的全路径--> &lt;select id="getUserList" resultType="com.lu.pojo.User"> select * from user &lt;/select> &lt;!--parameterType对应参数类型，当方法的参数只有一个，且参数类型为基本类型时，可以不写parameterType这一项， 方法参数有多个时，用map或注解--> &lt;select id="getUserById" parameterType="int" resultType="com.lu.pojo.User"> select * from user where id = #{id} /*此处#{id}接收getUserById方法的参数，因此名称与参数名一致*/ &lt;/select> &lt;insert id="addUser" parameterType="com.lu.pojo.User"> /*此处#{id}, #{name}, #{passwd}自动接收User类中的属性，因此名字与三个属性名一致*/ insert into user (id, name, passwd) values (#{id}, #{name}, #{passwd}) &lt;/insert> &lt;update id="updateUser" parameterType="com.lu.pojo.User"> update user set name = #{name}, passwd = #{passwd} where id = #{id} /*修改多个参数中间用逗号隔开不要忘*/ &lt;/update> &lt;delete id="deleteUser" parameterType="int"> delete from user where id = #{id} &lt;/delete> &lt;/mapper> 测试，代码如下： public class UserDaoTest { @Test public void getUserListTest() { // 第一步：获取sqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); // 第二部：getMapper UserDao mapper = sqlSession.getMapper(UserDao.class); // 第三步：执行sql for (User user: mapper.getUserList()) System.out.println(user); // 第四步：关闭连接 sqlSession.close(); // 注意事项：增删改操作必须要提交事务 --> sqlSession.commit(); } } map的使用（野路子，增加灵活性但不利于维护） 使用场景：当表中的字段过多，而只需要更新少量字段时，不需要像上方一样，传入一个带全部字段的新对象，而只需要利用map传递需要的字段即可。同样在添加操作时，也可以在map中只存放notnull的字段，对于允许null的字段，可以不添加。示例如下： &lt;update id="updateUser2" parameterType="map"> /*上方参数类型map即表示Map类型，下方的#{key_name}和#{key_id}接收map中的值，故名称与map中的键名一致*/ update user set name = #{key_name} where id = #{key_id} &lt;/update> 配置解析 核心配置文件mybatis-config.xml environments environments标签下可以有多套环境，但同时最多只能使用一套（即互斥使用），修改default的值即可切换环境 transactionManager标签即事务管理器，只需知道除了JDBC还有一个MANAGED即可 dataSource即数据源，type的值默认为POOLED即使用连接池，只需知道type不止这一个值即可 properties properties标签即引入外部属性文件 properties标签必须位于configuration标签下的第一行 properties标签下也可以添加propertie标签，并优先读取propertie标签内的值，然后读取外部文件，并覆盖同名键 typeAliases typeAliases即类型别名，为java类型设置一个短的名字，用于减少类完全限定名（类的全路径）的冗余 类型别名有两种实现方式，一种为typeAlias，即为每一个类自定义一个别名，另一种为package，它指定一个包，将包下所有类的别名设定为类名的首字母小写（其实大写也可以用，但建议小写），如下：（当实体类少时用第一种，实体类多时用第二种） &lt;typeAliases> &lt;typeAlias type="com.lu.pojo.User" alias="User"/> &lt;package name="com.lu.pojo"/> &lt;/typeAliases> settings logImpl：设置日志 cacheEnabled：缓存 lazyLoadingEnabled：懒加载 mappers 一般会将操作数据库的接口与其同名sql映射文件mapper.xml放在同一个包下，但这样还需另外设置过滤操作。也可以在resources目录下创建与接口所在目录的同名目录，然后将sql映射文件放入该目录中，这样在编译后接口与映射文件就在同一个包下了。 生命周期与作用域 错误的使用可能会导致严重的并发问题
...</p></div><footer class=entry-footer><span title='2021-04-26 19:42:15 +0000 UTC'>2021-04-26</span>&nbsp;·&nbsp;976 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to mybatis学习笔记" href=https://ethereal-lu.github.io/posts/java/mybatis%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SpringMVC学习笔记</h2></header><div class=entry-content><p>第一个SpringMVC项目 新建maven父项目，引入依赖：junit，spring-webmvc，servlet-api，jsp-api，jstl 新建maven子项目，添加web支持 配置web.xml，注册DispatcherServlet，如下： &lt;?xml version="1.0" encoding="UTF-8"?> &lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"> &lt;!--配置DispatcherServlet--> &lt;servlet> &lt;servlet-name>springmvc&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;!--绑定一个springmvc的配置文件： [servlet-name]-servlet.xml--> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:springmvc-servlet.xml&lt;/param-value> &lt;/init-param> &lt;!--启动级别 1， 1级表示随着服务器一起启动--> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;!-- / 匹配所有请求（不包括 .jsp)--> &lt;!-- /* 匹配所有请求（包括 .jsp)，若此处使用/*则在视图解析时会再加上.jsp，使页面名变为a.jsp.jsp从而出错--> &lt;servlet-mapping> &lt;servlet-name>springmvc&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> &lt;/web-app> 在resource下创建springmvc-servlet.xml，如下： &lt;?xml version="1.0" encoding="utf-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"> &lt;!--处理器映射器--> &lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/> &lt;!--处理器适配器--> &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"/> &lt;!--视图解析器--> &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" id="internalResourceViewResolver"> &lt;property name="prefix" value="/WEB-INF/jsp/" /> &lt;!--前缀--> &lt;property name="suffix" value=".jsp" /> &lt;!--后缀--> &lt;/bean> &lt;bean id="/hello" class="com.lu.controller.HelloController"/> &lt;/beans> java下创建Controller类 // 实现Controller接口，就是一个控制器，就会获得控制器功能：处理请求并返回一个模型与视图对象 public class HelloController implements Controller { @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { ModelAndView mv = new ModelAndView(); // 业务代码 String result = "SpringMVC"; mv.addObject("msg", result); // 视图跳转 mv.setViewName("hello"); return mv; } } WEB-INF下的jsp下创建hello.jsp，里面的body中添加${msg}即可 SpringMVC执行流程 ...</p></div><footer class=entry-footer><span title='2021-04-25 14:58:37 +0000 UTC'>2021-04-25</span>&nbsp;·&nbsp;699 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to SpringMVC学习笔记" href=https://ethereal-lu.github.io/posts/java/springmvc%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MarkDown无法显示本地图片</h2></header><div class=entry-content><p>访问控制的原因：在vscode中按ctrl+shift+p打开命令面板，输入更改预览安全设置，选中允许不安全的本地内容 本地图片不允许使用png格式（网络图片却可以），最好换为jpg格式（有可能只适用于本机） 本地图片路径不支持绝对路径，要通过../../…改为相对路径</p></div><footer class=entry-footer><span title='2021-04-21 21:08:18 +0000 UTC'>2021-04-21</span>&nbsp;·&nbsp;3 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to MarkDown无法显示本地图片" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/markdown/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Servlet学习笔记</h2></header><div class=entry-content><p>Servlet定义 Servlet是一个Java应用程序，运行在服务器端，用来处理客户端请求并作出响应的程序。
实现Servlet的主要方式 程序实现Servlet接口（很少使用） 编写类实现Servlet接口 根据业务重写service方法 到web.xml中配置Servlet程序的访问地址（基于注解时不需要） 程序继承HttpServlet类（一般使用这种） 编写类继承HttpServlet类 根据业务需要重写doGet或doPost方法 到web.xml中配置Servlet程序的访问地址（基于注解时不需要） 在IDEA中直接创建Servlet程序 实质上还是第二种方法，只是IDEA帮你做了一些通用的工作 Servlet的生命周期 执行Servlet构造器方法，该方法在初次访问时调用一次。由Servlet容器（Tomcat）创建。这说明 Servlet 是单实例的! 执行init初始化方法，该方法在初次访问时调用一次。 执行service方法，该方法在每次访问时都会调用一次。 执行destory方法，该方法在web工程停止时调用一次。 用于释放当前 Servlet 所占用的资源。 Servlet接口的架构 Servlet的域对象 概念：可以在不同Servlet之间传递数据的对象，就是域对象。通俗的讲就是这个对象本身可以存储一定范围内的所有数据，通过它就能获取和存储数据。 域对象共有的方法： getAttribute(String name) 获取对应的数据 getAttributeNames() 获取所有的key removeAttribute(String name) 移除对应的数据 setAttribute(String name, Object object) 设置数据 Servlet的三大域对象分别为ServletRequest域、HttpSession域、ServletContext域 ServletRequest： 生命周期：请求开始到请求结束 作用域：整个请求链（包括请求转发） HttpSession： 生命周期：会话开始到会话结束，服务器会为每个浏览器创建一个供其独享的Session对象，当一段时间内，session没有被使用（默认是30分钟），服务器会销毁该session。 作用域：一次会话 ServletContext： 生命周期：服务器开启到服务器关闭 作用域：整个web应用 ServletConfig类 ServletConfig类是Servlet程序的配置信息类，里面封装了一些初始化配置的信息 Servlet程序和ServletConfig对象都是由Tomcat负责创建，供我们使用。 每创建一次Servlet程序时，就创建一个ServletConfig对象。 每个ServletConfig对象都只能获取自己的Servlet的信息，不能跨域获取 重写init方法时要带上父类的init方法，如果不带上，则在使用ServletConfig相关方法时就会引发NullPointerException，这是因为父类GenericServlet的init方法中保存了ServletConfig对象，如果重写了init方法，该对象就会丢失，故而引发NullPointerException。 作用： 获取Servlet程序的别名，即servlet-name的值servletConfig.getServletName() 获取初始化参数init-paramservletConfig.getInitParameter() 获取ServletContext对象servletConfig.getServletContext() ServletContext类 ServletContext是接口，表示Servlet上下文对象 一个web工程只有一个ServletContext对象实例，在web工程启动时创建，停止时销毁 ServletContext对象是一个域对象 域对象是可以像map一样存取数据的对象，域指的是存取数据的操作范围 存数据 取数据 删除数据 Map put() get() remove() 域对象 serAttribute() getAttribute() removeAttribute() 作用： 获取web.xml中配置的上下文参数context-param: servletContext.getInitParameter() 获取当前的工程路径，格式：/工程路径: servletContext.getContextPath() 获取工程部署后在服务器硬盘上的绝对路径: servletContext.getRealPath("/")其中/在服务器解析时，表示地址为：http://ip:port/工程路径映射到IDEA为web目录 像map一样存储数据 HttpServletRequest类 作用：每次只要有请求进入Tomcat服务器，Tomcat服务器就会把请求过来的HTTP协议信息解析好封装到Request对象中，然后传递到service方法（doGet和DoPost中给我们使用，我们可以通过HttpServletRequest对象，获取到所有请求的信息。（每次请求创建一个，请求完成即销毁） 常见API： request.getRequestURI() ：获取请求的资源路径 request.getRequestURL() ：获取请求的url request.getRemoteHost() ：获取客户端ip地址 request.getHeader(String key) ：获取请求头中对应键的值 request.getMethod() ：获取请求方式 request.getParameter(String key) ：获取请求参数 request.getParameterValues(String key): 获取请求参数，用于参数值有多个时 通常在doPost方法的第一行写request.setCharacterEncoding("UTF-8");用来解决post请求的中文乱码问题 HttpServletRequest对象也是域对象。每个请求对应着唯一一个HttpServletRequest对象，而且在请求结束之前会一直存在，故在处理请求过程中可以使用request.setAttribute(String name, Object o)方法对该对象添加属性，用request.getAttribute(String name)获取该对象的属性，从而执行一些操作。 请求转发：服务器收到请求后，从一个资源转到另一个资源的操作 特点：1、浏览器地址栏没有改变。2、属于一次请求：由多个servlet资源共同完成的同一个请求，故HttpServletRequest对象的作用域涵盖请求转发过程，从而这些servlet资源可以共享该对象中的数据。3、能访问WEB-INF中的资源。4、不可以访问当前工程以外的资源。 RequestDispatcher requestDispatcher = request.getRequestDispatcher("/目的资源名称");请求转发必须以斜杠/开头，/表示http://ip:port/工程路径映射到IDEA为web目录 base标签的作用：所有的相对路径都是以base标签中的地址为参照。在没有base标签时，所有路径都以当前地址栏中的地址为参照，这在某些情况下会出错（如请求转发时，地址栏中的地址不变，但页面改变，若此页面中有相对路径，则参考基准不再是当前页面，而是地址栏的地址，从而出错）。若在页面中引入base标签，则相对路径参考基准成为base标签的路径。base标签在HTML文档的head标签内，如&lt;base herf="http://localhost:8080/project/a/b.html>。 HttpServletResponse类 作用：HttpServletResponse类和HttpServletRequest类一样，每次请求进来，Tomcat服务器都会创建一个Response对象传递给Servlet程序去使用。HttpServletRequest表示请求过来的信息，HttpServletResponse表示所有响应的信息，如果需要设置返回给客户端的信息，都可以通过HttpServletResponse对象进行设置。 输出流：HttpServletResponse类通过流将响应传递给客户端。 字节流 getOutputStream(); 常用于下载（传递）二进制数据 字符流 getWriter(); 常用于回传字符串（常用） 两个流只能互斥使用 中文乱码：HttpServletResponse响应的默认字符集为ISO-8859-1，所以会中文乱码，可以通过response.setContentType("text/html; charset=UTF-8");将服务器和浏览器的字符集以及响应头都设置为UTF-8，就能解决中文乱码问题。此方法必须在获取流对象之前调用才有效 请求重定向： 第一种方法：在下图的response1中写response.setStatus(302) 来设置响应状态码，response.setHeader("Location", "http://ip:port/工程路径/response2 来设置响应头，告知新地址。 第二种方法（推荐使用）：在下图的response1中写response.sendRedirect(http://ip:port/工程路径/response2即可。 请求重定向是两次独立的请求，只是第二次有浏览器代劳，不需要手动发起请求而已。 特点：1、浏览器地址栏发生变化。2、属于两次请求。3、前后两个servlet资源不共享request域中的数据。4、不能访问WEB-INF中的资源。5、可以访问当前工程以外的资源。
web中 / 的不同含义 在web中 / 斜杠是一种绝对路径 / 斜杠如果被浏览器解析，得到地址为：http://ip:port/，如html中的&lt;a href="/">斜杠&lt;/a> / 斜杠如果被服务器解析，得到地址为：http://ip:port/工程路径，如 &lt;url-pattern>/hello&lt;/url-pattern> 、 servletContext.getRealPath("/") 、 request.getRequestDispatcher("/") 特殊情况：response.sendRediect("/");重定向，会将 / 斜杠发送给浏览器解析，得到http://ip:port/ 基于xml的方式 Servlet中web.xml的配置 &lt;?xml version="1.0" encoding="UTF-8"?> &lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"> &lt;!--servlet标签给Tomcat配置Servlet程序--> &lt;servlet> &lt;!--servlet-name标签：给Servlet程序起一个别名（一般是类名）--> &lt;servlet-name>HiServlet&lt;/servlet-name> &lt;!--servlet-class是Servlet程序的全类名--> &lt;servlet-class>com.example.tomcat.HiServlet&lt;/servlet-class> &lt;/servlet> &lt;!--servlet-mapping标签给Servlet程序配置访问地址--> &lt;servlet-mapping> &lt;!--servlet-name标签告诉服务器，我当前配置的地址给哪个Servlet程序使用--> &lt;servlet-name>HiServlet&lt;/servlet-name> &lt;!--url-pattern标签配置访问地址 / 斜杠在服务器解析时，表示地址为：http://ip:port/工程路径 本工程即为http://localhost:8080/tomcat_war_exploded/ /hello 表示：http://ip:port/工程路径/hello 即http://localhost:8080/tomcat_war_exploded/hello --> &lt;url-pattern>/hello&lt;/url-pattern> &lt;/servlet-mapping> &lt;/web-app> 从url定位到Servlet程序过程 对照上方的xml配置文件：当在地址栏输入http://localhost:8080/tomcat_war_exploded/hello时，由8080定位到Tomcat服务器，再由/tomcat_war_exploded定位到该工程，然后根据/hello定位到xml配置文件中&lt;servlet-mapping>标签下的&lt;url-pattern>标签，其对应的&lt;servlet-name>标签值为HiServlet，再根据这个标识符找到相同名的&lt;servlet>标签，根据其标签下&lt;servlet-class>的值定位到类的位置，然后执行类中的service方法。
...</p></div><footer class=entry-footer><span title='2021-04-21 18:48:13 +0000 UTC'>2021-04-21</span>&nbsp;·&nbsp;243 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Servlet学习笔记" href=https://ethereal-lu.github.io/posts/java/servlet%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>tomcat笔记</h2></header><div class=entry-content><p>将工程部署到tomcat中 直接将工程拖拽到tomcat的webapps目录下即可访问 在tomcat中的conf\Catalina\localhost下添加配置文件来配置工程，此时工程可以存放于机器的任何位置 配置文件的示例如下 &lt;Context path="/github_blog" docBase=“E:\programme_work\vscode_work\GitHubSite\public”/> 其中，Context表示一个工程上下文
path表示工程的访问路径。是该文件的映射，即在url中输入 http://localhost:8080/github_blog/，就会进入这个工程。
docBase表示工程目录的实际位置 一个配置文件对应于一个工程</p></div><footer class=entry-footer><span title='2021-04-20 20:39:32 +0000 UTC'>2021-04-20</span>&nbsp;·&nbsp;12 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to tomcat笔记" href=https://ethereal-lu.github.io/posts/java/tomcat%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>hexo的常见问题</h2></header><div class=entry-content><p>hexo的分类问题 在每个markdown文件的头部，date的下一行添加一行
categories: 类别1 即可将该文件归类为 “类别1” 这一类中
hexo无法显示图片问题 确认根目录_config.yml中有: post_asset_folder: true 确保在md文件所在目录下创建和md文件同名的目录，在里面放该md需要的图片，然后在md中插入![](文件名.jpg) 只需写图片文件名，不用写目录名 如果还不行，在站点根目录下先执行npm uninstall hexo-asset-image --save（如果之前下载过）。再执行npm install hexo-asset-image --save Chrome浏览器图片显示正常，而Edge浏览器无法显示，有可能是Egde不支持，故使用Chrome就可以了</p></div><footer class=entry-footer><span title='2021-04-20 20:07:32 +0000 UTC'>2021-04-20</span>&nbsp;·&nbsp;21 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to hexo的常见问题" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/hexo/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Tomcat启动一闪而过以及报java.lang.IllegalStateException: 无输出目录以及乱码</h2></header><div class=entry-content><p>黑屏一闪而过 问题：环境变量中没有JAVA_HOME变量。
解决：添加该变量，值为jdk的根目录，例如 D:\java\jdk
报java.lang.IllegalStateException: 无输出目录 问题：Tomcat文件的权限不够，导致不能正常编译。
解决：将Tomcat文件的权限提升为完全控制
乱码 问题：编码格式的问题 解决：将tomcat下的conf\logging.properties中的java.util.logging.ConsoleHandler.encoding的值从UTF-8修改为GBK</p></div><footer class=entry-footer><span title='2021-04-20 17:20:53 +0000 UTC'>2021-04-20</span>&nbsp;·&nbsp;11 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Tomcat启动一闪而过以及报java.lang.IllegalStateException: 无输出目录以及乱码" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/tomcat/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Spring5学习笔记</h2></header><div class=entry-content><p>IOC： 控制反转，把创建对象的过程交给Spring进行管理 Aop： 面向切片，不修改源代码进行功能增强
Spring5入门案例基本步骤： 1、创建项目 2、在项目中创建一个lib文件夹，把需要的jar包复制进来 3、点击 file -> project structure -> modules -> dependencies -> 左下角的 + 号 -> jars or directories -> 选中刚复制过来的jar包，将导入的jar包全选，点击ok 4、创建普通类User 5、创建Spring配置文件，在配置文件配置创建的对象在src中创建xml格式的Spring配置文件， 在&lt;beans>的内部末尾添加 &lt;!–配置User对象创建–> &lt;bean id=“user” class=“com.ethereal.spring5.User”>&lt;/bean> 两行
6、进行测试代码编写
public class TestSpring5 { @Test public void testAdd() { // 加载spring配置文件 ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml"); // 获取配置创建的对象 User user = context.getBean("user", User.class); System.out.println(user); user.add(); } } IOC容器： (Inversion of Control) 控制反转，把创建对象和对象之间调用的过程交给Spring进行管理 1、IOC底层原理 xml解析 + 反射 + 工厂模式 （降低耦合度）
...</p></div><footer class=entry-footer><span title='2021-04-20 15:39:41 +0000 UTC'>2021-04-20</span>&nbsp;·&nbsp;578 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Spring5学习笔记" href=https://ethereal-lu.github.io/posts/java/spring5%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go 基础</h2></header><div class=entry-content><p>1、基础 包含有 main 函数的包，其包名必须是 main。包名与文件名没有任何关系。但在只包含一个main函数的项目中，一般文件名与包名一致
go 语句的末尾加不加分号都可以，建议不加
导包时推荐使用第二种
// 1 import "fmt" import "time" // 2 import ( "fmt" "time" ) 函数体前的大括号必须与函数名在同一行，否则报错 func main() { fmt.Println("hello go") } 同样 if else 中的 else 必须与 if 的末尾大括号在同一行，否则报错 if arr == nil { fmt.Println("空切片") } else { fmt.Println("非空") } 2、变量 2.1、变量声明 方法一二三既可以用于局部变量也可以用于全局变量，而方法四只能在函数体内用于局部变量
// 方法一：只声明，不显式赋值，默认值为0 var a int fmt.Println(a) // 0 // 方法二：声明并显式初始化 var b int = 100 fmt.Println(b) // 100 // 方法三：初始化时省去数据类型，自动推导 var c = "abc" fmt.Println(c) // "abc" // 方法四：省去 var 关键字，直接使用海象运算符类型推导（常用这种），表示声明并初始化 d := 4.5 fmt.Println(d) // 4.5 fmt.Printf("type of d is %T\n", d) // 格式化打印，%T 表示打印变量类型；此处输出为 float64 2.2、多个变量的声明 var aa, bb = 100, 200 var cc, dd = 4.5, "abc" // 或者下面这种写法 var ( ee = 300 ff = true ) // 也可以这样 gg, hh := 3, true 3、常量与枚举 func main() { // 常量（只读） const length = 10 fmt.Println(length) } // const 定义枚举类型 const ( // 在第一个枚举成员后赋值关键字 iota，之后的每行的成员的值自动加 1 SPRING = iota // iota 为常量 0 SUMMER // 1 AUTUMN // 2 WINTER // 3 ) const ( // 也可以赋值 iota 的表达式，此时之后的成员都会在 iota 加一的基础上赋值表达式 SPRING = iota * 10 // 0 SUMMER // 10 AUTUMN // 20 WINTER // 30 ) // iota 逐行累加；iota 只能出现在 const 的括号中 const ( a, b = iota + 1, iota + 2 // iota = 0; a = 1; b = 2 c, d // iota = 1; c = 2; d = 3 e, f // iota = 2; e = 3; f = 4 g, h = iota * 2, iota * 3 // iota = 3; g = 6; h = 9 i, k // iota = 4; i = 8; k = 12 ) 4、函数 若函数名首字母大写，表示 public；小写，表示 private
...</p></div><footer class=entry-footer><span title='2021-01-02 17:39:41 +0000 UTC'>2021-01-02</span>&nbsp;·&nbsp;2306 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Go 基础" href=https://ethereal-lu.github.io/posts/go/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://ethereal-lu.github.io/posts/page/8/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://ethereal-lu.github.io/posts/page/10/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>