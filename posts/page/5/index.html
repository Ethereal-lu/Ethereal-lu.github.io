<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | lu</title>
<meta name=keywords content><meta name=description content="Posts - lu"><meta name=author content="lu"><link rel=canonical href=http://localhost:1313/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity="sha256-1yREUm1+y9sAFUOKf6iQVKZYv3WdBULi5d+BzpS0k+4=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=http://localhost:1313/posts/index.xml><link rel=alternate hreflang=en href=http://localhost:1313/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/"><meta property="og:site_name" content="lu"><meta property="og:title" content="Posts"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/categories/ title=categories><span>categories</span></a></li><li><a href=http://localhost:1313/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>RabbitMQ基础</h2></header><div class=entry-content><p>一、概述 1.1、什么是消息队列 消息：指的是两个应用间传递的数据。数据的类型有很多种形式，可能只包含文本字符串，也可能包含嵌入对象。
消息协议：为了让消息发送者和消息接收者都能够明白消息所承载的信息，它们就需要按照一种统一的格式描述消息。
消息队列：（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message。
消息从发送者到接收者的方式也有两种。 一种为即时消息通讯，也就是说消息从一端发出后（消息发送者）立即就可以达到另一端（消息接收者），这种方式的具体实现就是RPC（当然单纯的http通讯也满足这个定义）； 另一种为延迟消息通讯，即消息从某一端发出后，首先进入一个容器进行临时存储，当达到某种条件后，再由这个容器发送给另一端。 这个容器的一种具体实现就是消息队列，如RabbitMQ。
1.2、为什么使用消息队列 应用解耦：不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个； 流量削峰：如数据库只能同时处理一万条请求，如果来了两万条请求就执行一万条，将剩余一万条放在消息队列顺序执行。 异步处理：A 调用 B 处理数据，但 B 处理时间很长；A可以不用等，当B执行完将结果放在消息队列，再由消息队列将结果给A，这样就不用轮询或提供回调函数了。 广播 最终一致性 1.3、mqtt 与 MQ 的区别 mqtt：一种通信协议，类似人类交谈中的汉语、英语、俄语中的一种语言规范 MQ：一种通信通道，也叫消息队列，类似人类交谈中的用电话、email、微信的一种通信方式 json：一种内容格式，类似人类交谈中的排比句等方式
1.4、RPC 执行流程 RPC（Remote Procedure Call）远程过程调用协议，一种通过网络从远程计算机上请求服务，而不需要了解底层网络技术的协议。其主要目的是做到不同服务间调用方法像同一服务间调用本地方法一样。
当业务需要强一致性，关注业务逻辑的处理结果，则 RPC 比消息队列更合适。
强一致性指不论在任何时候读取的都是最新的数据，最终一致性是允许可以在一段时间内每个结点的数据不一致，但是经过一段时间每个结点的数据必须一致，它强调的是最终数据的一致性。
客户端处理过程中调用client sub，就像调用本地方法一样，传入参数 client sub将参数编组为消息，然后通过系统调用向服务端发送消息 服务端将接收到的数据包传递给server sub server sub将接收到的数据解组为参数 server sub再调用服务端的过程，过程执行的结果以反方向的相同步骤响应给客户端 以 Google 的 grpc 为例：先在 proto 文件中声明接口，包括方法名、参数和返回值，然后使用工具生成 go 可以用的库；服务端创建 grpc 服务实例并将本地实现的服务注册进该实例中，然后监听本地端口，收到请求后就执行本地方法并将结果返回；客户端创建 grpc 客户端实例，然后调用 proto 中声明的方法即可获得结果。
1.5、MQ 分类 ActiveMQ：老、较少使用 Kafka：大数据实时计算和日志采集方面卓越 RocketMQ：阿里开源产品 RabbitMQ：主流 二、RabbitMQ介绍 2.1、RabbitMQ 简介 RabbitMQ是一个在AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。
...</p></div><footer class=entry-footer><span title='2022-04-07 14:42:15 +0000 UTC'>2022-04-07</span>&nbsp;·&nbsp;2148 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to RabbitMQ基础" href=http://localhost:1313/posts/%E5%88%86%E5%B8%83%E5%BC%8F/rabbitmq/rabbitmq/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ubuntu的ufw与iptables</h2></header><div class=entry-content><p>1、概述 进出计算机的流量通过“端口”进行过滤，“端口”是附加到特定应用程序使用的流量数据包的相对任意名称。
按照惯例，某些端口通常用于特定类型的应用程序。例如，端口 80 通常用于不安全的 Web 浏览，端口 443 用于安全的 Web 浏览。
可以通过“打开”或“关闭”（即过滤）为特定类型的流量指定的端口来允许或阻止到特定应用程序的流量。例如，如果端口 80 “关闭”，则无法进行（不安全的）网页浏览。
Linux 内核包括 netfilter 子系统，用于操纵或决定进入或通过计算机的网络流量的命运。所有现代 Linux 防火墙解决方案都使用该系统进行数据包过滤。
如果没有用户界面来管理内核的数据包过滤系统，那么用户或管理员几乎没有什么用处。这就是 iptables 的目的。当一个数据包到达您的计算机时，它会根据通过 iptables 提供给它的规则传递给 netfilter 子系统接受、处理或拒绝。因此，iptables 是您管理防火墙所需的一切（如果您熟悉它）。然而，许多前端可用于简化任务。
因此，用户可以配置防火墙以允许某些类型的网络流量进出系统（例如 SSH 或 Web 服务器流量）。这是通过在防火墙中打开和关闭 TCP 和 UDP“端口”来完成的。此外，防火墙可以配置为允许或限制对特定 IP 地址（或 IP 地址范围）的访问。
2、端口映射与端口转发 端口映射：端口映射就是将内网中的主机的一个端口映射到外网主机的一个端口，提供相应的服务。当用户访问外网IP的这个端口时，服务器自动将请求映射到对应局域网内部的机器上。
我们在内网中有一台Web服务器，但是外网中的用户是没有办法直接访问该服务器的。于是我们可以在路由器上设置一个端口映射，只要外网用户访问路由器ip的80端口，那么路由器会把自动把流量转到内网Web服务器的80端口上。并且，在路由器上还存在一个Session，当内网服务器返回数据给路由器时，路由器能准确的将消息发送给外网请求用户的主机。在这过程中，路由器充当了一个反向代理的作用，他保护了内网中主机的安全。
端口转发：端口转发（Port forwarding），有时被叫做隧道，是安全壳（SSH） 为网络安全通信使用的一种方法。
比如，我们现在在内网中，是没有办法直接访问外网的。但是我们可以通过路由器的NAT方式访问外网。假如我们内网现在有100台主机，那么我们现在都是通过路由器的这一个公网IP和外网通信的。那么，当互联网上的消息发送回来时，路由器是怎么知道这个消息是给他的，而另外消息是给你的呢？这就要我们的ip地址和路由器的端口进行绑定了，这时，在路由器中就会有一个内网ip和路由器端口对应的一张表。当路由器的10000端口收到消息时，就知道把消息发送给他，而当20000端口收到消息时，就知道把消息发送给你。这就是端口转发，其转发一个端口收到的流量，给另一个主机。
端口转发：转发的重点在“转”上面。送快递的过来，把所有快递都交给门口保安，保安再根据每件快递上的收件人来分发。
端口映射：就是在大门口给每个人装个柜子，送快递的直接按收件人名字，把快递放到对应的柜子里面。
3、ufw与iptables iptables 是防火墙规则的数据库，是 Linux 系统中实际使用的防火墙。 Linux系统中配置iptables的传统界面是命令行界面终端。
UFW（简单防火墙）是 iptables 的前端，是Ubuntu系统上配置iptables防火墙的工具，特别适合基于主机的防火墙。 UFW 是专门为 Ubuntu 开发的（但在其他发行版中可用），也可以从终端进行配置。</p></div><footer class=entry-footer><span title='2022-04-07 14:42:15 +0000 UTC'>2022-04-07</span>&nbsp;·&nbsp;62 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to ubuntu的ufw与iptables" href=http://localhost:1313/posts/linux/ubuntu%E7%9A%84ufw%E4%B8%8Eiptables/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>AQS</h2></header><div class=entry-content><p>AQS的核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就通过cas 的方式将当前线程添加到等待队列的尾部，直到它的前继节点释放锁并唤醒它。
在 AQS 中用变量 state 代表共享资源，通过 cas 改变 state 的值来竞争锁。
ReentrantLock 实现了公平锁和非公平锁，他们都继承了 AQS，公平锁和非公平锁的最大区别就是在获取锁的时候，非公平锁直接和等待队列的头节点竞争锁，而非公平锁只有在自己是队列头结点时才去获取锁。
ReentrantLock 中，若 state 的值为0，说明当前共享资源是空闲的，可以获取。若获取到锁的线程再次获取锁时，state 的值加 1，这就是可重入锁。同时这样会避免多余的 cas 开销。</p></div><footer class=entry-footer><span title='2022-04-06 21:12:41 +0000 UTC'>2022-04-06</span>&nbsp;·&nbsp;22 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to AQS" href=http://localhost:1313/posts/java/java-%E8%BF%9B%E9%98%B6/aqs/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>BIO,NIO,AIO</h2></header><div class=entry-content><p>本文摘自(31条消息) Java面试常考的 BIO，NIO，AIO 总结_有梦想的小树的博客-CSDN博客_bio nio
Java 中的 BIO、NIO和 AIO 理解为是 Java 语言对操作系统的各种 IO 模型的封装。程序员在使用这些 API 的时候，不需要关心操作系统层面的知识，也不需要根据不同操作系统编写不同的代码。只需要使用Java的API就可以了。
同步与异步
同步： 同步就是发起一个调用后，需要等待被调用者返回结果。 异步： 异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。 同步和异步的区别最大在于异步的话调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。
阻塞和非阻塞
阻塞： 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。 非阻塞： 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。 同步和阻塞最大的区别就是线程是否会被挂起。
那么同步阻塞、同步非阻塞和异步非阻塞又代表什么意思呢？
在等待返回结果前如果什么也不干就是同步阻塞；如果可以做一些其他的事只需要以轮询的方式查看结果是否返回就是同步非阻塞；如果不需要等待返回结果就是异步非阻塞。
举个生活中简单的例子，你妈妈让你烧水，小时候你比较笨啊，在哪里傻等着水开（同步阻塞）。等你稍微再长大一点，你知道每次烧水的空隙可以去干点其他事，然后只需要时不时来看看水开了没有（同步非阻塞）。后来，你们家用上了水开了会发出声音的壶，这样你就只需要听到响声后就知道水开了，在这期间你可以随便干自己的事情，你需要去倒水了（异步非阻塞）。
1. BIO (Blocking I/O) 最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。 当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。 典型的阻塞IO模型的例子为 data = socket.read(); 如果数据没有就绪，就会一直阻塞在read方法。
1.1 传统 BIO BIO通信（一请求一应答）模型图如下(图源网络，原出处不明)：
采用 BIO 通信模型 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。我们一般通过在 while(true) 循环中服务端会调用 accept() 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接，如上图所示。
如果要让 BIO 通信模型 能够同时处理多个客户端请求，就必须使用多线程（主要原因是 socket.accept()、 socket.read()、 socket.write() 涉及的三个主要函数都是同步阻塞的），也就是说它在接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的 一请求一应答通信模型 。我们可以设想一下如果这个连接不做任何事情的话就会造成不必要的线程开销，不过可以通过 线程池机制 改善，线程池还可以让线程的创建和回收成本相对较低。使用FixedThreadPool 可以有效的控制了线程的最大数量，保证了系统有限的资源的控制，实现了N(客户端请求数量):M(处理客户端请求的线程数量)的伪异步I/O模型（N 可以远远大于 M），下面一节"伪异步 BIO"中会详细介绍到。
...</p></div><footer class=entry-footer><span title='2022-04-06 21:12:41 +0000 UTC'>2022-04-06</span>&nbsp;·&nbsp;200 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to BIO,NIO,AIO" href=http://localhost:1313/posts/java/java-%E8%BF%9B%E9%98%B6/bionioaio/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>面经碎知识汇总</h2></header><div class=entry-content><p>1、大文件上传 每个分块的文件内容都是通过 MultipartFile 来接收的，改接口的所有实现类都是通过包装 HttpServletRequest 来实现的，故该文件传输是通过 HTTP 协议实现的。
1.1、分片上传 先获取完整文件的 MD5 值，之后将文件分割成相同大小的数据块； 每次上传文件时都携带上 MD5 值、分块序号、文件内容等。 每收到一个分块，便将其存储到文件中，并将分块序号添加到 redis 中。 分块全部上传完成后，将所有分块合成一个完整文件，并将各分块删除。 1.2、断点续传 上传之前先访问一个用于检查的接口来检查已经上传了哪些分块，该接口会将 redis 中的已经上传的分块的序号返回给前端，前端只需根据该结果从未上传的分块开始上传即可实现断点续传。
2、线程抛异常 2.1、普通线程 一个普通线程在运行过程中出现了异常有以下两种场景：
如果该异常被捕获或抛出，则程序继续运行。 如果异常没有被捕获该线程将会停止执行。 Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler，并将线程和异常作为参数传递给该handler的uncaughtException()方法进行处理。因此，可以继承ThreadGroup类并重写其uncaughtException方法来处理异常。
2.2、线程池中的线程 线程池中的某个线程在运行过程中出现了异常有以下场景：
若线程被execute方法执行，则在线程出现异常时会将异常输出在控制台，若线程被submit方法执行，则线程出现异常时不会在控制台输出，必须调用Future.get()方法时，才会输出异常。 一个线程出现异常不会影响线程池里面其他线程的正常执行。 线程出现异常不是被回收而是线程池把这个线程移除掉，同时创建一个新的线程放到线程池中。 submit 内部调用了 execute，为何还有这种区别
因为 submit 方法会将任务封装为 FutureTask （FutureTask 会将 Runnable 通过适配器转为 Callable），而 FutureTask 会捕获线程运行中的异常，将其存储在线程结果信息中，当调用 get 方法时判断线程运行结果状态，有异常就抛出存储的异常信息，因此submit运行异常我们只能用get方法来拿到。
3、TCP 有什么值得改进的地方 TCP是基于四元组的（源IP，目的IP，源端口，目的端口），如果使用中途网络切换了或者连接超时重连后IP换了，那么四元组就改变了，就需要重新发起三次握手连接，所以此处值得改进 TCP保证有序性，如果响应队列中队头的报文没有返回，那么后续报文就会被阻塞。尽管HTTP1.1可以通过Pipelining在一条TCP连接中发送多次HTTP请求，以及HTTP2.0采用多路复用将请求拆分为多个帧传输，但是由于底层使用的还是TCP，因此还存在队头的帧没有传输后续帧被阻塞的情况。因此此处值得改进 TCP 的拥塞控制算法是在丢包之后才开始降低传输速度，而Google 的 BBR 拥塞控制算法是通过主动探测网络带宽和RTT来避免丢包 拥塞控制通过BBR改善，前两点可以通过QUIC协议改善。
QUIC（Quick UDP Internet Connection）是谷歌制定的一种基于UDP的低时延的传输层协议。
QUIC 在 UDP 的基础上融合了 TCP、TSL、HTTP2.0的协议的特性，使其既有低的连接时延，又有高的安全性。
客户端第一次连接服务器时，QUIC只需要1RTT（Round-Trip Time）的延迟就可以建立可靠安全的连接，之后客户端可以在本地缓存加密的认证信息，再次与服务器建立连接时可以实现0-RTT的连接建立延迟。QUIC同时复用了HTTP/2协议的多路复用功能，而且由于QUIC基于UDP所以避免了HTTP/2的队头阻塞。
...</p></div><footer class=entry-footer><span title='2022-04-05 21:12:41 +0000 UTC'>2022-04-05</span>&nbsp;·&nbsp;447 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 面经碎知识汇总" href=http://localhost:1313/posts/%E9%9D%A2%E7%BB%8F/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Redis基础</h2></header><div class=entry-content><p>概述 Redis是什么？
Redis（Remote Dictionary Server )，即远程字典服务！
Redis能干吗？ —》 数据库、缓存、中间件
内存存储、持久化（rdb、aof） 效率高，可用于缓存 发布订阅系统 地图信息分析 计时器、计数器 。。。 Redis 通过“Redis序列化协议”（简称“RESP”），实现客户端与服务端之间的连接通信，其底层是通过TCP来完成的。
Linux安装配置redis 下载并解压redis后，将解压好的包移动到/usr/local/redis中，然后cd /usr/local/redis，依次在该目录下执行make，make test（也可以不执行）和make install。之后将该目录下的redis.conf备份，再vim redis.conf，将daemonize的值从no改为yes。cd /usr/local/bin，执行redis-server ../redis/redis.conf。配置完成。
redis 是单线程 对Redis来说，执行get、set以及eval等API，都是一个一个的任务，这些任务都会由Redis的线程（单线程）去负责执行，任务要么执行成功，要么执行失败，这就是Redis的命令是原子性的原因。
redis 6 引入了多线程 redis 5 及之前的版本一直使用的是单线程，多线程是 Redis6.0 推出的一个新特性。 Redis 的核心线程负责网络 IO ，命令处理以及写数据到缓冲，而随着网络硬件的性能提升，单个主线程处理⽹络请求的速度跟不上底层⽹络硬件的速度，导致网络 IO 的处理成为了 Redis 的性能瓶颈。
而 Redis6.0 就是从单线程处理网络请求到多线程处理，通过多个 IO 线程并⾏处理网络操作提升实例的整体处理性能。需要注意的是对于读写命令，Redis 仍然使⽤单线程来处理，这是因为继续使⽤单线程执行命令操作，就不⽤为了保证 Lua 脚本、事务的原⼦性，额外开发多线程互斥机制了。
redis 将所有的数据都放在内存中。单线程避免切换上下文，所以快。
多线程开发中并发访问控制是⼀个难点，需要精细的设计才能处理。如果只是简单地处理，比如简单地采⽤⼀个粗粒度互斥锁，只会出现不理想的结果。即便增加了线程，系统吞吐率也不会随着线程的增加而增加，因为大部分线程还在等待获取访问共享资源的互斥锁。而且，大部分采用多线程开发引入的同步原语保护共享资源的并发访问，也会降低系统代码的易调试性和可维护性。而正是以上这些问题，才让 Redis 采⽤了单线程模式。
官方解释：因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦)。
基础知识 redis所有命令不区分大小写
数据库基本命令 redis默认有16个数据库（0~15），默认使用第0个数据库。数据库之间数据相互隔离
127.0.0.1:6379> SELECT 3 # 切换数据库 OK 127.0.0.1:6379[3]> DBSIZE # 查看当前数据库大小 (integer) 0 127.0.0.1:6379> FLUSHDB # 清空当前数据库 OK 127.0.0.1:6379> FLUSHALL # 清空所有数据库 OK 127.0.0.1:6379> SHUTDOWN # 关闭redis服务 Redis-key基本命令 127.0.0.1:6379> set age 18 # 添加键值对 OK 127.0.0.1:6379> get name # 通过key获取value "xunlu" 127.0.0.1:6379> KEYS * # KEYS + 正则表达式。返回所有符合正则表达式的键 1) "age" 2) "name" 127.0.0.1:6379> EXISTS name # 判断是否存在指定的key (integer) 1 # 返回1则存在，0则不存在 127.0.0.1:6379> EXPIRE name 10 # 设置键name的有效期为10秒 (integer) 1 127.0.0.1:6379> ttl name # 查看键name的有效时间还剩下多少 (integer) 4 127.0.0.1:6379> MOVE name 1 # 将键值对移动到指定的数据库中 (integer) 1 127.0.0.1:6379> DEL name # 删除键值对 (integer) 1 127.0.0.1:6379> TYPE age # 获取当前键对应值的类型 string 数据类型 五种基本数据类型 String —> 应用：计数器（如访问量，点赞数等） 127.0.0.1:6379> set name xunlu OK 127.0.0.1:6379> APPEND name feilu # 追加字符串，类似StringBuilder的append (integer) 10 # 若追加的键不存在，则新建键值对 127.0.0.1:6379> get name "xunlufeilu" ----------------------------------------------- 127.0.0.1:6379> STRLEN name # 返回值的长度 (integer) 10 ----------------------------------------------- 127.0.0.1:6379> set views 0 OK 127.0.0.1:6379> INCR views # 每执行一次，值就会加1.（只能作用于integer类型） (integer) 1 127.0.0.1:6379> INCR views (integer) 2 127.0.0.1:6379> DECR views # 每执行一次，值就会减1.（只能作用于integer类型） (integer) 1 127.0.0.1:6379> INCRBY views 10 # 指定增加的步长 (integer) 11 127.0.0.1:6379> DECRBY views 10 # 指定减少的步长 (integer) 1 ----------------------------------------------- 127.0.0.1:6379> set name xunlu OK 127.0.0.1:6379> GETRANGE name 0 2 # 截取部分值（start和end都包括在内） "xun" 127.0.0.1:6379> GETRANGE name 0 -1 # == get name "xunlu" 127.0.0.1:6379> SETRANGE name 0 gao # 替换部分字符，起始替换位置 + 替换的值 (integer) 5 127.0.0.1:6379> get name "gaolu" ----------------------------------------------- # setex(set with expire) 【原子性操作】 # setnx(set if not exist) 【原子性操作】 127.0.0.1:6379> setex name 30 xunlu # 新建键值对，并设置有效期为30秒 OK # 等同于 set name xunlu ex 30 127.0.0.1:6379> setnx gender male # nx表示键不存在时才能正确执行，即只能新建 OK # 等同于 set gender male nx # 常用于分布式锁 127.0.0.1:6379> get gender "male" 127.0.0.1:6379> set gender female nx # 此时键gender已经存在，执行失败 (nil) ----------------------------------------------- 127.0.0.1:6379> MSET k1 v1 k2 v1 k3 v1 # 批量创建键值对 OK 127.0.0.1:6379> KEYS * 1) "k1" # msetnx 【原子性操作】 2) "k3" 3) "k2" 127.0.0.1:6379> MGET k1 k2 k3 # 批量获取 1) "v1" 2) "v1" 3) "v1" ------------------------------------------------ 127.0.0.1:6379> set user {id:1,name:xunlu,age:3} # 可以将值设为json字符串，然后通过json解析 OK 127.0.0.1:6379> mset user:name xunlu user:age 18 # redis支持键中存在`:`冒号，亦可用于解析 OK ------------------------------------------------ 127.0.0.1:6379> getset db redis # 先get再set。没有返回nil，再设新值 (nil) 127.0.0.1:6379> getset db redis # 有则返回旧值，再设新值 "redis" List（双向链表） 绝大部分的list命令都以l开头，list的名字也可作为key，故有些redis-key的命令也可用 应用：消息队列、栈 # 添加、范围读取 LPUSH key element [element ...] # key为列表的名字，添加到列表的头部 RPUSH key element [element ...] # 添加到列表的尾部 127.0.0.1:6379> LPUSH list mid # 列表名为list，head、mid、tail为元素 (integer) 1 127.0.0.1:6379> LPUSH list head (integer) 2 127.0.0.1:6379> RPUSH list tail (integer) 3 127.0.0.1:6379> LRANGE list 0 -1 1) "head" 2) "mid" 3) "tail" 127.0.0.1:6379> LRANGE list 0 1 # 从头向尾读，没有RRANGE这个命令 1) "head" 2) "mid" -------------------------------------------------- # 删除、改变list LPOP key [count] # 从头部弹出元素 RPOP key [count] # 从尾部弹出元素 LREM key count element # 根据值移除元素，count表示从多个相同的值中移除的个数 LTRIM key start stop # 将列表截断，只保留[start ~ stop]的值 -------------------------------------------------- # 按下标索引 127.0.0.1:6379> LINDEX list 0 # 获取list的第i个值 "head" 127.0.0.1:6379> LINDEX list 1 "mid" -------------------------------------------------- # 长度 127.0.0.1:6379> LLEN list # 获取list的长度 (integer) 3 -------------------------------------------------- # 组合命令 RPOPLPUSH source destination # 从容器source的尾部弹出并添加到容器destination的头部 "tail" # source和destination自然可以是同一个列表 ------------------------------------------------- # 修改列表中的值 LSET key index element # 修改列表指定下标处的值 127.0.0.1:6379> LSET list 0 prehead OK ------------------------------------------------- # 插值 LINSERT key BEFORE|AFTER pivot element # pivot为列表中已有的元素，往列表中元素的前或后插入元素 Set（无序不重复）（命令都以s打头） # 添加、查看 SADD key member [member ...] # 添加元素（可以批量） 127.0.0.1:6379> SADD set first second third (integer) 3 127.0.0.1:6379> SMEMBERS set # 查看所有元素 1) "second" 2) "third" 3) "first" 127.0.0.1:6379> SISMEMBER set first # 判断是否包含指定元素 (integer) 1 127.0.0.1:6379> SISMEMBER set fifth (integer) 0 127.0.0.1:6379> SCARD set # 集合的长度 (integer) 3 ------------------------------------------------- # 移除 SREM key member [member ...] # 删除指定元素（可以批量） SPOP key [count] # 随机删除元素（可以指定个数） SMOVE source destination member # 将指定元素从集合source移动到集合destination ------------------------------------------------- SRANDMEMBER key [count] # 随机返回元素（可以指定个数） ------------------------------------------------- # 集合计算 # 差集 SDIFF set1 set2 # 集合set1中有但set2中没有的元素 # 交集 SINTER set1 set2 # 交 # 并集 SUNION set1 set2 # 并 Hash（命令都以h打头） 相当于map，则变为key-(key-value)，故（更适合对象的存储） # 添加 HSET key field value [field value ...] # 存值，key为hash容器的名字 HMSET key field value [field value ...] # 批量存值 127.0.0.1:6379> HSET hash name xunlu (integer) 1 127.0.0.1:6379> HSET hash age 18 (integer) 1 ------------------------------------------------- # 查看 HGET key field # 指定字段的取值 HMGET key field [field ...] # 批量取值 127.0.0.1:6379> HGET hash name "xunlu" 127.0.0.1:6379> HGETALL hash # 查看全部内容 1) "name" 2) "xunlu" 3) "age" 4) "18" ------------------------------------------------- # 删除 HDEL key field [field ...] # 删除指定元素（可批量） ------------------------------------------------- # 长度 127.0.0.1:6379> HLEN hash (integer) 2 ------------------------------------------------- # 是否存在 HEXISTS key field # 判断指定字段是否存在 ------------------------------------------------- 127.0.0.1:6379> HKEYS hash # 取全部字段名 1) "name" 2) "age" 127.0.0.1:6379> HVALS hash # 取全部字段的值 1) "xunlu" 2) "18" ------------------------------------------------- # 自增、自减 HINCRBY key field increment # field = field + increment （increment为负数即为减） ------------------------------------------------- HSETNX key field value # 和setnx作用类似 Zset（有序集合）【底层为跳表】 # 添加、查看 ZADD key score member [score member ...] # score用于排序 127.0.0.1:6379> ZADD salary 2500 mary 3000 alice 1000 lisa (integer) 3 ZRANGE salary 0 -1 # 返回所有数据 -------------------------------------------------- # 排序 ZRANGE salary 100 0 byscore rev withscores # ZRANGE 后可跟上多个参数来约束比较，如通过score、降序、带上score ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] # 小到大 ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count] # 大到小 127.0.0.1:6379> ZRANGEBYSCORE salary -inf +inf # 返回score在-inf +inf之间元素的排序，小到大 1) "lisa" 2) "mary" 3) "alice" -------------------------------------------------- # 移除 ZREM key member [member ...] -------------------------------------------------- # 长度 127.0.0.1:6379> ZCARD salary # 总个数 (integer) 3 127.0.0.1:6379> zcount salary 2000 3000 # 指定区间个数（score的区间） (integer) 2 三种特殊数据类型 Geospatial 地理位置 【底层由Zset实现、因此可以使用zset的命令，如ZREM等】 # 添加城市及经纬度信息 GEOADD key [NX|XX] [CH] longitude latitude member [longitude latitude member ...] 127.0.0.1:6379> GEOADD china:city 116.40 39.90 beijing # 经度、纬度 (integer) 1 127.0.0.1:6379> GEOADD china:city 121.47 31.23 shanghai (integer) 1 127.0.0.1:6379> type china:city # 底层由Zset实现 zset ------------------------------------------------------------ # 获取指定城市的经纬度信息 GEOPOS key member [member ...] 127.0.0.1:6379> GEOPOS china:city beijing 1) 1) "116.39999896287918091" 2) "39.90000009167092543" ------------------------------------------------------------- # 获取两地的距离（直线距离） GEODIST key member1 member2 [m|km|ft|mi] # 可指定单位，默认为米 127.0.0.1:6379> GEODIST china:city beijing shanghai km "1067.3788" ------------------------------------------------------------- # 获取范围内的元素 GEORADIUS key longitude latitude radius m|km|ft|mi # 根据指定经纬度和半径获取范围内的元素 127.0.0.1:6379> GEORADIUS china:city 120 30 500 km # 经度、维度、半径 1) "hangzhou" 2) "shanghai" GEORADIUSBYMEMBER key member radius m|km|ft|mi # 根据元素名和半径获取范围内的元素 Hypeloglog（基数统计、即去重后计数）【占用内存很小，最大只需要12KB】（有0.81%错误率）— 使用伯努利概率分布，根据第一个 1 出现的位置推测有多少基数。 PFADD key element [element ...] # 添加 PFCOUNT key [key ...] # 基数统计 127.0.0.1:6379> pfadd key a a a a l k j h j k l d (integer) 1 127.0.0.1:6379> PFCOUNT key (integer) 6 PFMERGE destkey sourcekey [sourcekey ...] # 合并 Bitmaps（位图） 位存储、只有两种状态的都可以用它存储 SETBIT key offset value # 添加，其中value的值只能是 0 或 1 GETBIT key offset # 查看 BITCOUNT key [start end] # 统计value为 1 的个数 发布订阅 基于频道 基于频道(Channel)的发布/订阅有两个命令分别是 publish 和 subscribe 。
...</p></div><footer class=entry-footer><span title='2022-04-01 17:39:41 +0000 UTC'>2022-04-01</span>&nbsp;·&nbsp;1606 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Redis基础" href=http://localhost:1313/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MySQL主从复制</h2></header><div class=entry-content><p>复制原理 主从复制的原理其实就是把主服务器上的 binlog 日志复制到从服务器上执行一遍，这样从服务器上的数据就和主服务器上的数据相同了。
复制过程 主节点开启bin-log功能，记录任何修改了数据库数据的事件。 从节点每隔一定时间探测 master 的 binlog 是否发生改变，如果发生改变，则开启一个线程（I/O Thread)把自己扮演成 mysql 的客户端，请求主节点的binlog，请求时携带参数 position 表示请求该位置之后的内容；如果不携带表示从头开始复制（用于首次复制）。 主节点启动一个线程（dump Thread）与从节点的 I/O Thread建立连接，将 binlog 中 position 之后的内容返回给从节点 IO 线程。 从节点接收到主节点发送过来的数据把它放置到中继日志（Relay log）文件中。 从节点启动另外一个线程（sql Thread ），把 Relay log 中的事件读取出来，并在本地再执行一次。 复制策略 「同步策略」：Master会等待所有的Slave都回应后才会提交，用于强一致性场景但会严重影响性能 「半同步策略」：Master至少会等待一个Slave回应后提交。 「异步策略」：Master不用等待Slave回应就可以提交。 「延迟策略」：Slave要落后于Master指定的时间。 Binlog 格式 statement：记录的是修改SQL语句 row：记录的是每行实际数据的变更 mixed：statement和row模式的混合 面试题 主从复制功能
负载均衡、读写分离 备份容灾 高可用和故障切换 主从复制，达到了写性能的瓶颈如何解决
分库分表
主从复制的过程有数据延迟怎么办
数据延迟会导致Slave被读取到的数据并不是最新数据。
如果业务场景需要强一致性，使用复制策略中的同步策略。</p></div><footer class=entry-footer><span title='2022-03-27 21:39:41 +0000 UTC'>2022-03-27</span>&nbsp;·&nbsp;54 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to MySQL主从复制" href=http://localhost:1313/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>InnoDB锁</h2></header><div class=entry-content><p>锁机制用于管理对共享资源的并发访问。
1、锁粒度 表锁是MySQL中最大粒度的锁定机制，会锁定整张表，可以很好的避免死锁，是 MySQL 中最大颗粒度的锁定机制。表锁由 MySQL Server 实现，一般在执行 DDL 语句时会对整个表进行加锁，比如说ALTER TABLE等操作。在执行 DML 语句时，也可以通过LOCK TABLES显式指定对某个表进行加锁。
页级锁锁定一页，主要应用于 BDB 存储引擎。
行级锁的锁定颗粒度在 MySQL 中是最小的，只针对操作的当前行进行加锁，所以行级锁发生锁定资源争用的概率也最小。只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。InnoDB 默认使用行级锁。
2、行锁详解 InnoDB默认使用行锁，实现了两种标准的行锁——共享锁与排他锁；
1、除了显式加锁的情况，其他情况下的加锁与解锁都无需人工干预。 2、InnoDB所有的行锁算法都是基于索引实现的，锁定的也都是索引或索引区间
lock in share mode与for update的区别：
lock in share mode 是共享锁；for update 是排他锁 没有覆盖索引时，两种锁都需要即锁辅助索引又锁主键索引；当有覆盖索引时，lock in share mode 只锁辅助索引，而 for update 即锁辅助索引又锁主键索引。 3、当前读与快照读 **1、当前读：**即加锁读，读取记录的最新版本，会加锁保证其他并发事务不能修改当前记录，直至获取锁的事务释放锁；使用当前读的操作主要包括：显式加锁的读操作与插入/更新/删除等写操作。
2、快照读：即不加锁读，读取记录的快照版本而非最新版本，通过MVCC实现；
InnoDB默认的RR事务隔离级别下，不显式加『lock in share mode』与『for update』的『select』操作都属于快照读，保证事务执行过程中只有第一次读之前提交的修改和自己的修改可见，其他的均不可见；
4、MVCC MVCC『多版本并发控制』，与之对应的是『基于锁的并发控制』；
MVCC的最大好处：读不加任何锁，读写不冲突，对于读操作多于写操作的应用，极大的增加了系统的并发性能；
5、锁算法 InnoDB主要实现了三种行锁算法：
5.1、记录锁 记录锁(Record Locks)也称为行锁，顾名思义，表示对某一行记录加锁。
5.2、间隙锁 Gap锁，锁定的是索引记录之间的间隙，是防止幻读的关键；并发事务插入新数据前会先检测间隙中是否已被加锁，防止幻读的出现；间隙锁与间隙锁不互斥。
注意！间隙锁锁住的是一个区间，而不仅仅是这个区间中目前仅存在的数据行。
插入意向锁名字里虽然有意向锁这三个字，但是它并不是意向锁，它属于行级锁，是一种特殊的间隙锁，该锁只用于并发插入操作。是在插入一条记录行前，由 INSERT 操作产生的一种间隙锁。该锁用以表示插入意向，由于插入意向锁只是锁住一个点，当多个事务在同一区间插入位置不同的多条数据时，事务之间不需要互相等待。 间隙锁的意义只在于阻止区间被插入，因此是可以共存的。一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁，共享和排他的间隙锁是没有区别的，他们相互不冲突，且功能相同。
...</p></div><footer class=entry-footer><span title='2022-03-27 17:39:41 +0000 UTC'>2022-03-27</span>&nbsp;·&nbsp;100 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to InnoDB锁" href=http://localhost:1313/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/innodb%E9%94%81/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MySQL小知识</h2></header><div class=entry-content><p>1、or和union的区别 对于单列来说，用or是没有任何问题的，但是or涉及到多个列的时候，每次select只能选取一个index，另一列需要进行table-scan，即全部扫描一遍，但是使用union就可以解决这个问题，分别使用各自列的index进行查询。 但是这里还会有一个问题就是，UNION会对结果进行排序去重，可能会降低一些performance。
2、having和where的区别 where是在分组前对数据进行过滤；where后面不可以使用聚合函数 having是在分组后对数据进行过滤；having后面可以使用聚合函数 having 的作用就是弥补 where 的粗粒度，实现在组内更细粒度的筛选。
在查询过程中执行顺序：from>where>group（含聚合）>having>order>select。</p></div><footer class=entry-footer><span title='2022-03-27 17:39:41 +0000 UTC'>2022-03-27</span>&nbsp;·&nbsp;11 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to MySQL小知识" href=http://localhost:1313/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%B0%8F%E7%9F%A5%E8%AF%86/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MySQL索引</h2></header><div class=entry-content><p>索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组。
1、索引类型 普通索引：最基本的索引，可以在任意一列或多列的组合上加普通索引。允许存在重复值以及空值。 唯一索引：与普通索引不同的是，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。 主键索引：与唯一索引不同的是，不允许有空值。 组合索引：组合索引与单列索引相对应，只包含一个字段的索引叫做单列索引，包含两个或以上字段的索引叫做复合索引（或组合索引）。上述三种索引既可以是单列索引也可以是组合索引。 2、聚集索引 聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。
怎么理解呢？
聚簇索引的顺序，就是数据在硬盘上的物理顺序。一般情况下主键就是默认的聚簇索引。
一张表只允许存在一个聚簇索引，因为真实数据的物理顺序只能有一种。如果一张表上还没有聚簇索引，为它新创建聚簇索引时，就需要对已有数据重新进行排序，所以对表进行修改速度较慢是聚簇索引的缺点，对于经常更新的列不宜建立聚簇索引。
聚簇索引性能最好，因为一旦具有第一个索引值的记录被找到，具有连续索引值的记录也一定物理地紧跟其后。一张表只能有一个聚簇索引，所以非常珍贵，必须慎重设置，一般要根据这个表最常用的SQL查询方式选择某个（或多个）字段作为聚簇索引（或复合聚簇索引）。
InnoDB对主键建立聚簇索引。 如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。 如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引。 3、索引的最左匹配 最左前缀匹配原则，非常重要的原则，建立一个索引，对于索引中的字段，mysql会一直向右匹配直到遇到范围查询(>、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。
mysql创建复合索引的规则是首先会对复合索引的最左边的，也就是第一个name字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的cid字段进行排序。其实就相当于实现了类似 order by name cid这样一种排序规则。 所以：第一个name字段是绝对有序的，而第二字段就是无序的了。所以通常情况下，直接使用第二个cid字段进行条件判断是用不到索引的。
在第一个值等值匹配的前提下，第二个值是有序的，因此mysql索引规则中要求复合索引要想使用第二个索引，必须先使用第一个索引的原因。（而且第一个索引必须是等值匹配）。
order by也会用到索引，但前提是 where子句必须用到索引；如果 where子句的字段没有索引，即使order by的字段有索引也不会用到。where和order by使用的索引可以是同一个组合索引，同样符合最左匹配原则，比如 select * from tb_user where name = "lu" and age &lt; 21 order by score，如果有 (name, age, score) 的组合索引，由于 age 使用了范围搜索，score 索引就会失效。
...</p></div><footer class=entry-footer><span title='2022-03-27 17:39:41 +0000 UTC'>2022-03-27</span>&nbsp;·&nbsp;371 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to MySQL索引" href=http://localhost:1313/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E7%B4%A2%E5%BC%95/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=http://localhost:1313/posts/page/4/>«&nbsp;Prev&nbsp;
</a><a class=next href=http://localhost:1313/posts/page/6/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>