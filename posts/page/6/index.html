<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | lu</title>
<meta name=keywords content><meta name=description content="Posts - lu"><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity="sha256-1yREUm1+y9sAFUOKf6iQVKZYv3WdBULi5d+BzpS0k+4=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://ethereal-lu.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/posts/"><meta property="og:site_name" content="lu"><meta property="og:title" content="Posts"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ethereal-lu.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://ethereal-lu.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://ethereal-lu.github.io/>Home</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>事务实现原理</h2></header><div class=entry-content><p>MySQL 默认开启事务自动提交模式，即除非显式的开启事务（BEGIN 或 START TRANSACTION），否则每条 SOL 语句都会被当做一个单独的事务自动执行。
在 MySQL 中，可以使用 SET autocommit 语句设置事务的自动提交模式，语法格式如下：
SET autocommit = 0|1|ON|OFF; 对取值的说明：
值为 0 和值为 OFF：关闭事务自动提交。如果关闭自动提交，用户将会一直处于某个事务中，只有提交或回滚后才会结束当前事务，重新开始一个新事务。 值为 1 和值为 ON：开启事务自动提交。如果开启自动提交，则每执行一条 SQL 语句，事务都会提交一次。 事务想要做到可靠性以及并发处理。
1、redo log 与 undo log 1.1、redo log mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Boffer Pool(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做缓冲池和磁盘之间的同步。
那么问题来了，如果还没来的同步的时候宕机或断电了怎么办？还没来得及执行上面图中红色的操作。这样会导致丢部分已提交事务的修改信息！
所以引入了redo log来记录已成功提交事务的修改信息，并且会把redo log持久化到磁盘，系统重启之后在读取redo log恢复最新数据。
redo log在事务提交时就写入磁盘，不会等待后台程序执行。
总结： redo log是用来恢复数据的 用于保障，已提交事务的持久化特性。
既然redo log也需要存储，也涉及磁盘IO为啥还用它？
（1）redo log 的存储是顺序存储，而缓存同步是随机操作。
（2）缓存同步是以数据页为单位的，每次传输的数据大小大于redo log。
1.2、undo log undo log 叫做回滚日志，用于记录数据被修改前的信息。会记录执行的操作以及修改前的信息，这样根据操作记录做相反的操作即可恢复到事务执行前的状态。
undo log 记录事务修改之前版本的数据信息，因此假如由于系统错误或者rollback操作而回滚的话可以根据undo log的信息来进行回滚到没被修改前的状态。
总结： undo log是用来回滚数据的用于保障 未提交事务的原子性
2、事务的实现 事务的原子性是通过 undo log 来实现的 事务的持久性性是通过 redo log 来实现的 事务的隔离性是通过 (读写锁+MVCC)来实现的 一致性是通过原子性，持久性，隔离性来实现的！！ 2.1、原子性的实现 一个事务必须被视为不可分割的最小工作单位，一个事务中的所有操作要么全部成功提交，要么全部失败回滚，对于一个事务来说不可能只执行其中的部分操作，这就是事务的原子性。
...</p></div><footer class=entry-footer><span title='2022-03-27 17:39:41 +0000 UTC'>2022-03-27</span>&nbsp;·&nbsp;188 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 事务实现原理" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ConcurrentHashMap</h2></header><div class=entry-content><p>1、ConcurrentHashMap 如何保证线程安全 ConcurrentHashMap 是由 Node 数组构成，这里先将 Node 数组的每个下标对应的空间称为一个桶，以方便叙述。ConcurrentHashMap 的 get 操作不需要加锁，只有 put 和 remove 需要加锁。当执行 put\remove 操作时，会先定位到桶，然后将桶中的链表头节点或树的根节点锁住，因为必须要获取到链表头节点或树的根节点才能对整个链表或树操作，所以可以保证线程安全。
当 put 操作发现桶中没有数据时，会通过 cas 操作赋值，而不是上锁。
2、ConcurrentHashMap 扩容 ConcurrentHashMap 中有一个 sizeCtl 变量，它类似于 HashMap 中的 threshold ，通过比较元素数量与 sizeCtl 的大小判断是否需要扩容。扩容时，先创建一个2倍大小的新数组并初始化一个forwardNode实例fwd，然后遍历每一个桶，若桶中元素为 null 时，直接将其赋值为fwd，否则将桶中的元素转移到新数组，再将其赋值为fwd。在扩容的过程中若进来其他的读线程，若读线程发现桶中的元素是 fwd，就会帮助进行转移，否则进行正常的读操作。若进来写线程，若写线程发现桶中的元素是 fwd，就会帮助进行转移，否则阻塞，直到扩容完成。</p></div><footer class=entry-footer><span title='2022-03-26 11:12:41 +0000 UTC'>2022-03-26</span>&nbsp;·&nbsp;38 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to ConcurrentHashMap" href=https://ethereal-lu.github.io/posts/java/java-%E8%BF%9B%E9%98%B6/concurrenthashmap/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>基础数据结构</h2></header><div class=entry-content><p>1、总体注意事项 1.1、输入方式 两种输入方式，对于绝大多数时候，均选择Scanner作为输入。
import java.util.Scanner; Scanner sc = new Scanner(System.in); 当输入数据很大时，选择 BufferedReader，但其只能以行作为单位读取，需要分割为字符串数组，再解析为其他类型。
import java.io.BufferedReader; import java.io.InputStreamReader; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 1.2、读取 有些题目会有共包含 T 组案例，每组案例内 *** 操作，这种只需按 T 建循环即可。但有些题目没有指明共有 T 组案例，却在案例中包含了多组案例，此使必须在所有代码的外面包裹一层 while (sc.hasNext()) {...}，否则会出现虽然自测通过，但提交时却通过 0 组。
1.3、审题 当感觉找到一个比题目复杂度要求还低的方法时，一定要慎重考虑，这个方法真的对吗，能否覆盖所有情况，尽早换思路。 遇到与数字相关的题目，先看能不能找规律或化简，将题目转化为简单的模型再做。 与数字相关的题目，一定看是否为越界，注意用 long 和 double。 2、链表 2.1、链表反转 可以使用的方法有 栈、三指针法、头插法
使用头插法，因为对于一个区间的反转或者 k 个一组反转，使用头插法非常方便。
public ListNode reverseKGroup (ListNode head, int k) { ListNode pre = new ListNode(-1); pre.next = head; ListNode ret = pre, p = head; tag: while (p != null) { // 如果最后不够 k 个，则不反转 for (int i = 0; i &lt; k; i++) { if (p == null) break tag; p = p.next; } p = pre.next; // 使用头插法，注意：循环 k - 1 次。 for (int i = 0; i &lt; k - 1; i++) { ListNode temp = p.next; p.next = temp.next; temp.next = pre.next; pre.next = temp; } pre = p; p = p.next; } return ret.next; } 2.2、LRU缓存 方法一：LinkedHashMap。
...</p></div><footer class=entry-footer><span title='2022-03-26 11:12:41 +0000 UTC'>2022-03-26</span>&nbsp;·&nbsp;991 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 基础数据结构" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>面经-美团</h2></header><div class=entry-content><p>实习一面：75min 4.21 1、自我介绍
2、项目中用户权限控制的数据表设计问题
3、如果有 100 个元素，且之后不会增加，存储在 hashmap 中，初始容量应该设置为多少？
答：64？ 100？ 128？ 瞎蒙
正确：为了不触发扩容操作，初始值应该设置为 129 到 256 的任意一个值；因为在 hashmap 的构造函数中，会将输入的初始容量转换为第一个大于等于它的 2 的幂次值并赋值给 threshold ，而在 put 操作中，会将该 threshold 赋值给 capacity ，并根据 capacity * loadfactory得到新 threshold 。因此，如果初始值设置为小于等于 128，则经过 put 操作后，threshold 会变为 96，小于 100，如此一定会触发扩容操作。故为了不触发扩容需保证初始容量为 256。
4、如果有 41 个 int 数字，另外再给一个数字，如何判断这个数字在不在之前的 41 中？（后续准备八股文才反应过来，应该是40亿吧）
答：hashset 或 布隆过滤器，瞎蒙。布隆过滤器存在误差。
应该使用位图。由于 2^32 大约42亿多，故可以申请 2^32 个 bit，每个数对应一个bit，若有值该bit位为1，否则为0；如若 1 在，则第一个 bit 位置为 1，若17在，则第17个 bit 位置为 1。这样判断一个值在不在时只需判断该 bit 位是否为 1 即可。40 亿个 32 位int 大约 16GB，而使用位图算法，大约只需 500MB，可以在内存中判断。
...</p></div><footer class=entry-footer><span title='2022-03-26 11:12:41 +0000 UTC'>2022-03-26</span>&nbsp;·&nbsp;255 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 面经-美团" href=https://ethereal-lu.github.io/posts/%E9%9D%A2%E7%BB%8F/%E9%9D%A2%E7%BB%8F-%E7%BE%8E%E5%9B%A2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Docker基础</h2></header><div class=entry-content><p>1、概述 Docker 基于 Go 语言实现。一次镜像，处处运行。
Go文件编译后是平台级别的机器码，因此Docker 不需要 Go 环境支撑。由于 Docker 容器模型是基于 linux 内核的，因此 Docker 必须安装在 linux 环境上。
Docker for Windows 中负责运行环境配置的工具是 Docker Machine。它会在 Windows 上创建一个 Linux 虚拟机，用于运行 Docker 引擎。
Docker 相关的本地资源都存放在/var/lib/docker/目录下
docker 的配置文件路劲：/etc/default/docker
1.1、LCX Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。
LXC与docker的关系
Docker并不是LXC的替代品，Docker的底层就是使用了LXC来实现的。LXC将Linux进程沙盒化，使得进程之间相互隔离，并且能够控制各进程的资源分配。 在LXC的基础之上，Docker提供了一系列更强的功能。 移植性：通过抽象容器配置，容器可以实现一个平台移植到另一个平台； 镜像系统：基于 AUFS 的镜像系统为容器的分发带来了很多的便利，同时共同的 镜像层只需要存储一份，实现高效率的存储； 版本管理：类似于 GIT 的版本管理理念，用户可以更方面的创建、管理镜像文件； 仓库系统：仓库系统大大降低了镜像的分发和管理的成本； 1.2、docker 启动为什么比虚拟机快 1.Docker有着比虚拟机更少的抽象层，由于Docker不需要Hypervisor实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在Cpu、内存利用率上Docker将会在效率上有明显优势。
2.Docker利用的是宿主机的内核，而不需要Guest OS，因此，当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统，避免了引导、加载操作系统内核这个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载Guest OS，这个新建过程是分钟级别的，而Docker由于直接利用宿主机的操作系统则省略了这个过程，因此新建一个Docker容器只需要几秒钟。
Docker容器 虚拟机（VM） 操作系统 与宿主机共享OS 宿主机OS上运行宿主机OS 存储大小 镜像小，便于存储与传输 镜像庞大（vmdk等） 运行性能 几乎无额外性能损失 操作系统额外的cpu、内存消耗 移植性 轻便、灵活、适用于Linux 笨重、与虚拟化技术耦合度高 硬件亲和性 面向软件开发者 面向硬件运维者 2、基本组成 docker 的三要素是：镜像、容器、仓库。
...</p></div><footer class=entry-footer><span title='2022-03-17 17:12:41 +0000 UTC'>2022-03-17</span>&nbsp;·&nbsp;631 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Docker基础" href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8/docker/docker%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C# 学习笔记</h2></header><div class=entry-content><p>1、基础概念 1.1、.Net 概念 通常所说的 .Net 包括 .Net 平台和 .Net FrameWork 框架。它们两者的关系即 jvm 和 jre 的关系。
.Net FrameWork 框架由两部分组成，分别是 .Net 类库和 CLR（公共语言运行时）。
1.2、C# 语言 C# 是一种编程语言，可以开发基于 .Net 平台 的应用。
1.3、.Net 作用 Winform 开发桌面应用程序 ASP.NET 开发 web 网站 Unity3D 开发游戏和虚拟现实 1.4、.Net 两种交互模式 C/S：客户机（Client）/服务器模式。客户端需要安装专用的客户端软件，如 微信。 B/S：浏览器（Browser）/服务器模式。客户端只需要安装浏览器即可。 2、语法规则 C# 的基础语法规则几乎与 java 一样。
2.1、基本类型 与 java 一样，包括 byte、short、int、long、float、double、bool等，u开头表示无符号。
如果一个小数是浮点类型，则其后需加个 f ，否则默认为 double 型。
2.2、字符串 类名为 string ，小写。它的使用和 java 几乎一样，注意方法名为大写开头。
字符串格式化：string str = $"{name}的年龄为{age}"，其中name和age为之前声明的变量。
2.3、函数 C# 的函数名要大写开头。
...</p></div><footer class=entry-footer><span title='2021-12-01 21:39:41 +0000 UTC'>2021-12-01</span>&nbsp;·&nbsp;349 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to C# 学习笔记" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/c%23-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>VMware + Ubuntu18.04设置静态 IP</h2></header><div class=entry-content><p>进入VMware 的虚拟网络编辑器；
选择 VMnet8，点击 DHCP 设置，记住子网 IP，子网掩码和起始终止 IP，关闭。
点击右下方的更改设置，取消勾选 DHCP 分配 IP。再输入刚才记住的子网 IP 和子网掩码。
点击 NET 设置，记住网关并点击左下方的 DNS 设置，取消勾选自动检测并设置首选DNS为 8.8.8.8，备用为 114.114.114.114。确定、确定、应用。
打开主机的网络适配器中的 VMnet8 ，进入它的 IPV4 设置，将 IP 设置为之前记住的起始终止 IP 之间的任意一个，子网掩码和 DNS 都与之前设置的VMware一致。
一路确定并禁用再启用 VMnet8。
打开虚拟机，bash 输入 vim /etc/network/interfaces，内容如下：
source /etc/network/interfaces.d/* auto lo iface lo inet loopback auto ens32 iface ens32 inet static # 下方设置与之前步骤设置的一致 address 192.168.40.130 # 主机中设置的 IP，以后虚拟机 IP 固定为它 netmask 255.255.255.0 # 子网掩码 gateway 192.168.40.2 # 网关 dns-nameservers 8.8.8.8 # dns 输入vim /etc/systemd/resolved.conf，使其内容如下：
...</p></div><footer class=entry-footer><span title='2021-11-14 22:08:18 +0000 UTC'>2021-11-14</span>&nbsp;·&nbsp;122 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to VMware + Ubuntu18.04设置静态 IP" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81-ip/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>feign发起https请求</h2></header><div class=entry-content><p>1、安装 openssl 2、bash 进入任意目录执行以下命令
mkdir certs # 证书目录 mkdir private # 密钥目录 openssl rand -out private/.rand 1000 # 在构建根证书之前需要构建随机数文件(.rand) openssl genrsa -aes256 -out private/ca.key.pem 2048 # 构建根证书私钥 openssl req -new -key private/ca.key.pem -out private/ca.csr -subj "/C=CN/ST=BJ/L=BJ/O=FATE/OU=fate/CN=*.FATE.ORG" # 生成根证书签发申请 openssl x509 -req -days 10000 -sha1 -extensions v3_ca -signkey private/ca.key.pem -in private/ca.csr -out certs/ca.cer # 签发根证书 openssl pkcs12 -export -cacerts -inkey private/ca.key.pem -in certs/ca.cer -out certs/ca.p12 # 根证书转换为PKCS12格式密钥库 openssl genrsa -aes256 -out private/server.key.pem 2048 # 构建服务器证书私钥 openssl req -new -key private/server.key.pem -out private/server.csr -subj "/C=CN/ST=BJ/L=BJ/0=fate/OU=fate/CN=www.fate.org" # 生成服务器证书签发申请 openssl x509 -req -days 3650 -sha1 -extensions v3_req -CA certs/ca.cer -CAkey private/ca.key.pem -CAserial ca.srl -CAcreateserial -in private/server.csr -out certs/server.cer # 签发服务器证书 openssl pkcs12 -export -clcerts -inkey private/server.key.pem -in certs/server.cer -out certs/server.p12 # 服务器证书转换为PKCS12格式密钥库 3、将 server.p12 复制到微服务端的 resources 目录下
...</p></div><footer class=entry-footer><span title='2021-11-02 11:08:18 +0000 UTC'>2021-11-02</span>&nbsp;·&nbsp;187 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to feign发起https请求" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/feign%E5%8F%91%E8%B5%B7https%E8%AF%B7%E6%B1%82/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>微服务学习笔记</h2></header><div class=entry-content><p>1、微服务架构介绍 1.1、微服务概念 微服务就是将一个单体架构的应用按业务划分为一个个独立运行的程序即服务，他们之间通过 HTTP 协议进行通信（也可以采用消息队列来通信，如 RabbotMQ、Kafaka 等），可以采用不同的编程语言，使用不同的存储技术，自动化部署（如Jenkins）减少人为控制，降低出错概率。服务数量越多，管理起来越复杂，因此采用集中化管理。例如 Eureka，Zookeeper 等都是比较常见的服务集中化管理框架。
微服务是一种架构风格。有两个特点：
职责单一：一个微服务解决一个业务问题（注意是一个业务问题而不是一个接口）。 面向服务：将自己的业务能力封装并对外提供服务，这是继承SOA的核心思想，一个微服务本身也可能调用其它的微服务。 1.2、微服务设计原则 AKF 拆分原则
前后端分离原则
无状态服务
状态：如果一个数据需要被多个服务共享，才能完成一笔交易，那么这个数据被称为状态。进而依赖这个状态数据的服务被称为有状态服务，反之称为无状态服务。
例如对空调的设置：1、若空调遥控器发送加一或减一的指令，空调根据现在的温度计算并调整温度，则空调提供的是有状态服务，状态是空调当前温度。2、若空调遥控器发送的是加一或减一之后的温度数值，空调根据接收到的温度数值设置温度，则空调提供的是无状态服务。
Restful 通信风格
2、Eureka 注册中心 应用微服务化之后，首先遇到的第一个问题就是服务发现问题，一个微服务如何发现其他微服务呢？最简单的方式就是每个微服务里面配置其他微服务的地址，但是当微服务数量众多的时候，这样做明显不现实。所以需要使用到微服务架构中的一个最重要的组件：服务注册中心，所有服务都注册到服务注册中心，同时也可以从服务注册中心获取当前可用的服务清单。
2.1、注册中心概念 注册中心可以理解为微服务架构中的“通讯录”。它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其他服务时，就到这里找到服务的地址，进行调用。
张三办了张新的电话卡并将号码告诉我，我将其名字和号码的映射保存进通讯录。 -- 服务注册 我想给张三打电话，于是在通讯录中根据其名字找到张三，然后根据映射到的电话号码拨打 -- 服务发现 --------------------------------------------------------- 上例中我和张三分别代表一个微服务，通讯录是独立于我和张三的服务注册中心 总结：服务注册中心的作用就是服务的注册和服务的发现。
2.2、Eureka 入门案例 1、创建一个 SpringBoot 项目并引入web、test和下方两个依赖 。
&lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-dependencies&lt;/artifactId> &lt;version>2020.0.4&lt;/version> &lt;type>pom&lt;/type> &lt;scope>runtime&lt;/scope> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-eureka-server&lt;/artifactId> &lt;version>3.0.4&lt;/version> &lt;/dependency> 2、application.yaml 如下
server: port: 8761 # 官方文档使用的端口 spring: application: name: eureka-server # 应用名称 # 配置 eureka-server 注册中心 eureka: instance: hostname: localhost # 主机名，默认根据操作系统的主机名获取 client: # 下方值为 false 的两项，只有当自身为单节点的注册中心时才需要设置为 false 。 # 单节点指的是只有一个注册中心，不是只有一个微服务。 # 当自身是微服务或者是集群中的注册中心之一时无需设置，使用默认 true。 register-with-eureka: false # 是否将自己注册到注册中心，默认为 true fetch-registry: false # 是否从注册中心获取服务注册信息，默认 true service-url: # 注册中心对外暴露的注册地址 defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ 3、启动类前添加 @EnableEurekaServer 注解
...</p></div><footer class=entry-footer><span title='2021-10-25 17:42:15 +0000 UTC'>2021-10-25</span>&nbsp;·&nbsp;2156 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 微服务学习笔记" href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>设计模式</h2></header><div class=entry-content><p>1、设计模式分类 创建型模式
用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。
结构型模式
用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。
行为型模式
用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。
2、UML图 统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。
2.1、类的表示方式 在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。
属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：
+：表示public
-：表示private
#：表示protected
属性的完整表示方式是： 可见性 名称 ：类型 [ = 缺省值]
方法的完整表示方式是： 可见性 名称(参数列表) [ ： 返回类型]
2.2、类与类之间关系的表示方式 感觉没必要记，用到时再查吧。
3、软件设计原则 在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。
3.1 开闭原则 对扩展开放，对修改关闭。即使用接口和抽象类，扩展时实现新的派生类而不修改子类。增加新功能时添加新的代码，而不要修改原有代码。
3.2 里氏代换原则 里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。
3.3 依赖倒转原则 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。
简单说就是尽量让接口作为成员变量，而不要让实现类作为成员变量。
3.4 接口隔离原则 客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。
被迫依赖：类 B 为了定义一个已经在类 A 中定义了的方法而去继承类 A，此时类 B 被迫依赖于类 A 中其他它并不需要的方法。
应该将该方法单独抽象为接口，若所有实现类的方法体都一样，可以用 default 修饰并实现。
继承接口时也一样，不要使类被迫依赖于接口中其他不适用的方法。应该将接口拆分为多个接口。
...</p></div><footer class=entry-footer><span title='2021-09-25 17:12:41 +0000 UTC'>2021-09-25</span>&nbsp;·&nbsp;6688 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 设计模式" href=https://ethereal-lu.github.io/posts/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://ethereal-lu.github.io/posts/page/5/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://ethereal-lu.github.io/posts/page/7/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>