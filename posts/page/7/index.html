<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | lu</title>
<meta name=keywords content><meta name=description content="Posts - lu"><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity="sha256-1yREUm1+y9sAFUOKf6iQVKZYv3WdBULi5d+BzpS0k+4=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://ethereal-lu.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/posts/"><meta property="og:site_name" content="lu"><meta property="og:title" content="Posts"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ethereal-lu.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="lu (Alt + H)">lu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://ethereal-lu.github.io/>Home</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>指令重排与内存屏障</h2></header><div class=entry-content><p>指令重排 有两种发生指令重排的情况：一个是编译的时候，由编译原理的知识知道，编译器会对代码进行优化，这一步就涉及到指令重排，当然，编译完成之后的目标代码中指令的顺序就是确定的，不同线程执行该代码的顺序是一样的；另一个就是CPU在执行具体的指令的时候，也会因为计算机当前的状态（比如寄存器的占用情况、ALU的使用情况，cup缓存层的存在等原因）的不同导致指令最终的执行顺序发生变化(实际上，cpu本身并不会对指令进行重排，它本身是按照编译后的顺序来执行指令的，只是由于执行不同的指令需要的时间长短不同，以及缓存层的存在，再加上CPU执行指令的流水线并不是串行化等因素，那么就有可能出现排在靠前位置的指令还没执行完，而排在靠后的指令已经执行完了的情况，这一情况就是所谓的CPU执行指令的乱序）
编译器指令重排 如果两条有依赖关系 (像 a++; b=f(a); ) 的指令挨得很近，后一条指令必定会因为等待前一条执行的结果，而在流水线中阻塞很久(这个“很久”是对计算机而言哈)。而编译器的乱序，作为编译优化的一种手段，则试图通过指令重排，在这两条指令之间插入其他指令，将这两条指令拉开一定的距离，以保证后一条指令执行的时候前一条指令结果已经得到了，那么也就不需要阻塞等待了。所以相比于CPU的乱序，编译器的乱序才是真正对指令顺序做了调整，但是编译器所进行的调整也必须保证上下文的依赖逻辑，即存在依赖关系的指令顺序不能调整。
CPU 指令重排 现在的CPU一般采用流水线来执行指令。一个指令的执行被分成：取址，译码，访存，执行，写回等若干个阶段。流水线中的多个指令是可以同时处于同一个阶段的，只要CPU内部相应的处理部件未被占满。这样一来，乱序就可能产生了。比如一条加法指令出现在一条除法指令的后面，但由于除法的执行时间很长，在它执行完之前，加法可能就先执行完了。再比如两条访存指令，可能由于第二条指令中了cache(或其它原因)而导致它先于第一条指令完成。指令流水线除了在资源不足的情况下会卡住之外(如一个加法器应付两条加法指令)，指令之间存在的相互依赖才是导致流水线阻塞的主要原因。当然，CPU的乱序执行并不是任意地乱序，而必须保证上下文依赖逻辑的正确性。
内存屏障 不存在依赖关系的内存操作会被按随机顺序有效得到执行，但这在CPU与CPU(多核)交互时或CPU与IO设备交互(一般IO比较耗时)时，这可能成为问题。我们需要一些手段来干预编译器和CPU对指令顺序的影响，而内存屏障就是这样的干预手段。它们能保证处于屏障两边的内存操作满足部分有序(“部分有序”的意思是，内存屏障之前的操作必须都先于屏障之后的操作，但是如果几个操作出现在屏障的一边，则不保证它们有序)。这样的强制措施是非常重要的，因为系统中的CPU和其它设备可以使用各种各样的策略来提高性能，包括对内存操作的乱序、延迟和合并执行、预取、投机性的分支预测和各种缓存……内存屏障就是用于禁用或者抑制这些策略，使代码能够清楚地控制多个CPU和/或设备的交互。操心系统中存在各式各样的内存屏障，不同的内存屏障涉及到了各种复杂的实现，这里不过多地讲了，但关于内存屏障还要记住的一点就是：在内存屏障之前出现的内存访问不保证在内存屏障指令完成之前完成，内存屏障相当于在该CPU的访问队列中画了一条线，使得相关访存类型的请求不能相互跨越(用于实现内存屏障的指令，其本身并不作为参考对象，其两边的访存操作才被当作参考对象，所以屏障指令执行完成并不表示出现在屏障之前的所有访存操作都已经完成，但如果屏障之后的某一个访存操作已经完成，则屏障指令之前的所有访存操作必定都已经完成了)。
要想并发程序正确地执行，必须要保证程序的原子性、可见性以及有序性。只要有一个没有被保证，就可能会导致程序运行不正确。</p></div><footer class=entry-footer><span title='2021-08-26 23:08:18 +0000 UTC'>2021-08-26</span>&nbsp;·&nbsp;15 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 指令重排与内存屏障" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E4%B8%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>lambda 表达式中使用的变量为什么必须是 final</h2></header><div class=entry-content><p>Java 规范中规定：Lambda 表达式中要用到的，但又未在 Lambda 表达式中声明的变量，必须声明为 final 或者是 effectively final，否则就会出现编译错误。
有效 final 即不用显示声明为 final，由 JVM 添加 final。
个人理解 由于 lambda 表达式相当于生成一个对象，存储在堆中（生命周期长），而方法的局部变量存储在栈中（生命周期短）。如果 lambda 表达式在使用了外部方法中的局部变量后，该局部变量又发生变化，且方法执行完毕内存被释放，此 lambda 表达式生成的对象可能依然存活（未被GC回收），但是却无法得知局部变量改变后的值，造成数据一致性破坏。
// 报错 public class Test { public void func() { int a = 5; Runnable runnable = () -> { a++; }; } } 上方在方法中报错而下方在类中不报错，因此推断与栈和堆的生存周期有关系。
// 不报错 public class Test { private int a = 3; Runnable runnable = () -> { a++; }; } **存在问题：**作为方法中的内部类，既然方法被释放后，该类绝不可能再被使用，矛盾！
其他理解 lambda是对接口中的方法的一种简写方式，当方法想要使用外部的变量的时候，需要把值给传过去，但是方法中无论怎么改变量的值，都不会改变这个变量在外部的值（值传递和引用传递的区别），所以加上final就是为了方便开发者，以免误以为可以更改这个变量的值。final的目的就是告诉开发人员不能改变外面的变量值。
**存在问题：**外部变量什么时候传递给 lambda 的。难道隐式的传了？
悬而未决，先睡觉
...</p></div><footer class=entry-footer><span title='2021-08-18 23:08:18 +0000 UTC'>2021-08-18</span>&nbsp;·&nbsp;76 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to lambda 表达式中使用的变量为什么必须是 final" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/lambda/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>文件的 MD5 值</h2></header><div class=entry-content><p>是什么 文件的 MD5 值不是文件的属性也不是文件存储的内容，而是由分析程序根据文件的信息分析得到的一串独一无二的字符值。当两个文件的 MD5 值相同时说明这两个文件的内容完全一样。任何数据计算得到的 MD5 值长度都相等。
作用 由于同一个分析程序对于内容一样的文件分析得到的 MD5 值始终是一样的，因此可以通过对传输前后的文件进行 MD5 值的对比来检验传输途中文件是否被他人篡改。
MD5 值何时改变 1、不同的分析程序对同一份文件分析得到的 MD5 值可能不同。
2、对文件的内容进行增删改后，文件的 MD5 值会发生改变。
3、修改文件的名称和后缀都不会改变文件的 MD5 值。
查看文件 MD5 值的方法 1、Windows
certutil -hashfile 文件路径 md5 # 示例 certutil -hashfile E:\资料\作业资料\abc.py md5 2、Linux
md5sum 文件路径</p></div><footer class=entry-footer><span title='2021-08-18 23:08:18 +0000 UTC'>2021-08-18</span>&nbsp;·&nbsp;42 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 文件的 MD5 值" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E6%96%87%E4%BB%B6md5/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>JUC 并发编程</h2></header><div class=entry-content><p>线程基础知识 概述 每个线程拥有一个自己独立的栈，但是共享进程的堆空间。
Thread 中的 run 方法是一个回调函数，与普通函数没什么区别，所以以如下方式调用run时，就是一个普通的方法执行。而 start 方法会在本地创建一个线程，然后在本地代码中通过 jvm 回调 run 方法来执行任务。
Thread thread = new Thread(() -> {...}); thread.run(); 线程实现方法 Thread类是描述线程的类，要实现多线程，必须继承Thread类
方法一、创建Thread类的子类 1、创建Thread类的子类，并重写run方法，其中设置线程的任务
2、创建子类对象，并执行start方法
​ （执行start方法会创建一个新的栈空间，并在该栈空间中执行run方法。每执行一次步骤2，就开启一个新的线程）
方法二、实现Runnable接口 推荐使用这种 —> 使用该方法时，Thread 类是咱们自定义类的静态代理类
1、创建一个Runnable接口的实现类，并重写run方法，其中设置线程的任务
2、创建对象，并将其作为参数传递给Thread类的构造方法，再调用start方法。
​ new Thread(new MyRunnable()).start(); ​ 匿名内部类实现： new Thread(new Runnable(){重写run方法}).start();
方法三、实现Callable接口 Callable接口类似于Runnable，但Runnable不会返回结果，也不会抛出检查异常，Callable可以，Runnable 效率比 Callable 低。
1、创建一个Callable接口的实现类，并重写call方法，其中设置线程的任务 2、在使用的地方创建该类对象 obj 。 3、ExecutorService executorService = Executors.newFixedThreadPool(5); // 创建执行服务 4、Future future = executorService.submit(obj); // 提交执行 5、V result = future.get(); // 获取结果 6、executorService.shutdownNow(); // 关闭服务
...</p></div><footer class=entry-footer><span title='2021-08-16 17:12:41 +0000 UTC'>2021-08-16</span>&nbsp;·&nbsp;2357 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to JUC 并发编程" href=https://ethereal-lu.github.io/posts/java/juc%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Enum 向注解赋值问题</h2></header><div class=entry-content><p>问题 Enum 如下
@Getter @AllArgsConstructor(access = AccessLevel.PRIVATE) public enum RoleEnum { ADMIN (0, "admin"), ANALYST (1, "analyst"); private final Integer intValue; private final String strValue; } 将该 enum 对象的属性赋值给注解时报错：
@RequiresRoles(RoleEnum.ADMIN.getStrValue()) // error: "attribute value must be constant" 报错显示注解所需值必须是常量
这是因为 ADMIN 作为 RoleEnum 的对象，只有当 RoleEnum 被类加载器所加载之后才会生成，而在编译期 strValue 属性还是变量，所以会报错。
解决 在 enum 中添加内部类存储常量
@Getter @AllArgsConstructor(access = AccessLevel.PRIVATE) public enum RoleEnum { ADMIN (0, Names.ADMIN), ANALYST (1, Names.ANALYST); public static class Names { public static final String ADMIN = "admin"; public static final String ANALYST = "analyst"; } private final Integer intValue; private final String strValue; } 向注解中赋值时使用内部类的常量
...</p></div><footer class=entry-footer><span title='2021-08-11 16:39:41 +0000 UTC'>2021-08-11</span>&nbsp;·&nbsp;97 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Enum 向注解赋值问题" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/enum%E8%B5%8B%E5%80%BC/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Shrio学习笔记</h2></header><div class=entry-content><p>作者 小陈
微信 chenxu521600
B站 编程不良人 | 百知教育
资料 http://www.baizhiedu.xin
1.权限的管理 1.1 什么是权限管理 基本上涉及到用户参与的系统都要进行权限管理，权限管理属于系统安全的范畴，权限管理实现对用户访问系统的控制，按照安全规则或者安全策略控制用户可以访问而且只能访问自己被授权的资源。
权限管理包括用户身份认证和授权两部分，简称认证授权。对于需要访问控制的资源用户首先经过身份认证，认证通过后用户具有该资源的访问权限方可访问。
1.2 什么是身份认证 身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确。对于采用指纹等系统，则出示指纹；对于硬件Key等刷卡系统，则需要刷卡。
1.3 什么是授权 授权，即访问控制，控制谁能访问哪些资源。主体进行身份认证后需要分配权限方可访问系统的资源，对于某些资源没有权限是无法访问的
2.什么是shiro Apache Shiro™ is a powerful and easy-to-use Java security framework that performs authentication, authorization, cryptography, and session management. With Shiro’s easy-to-understand API, you can quickly and easily secure any application – from the smallest mobile applications to the largest web and enterprise applications.
Shiro 是一个功能强大且易于使用的Java安全框架，它执行身份验证、授权、加密和会话管理。使用Shiro易于理解的API，您可以快速轻松地保护任何应用程序—从最小的移动应用程序到最大的web和企业应用程序。
Shiro是apache旗下一个开源框架，它将软件系统的安全认证相关的功能抽取出来，实现用户身份认证，权限授权、加密、会话管理等功能，组成了一个通用的安全认证框架。
3.shiro的核心架构 ...</p></div><footer class=entry-footer><span title='2021-07-27 18:48:13 +0000 UTC'>2021-07-27</span>&nbsp;·&nbsp;2810 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Shrio学习笔记" href=https://ethereal-lu.github.io/posts/java/shiro%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MyBatisPlus学习笔记</h2></header><div class=entry-content><p>1、快速开始 1.1、导入依赖 mybatis 和 mybatis-plus 的依赖不要同时导入。
&lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;scope>runtime&lt;/scope> &lt;/dependency> &lt;dependency> &lt;groupId>com.baomidou&lt;/groupId> &lt;artifactId>mybatis-plus-boot-starter&lt;/artifactId> &lt;version>3.4.3&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>com.baomidou&lt;/groupId> &lt;artifactId>mybatis-plus-core&lt;/artifactId> &lt;version>3.4.3&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.projectlombok&lt;/groupId> &lt;artifactId>lombok&lt;/artifactId> &lt;optional>true&lt;/optional> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;/dependencies> 1.2、配置 在主yaml中配置和 mybatis 的完全一样，没其他配置。
1.3、使用 @Repository public interface UserMapper extends BaseMapper&lt;User> { } UserMapper 接口只需继承 BaseMapper ，其中泛型填入被操作的实体类。BaseMapper 中已经实现许多的方法，直接使用即可。
2、配置日志 使用 mybatis-plus 的方法时，具体 sql 代码是不可见的，我们希望知道它是怎么执行的，就需要看日志。
# 配置日志 mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 这里使用 mybatis 自带的控制台输出 3、CRUD扩展 数据库的 user 表如下：
...</p></div><footer class=entry-footer><span title='2021-07-18 19:42:15 +0000 UTC'>2021-07-18</span>&nbsp;·&nbsp;1232 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to MyBatisPlus学习笔记" href=https://ethereal-lu.github.io/posts/java/mybatisplus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>JVM学习笔记</h2></header><div class=entry-content><p>JVM有几大模块组成：
类加载的子系统 内存模型 执行引擎 垃圾收集器（GC） JIT(热点代码缓存) 自动内存管理 1、内存区域划分 Java虚拟机所管理的内存包括方法区、虚拟机栈、本地方法栈、堆、程序计数器。
1.1、程序计数器 字节码解释器工作时就是通过改变这个计数器 的值来选取下一条需要执行的字节码指令，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地 址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。
1.2、虚拟机栈 Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、 float、long、double）、对象引用和returnAddress 类型。操作数栈主要用于保存方法执行过程中变量的临时结果，方法执行过程中会根据字节码指令向操作数栈压入和弹出数据，返回值也是存储在操作数栈中。
1.3、本地方法栈 本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机 栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native） 方法服务。
1.4、堆 Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java 世界里“几乎”所有的对象实例都在这里分配内存。
Class 对象也存储在堆中。以 Person 类为例，类加载时会创建 instanceKlass （jvm 的一种数据结构）用来存储 Person 类的元数据，包括常量池、字段、方法等，存放在方法区，若是第一次加载 Person 类，会同时生成这个类对应的Class对象， instanceKlass 中包含指向该 Class 对象的指针；之后每次创建 person 实例时都是通过Class对象作为模板创建的（即不是根据 instanceKlass 创建对象），person 实例中包含指向方法区 instanceKlass 的指针。
Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该 被视为连续的。
1.5、方法区 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
运行时常量池（Runtime Constant Pool）是方法区的一部分。用于存放编译期生成的各种字面量与符号引用。
2、HotSpot虚拟机对象探秘 2.1、对象的创建 1、先检查类是否已经被加载、解析和初始化过，如果没有，那必须先执行相应的类加载过程。
2、为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。当使用带压缩整理过程的收集器时，内存的分配算法是指针碰撞，既简单又高效；而当使用基于清除算法的收集器时，采用较为复杂的空闲列表来分配内存。
3、虚拟机将分配到的内存空间（但不包括对象头）都初始化为零值。
4、设置对象头中的信息。
5、执行构造函数，按照程序员的意愿对对象进行初始化。
2.2、对象的内存布局 对象在堆内存中的存储布局可以划分为三个部分：对象头、实例数据和对齐填充。
...</p></div><footer class=entry-footer><span title='2021-07-10 19:42:15 +0000 UTC'>2021-07-10</span>&nbsp;·&nbsp;563 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to JVM学习笔记" href=https://ethereal-lu.github.io/posts/java/jvm%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>数据预处理</h2></header><div class=entry-content><p>无量纲化 归一化(Normalization) 对异常值很敏感！
将所有数据收敛到 [0, 1] 之间。归一化由中心化和缩放组成。
中心化：让所有数据减去一个固定值，让数据样本平移到某个位置。
缩放处理(Scale)：所有数据除以一个固定值，将数据固定在某个范围内（取对数也算）。
归一化公式如下： x* = ( x - min(x) ) / ( max(x) - min(x) )
sklearn.preprocessing.MinMaxScaler 类可实现归一化操作。该函数中的feature_range参数控制我们希望把数据压缩到的范围，默认为[0, 1]。
import pandas as pd from sklearn.preprocessing import MinMaxScaler data = [[-1, 2], [-0.5, 6], [0, 10], [1, 18]] # 实现归一化 scaler = MinMaxScaler() # 实例化 scaler = scaler.fit(data) # fit. 在这里本质是生成Min(x)和 max(x) result = scaler.transform(data) # 通过接口导出结果 # 至此，已经得出归一化之后的结果，就是result。（会发现是按列归一化的） # 下方语句将训练和导出结果一步达成，相当于上方两步一起执行，作用一样。 result = scaler.fit_transform(data) # 下方将归一化后的结果逆转,即输入归一化之后的结果会返回没归一化的值 original_data = scaler.inverse_transform(result) # 归一化到其他范围 data = [[-1, 2], [-0.5, 6], [0, 10], [1, 18]] scaler = MinMaxScaler(feature_range=[5, 10]) result = scaler.fit_transform(data) # 当X中的特征数量非常多的时候，fit会报错，表示数据量太大我计算不了 # 此时可以使用partial_fit训练，用法和 fit 一样 # scaler = scaler.partial_fit(data) 标准化(Standardization) 由于归一化对异常值很敏感，故一般使用标准化。
...</p></div><footer class=entry-footer><span title='2021-07-02 17:45:10 +0000 UTC'>2021-07-02</span>&nbsp;·&nbsp;417 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 数据预处理" href=https://ethereal-lu.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Matplotlib笔记</h2></header><div class=entry-content><p>Matplotlib笔记</p></div><footer class=entry-footer><span title='2021-07-01 17:45:10 +0000 UTC'>2021-07-01</span>&nbsp;·&nbsp;word&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Matplotlib笔记" href=https://ethereal-lu.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/matplotlib%E5%AD%A6%E4%B9%A0/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://ethereal-lu.github.io/posts/page/6/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://ethereal-lu.github.io/posts/page/8/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>