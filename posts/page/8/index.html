<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | lu</title>
<meta name=keywords content><meta name=description content="Posts - lu"><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity="sha256-1yREUm1+y9sAFUOKf6iQVKZYv3WdBULi5d+BzpS0k+4=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://ethereal-lu.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/posts/"><meta property="og:site_name" content="lu"><meta property="og:title" content="Posts"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ethereal-lu.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="lu (Alt + H)">lu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://ethereal-lu.github.io/>Home</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Numpy笔记</h2></header><div class=entry-content><p>Numpy笔记</p></div><footer class=entry-footer><span title='2021-07-01 17:45:10 +0000 UTC'>2021-07-01</span>&nbsp;·&nbsp;word&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Numpy笔记" href=https://ethereal-lu.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/numpy%E5%AD%A6%E4%B9%A0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Pandas笔记</h2></header><div class=entry-content><p>Pandas笔记</p></div><footer class=entry-footer><span title='2021-07-01 17:45:10 +0000 UTC'>2021-07-01</span>&nbsp;·&nbsp;word&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Pandas笔记" href=https://ethereal-lu.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/pandas%E5%AD%A6%E4%B9%A0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>PyTorch笔记</h2></header><div class=entry-content><p>torch的tensor默认为FloatTensor类型，可以使用torch.set_default_tensor_type(torch.DoubleTensor)设置默认类型为DoubleTensor，pytorch和numpy的张量在内存中都是默认按行优先顺序排列。
基础 生成张量 x = torch.empty(5, 3) == torch.Tensor(5, 3) # 构造一个未初始化的5✖3的矩阵，里面都是任意的随机数 y = torch.rand(5, 3) # 构造一个随机初始化的5✖3的矩阵，里面是从区间(0, 1)的均匀分布中抽取出的一组随机数 z = torch.randn(5, 3) # 构造一个随机初始化的5✖3的矩阵，里面是从标准正态分布中抽取出的一组随机数 a = torch.zeros(5, 3, dtype=torch.int) # 0填充，类型为整数，还可以是别的 torch.ones(5, 3) 1填充 torch.eye(3) 3×3的单位矩阵 b = torch.tensor([1, 2, 3, 4]) # 用数据直接构建向量 c = torch.randn_like(b, dtype=torch.float) # 构造形状与b相同的随机数组,torch.ones_like,torch.zeros_like,形状相同的全1.全0 torch.randint(1, 10, [5, 3]) # 构造一个5✖3的矩阵，里面是从[1, 10)中抽取出的一组随机整数 torch.normal(mean, std) # mean和std都是tensor，随机从mean为均值，std为方差的正太分布取值。输出形状为mean的形状。每一项一一对应，相互独立 torch.full([5, 3], 6) # 生成一个5✖3的矩阵，并将元素全部填充为6 torch.arange(0, 10) # tensor([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) torch.arange(0, 10, 2) # tensor([0, 2, 4, 6, 8]) torch.linspace(0, 10, steps=4) # tensor([ 0.0000, 3.3333, 6.6667, 10.0000]) torch.logspace(0, 1, steps=10) # 对数函数中，y轴上在[0, 1]均匀取10个数，返回其对应的x轴上的值 常用函数及操作 idx = torch.randperm(4) a[idx] # idx == tensor([2, 0, 3, 1]) 打乱顺序。将a的第一维度按照idx的顺序重新排列，idx的顺序随机生成 a[i, j] 获取张量a中位于(i, j) 处的元素，类似于python中的a[i][j] a.dim() 返回张量的维度 c.shape == c.size() 都是返回数组形状，返回的是元组 list(c.shape) 将结果变为python中的list c.size(i) 返回上方所得元组中的第i个元素 c.numel() 返回各维度的乘积 x + y == torch.add(x, y) 两数组相加 乘法： 二维 a.mm(b) 多维（包括二维）： a.matmul(b) == a@b 对应元素相乘： a.mul(b) == a*b (4, 3, 28, 64) @ (4, 3, 64, 32) = (4, 3, 28, 32) 即前两维不变，后两维相乘 (4, 3, 28, 64) @ (4, 1, 64, 32) = (4, 3, 28, 32) 利用Broadcasting (4, 3, 28, 64) @ (4, 64, 32) 出错，Broadcasting的4和3不对应 a.pow(i) a的i次方 a.clamp(min[, max]) 夹逼 a.norm(p, dim=0) 对0维上的对应位置的数据分别做p范数 in: a = torch.full([5, 3], 1.) a.norm(2, dim=0) out: tensor([2.2361, 2.2361, 2.2361]) sqrt(5)==2.2361 a.min() a.max() a.mean() a.prod()累乘 a.sum() a.argmax()最大值的索引 a.argmin()最小值的索引【铺成一维后的索引】 a.max(dim=0)返回0维上的最大值及索引 也可以加参数keepdim=True表示结果与a的形状一致 a.argmax(dim=0) 0维上的最大值的索引，a.argmin(dim=0)一样 a.topk(n, dim=1) 返回1维上的前n个最大值及其索引，添加参数largest = False求最小的 a.kthvalue(k, dim=1) 返回1维上的第k小的值及索引 in-place运算符：任何in-place运算符都以 _ 结尾，如x.add_(y) x.add(y) 不会影响x的值，但是x.add_(y)会将计算结果保存在x中。即执行z=x.add(y)与x.add_(y)之后，z的值与x的值相同 各种切片操作都支持，如 x[:, 1:] 包括所有行以及第一行以后的所有列 x = y.numpy() 将torch tensor 转为 numpy array x与y共享内存 y = torch.from_numpy(x) 将torch tensor 转为 numpy array x与y共享内存 torch.rand(1).item() 只包含一个元素的tensor，可以用item()函数将里面的value变为python类型的数值 高级函数 torch.where(condition, a, b) 根据条件选择赋值 condition = torch.rand(2, 2) # tensor([[0.2886, 0.7170], # [0.4666, 0.5724]]) a = torch.zeros(2, 2) b = torch.ones(2, 2) c = torch.where(condition > 0.5, a, b) # tensor([[1., 0.], # [1., 0.]]) # 相应位置，若condition在此处的值大于0.5则c在此处的值被赋予a的值，否则赋予b的值 torch.gather(input, dim, index) 在dim维度上按index的索引搜索input的值并返回 维度变换 x = x.view(3, 5)或x.reshape(3, 5) # 重塑形状，如同numpy中的reshape函数。可以将其中一个参数写为-1，解释器会自动推导。view和reshape本质不会改变数据在内存中的排列规则，只是改变了访问的规则
...</p></div><footer class=entry-footer><span title='2021-07-01 17:45:10 +0000 UTC'>2021-07-01</span>&nbsp;·&nbsp;1074 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to PyTorch笔记" href=https://ethereal-lu.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/pytorch%E5%AD%A6%E4%B9%A0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>c语言数组赋值问题</h2></header><div class=entry-content><p>数组正常初始化是没问题的
char ch[50] = "Reindeer"; 但是分步赋值，或重新赋值就会报错
// 分步赋值 char ch[50]; ch = "Reindeer"; // 重新赋值 char ch[50] = "Reindeer"; ch = "Ethereal"; // 报错 Array type 'char [50]' is not assignable 原因： ch 就是字符数组的首地址，是一个常量，不能作为左值。
解决：可以使用 strcpy 函数赋值
char ch[50]; strcpy(ch, "Ethereal");</p></div><footer class=entry-footer><span title='2021-06-06 20:57:45 +0000 UTC'>2021-06-06</span>&nbsp;·&nbsp;41 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to c语言数组赋值问题" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>javaScript学习笔记</h2></header><div class=entry-content><p>javaScript 也是万物皆对象。
数据类型 ES6开始，所有的局部变量声明都用let，ES5及之前所有的变量声明都用var。
ES6开始支持 “use strict” 即严格检查模式，预防javaScript的随意性导致的一些问题，使用时必须写在javaScript的第一行
数值 弱类型，无需指定具体类型，只看做变量即可。
let a = 1; let b = 1.2; let c = 1e5; 字符串 字符串是常量，不可变。
单引号或双引号都可以，还可以用反引号写多行文字。特殊字符用 \ 转义。\n \r 等与其他语言一样。
模板字符串（和EL表达式一样） ES6才有
let name = "Reindeer"; let greet = "Hello, ${name}"; // "Hello, Reindeer" 方法：java中String的方法基本都有，且名字和作用都一样。在js中字符串可以使用下标，且length是属性不是方法。
数组 js中数组的长度可变：通过给arr.length赋值，可改变数组长度。若变大，新扩展单元为undefined；若变小，则截取前半段
同一个数组中可以包含任意的数据类型，如下：
let arr = [1, "hello", 2.5, 'c', true]; 方法
arr.length; // 数组长度 ------------------------------------------------------------------------ arr.indexOf(2.5); // 通过元素索引下标 ------------------------------------------------------------------------ // 若数组中同时包含 数字1 和字符串"1" ，则他俩不一样 ------------------------------------------------------------------------ newArr = arr.slice(2) // 从下标2开始复制到末尾，返回新数组 newArr = arr.slice(2, 4) // 从下标2开始复制下标4，返回新数组 ------------------------------------------------------------------------ // 作为栈使用 arr.push("Reindeer"); // 向数组尾部压入元素 arr.pop(); // 从数组尾部弹出元素 arr.unshift("Reindeer"); // 向数组头部压入元素 arr.shift(); // 从数组头部弹出元素 // 两者结合也可以用作队列 ------------------------------------------------------------------------ // 其他常用方法 arr.sort(); // 排序 [1, 2.5, "c", "hello", true] arr.reverse(); // 反转 [true, "hello", "c", 2.5, 1] arr.concat([3, 4, 5]); // 拼接，返回新数组，不改变原数组。 arr.join('--') // 连接为字符串，"1--2.5--c--hello--true" let arr = [[1, 2, 3], [4, 5, 6],[7, 8, 9]]; // 多维数组 对象 js 的对象长得和 python 的字典一样。键都为字符串，值任意
...</p></div><footer class=entry-footer><span title='2021-05-31 19:42:15 +0000 UTC'>2021-05-31</span>&nbsp;·&nbsp;1168 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to javaScript学习笔记" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/javascript%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MyISAM与InnoDB 的区别</h2></header><div class=entry-content><p>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务
InnoDB支持外键，而MyISAM不支持。
InnoDB是聚集索引，InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。
InnoDB不保存表的具体行数，而MyISAM用一个变量保存了整个表的行数。（因为事务）
InnoDB支持行级锁，MyISAM不支持。
InnoDB表必须有主键索引（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有。</p></div><footer class=entry-footer><span title='2021-05-22 17:39:41 +0000 UTC'>2021-05-22</span>&nbsp;·&nbsp;6 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to MyISAM与InnoDB 的区别" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/myisam%E4%B8%8Einnodb%E7%9A%84%E5%8C%BA%E5%88%AB/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MySQL概述</h2></header><div class=entry-content><p>基本命令 show columns from user == describe user == desc user查询user表的结构 sql的注释为两个杠 --，多行注释为/* */ 创建表： -- 表明和字段名用反引号引起来是为了防止与sql的关键字相同，更规范 CREATE TABLE IF NOT EXISTS `user` ( -- IF NOT EXISTS 为可选 -- COMMENT 为注释，在表中看不到，但是调出创建表的命令时，可以直观看到字段的含义 `id` int NOT NULL AUTO_INCREMENT COMMENT '学号', `name` varchar(30) DEFAULT NULL COMMENT '名字', `birthday` DATETIME DEFAULT NULL COMMENT '出生日期', `passwd` varchar(30) DEFAULT NULL COMMENT '密码', `perms` varchar(100) NOT NULL DEFAULT 'normal' COMMENT '权限', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 -- 显示声明引擎和默认字符集（可在my.ini中修改） -- 真实开发中还需要有，version（乐观锁）、deleted（逻辑删除）、gmt_create（创建时间）、 -- gmt_modified（修改时间） 修改表 ALTER TABLE teacher RENAME AS teacher1 -- 修改表名 ALTER TABLE teacher ADD age INT -- 添加字段 ALTER TABLE teacher MODIFY age VARCHAR(11) -- 修改字段的约束 ALTER TABLE teacher CHANGE 旧名 新名 INT -- 修改字段名（可以同时修改约束） ALTER TABLE teacher DROP age -- 删除字段 删除表 DROP TABLE IF EXISTS teacher -- 加上判断的删除 查看相关历史命令语句 SHOW CREATE DATABASE mybatis -- 查看创建数据库的语句 SHOW CREATE TABLE `user` -- 查看创建数据表的语句 数据表类型（引擎） MYISAM 早期使用 InnoDB 默认使用 MYISAM InnoDB 事务支持 不支持 支持 数据行锁定 不支持 支持 外键约束 不支持 支持 全文检索 支持 现在支持 表空间大小 较小 较大，约两倍 主要区别 MYISAM 节约空间，速度较快 InnoDB 安全性高，支持事务，多表多用户操作 数据管理 DDL，Data Definition Language，数据库定义语言 用于定义和管理数据库所有对象的语言，包括：CREATE，ALERT，DROP，TRUNCATE DML，Data Manipulation Language，数据库操作语言 SQL中处理数据等操作，包括：SELECT，INSERT，UPDATE，DELETE，CALL，EXPLAIN PLAN，LOCK DCL，Data Control Language，数据库控制语言 用来授予或回收访问数据库和某种特权并控制数据库操纵事务发生的时间及效果，对数据库实行监控，包括：COMMIT，SAVEPOINT，ROLLBACK，SET TRANSACTION delete和truncate的区别 TRUNCATE student == DELETE FROM student 清空表内容
...</p></div><footer class=entry-footer><span title='2021-05-22 17:39:41 +0000 UTC'>2021-05-22</span>&nbsp;·&nbsp;661 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to MySQL概述" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Java学习笔记</h2></header><div class=entry-content><p>数组： 数组的初始化方式： 1、动态初始化（指定长度） 数据类型[] 数组名 = new 数据类型[数组长度]； 2、静态初始化（指定内容） 数据类型[] 数组名 = new 数据类型[] {元素1， 元素2， 元素3， ... }； 元素值可以是变量 省略的静态初始化 数据类型[] 数组名 = {元素1， 元素2， 元素3， ... }； 该方式不允许拆分为2步，即先定义数组名，再经行赋值。 直接打印数组名，打印的是数组的内存地址。 支持下标索引。 未初始化的默认初始值： 整数类型： 0 浮点类型： 0.0 字符类型： '\u0000' 布尔类型： false 引用类型： null 获取数组长度： 数组名.length; 获取数组副本： 数组名.clone(); 成员变量与局部变量： 成员变量定义在类内，方法外。局部变量定义在方法内。 成员变量不要写static关键字。??? 成员变量有默认值，而局部变量没有默认值。 当成员变量与局部变量的命名冲突时，按照就近原则，优先使用局部变量。若想使用全局变量，使用this.成员变量名。 可变参数: 使用前提：当方法的参数类型确定，但是参数个数不确定时，使用可变参数。 使用格式：修饰符 返回值类型 方法名(数据类型...变量名) {} 例如: public void func (int... num) {} 原理： 可变参数底层是一个数组，根据传递参数个数的不同，会创建不同长度的数组，来存储这些参数。参数个数可以是0个或多个。 因此，方法中的变量名其实就是数组的名字，可以作为数组使用。 注意： 一个方法的参数列表中只能有一个可变参数。 如果方法有多个参数，则可变参数必须放在参数末尾。 类的使用: 1、导包：import 包路径.类名称 当类与当前文件处于同一个包中时，可以不用导包。只有java.lang下的包不需要导包，其他都需要导包。 但实际使用中，可以不用手动导包，当你使用某个类时，系统会自动帮你导包。 2、实例化： 类名称 对象名 = new 类名称(); 3、使用: 对象名.成员变量名 对象名.成员方法名(参数) Private: Getter: 函数格式必须是 getXXX 如果变量是布尔类型，则使用isXXX Setter: 函数格式必须是 setXXX Private修饰构造函数时，外部不能再构造该类的实例，故只能在类内构造好全部实例并赋给static类型的变量。叫构造函数私有化 this: this是当前对象的引用，即this和对象是同一个东西。 this.成员变量 调用本类成员变量 可以将类内的成员变量与方法中的同名局部变量区分。 this.成员方法 调用本类成员方法 this(...) 调用本类构造函数 --> 写在第一行，只能调用一个。 若子类使用了this(...)，则不再默认赠送super()。 super: super.成员变量 调用父类成员变量 可以将父类中的成员变量和子类中的同名成员变量区分。 super.成员方法 调用父类成员变量 super(...) 调用父类类构造函数 --> 写在第一行，只能调用一个。 构造函数： 格式： public 类名（参数类型 参数名称 ， ...）{...} 注意事项： 构造方法的名称和类名要严格相等，大小写敏感。 构造方法没有返回值类型。 若不明确定义构造函数，则会自动生成默认构造函数，若手动定义了任意形式的构造函数，编译器将不会再生成默认构造函数。 构造函数支持重载 继承中的构造函数: 构造链：同C++一样--> 祖宗 > 父类 > 子类 子类构造方法中若不显式调用super，则默认隐含一个 "super()" 调用。 子类构造函数可以显式地写 super([参数1，...]) 来调用父类的重载构造函数。且必须在方法体的第一行，即只能调用一个。 标准类：也叫做 Java Bean 通常包含以下4部分内容： 所有的成员变量都要使用private关键字。 为每一个成员变量编写一对儿Getter/Setter方法 编写一个无参构造函数 编写一个全参构造函数 点击 Code->Generate 或者 快捷键 alt + insert 可以自动生成上述内容 ==： 对于基本类型， == 比较的是值 对于引用类型， == 比较的是地址 基本类型与字符串之间的转换： 基本类型 --> 字符串 1、基本数据类型的值+"" 最简单的方式（工作中常用） 2、使用包装类的静态方法 static String toString(int i) 将i变为字符串形式 如 Integer.toString(100); 3、使用String类的静态方法 static String valueOf(int i) 将i变为字符串形式 如 String.valueOf(100); 字符串 --> 基本类型 使用包装类的静态方法 parseXX("字符串") Integer static int parseInt(String s) 如 Integer.parseInt("100"); ... ... 泛型: 泛型名字不一定是E，可以是任意大写字母。 类: public class ClassName&lt;E> { ... 在类内将需要的地方都用E代替} 实例化对象时确定类型 方法: 修饰符 &lt;E> 返回值类型 方法名(参数列表){ ... } 调用方法时确定类型 接口: 含有泛型的接口定义与类相同。 确定类型的方法：1、在实现类中确定类型 2、实现类依然沿用接口的泛型E，实现类创建对象时确定类型 通配符: &lt;?> 代表任意数据类型， 使用: 例如当多个不同类型的ArrayList集合要作为参数调用同一个方法时，可以将参数设置为ArrayList&lt;?> list方便接受任意类型。 高级使用: ? extends E 表示 ? 只能是E的子类/本身 ? super E 表示 ? 只能是E的父类/本身 static: 带上static的成员变量或函数，不属于对象，而是属于类，所有对象共享。 类名.静态变量 类名.静态方法() 注意事项：静态不能直接访问非静态 --> 在内存中，先有静态，后有非静态 静态不能使用this 静态代码块：static{ ... } 首次用到类时，静态代码块唯一执行一次。 典型用途：一次性地对静态成员变量赋值。 override: 在子类的覆盖重写方法前面加上 @override 可以检验该方法是否为重写方法（建议写上） 子类方法的返回值的范围必须 小于等于 父类方法的返回值的范围。 子类方法的权限必须 大于等于 父类方法的权限 权限： public > protected > (default) > private (default) 表示什么也不写，留空。 同一个类 YES YES YES YES (我自己) 同一个包 YES YES YES NO (我领居) 不同包子类 YES YES NO NO (我儿子) 不同包不同类 YES NO NO NO (陌生人) abstract: 抽象方法：只定义，不实现。加上abstract关键字，去掉大括号，直接分号结束。 抽象类： 抽象方法所在的类，必须是抽象类。在class前加上abstract即可。但抽象类中不一定包含抽象方法（通常是有的）。 使用步骤： 抽象类不能直接创建对象。 必须用一个子类继承抽象父类。 子类必须覆盖重写抽象父类中的所有抽象方法。-->此处覆盖重写即实现：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。 创建子类对象，并使用。 interface： 概念：接口就是多个类的公共规范。是一种引用数据类型，最重要的就是其中的抽象方法。 定义：public interface 接口名称 { ... } 包含：常量、抽象方法、默认方法、静态方法、私有方法。 常量：可以理解为成员变量，但是必须使用 public static final 三个关键字修饰，故相当于常量。 public static final 数据类型 常量名称 = 值 （三个关键字可省略，但不能换为别的） 注意：1、接口中的常量可以省略public static final，但写不写效果一样。 2、接口中的常量必须手动赋值，不能不赋值。赋值之后无法改变。 3、常量名称全部大写，由下划线连接。 使用：接口名称.常量 抽象方法：1、接口中的抽象方法，修饰符固定为 public abstract (可省略，但不能换为别的) 2、方法的三要素可随意定义。 默认方法：public default 返回值类型 方法名(参数列表) {方法体} (public可省略，default不能省略) 可以解决接口升级的问题。（不想改变实现类，但是接口中又想要添加新方法，则接口就可以用默认方法自己实现）（实现类可以覆盖重写默认方法） 默认方法会被实现类继承，故可以通过实现类的对象访问默认方法。 静态方法：public static 返回值类型 方法名(参数列表) {方法体} (public可省略，static不能省略) 使用：接口名称.静态方法(参数); 不能通过对象访问。 私有方法：1、普通私有方法：解决多个默认方法之间的重复代码问题 private 返回值类型 方法名(参数列表) {方法体} 只有接口中的默认方法能访问。 2、静态私有方法：解决多个静态方法之间的重复代码问题 private static 返回值类型 方法名(参数列表) {方法体} 只有接口中的默认方法和静态方法能访问。 使用：1、接口不能直接使用，必须有一个“实现类”来“实现”该接口。 public class 实现类名称 implements 接口名称 {...} 2、接口的实现类必须实现接口中的全部抽象方法。去掉abstract关键字，加上大括号实现体。 3、创建实现类对象，使用。 注意事项：1、接口没有静态代码块和构造方法。 2、如果实现类没有覆盖重写所有接口中的所有方法，则该实现类自己就必须是抽象类。 3、一个实现类可以实现多个接口 public class 类名 implements interface1, interface2 {}。 4、若一个类实现的多个接口中有重名的抽象方法，则只需实现一个即可。 5、若一个类实现的多个接口中有重名的默认方法，则该实现类必须对重名默认方法覆盖重写。 6、若一个类的直接父类中的方法和它实现的接口中的默认方法重名，则优先使用直接父类的方法。 在java中【继承 优先于 接口】 7、接口是多继承的。多个父接口当中的抽象方法如果重名，没关系。 多个父接口当中的默认方法如果重名，则子接口必须对重名的默认方法覆盖重写，【而且带着default关键字】 多态：（一个子类对象既有子类形态，又有父类形态）一个对象拥有多种形态，即【对象】的多态性。【多态性指的是对象，而不是类】 代码中体现多态性： 父类引用指向子类对象。 格式 父类名称 对象名 = new 子类名称(); 或 接口名称 对象名 = new 实现类名称(); 【初步理解: 定义了一个指向子类对象的父类引用，这个引用指向的是子类的对象，但是只能访问父类大小的内存空间，所以它只能访问父类继承到子类当中的成员 （包括成员变量和成员函数）的那部分内存空间，而不能访问子类独有的多出来的那部分内存空间，而对于被子类重写了的方法，该引用依然可以访问 这部分内存，只是内存中的内容已经被改写了，所以访问到的是子类重写之后的方法。综上所述，该引用能访问的范围是所有从父类继承下来的变量和 父类独有方法，以及被子类重写之后的方法。】 多态对象访问成员变量： 对象名.成员变量 访问的是父类的成员变量，若没有则向上找，不会向下找。 不能用这种方法访问子类特有成员变量。 多态对象访问成员函数： 若子类重写了父类的成员函数，则访问子类的成员函数。 若子类没有重写，则访问父类的成员函数，没有则向上找。 同样不能访问子类特有成员函数。 记忆口诀；对于成员变量，等号左边是谁就优先用谁。对于成员方法，new的是谁就优先用谁。 使用多态的好处：比如将父类的引用作为参数传入方法中，则该引用可以指向不同的子类对象使方法实现不同的功能，却不需要改变方法中的任何代码。 对象的向上转型： 在特定场合会自动向上转型，如方法参数要求为父类，但是传入一个子类对象也正确，这时就发生了自动向上转型。与int double发生自动类型转换原理一样。 格式：与多态相同：父类名称 对象名 = new 子类名称(); 含义：创建一个子类对象，把它当作父类来看待使用。 【向上转型一定是安全的】从小范围转向了大范围，如将小范围的猫向上转型为更大范围的动物。 类似于将short转换为int。 弊端：不能访问子类特有方法。 对象的向下转型：其实是一个【还原】的动作。 格式： 子类名称 对象名 = (子类名称) 父类对象; (子类名称)必须有，不能省略。 含义： 将向上转型之后的父类对象还原为本来的子类对象。 注意： 只有本来是猫，向上转型为动物后，再向下转型为猫才是正确的。 若本来不是猫，却硬要向下转型为猫就会出错(编译不会报错，但运行会出现异常ClassCastException)。 instanceof: 格式： 对象名 instanceof 类名 作用： 返回一个布尔值，判断前面的对象能不能当作后面类的实例。 应用： 在向下转型之前，判断需要转型的对象是不是目标类的对象，是则向下转型，不是则不转型。 final: 该关键字表示最终的，不可再改变的。 用法: 修饰一个类、方法、局部变量、成员变量。 修饰一个类： public final class 类名 {...} 不能有子类。 修饰一个方法： 该方法不能被重写。 对于类和方法，abstract 和 final 不能同时使用，会矛盾。 修饰一个局部变量： 一次赋值，终生不变。（可以先定义，再赋值。分两步）--对于基本类型，值不可变。对于引用类型，地址值不可变。 修饰一个成员变量： 由于成员变量有默认值，所以不能分两步，必须当场手动赋值或通过构造函数赋值。 修饰一个数组或集合： 该数组或集合不能再被赋值，但内部的数据还可以改变。 内部类： 一个类内部包含另一个类，即一个事物内部包含另一个事物。 例如 身体和心脏的关系 分类： 成员内部类 局部内部类（包含匿名内部类） 成员内部类：修饰符 class 外部类名称 { 修饰符 class 内部类名称 {...} ... } 内用外，随意访问。外用内，需要内部类对象。 在main方法中使用：1、间接方式： 在外部类的方法中调用内部类，然后main通过访问外部类的方法调用内部类。 2、直接方式： 外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称(); 当局部变量、内部类的成员变量、外部类的成员变量重名时： 内部类的成员方法调用内部类的成员变量用this.内部成员变量。 内部类的成员方法调用外部类的成员变量用Outer.this.外部成员变量。 局部内部类：如果一个类定义在方法内部，就是局部内部类。---只有当前所属的方法才能使用它，出了这个方法就不能使用了。 格式：修饰符 class 外部类名称 {... 修饰符 返回值类型 外部类方法名称(参数列表) { class 内部局部类名称 {...} ... } ...} 注意：若局部内部类要访问所在方法的局部变量，则该局部变量必须是【有效final的】（即可以不写final关键字，但是不能变） 因为局部内部类在堆中，生命周期长，而局部变量在栈中，生命周期短，所以不能变。 【匿名内部类】：【用的最多】 如果接口的实现类（或者父类的子类）只需使用唯一的一次，则可以省略该类的定义，而改为使用匿名内部类。 格式：接口名称 对象名 = new 接口名称() { 重写所有抽象方法 }; 注意：1、匿名内部类只能唯一【创建一次对象】。若想多次创建对象，就要单独定义实现类。 2、匿名对象只能唯一【调用一次方法】。若想多次调用方法，就要给对象起个名字。 3、匿名内部类是省略了实现类/子类名称。而匿名对象是省略了对象名称。他俩不是一回事。 new 接口名() { 重写所有抽象方法 }.方法(参数); 即匿名内部类又匿名对象的使用方法。 异常: throw : 用于抛出异常， 例如: throw new NullPointerException("异常产生的原因") 若抛出运行时异常，可不理会，默认由JVM处理 若抛出编译器异常，则必须处理。throws或try-catch throws: 声明异常。 (用于甩锅) 格式: 修饰符 返回值类型 方法名(参数列表) throws AAAException, BBBException... {throw new AAAException("原因")...} 注意: 1、throws必须写在方法声明处 2、throws后面必须是Exception或者是其子类 3、throws后面必须声明方法内部抛出的所有异常 4、若调用了一个声明抛出异常的方法，则必须处理这些异常。可以继续抛出，也可以自己处理。 try-catch: 自己处理异常 try可以抛出多个异常，这时需要使用多个catch来捕获异常。 try中若产生异常，则try代码块中产生异常之后的代码不会执行，而跳转到catch。 try中若没有产生异常，则执行完try中的代码继续执行try-catch之后的代码。 finally: 不论是否发生异常，finally代码块中的代码一定会执行。 格式 : try{} catch{} finally{} 注意 : finally必须与try一起使用，一般用于资源释放。 正是由于其有一定会执行到，所以若finally代码块中有return语句，则一定会返回finally中的结果。（要避免） 注意 : 子类异常一定要与父类异常一致。 Thread : Thread类是描述线程的类，要实现多线程，必须继承Thread类 每个线程拥有一个自己独立的栈，但是共享进程的堆空间。 Thread.sleep(毫秒) // 静态方法 睡眠 Thread thread = Thread.currentThread(); // 获取当前线程 第一种方法： 创建Thread类的子类 1、创建Thread类的子类，并重写run方法，其中设置线程的任务 2、创建子类对象，并执行start方法 (执行start方法会创建一个新的栈空间，并在该栈空间中执行run方法)(每执行一次步骤2，就开启一个新的线程) 第二种方法： 实现Runnable接口 (推荐使用这种) ---> 使用该方法时，Thread 类是咱们自定义类的静态代理类 1、创建一个Runnable接口的实现类，并重写run方法，其中设置线程的任务 2、创建对象，并将其作为参数传递给Thread类的构造方法，再调用start方法。 new Thread(new MyRunnable()).start(); 匿名内部类实现： new Thread(new Runnable(){重写run方法}).start(); 第三种方法： 实现Callable&lt;V>接口 （面试可能会问到） Callable接口类似于Runnable，【Runnable不会返回结果，也不会抛出检查异常，Callable可以】 1、创建一个Callable&lt;V>接口的实现类，并重写call方法，其中设置线程的任务 2、在使用的地方创建该类对象 obj 。 3、ExecutorService executorService = Executors.newFixedThreadPool(5); // 创建执行服务 4、Future&lt;V> future = executorService.submit(obj); // 提交执行 5、V result = future.get(); // 获取结果 6、executorService.shutdownNow(); // 关闭服务 同步： 多个对象访问同一个资源，可以并发读取，但当其中某一个对象要修改时，就必须实现同步 所有的对象都拥有一把锁。 锁对象选取总结为一句话就是 在同步代码中要改变谁就锁谁。 方法一： 同步代码块： synchronized (锁对象) {访问共享数据的代码} 线程不仅要抢夺CUP，还要占用锁对象。同时拥有才能执行代码 锁对象可以是任意对象，但必须是同一个对象，推荐将共享资源作为锁对象。线程占用锁对象后直到执行完毕才释放。 方法二： 同步方法 修饰符 synchronized 返回值类型 方法名 (参数列表) {访问共享数据的代码} // 该方法即为同步方法 首先将 访问共享数据的代码块 抽取出来，作为上述方法。 同步方法的锁对象默认为 this ，即同步方法所在类的对象；创建该类的对象后，该对象调用同步方法时就会锁住对象自己。 当同步方法同时也是静态方法时，锁对象为同步方法所在类的 Class 对象。 方法三： Lock锁 Lock是一个接口，有两个方法 void lock() 获取锁 和 void unlock() 释放锁 它有一个实现类ReentrantLock（可重入锁）， 先实例化一个ReentrantLock对象。 在出现安全问题代码之前用该对象调用 lock() 方法。在出现安全问题代码之后用该对象调用 unlock() 方法。 lock() 和 unlock() 方法建议放在 try --- finally 代码块中 线程状态： 线程停止：不推荐使用 Thread 类提供的 stop() 等方法。推荐自己通过一个标志位控制停止 public class MyRunnable implements Runnable { private boolean flag = true; @Override public void run() { while (flag) { TODO... } } public void stop() { flag = false; } } 通过调用自己实现的 stop 方法来停止线程 下方所有方法都是 Thread 类中的方法！ 线程休眠：Thread.sleep(毫秒) // sleep 不会释放锁、 wait 会释放锁。 线程礼让： Thread.yield(); 使当前线程从运行状态变为就绪状态，让 cpu 从所有就绪的线程中挑一个运行。 礼让有可能不成功，因为 cpu 可能再挑选一次还是让当前线程继续执行。 线程强制执行： join() ，相当于插队，停止现在执行的线程，立刻执行自己的线程，且本线程执行结束才能执行其他线程 public class MyRunnable implements Runnable { @Override public void run() { for (int i = 0; i &lt; 1000; i++) { System.out.println("Runnable " + i); } } public static void main(String[] args) throws InterruptedException { MyRunnable myRunnable = new MyRunnable(); Thread thread = new Thread(myRunnable); thread.start(); for (int i = 0; i &lt; 500; i++) { if (i == 200) { thread.join(); } System.out.println("主线程" + i); } } } 在上方举例代码中，主线程执行到200之前，主线程和Runnable线程交替执行，当主线程执行到200次时， Runnable 线程插队接着执行，之后Runnable线程全部执行完毕后才由主线程继续执行。 查看线程状态：Thread.State state = thread.getState(); // Thread.State 是一个枚举类型 线程优先级：1 最小；10 最大；默认为5。优先级越高在就绪状态很大可能越早执行，但也不是一定。 守护（daemon）线程： 线程分为用户线程和守护线程。 虚拟机必须保证用户线程执行完毕，但不用等待守护线程执行完毕。 守护线程有：后台记录日志、监控内存、垃圾回收等 private boolean daemon = false; // 默认 daemon 属性是关闭的，即默认为用户线程 thread.setDaemon(true); // 可通过这样将线程设置为 守护线程。 // 将线程设置为守护线程之后，虚拟机将不再保证该线程是否执行结束， // 即只要当用户线程执行结束后就将整个程序关闭，而不考虑守护线程此时是否已经执行完毕。 线程池 : 底层原理 ： 线程池就是一个容纳多个线程的容器，可由集合实现 使用步骤: 1、使用线程池工厂类Executors里面的静态方法newFixedThreadPool生产一个指定线程数量的线程池，由ExecutorService接口接收。 2、创建Runnable接口的实现类，重写run方法，设置线程任务。 3、调用ExecutorService中的execute方法，传递线程任务，开启线程，执行run方法。 例: ExecutorService executorService = Executors.newFixedThreadPool(5); // 创建服务 Runnable runnable = new Runnable() { //此处虽然new 的是Runnable接口，但是立即重写了run方法，故相当于其实现类。 @Override public void run() { //线程任务 } }; executorService.execute(runnable); // 执行服务 executorService.shutdownNow(); // 关闭服务 ExecutorService 中的 submit()方法和 execute()方法作用相同，只是适用于不同场景 void execute(Runnable command) // 执行任务，没有返回值，一般用于执行 Runnable &lt;T> Future&lt;T> submit(Callable&lt;T> task); // 执行任务，有返回值，一般用于执行 Callable Lambda表达式 : 可推导，可省略 格式： () -> {} 使用前提： 必须是接口，且接口中有且只有一个抽象方法 (有且只有一个抽象方法的接口，称为"函数式接口") 可以省略的内容： 1、(参数列表) 参数列表中的数据类型可以省略， 如果参数只有一个，则括号()也可以省略 2、{方法体} 如果{}中的代码只有一行，无论是否有返回值，都可以省略 {}， return， 分号 （要省一起省） 注解: @override 检测是否为覆盖重写 @FunctionalInterface 检测是否为函数式接口 ------------------------------------------------------------------------------------------------------------------ API使用： Scanner： 功能：从键盘输入数据到程序。 包路径：java.util.Scanner 实例化：Scanner sc = new Scanner(System.in); System.in 表示从键盘输入数据。 方法：---其实键盘输入的一切东西都是字符串，使用不同的函数会将字符串转换为相应的类型。-->故若记不住也可以一直使用sc.next();之后再转换类型 获取键盘输入的一个int数字： int num = sc.nextInt(); 获取键盘输入的一个字符串： String str = sc.next(); 读取文件内容：Scanner in = new Scanner(Paths.get("\u202AC:\\Users\\Lenovo\\Desktop\\1.txt"), StandardCharsets.UTF_8); 之后再用in的各种方法。nextLine(); next(); nextInt(); 等 Random: 功能: 获取随机数。 实例化：Random rand = new Random(); 方法：int rand_num = rand.nextInt(n) 在[0, n)中随机取一个数字。----> m + rand.nextInt(n)取到[m, m + n）中的随机数。 ArrayList: [元素1， 元素2， 元素3， ...] 功能：可变长的数组。 泛型：装在集合中的元素必须是同一个类型，只能是引用类型，不能是基本类型。 实例化：ArrayList&lt;String> list = new ArrayList&lt;>(); 注意事项：直接打印list输出的不是一个地址值，而是空的中括号。 不支持下标索引，只能用get()方法获取。 常用方法：list.add("李沁") 添加元素，返回一个boolean值，表示添加的动作是否成功。一定成功，可以不接受返回值。 list.get(index) 根据索引获取元素，返回获取的元素。 list.remove(index) 根据索引删除元素，返回被删除的元素。 list.size() 获取集合长度。 若想在ArrayList中存储基本类型，需要使用其包装类(引用类型)： 基本类型 包装类 byte Byte short Short ... ... （与上方一样，只需首字母大写） int Integer 【特殊】 char Character 【特殊】 ArrayList&lt;Integer> list_int = ArrayList&lt;>(); // 自动装箱：int --> Integer 自动拆箱：integer --> int String: 功能：字符串（常量） --> Java中所有的双引号字符串都是String类的实例。 实例化：直接创建： String str1 = "李沁"; 在字符串常量池中， 其他实例化方式都在堆中，不在池里。 使用空构造函数： String str2 = new String(); 根据字符数组创建： char[] charArray = { 'a', 'b', 'c' }; String str3 = new String(charArray) // abc 根据字节数组创建： byte[] byteArray = { 97, 98, 99 }; String str3 = new String(byteArray) // abc 方法：str1.equals(str2) 比较str1和str2的值是否相等，返回boolean。 常变量比较时推荐 常量.equals(变量) str1.equalsIgnoreCase(str2) 忽略大小写。 str.length() 长度 str.concat(str1) 拼接 str.charAt(index) 根据索引返回字符 str.indexOf(str1) 在str中查找str1，返回首次找到的索引值；若没有，返回-1 str.substring(index) 截取，从index到末尾 str.substring(int begin, int end) 截取，[begin, end) str.toCharArray() 转换为字符数组 str.getBytes() 转换为字节数组 用于遍历字符串 str.replace(old, new) 用new替换str中的old str.split(regex) 切割，返回数组 Arrays: 功能：与数组相关的类，提供大量静态方法，用来实现数组常见的操作。 方法： Arrays.toString(数组) 将参数变成字符串 [元素1， 元素2，元素3，...] Arrays.deepToString(多维数组) 将参数变成字符串 [元素1， 元素2，元素3，...] Arrays.sort(数组) 排序。默认从小到大，自定义类型的排序需要Comparable或Comparator接口 Arrays.equals(数组1， 数组2) 两个数组完全相等是返回ture Math: 功能：数学相关的类，提供大量静态方法，用来实现数学运算相关的操作。 方法： Math.abs() 绝对值 Math.ceil() 向上取整 Math.floor() 向下取整 Math.round() 四舍五入 Collection接口: 所有单列集合的顶层接口 List接口: 1、有序（存入和取出的顺序一致） 2、允许元素重复 3、有索引 Vector:(了解) Arraylist:(重点) 底层由数组实现，查询快，增删慢。 LinkedList:(次之) 底层由链表实现，查询慢，增删快。 特有方法: addFirst() == push() addLast() == add() getFirst() getLast() removeFirst() == pop() removeLast() 这两种方法都会删除并返回 共有方法： void add(int index, E element) 将元素添加到索引位置 E get(int index) 返回索引处的元素 E remove(int index) 删除索引位置元素,并返回被删除的元素 E set(int index, E element) 替换索引位置元素,并返回被替换前的元素 Set接口: 1、不允许元素重复 2、没有索引 TreeSet: (无序) (了解) 底层由二叉树实现，一般用于排序。 HashSet: (无序) (重点) 底层由哈希表实现。(查询速度很快) 注意: 使用HashCode存储自定义类型时，需要重写HashCode()和equals()。可通过alt + insert直接添加。才能保证元素不重复。 LinkedHashSet: (有序) (次之) 底层由哈希表+链表实现。 extends HashSet 比HashSet多了一条链表，用来记录元素的顺序 共有方法： boolean add(E e) 添加， 无需接收 boolean remove(E e) 删除， 若有e，删除并返回true。若没有e，无动作并返回false void clear() 清空。 但不删除集合。 boolean contains(E e) 是否包含。 boolean isEmpty() 是否为空。 int size() 元素个数。 Object[] toArray() 转为数组。 哈希值: 是一个十进制的整数，由操作系统随机给出的对象的逻辑地址值。 哈希表: 拉链法。由哈希值为元素组成数组（初始长度为16）。若哈希值相等，则以链表方式挂在该哈希值后面。当链表长度超过8时，变为红黑树。检索速度加快。 Collections : 是Collection的工具类，提供大量静态方法，用于操作集合。 以ArrayList为例: ArrayList&lt;String> list = new ArrayList&lt;>(); addAll(Collection&lt;T> c, T... elements) : 往集合中添加多个元素。 Collections.addAll(list, "a", "b", "c"); shuffle(List&lt;T> list) : 打乱顺序。 Collections.shuffle(list); sort(List&lt;T> list) : 排序， 默认升序。 Collections.sort(list); 注意：若要对自定义类型排序，则被排序的类必须实现Comparable接口，重写compareTo方法来定义排序规则。 this - 参数 ： 升序 (了解)另一种sort()： Collections.sort(arr, new Comparator&lt;Integer>() { @Override public int compare(Integer o1, Integer o2) { return o1 - o2; } }); 这种方法List接口中的方法类似-> arr.sort(new Comparator&lt;Integer>() {...}) Iterator: 迭代器 是接口 也有泛型 --> Collection&lt;String> array = new ArrayList&lt;>(); Iterator&lt;String> it = array.iterator(); 常用方法: boolean hasNext() 是否有下一个元素。 E next() 返回下一个元素。 使用： Collection中的实现类为 iterator() 1、实例化iterator 2、用hasNext() 3、用next() 增强for循环: 专门用来遍历数组与集合，由Iterator迭代器实现，遍历时不能做增删操作。 for (元素数据类型 变量 : 集合或数组名) { ... } Map: --> 字典 键值对 key是唯一的 HashMap: (无序) 底层为哈希表 LinkedHashMap : (有序) 底层为哈希表+链表(保证顺序) 方法: V put(K key, V value) : 添加，若key值不存在，则添加并返回null。若key值已存在，则更新value值，并返回被替换掉的value值。一般不接收返回值。 V remove(K key) : 删除，若key值存在，返回被删除的value。若key不存在，则返回null。 V get(K key) : 获取，若key值存在，返回对应的value。若key不存在，则返回null。 boolean containsKey(k key) : 判断是否包含指定的键。 Set&lt;K> keySet() 返回由键组成的Set，之后可以通过遍历Set来遍历Map。 for (K key : map.keySet()) { sout(key + map.get(key)) } Set&lt;Map.Entry&lt;K, V>> entrySet() --> for (Map.Entry&lt;K, V> entry : map.entrySet()) { 也是遍历，看起来不好用的样子 System.out.println(entry.getKey() + ' ' + entry.getValue());} 用Map存储自定义类型时，若自定义类型作为键，则必须将该类重写HashCode和equals方法，保证键是唯一的。 of方法： static &lt;E> List&lt;E> of (E... elements) 1、of方法只适用于List, Set, Map 接口。而不适用于他们的实现类 2、of方法返回一个不能被操作的集合。因此适合初始化，且初始化后不能改变。 3、Set 和 Map 调用of方法时不能有重复元素。 ------------------------------------------------------------------------------------------------------------------ ------------------------------------------------------------------------------------------------------------------ ------------------------------------------------------------------------------------------------------------------ ------------------------------------------------------------------------------------------------------------------ Object： 以下方法所有类都有，只是重写之后功能有所不同。 toString() 直接打印对象的名字，就是调用对象的toString方法->得到对象的地址值。 没有意义。 重写：可以和构造方法与Getter/Setter方法一样的步骤添加（重写）toString方法->打印出属性值。 equals() boolean equals(Object obj) 判断两个对象是否"相等"，返回布尔值。 比较两个对象的地址值，同上方的==作用一样。 没有意义。 重写： 原理 --> 由于equals方法的参数类型为Object,所以默认向上转型了。若想比较两个对象的属性值，需要先向下转型。 同样可以 alt + insert 直接生成equals方法。 判断两对象的属性值是否都一样。 hashCode() 返回对象的哈希码值 // synchronized 能实现线程同步、但无法实现线程间通信、用如下 4 个方法可以实现线程间通信。 wait() 等待。在被唤醒之前，放弃CPU的使用权 wait(毫秒值) 在被唤醒或到时间之前，放弃CPU的使用权 notify() 唤醒。随机唤醒锁对象中的一个进程 notifyAll() 唤醒锁对象(对象监视器)中的所有进程 这两种常搭配同步机制使用 objects: 该工具类提供的方法是容忍空指针的。 若 a=null，则a.equals(b) 报错。而Objects.equals(a, b) 正常运行。 Objects.requireNonNull(T obj) 查看obj是否为空，用来判断参数的合法性。 旧API : Date: 1970年1月1日 00:00:00 作为0时刻 Date() 无参构造--> 获取当前时间。 Date(long date) 有参构造 --> 输入毫秒值，输出相对于0时刻的日期。 getTime() 把日期转换为毫秒 DateFormat: 格式化日期。 抽象类。 String format(Date date) 把日期格式化为字符串。 Date parse(String source) 把符合的字符串解析为日期。 SimpleDateFormat: DateFormat的实现类 SimpleDateFormat(String pattern) 有参构造 参数一般为 "yyyy-MM-dd HH:mm:ss" 使用上方两个方法。 注意：用parse时，参数的模式必须与构造SimpleDateFormat对象时的模式完全一样，否则报错。 Calendar: 日历类 抽象类 getInstance() 静态方法 返回Calendar类的子类对象 Calendar instance = Calendar.getInstance(); 功能：使用默认时区和语言环境获得一个日历 get(field) 返回给定字段的值。 字段值有YEAR MONTH DATE HOUR MINTER SECOND 年月日时分秒 都是静态变量 set(field, value) 将给定的日历字段设置为给定值 add(field, amount) 修改指定的字段，通过amount的正负实现加减。 Date getTime() 将Calendar转为Date对象 原理：实际上该类中有一个fields数组，上述的方法都是在对该数组操作。字段值YEAR等固定为0，1，2等，作用是对该数组的索引。 新API LocalDate, LocalTime, LocalDateTime : 之前的Date类和Calendar类都有缺陷。JDK8 新引入日期时间类 由于LocalDateTime类使用较多，故以他为例，其余两种用法相同。 构造方法： 1、LocalDateTime now = LocalDateTime.now(); 获取当前时间 2、LocalDateTime localDateTime = LocalDateTime.of(2020, 1, 20, 12, 20, 34); 获取指定时间 常用方法： now.getDayOfMonth() 获取对象是这个月的第几天。类似的方法获取其他属性。 LocalDateTime time = now.withDayOfMonth(12); 使用类似方法设置属性。但是该语句执行后，time为修改后的值，而now的值不变。体现了时间的不可变性。 LocalDateTime plusDays = now.plusDays(3); 使用类似方法修改属性，在原有基础上加3天。不可变性同上。 LocalDateTime months = now.minusMonths(2); 使用类似方法修改属性，在原有基础上减2月。不可变性同上。 Instant 替换 Date 类 DateTimeFormatter : 类似于SimpleDateFormat 日期时间的格式化与解析 DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"); 构造 String format = formatter.format(LocalDateTime.now()); 格式化 TemporalAccessor parse = formatter.parse("2021-01-21 22:00:25"); 解析 System: 提供大量静态方法， 可以获取与系统相关的信息即服务 static currentTimeMillis() 返回以毫秒为单位的当前时间, 用来测试程序的效率。 static arraycopy(原数组， int 原数组起始位置， 目标数组， int 目标数组起始位置， int 要复制的数组元素的数量) 复制数组 StringBuilder: 在String类中，字符串是常量，底层是被final修饰的数组。字符串相加时，占用内存多，效率低下。 StringBuilder类是字符串缓冲区，可以提高字符串的操作效率（看成是一个长度可以变化的字符串） 底层也是一个数组，但是没有被final修饰，可以改变长度。 在内存中始终是一个数组，初始容量为16个字节，超出会自动扩容，占用空间少，效率高。 构造函数： StringBuilder() 无参构造，空字符串。 StringBuilder("abc") 有参构造，即参数的字符串。 成员函数： append(任意类型) 添加到字符串，并返回自身。所以无需接收。 toString() 将StringBuilder对象，转换为String对象。 通过StringBuilder的构造方法可以将String转换为StringBuilder. reverser() 翻转 File: 文件类，主要用于文件和目录的创建，查找和删除等操作 File类已被Path取代 静态方法: static String pathSeparator 路径分隔符 windows ; 分号 linux : 冒号 static String separator 文件名称分隔符 Windows \ 反斜杠 Linux / 正斜杠 构造方法: File(String pathname) 路径名 ==> 文件/文件夹 相对/绝对 存在/不存在 File(String parent, String child) 父路径，子路径 File(File parent, String child) 父路径，子路径。父路径是File型，故可以使用其方法做调整 常用方法: 获取方法: String getAbsolutePath() 返回绝对路径名 String getPath() 返回路径名 String getName() 返回末尾文件/文件夹 名字 long length() 返回文件大小（以字节为单位） 不能是文件夹，若路径不存在，返回0 判断方法: boolean exists() 文件或文件夹是否真实存在 boolean isDirectory() 路径是否以文件夹结尾 前提：真实存在 boolean isFile() 路径是否以文件结尾 前提：真实存在 创建删除: boolean creatNewFile() 不存在时创建文件 不能创建文件夹，路径必须存在 boolean delete() 删除文件/文件夹 boolean mkdir() 创建单级空文件夹 boolean mkdirs() 创建单级/多级空文件夹 多级文件夹：父文件夹中包含子文件夹 遍历文件夹: String[] list() 返回由所有文件或子目录组成的字符串数组 File[] listFiles() 返回由所有文件或子目录封装而成的文件数组 过滤器: File[] files = dir.listFiles(new FileFilter(){重写accept()方法，该方法中写入过滤规则，留下的返回ture，不要的返回false}) 可以写为Lambda表达式。 读取文件的方法： Scanner in = new Scanner(Paths.get("C:\\Users\\Lenovo\\Desktop\\1.txt"), StandardCharsets.UTF_8); String num = in.nextLine(); BufferedReader reader = Files.newBufferedReader(Paths.get("C:\\Users\\Lenovo\\Desktop\\1.txt"), StandardCharsets.UTF_8); String str = reader.readLine(); （不好用）BufferedReader bufferedReader = new BufferedReader(new FileReader("C:\\Users\\Lenovo\\Desktop\\1.txt")); String s = bufferedReader.readLine(); Properties: 用来加载配置文件, 示例如下： Properties properties = new Properties(); // ClassLoader classLoader = Person.class.getClassLoader(); 注释掉的两句作用与下一句一样 // InputStream is = classLoader.getResourceAsStream("jdbc.properties"); // 路径相对于src FileInputStream fis = new FileInputStream("src\\jdbc.properties"); // 路径相对于Module而不是src properties.load(fis); String user = properties.getProperty("user"); String passwd = properties.getProperty("passwd"); System.out.println(user + " " + passwd); IO流: （默认相对路径在Module下） 基本流: OutputStream: 字节输出流 (一切都以字节为单位) (一次读写一个字节) 接口 共有方法: write(byte[] bytes) 写入多个字节 close() FileOutputStream: 文件字节输出流 构造方法: FileOutputStream(String name[, boolean append = false]) 参数为路径，即写入的目标文件路径，如果没有该文件，会先创建该文件。若append为ture，则为追加写，否则会覆盖原文件 FileOutputStream(File file[, boolean append = false]) 参数为文件，即写入的目标文件，append同上。 InputStream: 字节输入流 接口 共有方法: read() 读取一个字节,返回读到的内容，读到文件末尾返回-1 int read(byte[] bytes) 读取多个字节，将读取到的内容存入字节数组中，并返回读取的有效字节个数，读到文件末尾返回-1 close() FileInputStream: 文件字节输入流 构造方法: FileInputStream(String name) FileInputStream(File file) Reader: 字符输入流 抽象 共有方法: read() read(char[] c) close() 作用和上述相同,包括返回-1等等都相同，只是读取单位变为字符。 FileReader: 文件字符输入流 ---> 只能读取IDEA默认编码格式文件(即UTF-8) 构造方法: FileReader(String filename) FileReader(File file) Writer: 字符输出流 抽象 共有方法: write() 参数可以为单个字符，字符数组或字符串 close() FileWriter: 文件字符输出流 构造方法: FileWriter(String filename[, boolean append = false]) FileWriter(File file[, boolean append = false]) 注意: 这里的write方法是将数据写入内存缓冲区(字符转为字节)，flash方法或close方法会数据刷新到文件。因此必须调用close()方法。 Properties集合: 实现了Map&lt;K, V> 唯一和IO流结合的集合 该集合的默认键和值都是字符串类型。store方法能把集合中的数据存入硬盘，load方法会加载到该集合中。 缓冲流: 创建一个缓冲区，减少系统IO次数，提高读写效率。 BufferedInputStream: 字节缓冲输入流 extends InputStream 用read写入，close关闭。只需要关闭缓冲流，基本流会随之关闭。 构造方法: BufferedInputStream(InputStream in[, int size]) read和write方法与基本流完全相同。 BufferedOutputStream: 字节缓冲输出流 extends OutputStream 用write写入，close关闭 构造方法: BufferedOutputStream(OutputStream out[, int size]) 参数可以传递FileOutputStream对象，可选参数size用于指定缓冲区大小 BufferedWriter: 字符缓冲输出流 extends Writer 构造方法: BufferedWriter(Writer out[, int size]) 可传入FileWriter 特有方法: void newLine() 无视系统差异，换行 BufferedReader: 字符缓冲输入流 extends Reader 构造方法: BufferedReader(Reader in[, int size]) 可传入FileReader 特有方法: String readLine() 读取一行数据，但不读取行末换行符。读到文件末尾返回null 转换流: 可以指定编码/解码的码表 OutputStreamWriter extends Writer: 步骤: 1、new对象 2、write() 3、close() 构造方法: OutputStreamWriter(OutputStream out[, String charsetName]) 参数一般传递为FileOutputStream。可选字段为编码表名称，不区分大小写，默认为UTF-8 InputStreamReader extends Reader: 步骤: 1、new对象 2、read() 3、close() 构造方法: OutputStreamWriter(InputStream in[, String charsetName]) (反)序列化流: 把对象以流的方式写入/读出到文件中 使用字节流 ObjectOutputStream: extends OutputStream 对象的序列化流 把对象以流的方式写入到文件中保存，叫写对象，也叫对象的序列化。 构造方法: ObjectOutputStream(OutputStream out) 参数一般传递为FileOutputStream。 特有方法: void writeObject(Object obj) 此处参数也可以是由obj组成的集合，如ArrayList&lt;Person> list 被序列化的对象(即参数obj)必须实现Serializable接口，以激活(反)序列化功能。其为标记型接口，内部没有任何抽象方法。 ObjectInputStream: extends InputStream 对象的反序列化流 把文件中保存的对象以流的方式读出来，叫读对象，也叫对象的反序列化。 构造方法: ObjectInputStream(InputStream in) 参数一般传递为FileInputStream。 特有方法: Object readObject() transient关键字: 瞬态关键字，被其修饰的成员变量不能被序列化，没有替他功能。static关键字也有这个功能。 注意：为了避免InvalidClassException,在每个被序列化的对象中都显示声明一个序列号-> private static final long serialVersionUID = 42L 打印流: PrintStream System.out.println(); enum : 枚举类 类的对象只有确定的有限个，我们称之为枚举类 当需要定义一组常量时，强烈建议使用枚举类 默认继承java.lang.Enum 定义： 类似于接口的定义，创建Class包时，选项中就有Enum的选项。 public enum Season { SPRING("春天", "warm"), 默认由public static final 修饰 SUMMER("夏天", "sun"), 实例写在类的最前面 AUTUMN("秋天", "cool"), 实例之间用逗号分隔，最后一个结尾为分号 WINTER("冬天", "cold"); 为什么不需要显示声明成员变量(由局部变量代替)，暂时不清楚 Season(String seasonName, String seasonDec){} } 构造函数默认由private修饰，可省略不写。 静态方法： values() 返回枚举类型的对象数组，方便用于遍历枚举值 valueOf(String objName) 返回枚举类中对象名为objName的对象 如: Season winter = Season.valueOf("WINTER"); toString() 返回当前枚举类对象常量的名字 反射: java.lang.Class 程序由javac.exe编译后，会生成一个或多个字节码文件(.class结尾)。 接着使用java.exe对某个字节码文件解释运行，就相当于将某个字节码文件加载到内存中，这个过程就叫类的加载， 加载到内存中的类就叫运行时类，这个运行时类就是Class的一个实例。 加载到内存中的运行时类会缓存一段时间，在此时间内以不同方式获取到的该运行时类的Class实例都是同一个。 获取Class实例的方法： 1、 Class clazz = Person.class; 2、 Person person = new Person(); Class clazz = person.getClass(); 3、 Class clazz = Class.forName(类相对于src的全路径); // 用的较多 ClassLoader：引导类加载器--》加载java核心类库 引导类加载器无法获取到 扩展类加载器--》加载jar包 通过Class实例.getClassLoader()即可获得类加载器，如 系统类加载器--》加载自定义类 Person.class.getClassLoader()获取的即为系统类加载器 无法创建实例的类型用 Class c = int.class; double.class; Math.class; 等 ArrayList&lt;Integer> list = new ArrayList&lt;>(); Class l1 = list.getClass(); 得到ArrayList&lt;Integer>类的Class实例 l1.getDeclaredConstructors(); 获取所有构造函数，去掉Declared为只获取public的构造函数 l1.getDeclaredMethods(); 获取所有函数，去掉Declared为只获取public的函数 l1.getDeclaredFields(); 获取所有属性，去掉Declared为只获取public的属性 l1.getSuperclass(); 获取父类 l1.getGenericSuperclass(); 获取带泛型的父类 li.getInterfaces(); 获取接口 li.getPackage(); 获取包 li.getAnnotations(); 获取注解 for (Method method: l1.getDeclaredMethods()) { System.out.println(Modifier.toString(method.getModifiers()) + " " + method.getReturnType() + " " + method.getName() + "(" + Arrays.toString(method.getParameterTypes()) + ");"); } Field f = l1.getDeclaredField("size"); 根据属性名称获取特定的Field对象。 f.setAccessible(true); 使其变为可访问的 Object v = f.get(list); Person person = new Person("alice", 21); 方法对象调用invoke方法来执行方法。 Class p = person.getClass(); public Object invoke(Object obj, Object... args) Method m = p.getMethod("getName"); 第一个参数为对象名，之后的参数为方法的参数。 String s = (String) m.invoke(person); 调用的是静态方法时，第一个参数为null。 代理的作用就是在不修改源码的情况下，对目标对象的方法增强。 静态代理：接口 + 代理类 + 被代理类 --》 一个代理类只能对应一个被代理类 代理类与被代理类实现同样的接口 动态代理：接口 + 代理类 + 多个被代理类 --》 一个代理类可以对应多个被代理类 代理类与被代理类实现同样的接口 结合src/proxy/annotationProxy包下的例子理解 1、根据自己需求创建一个被代理类对象（想象在项目中，要增强功能时，一定在之前已经使用过这个对象） 2、根据这个被代理类对象，动态获取一个代理类对象（因此，没有显示的代理类，是被动态获取到的） 3、使用代理类对象调用被代理类的方法。（具体原理看包中例子的注释）</p></div><footer class=entry-footer><span title='2021-05-20 17:39:41 +0000 UTC'>2021-05-20</span>&nbsp;·&nbsp;2258 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Java学习笔记" href=https://ethereal-lu.github.io/posts/java/java%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Annotation学习笔记</h2></header><div class=entry-content><p>元注解 元注解用于修饰注解 元注解有6中，如下： @Target 规定所修饰的注解只能用于指定的区域 @Documented 将注解生成在javadoc中 @Inherited 所修饰的注解作用于某类后，该类的子类会默认继承父类的注解 @Retention 所修饰的注解的作用时间，RUNTIME>CLASS>SOURCE @Native 使用本地方法 @Repeatable 可重复 注解接口格式 注解接口必须为public @interface Target {....}，其中public可以不写，@interface表示默认继承了 java.lang.annotation.Annotation接口 属性格式：属性类型 + 属性名 + ()；还可以使用default给属性赋予默认值 当属性只有一个且属性名为value()时，在使用的时候可以不指定属性名直接赋值 一个自定义的注解接口如下： @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnnotation { String name() default "hello"; // 使用时可以不赋值 int age(); // 使用时必须赋值 } 通过反射解析注解 Class类中有getAnnotation​()等获取注解的相关方法，通过调用这些方法获取我们填入的参数，从而做出相应的操作</p></div><footer class=entry-footer><span title='2021-05-12 18:48:13 +0000 UTC'>2021-05-12</span>&nbsp;·&nbsp;47 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Annotation学习笔记" href=https://ethereal-lu.github.io/posts/java/annotation%E7%AC%94%E8%AE%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SpringBoot学习笔记</h2></header><div class=entry-content><p>Spring Boot 是 Spring 的子项目，正如其名字，提供 Spring 的引导( Boot )的功能。
通过 Spring Boot ，开发者可以快速配置 Spring 项目，引入各种 Spring MVC、Spring Transaction、Spring AOP、等等框架，而无需不断重复编写繁重的 Spring 配置，降低了 Spring 的使用成本。
项目创建 新建 spring initializr 项目，在新建过程中引入 spring web 依赖 将所有的controller、pojo、dao等包创建在Application类的同名目录下（约定大于配置），创建在其他目录下会报错 在resources目录下创建banner.txt文件，可以在里面粘贴一些图片用于启动时展示 自动装配原理 父工程 spring-boot-dependencies 对springboot的所有依赖进行管理，其中就有依赖的版本控制，因此我们在pom.xml中引入依赖时，不需要指定版本
启动器：启动器都以spring-boot-starter打头，就是springboot的启动场景，如spring-boot-starter-web，就会帮我们自动导入web环境所有的依赖。springboot会将所有的功能场景变为一个个的启动器。我们要使用什么功能，只需要找到相对应的启动器并导入即可
主程序：
// @SpringBootApplication ：标注这个类是springboot的应用 @SpringBootApplication public class Springboot01HelloworldApplication { public static void main(String[] args) { // 启动springboot SpringApplication.run(Springboot01HelloworldApplication.class, args); } } @SpringBootApplication 是复合注解，主要包括 **@ComponentScan, @EnableAutoConfiguration, @SpringBootConfiguration**三个注解。
@SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) public @interface SpringBootApplication @ComponentScan 注解：组件扫描。 spring里有四大注解：@Service,@Repository,@Component,@Controller用来定义一个bean.@ComponentScan注解就是用来自动扫描被这些注解标识的类，最终生成ioc容器里的bean． @SpringBootConfiguration 注解：@SpringBootConfiguration继承自@Configuration，二者功能也一致，标注当前类是配置类， 并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。 @EnableAutoConfiguration 注解：从 classpath 中搜索所有的 META-INF/spring.factories 配置文件，然后将其中key为org.springframework.boot.autoconfigure.EnableAutoConfiguration 的 value 加载到spring容器中。 注解：
...</p></div><footer class=entry-footer><span title='2021-05-10 17:39:41 +0000 UTC'>2021-05-10</span>&nbsp;·&nbsp;1219 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to SpringBoot学习笔记" href=https://ethereal-lu.github.io/posts/java/springboot%E7%AC%94%E8%AE%B0/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://ethereal-lu.github.io/posts/page/7/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://ethereal-lu.github.io/posts/page/9/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>