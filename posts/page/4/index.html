<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | lu</title>
<meta name=keywords content><meta name=description content="Posts - lu"><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://ethereal-lu.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/posts/"><meta property="og:site_name" content="lu"><meta property="og:title" content="Posts"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ethereal-lu.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="lu (Alt + H)">lu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://ethereal-lu.github.io/>Home</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>缓存穿透、击穿、雪崩</h2></header><div class=entry-content><p>1、缓存穿透 1.1、问题描述 如果在请求数据时，在缓存层和数据库层都没有命中，这种情况就叫作缓存穿透。
造成缓存穿透的主要原因就是：查询某个 Key 对应的数据，Redis 缓存中没有相应的数据，则直接到数据库中查询。数据库中也不存在要查询的数据，则数据库会返回空，而 Redis 也不会缓存这个空结果。这就造成每次通过这样的 Key 去查询数据都会直接到数据库中查询，Redis 不会缓存空结果。这就造成了缓存穿透的问题。
1.2、解决办法 将空对象也缓存起来。即如果某个 key 在缓存和数据库都没有命中，就将该 key 的值置为空对象缓存到 redis。 布隆过滤器。将所有的 key 都存放在足够大的布隆过滤器中，每次查询先由其对 key 过滤，若布隆过滤器命中，则该 key 有可能存在，若布隆过滤器未命中，则该 key 一定不存在。 1.3、布隆过滤器 布隆过滤器由一个 bit 数组和若干哈希函数组成。
初始时将 bit 数组所有位置置 0。
对任意一个 key，通过哈希函数得到哈希值，将该哈希值对 bit 数组的长度取余就得到一个确定的位置，将该位置置为 1。对所有的哈希函数都执行上述操作，则一个 key 会对应多个位置。
查询时，对 key 进行同样的操作，若得到的所有位置都为 1，则该 key 有很大的可能存在；若有任意一个位置不为 1，则该值一定不存在。
之所以命中时是很有可能存在，根本问题是哈希的碰撞，可能其他一个或多个值的哈希映射与该值的所有映射碰撞，则无法判断该值是否存在。
布隆过滤器无法删除元素，一是无法精确判断该值是否存在，二是删除后会使得其他值在该点的碰撞映射删除导致误判。
应用场景：
redis 缓存穿透 爬虫或其他业务中判断是否访问过某 url web 拦截器，拦截重复请求，防止重复攻击 2、缓存击穿 2.1、问题描述 缓存数据都设置有过期时间，当高峰期对于某个热点数据有大量访问，若此时该数据正好过期，则大量的访问就直接落到数据库中，导致数据库崩溃。
2.2、解决办法 对于热点数据不设置过期时间 使用分布式锁。只有第一个到达的访问获取锁去数据库读取数据并写回缓存，其他的访问竞争锁失败陷入等待并循环查询缓存。 3、缓存雪崩 3.1、问题描述 若缓存服务器突然故障宕机，则大量请求就会直接淹没数据库，此时若不采取其他措施就直接重启数据库，它又会立刻被淹没，这就是缓存雪崩。
3.2、解决办法 redis 集群，保证高可用 限流，通过分布式锁限制访问数据库的线程数量 数据预热 ，可能产生大量访问之前，手动将数据加载到缓存，对数据设置不同的过期时间，使其均匀过期。（感觉像是缓存击穿的解决方法呢？）</p></div><footer class=entry-footer><span title='2022-04-16 22:39:41 +0000 UTC'>2022-04-16</span>&nbsp;·&nbsp;74 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 缓存穿透、击穿、雪崩" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E9%9B%AA%E5%B4%A9/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Redis分布式锁</h2></header><div class=entry-content><p>1、什么是分布式锁 分布式锁，顾名思义，就是分布式项目开发中用到的锁，可以用来控制分布式系统之间同步访问共享资源，一般来说，分布式锁需要满足的特性有这么几点：
1、互斥性：在任何时刻，对于同一条数据，只有一台应用可以获取到分布式锁；
2、高可用性：在分布式场景下，一小部分服务器宕机不影响正常使用，这种情况就需要将提供分布式锁的服务以集群的方式部署；
3、防止锁超时：如果客户端没有主动释放锁，服务器会在一段时间之后自动释放锁，防止客户端宕机或者网络不可达时产生死锁；
4、独占性：加锁解锁必须由同一台服务器进行，也就是锁的持有者才可以释放锁，不能出现你加的锁，别人给你解锁了；
2、实现分布式锁 Redis分布式锁主要是通过SETNX和SETEX这两个命令实现的。这两个命令都是原子操作。
核心思想就是每次想要获取锁的时候，就对一个固定的 key 值以 SETNX的方式存放，如果成功，就说明获取锁成功，否则以自旋的方式持续获取锁，直到超时获取失败。
解锁通过 LUA 代码实现，LUA是原子性的。
注：下方代码只体现实现锁的思想，不能实际使用。实际开发中使用 Redisson 。
3、分布式锁的缺陷 一、客户端长时间阻塞导致锁失效问题
客户端1得到了锁，因为网络问题或者GC等原因导致长时间阻塞，然后业务程序还没执行完锁就过期了，这时候客户端2也能正常拿到锁，可能会导致线程安全的问题。
二、redis服务器时钟漂移问题
如果redis服务器的机器时钟发生了向前跳跃，就会导致这个key过早超时失效，比如说客户端1拿到锁后，key的过期时间是12:02分，但redis服务器本身的时钟比客户端快了2分钟，导致key在12:00的时候就失效了，这时候，如果客户端1还没有释放锁的话，就可能导致多个客户端同时持有同一把锁的问题。
三、单点实例安全问题
如果redis是单master模式的，当这台机宕机的时候，那么所有的客户端都获取不到锁了，为了提高可用性，可能就会给这个master加一个slave，但是因为redis的主从同步是异步进行的，可能会出现客户端1设置完锁后，master挂掉，但此时数据还没有同步给slave 节点，当slave提升为master后，客户端1设置的锁丢失了，这时候客户端2设置锁也能够成功，导致客户端1和客户端2同时拥有锁。因此 reids 实现的分布式锁是 AP 模型。
4、RedLock 针对上述问题，官方推出了 RedLock 算法，RedLock 算法用于解决 Redis 集群中向一个 master 节点设置锁后该节点挂了，这时向其他 master 节点设置锁一定成功的问题。获取锁时在超过半数的实例中设置了锁就认为获取到了锁，解锁时将所有实例解锁。
RedLock 不足：
宕机重启之后，2个客户端拿到同一把锁：假设5个节点是A, B, C, D, E，客户端1在A, B, C上面拿到锁，D, E没有拿到锁，客户端1拿锁成功。 此时，C挂了重启，C上面锁的数据丢失（假设机器断电，数据还没来得及刷盘；或者C上面的主节点挂了，从节点未同步）。客户端2去取锁，从C, D, E 3个节点拿到锁，A, B没有拿到（还被客户端1持有），客户端2也超过多数派，也会拿到锁。 多个客户端同时竞争同一把锁，全部失败：比如有节点1、2、3、4、5，A、B、C同时竞争锁，A获得1、2,B获得3、4,C获得5,最后ABC都没有成功获得锁，没有获得半数以上的锁。需要强调，当客户端从大多数Redis实例获取锁失败时，应该尽快地释放（部分）已经成功取到的锁，方便别的客户端去获取锁，假如释放锁失败了，就只能等待锁超时释放了 效率低：需要顺序向所有 master 节点设置锁，master 节点越多，效率越低 5、Redisson Redisson 分布式锁通过 hash 实现，hash 名作为锁，hash 中的键为 线程ID，值为 重入次数。
加锁时设置了过期时间
...</p></div><footer class=entry-footer><span title='2022-04-12 22:39:41 +0000 UTC'>2022-04-12</span>&nbsp;·&nbsp;95 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Redis分布式锁" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Redis持久化</h2></header><div class=entry-content><p>1、Redis 核心主流程 AOF 和 RDB 的持久化过程中，有不少操作是在时间事件 serverCron 中被触发的。所以，这边有必要先了解下 Redis 中的事件核心流程。
Redis 的服务器进程就是一个事件循环，最重要的有两个事件：文件事件和时间事件。Redis 在服务器初始化后，会无限循环，处理产生的文件事件和时间事件。
文件事件常见的有：接受连接（accept）、读取（read）、写入（write）、关闭连接（close）等。使用 IO 多路复用处理。
时间事件中常见的就是 serverCron，redis 核心流程中通常也只有这个时间事件。serverCron 默认配置下每100ms会被触发一次，在该时间事件中，会执行很多操作：清理过期键、AOF 后台重写、RDB 的 save point 的检查、将 aof_buf 内容写到磁盘上（flushAppendOnlyFile 函数）等等。
2、Redis持久化 Redis是内存数据库，若不持久化到磁盘中，则redis进程一旦退出，数据就会丢失，因此需要持久化。
Redis 的持久化机制有以下三种：
RDB AOF 混合持久化（redis4.0引入） 2.1、RDB(Redis DataBase) 描述：类似于快照。在某个时间点，将 Redis 在内存中的数据保存到磁盘里面。RDB 持久化功能生成的 RDB 文件是经过压缩的二进制文件。恢复时将快照文件直接读入内存。
rdb保存的文件是dump.rdb。同样可以在redis.conf中修改
在redis.conf中对自动保存的间隔进行设置 # save 3600 1 After 3600 seconds (an hour) if at least 1 key changed # save 300 100 After 300 seconds (5 minutes) if at least 100 keys changed # save 60 10000 After 60 seconds if at least 10000 keys changed 2.1.1、触发条件 自动触发（全部是BGSAVE）
...</p></div><footer class=entry-footer><span title='2022-04-09 23:39:41 +0000 UTC'>2022-04-09</span>&nbsp;·&nbsp;403 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Redis持久化" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>IO 多路复用</h2></header><div class=entry-content><p>1、概念 IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件描述符；一旦某个文件描述符就绪，就能够通知应用程序进行相应的读写操作；没有文件描述符就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程。
文件描述符：Linux 中一切都可以看作文件，包括普通文件、链接文件、Socket 以及设备驱动等，对其进行相关操作时，都可能会创建对应的文件描述符。文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，用于指代被打开的文件，对文件所有 I/O 操作相关的系统调用都需要通过文件描述符。
Socket：在Linux 中，Socket 也是文件，发送端将数据写进发送方的 Socket ，再通过网卡、路由到接收方的 Socket ，接收方程序将数据从接收方 Socket 中读出来使用。一个 Socket 由&lt;协议、发送方 IP、发送方 Port、接收方 IP、接收方 Port> 五元组描述。总之，Socket 就是一个文件，同样可以进行读写。
2、Linux IO模型 目前Linux系统中提供了5种IO处理模型
阻塞IO 非阻塞IO IO多路复用 信号驱动IO 异步IO 阻塞IO 阻塞IO意味着当我们发起一次IO操作后一直等待成功或失败之后才返回，在这期间程序不能做其它的事情。阻塞IO操作只能对单个文件描述符进行操作，如果文件描述符不就绪就阻塞。
服务端采用单线程，当accept一个请求后，在recv或send调用阻塞时，将无法accept其他请求（必须等上一个请求处recv或send完），无法处理并发。 服务器端采用多线程，当accept一个请求后，开启线程进行recv，可以完成并发处理，但随着请求数增加需要增加系统线程，大量的线程占用很大的内存空间，并且线程切换会带来很大的开销。 非阻塞IO 服务器端当accept一个请求后，加入fds集合，每次轮询一遍fds，若IO失败则返回错误，每次轮询所有fd（包括没有发生读写事件的fd）会很浪费cpu
IO多路复用 个人认为IO多路复用是吸收了阻塞IO和非阻塞IO的优点的一种IO方式，即同时可以对多个请求进行处理，但当所有请求不就绪时会阻塞，不占用CPU资源。
服务器端采用单线程通过select/epoll等系统调用获取fd列表，遍历活跃（即有读写事件）的fd进行accept/recv/send，使其能支持更多的并发连接请求。
3、IO多路复用的实现 3.1、select select 每个进程可同时监听的文件描述符数量最大为 1024，虽然可以设置，但是会降低网络效率。
每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大
对socket扫描时是线性扫描，采用轮询的方法，效率较低（高并发时）
后面的不重要
数据结构：fd_set简单地理解为一个长度是1024的比特位，每个比特位表示一个需要处理的FD，如果是1，那么表示这个FD有需要处理的I/O事件，否则没有。
select 在调用期间会一直阻塞。
select将监听的文件描述符分为三组，分别是：read_fds是需要进行读操作的文件描述符，write_fds是需要进行写操作的文件描述符，except_fds是需要进行异常事件处理的文件描述符。
3.2、poll poll 仅仅时取消了 1024 的限制，其他和 select 一样，不分为三组。poll 是 fd 数组。
3.3、epoll epoll 底层是红黑树 + 链表。红黑树存储所有需要监听的 fd（文件描述符），链表存储活跃（有读写事件）的fd。
...</p></div><footer class=entry-footer><span title='2022-04-09 19:42:15 +0000 UTC'>2022-04-09</span>&nbsp;·&nbsp;175 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to IO 多路复用" href=https://ethereal-lu.github.io/posts/linux/io/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>linux创建子进程--fork()方法</h2></header><div class=entry-content><p>1、fork()的定义 fork()函数是Unix中派生新进程的唯一方法，子进程和父进程独立运行互不干扰。
声明如下：
#include &lt;unistd.h> pid_t fork(void); 调用一次fork()方法，该方法会返回两次。一次是在父进程中返回一次，返回值是新派生的进程的进程ID。一次是在子进程中返回，返回值是0，代表当前进程为子进程。如果返回值为-1的话，则代表在派生新进程的过程中出错。
那么在程序中，我们就可以根据此返回值来判断当前进程是父进程还是子进程，来实现一些具体的操作。例如：
int main() { pid_t pid; if((pid = fork()) = 0) { // TODO: 在子进程中实现具体操作 // ... exit(0); // 结束子进程 } // TODO: 在调用进程(父进程)实现具体操作 } 2、getpid和getppid函数 #include &lt;unistd.h> pid_t getpid(void); // 获取当前进程的pid pid_t getppid(void); // 获取当前进程父进程的pid 3、fork() 原理 父进程中在调用fork()派生新进程，实际上相当于创建了进程的一个拷贝；即在fork()之前的进程拥有的资源会被复制到新的进程中去。
​ （1）进程不同于程序是动态运行在内存中的实体，占用系统资源（CPU、内存等），而程序则是存放在磁盘中的静态的资源，占用磁盘空间而不占用系统资源。进程在内存中运行，由CPU分配资源。
（2）与进程相关的两个内存：虚拟内存和物理内存。所谓虚拟内存就是我们程序员视角下的内存，比如int a = 10; &amp;a 所得的值就是虚拟内存，是给我们程序员看的连续的地址空间。（当我们在代码中连续定义几个local object时，通过&可以观察到它们的地址是连续的）相对的，物理内存才是实实在在的存在于计算机硬件中的内存（比如买内存条时我们可以参考的4G、8G等容量参数），当执行 a = 20这条语句时，操作系统就会将 a 的虚拟地址送入 CPU的地址转换单元（MMU），如果a还没有实际的物理单元，则为a分配物理内存，写入20，反之直接将20写入a物理内存单元。
（3）为什么会有虚拟内存？ 虚拟内存的产生源自物理内存的稀缺，买过SSD或者内存条的伙伴都知道，250G的SSD也就是250块左右，而仅仅8G的内存条就要250块，内存的小容量与高价格的反差促使猿们必须节省内存的开销。由此产生了虚拟内存技术，32位系统下，CPU会为每个进程分配4G的虚拟地址单元（地址编号为0-4G），分为用户空间（通常为0-3G）和内核（kernel）空间（3-4G），用户空间存放该进程的堆栈变量、全局变量等，kernel里存放该进程的进程控制块（PCB，唯一区分每一个进程）。虚拟内存单元只有在被进程访问后才会映射为物理内存单元（见（2）a=20的执行过程）。
（4）内存使用的一大机制（虚拟内存能实现的原因）：缺页中断（见文章最后）。
3. fork()是如何产生子进程的？ 上面说了每一个进程都有自己0-4G的虚拟地址空间，因此，fork所做的动作就是在当前进程的基础上产生一个新进程：（1）复制父进程的0-3G的用户空间（2）创建新进程（子进程）的PCB
看一个例子吧：
#include &lt;unistd.h> #include &lt;stdio.h> #include &lt;stdlib.h> //global variable int globalVar = 78; int main(){ pid_t pid = getpid(); int k = 0; int i; for(i = 0; i &lt; 5; ++i){ pid = fork(); // 循环生成5个子进程 if(-1 == pid){ perror("FORK"); exit(1); } // 由于fork()返回两个值，该分支一定会被子进程执行，即每子进程都会跳出循环去执行下方代码， // 而父进程一直执行到循环结束，故每个子进程都会执行下方的if(i &lt; 5)，而父进程执行else // 所以下方图片输出可表明每个子进程写时都复制父进程的变量再修改，且不影响其他进程。 else if(0 == pid){ break; } } sleep(i); // 保证父进程最后退出 if(i &lt; 5){ ++k; // 写时复制 --globalVar; //写时复制 printf("I'm %dth child, pid = %d, parent is %d, k = %d, globalVar = %d\n", i, getpid(), getppid(), k, globalVar); }else{ ++k; --globalVar; printf("I'm parent, pid = %d, k = %d, globalVar = %d\n", getpid(), k, globalVar); } } ...</p></div><footer class=entry-footer><span title='2022-04-09 19:42:15 +0000 UTC'>2022-04-09</span>&nbsp;·&nbsp;194 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to linux创建子进程--fork()方法" href=https://ethereal-lu.github.io/posts/linux/linux%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B--fork%E6%96%B9%E6%B3%95/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>编码</h2></header><div class=entry-content><p>1、为什么使用编码 人类的语言并不适合计算机使用，所以就需要发明一种适合计算机的语言，这就是二进制。电脑读不懂人类语言，所以需要将人类语言转换为二进制语言，这就是编码；人类读不懂电脑的二进制语言，所以需要转换为人类语言，这就是解码。
2、为什么会乱码 编码与解码使用的规则不一样，就会乱码。即解码的时候，解码器不知道如何将当前的二进制转换为人类语言，就会乱码。
3、字符集的历史 3.1、百花齐放 ASCII 码占用了 0~127，即一个字节中的后 7 位。
IOS-8859-n 编码家族占用了 128~255，即利用了 ASCII 码未使用的第 1 位，因此IOS-8859-n 编码家族兼容ASCII 码。
至此一个字节的 8 位已全部占用，后来的编码必须使用多个字节。
GB2312：GB2312 并不兼容 ISO-8859-n 编码集，但是兼容 ASCII 编码。因为 ASCII 编码中的单字节字符一定是小于 128 的，所以最后我们就决定，中文的双字节字符都从 128 之后开始，也就是当发现字符连续两位都大于 128 时，就说明这是一个中文，指定了之后我们就把这种编码方式称之为 GB2312 编码。
GB2312 中收录的中文汉字都是简体字和常用字，对于一些生僻字以及繁体字没有收录，于是乎 GBK 出现了。
GBK： GBK 只要求第一位是大于 128，第二位可以小于 128，只要发现一个字节大于 128，那么紧随其后的一个字节就是和其作为一个整体作为中文字符。GBK兼容GB2312、ASCII，不兼容IOS-8859-n 。
3.2、Unicode Unicode 不兼容以上任何编码。Unicode 字符最开始采用的是 UCS-2 标准，UCS-2 标准规定一个字符至少使用 2 个字节来表示。由于无法攘括全世界所有字符，后来又有了 UCS-4 标准，可以用 4 个字节来存储一个字符。
Unicode 编码只是定义了字符集，对于字符集具体应该如何存储并没有做要求。
UTF 系列编码就是对 Unicode 字符集的实现，只不过实现的方式有所区别，其中主要有：UTF-8，UTF-16，UTF-32 等类型。
3.2.1、UTF-32 编码 UTF-32 编码基本按照 Unicode字符集标准来实现，任何一个符号都占用 4 个字节。浪费严重。
...</p></div><footer class=entry-footer><span title='2022-04-08 23:08:18 +0000 UTC'>2022-04-08</span>&nbsp;·&nbsp;369 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 编码" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A0%81/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>RabbitMQ基础</h2></header><div class=entry-content><p>一、概述 1.1、什么是消息队列 消息：指的是两个应用间传递的数据。数据的类型有很多种形式，可能只包含文本字符串，也可能包含嵌入对象。
消息协议：为了让消息发送者和消息接收者都能够明白消息所承载的信息，它们就需要按照一种统一的格式描述消息。
消息队列：（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message。
消息从发送者到接收者的方式也有两种。 一种为即时消息通讯，也就是说消息从一端发出后（消息发送者）立即就可以达到另一端（消息接收者），这种方式的具体实现就是RPC（当然单纯的http通讯也满足这个定义）； 另一种为延迟消息通讯，即消息从某一端发出后，首先进入一个容器进行临时存储，当达到某种条件后，再由这个容器发送给另一端。 这个容器的一种具体实现就是消息队列，如RabbitMQ。
1.2、为什么使用消息队列 应用解耦：不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个； 流量削峰：如数据库只能同时处理一万条请求，如果来了两万条请求就执行一万条，将剩余一万条放在消息队列顺序执行。 异步处理：A 调用 B 处理数据，但 B 处理时间很长；A可以不用等，当B执行完将结果放在消息队列，再由消息队列将结果给A，这样就不用轮询或提供回调函数了。 广播 最终一致性 1.3、mqtt 与 MQ 的区别 mqtt：一种通信协议，类似人类交谈中的汉语、英语、俄语中的一种语言规范 MQ：一种通信通道，也叫消息队列，类似人类交谈中的用电话、email、微信的一种通信方式 json：一种内容格式，类似人类交谈中的排比句等方式
1.4、RPC 执行流程 RPC（Remote Procedure Call）远程过程调用协议，一种通过网络从远程计算机上请求服务，而不需要了解底层网络技术的协议。其主要目的是做到不同服务间调用方法像同一服务间调用本地方法一样。
当业务需要强一致性，关注业务逻辑的处理结果，则 RPC 比消息队列更合适。
强一致性指不论在任何时候读取的都是最新的数据，最终一致性是允许可以在一段时间内每个结点的数据不一致，但是经过一段时间每个结点的数据必须一致，它强调的是最终数据的一致性。
客户端处理过程中调用client sub，就像调用本地方法一样，传入参数 client sub将参数编组为消息，然后通过系统调用向服务端发送消息 服务端将接收到的数据包传递给server sub server sub将接收到的数据解组为参数 server sub再调用服务端的过程，过程执行的结果以反方向的相同步骤响应给客户端 以 Google 的 grpc 为例：先在 proto 文件中声明接口，包括方法名、参数和返回值，然后使用工具生成 go 可以用的库；服务端创建 grpc 服务实例并将本地实现的服务注册进该实例中，然后监听本地端口，收到请求后就执行本地方法并将结果返回；客户端创建 grpc 客户端实例，然后调用 proto 中声明的方法即可获得结果。
1.5、MQ 分类 ActiveMQ：老、较少使用 Kafka：大数据实时计算和日志采集方面卓越 RocketMQ：阿里开源产品 RabbitMQ：主流 二、RabbitMQ介绍 2.1、RabbitMQ 简介 RabbitMQ是一个在AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。
...</p></div><footer class=entry-footer><span title='2022-04-07 14:42:15 +0000 UTC'>2022-04-07</span>&nbsp;·&nbsp;2148 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to RabbitMQ基础" href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/rabbitmq/rabbitmq/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ubuntu的ufw与iptables</h2></header><div class=entry-content><p>1、概述 进出计算机的流量通过“端口”进行过滤，“端口”是附加到特定应用程序使用的流量数据包的相对任意名称。
按照惯例，某些端口通常用于特定类型的应用程序。例如，端口 80 通常用于不安全的 Web 浏览，端口 443 用于安全的 Web 浏览。
可以通过“打开”或“关闭”（即过滤）为特定类型的流量指定的端口来允许或阻止到特定应用程序的流量。例如，如果端口 80 “关闭”，则无法进行（不安全的）网页浏览。
Linux 内核包括 netfilter 子系统，用于操纵或决定进入或通过计算机的网络流量的命运。所有现代 Linux 防火墙解决方案都使用该系统进行数据包过滤。
如果没有用户界面来管理内核的数据包过滤系统，那么用户或管理员几乎没有什么用处。这就是 iptables 的目的。当一个数据包到达您的计算机时，它会根据通过 iptables 提供给它的规则传递给 netfilter 子系统接受、处理或拒绝。因此，iptables 是您管理防火墙所需的一切（如果您熟悉它）。然而，许多前端可用于简化任务。
因此，用户可以配置防火墙以允许某些类型的网络流量进出系统（例如 SSH 或 Web 服务器流量）。这是通过在防火墙中打开和关闭 TCP 和 UDP“端口”来完成的。此外，防火墙可以配置为允许或限制对特定 IP 地址（或 IP 地址范围）的访问。
2、端口映射与端口转发 端口映射：端口映射就是将内网中的主机的一个端口映射到外网主机的一个端口，提供相应的服务。当用户访问外网IP的这个端口时，服务器自动将请求映射到对应局域网内部的机器上。
我们在内网中有一台Web服务器，但是外网中的用户是没有办法直接访问该服务器的。于是我们可以在路由器上设置一个端口映射，只要外网用户访问路由器ip的80端口，那么路由器会把自动把流量转到内网Web服务器的80端口上。并且，在路由器上还存在一个Session，当内网服务器返回数据给路由器时，路由器能准确的将消息发送给外网请求用户的主机。在这过程中，路由器充当了一个反向代理的作用，他保护了内网中主机的安全。
端口转发：端口转发（Port forwarding），有时被叫做隧道，是安全壳（SSH） 为网络安全通信使用的一种方法。
比如，我们现在在内网中，是没有办法直接访问外网的。但是我们可以通过路由器的NAT方式访问外网。假如我们内网现在有100台主机，那么我们现在都是通过路由器的这一个公网IP和外网通信的。那么，当互联网上的消息发送回来时，路由器是怎么知道这个消息是给他的，而另外消息是给你的呢？这就要我们的ip地址和路由器的端口进行绑定了，这时，在路由器中就会有一个内网ip和路由器端口对应的一张表。当路由器的10000端口收到消息时，就知道把消息发送给他，而当20000端口收到消息时，就知道把消息发送给你。这就是端口转发，其转发一个端口收到的流量，给另一个主机。
端口转发：转发的重点在“转”上面。送快递的过来，把所有快递都交给门口保安，保安再根据每件快递上的收件人来分发。
端口映射：就是在大门口给每个人装个柜子，送快递的直接按收件人名字，把快递放到对应的柜子里面。
3、ufw与iptables iptables 是防火墙规则的数据库，是 Linux 系统中实际使用的防火墙。 Linux系统中配置iptables的传统界面是命令行界面终端。
UFW（简单防火墙）是 iptables 的前端，是Ubuntu系统上配置iptables防火墙的工具，特别适合基于主机的防火墙。 UFW 是专门为 Ubuntu 开发的（但在其他发行版中可用），也可以从终端进行配置。</p></div><footer class=entry-footer><span title='2022-04-07 14:42:15 +0000 UTC'>2022-04-07</span>&nbsp;·&nbsp;62 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to ubuntu的ufw与iptables" href=https://ethereal-lu.github.io/posts/linux/ubuntu%E7%9A%84ufw%E4%B8%8Eiptables/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>AQS</h2></header><div class=entry-content><p>AQS的核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就通过cas 的方式将当前线程添加到等待队列的尾部，直到它的前继节点释放锁并唤醒它。
在 AQS 中用变量 state 代表共享资源，通过 cas 改变 state 的值来竞争锁。
ReentrantLock 实现了公平锁和非公平锁，他们都继承了 AQS，公平锁和非公平锁的最大区别就是在获取锁的时候，非公平锁直接和等待队列的头节点竞争锁，而非公平锁只有在自己是队列头结点时才去获取锁。
ReentrantLock 中，若 state 的值为0，说明当前共享资源是空闲的，可以获取。若获取到锁的线程再次获取锁时，state 的值加 1，这就是可重入锁。同时这样会避免多余的 cas 开销。</p></div><footer class=entry-footer><span title='2022-04-06 21:12:41 +0000 UTC'>2022-04-06</span>&nbsp;·&nbsp;22 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to AQS" href=https://ethereal-lu.github.io/posts/java/java-%E8%BF%9B%E9%98%B6/aqs/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>BIO,NIO,AIO</h2></header><div class=entry-content><p>本文摘自(31条消息) Java面试常考的 BIO，NIO，AIO 总结_有梦想的小树的博客-CSDN博客_bio nio
Java 中的 BIO、NIO和 AIO 理解为是 Java 语言对操作系统的各种 IO 模型的封装。程序员在使用这些 API 的时候，不需要关心操作系统层面的知识，也不需要根据不同操作系统编写不同的代码。只需要使用Java的API就可以了。
同步与异步
同步： 同步就是发起一个调用后，需要等待被调用者返回结果。 异步： 异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。 同步和异步的区别最大在于异步的话调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。
阻塞和非阻塞
阻塞： 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。 非阻塞： 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。 同步和阻塞最大的区别就是线程是否会被挂起。
那么同步阻塞、同步非阻塞和异步非阻塞又代表什么意思呢？
在等待返回结果前如果什么也不干就是同步阻塞；如果可以做一些其他的事只需要以轮询的方式查看结果是否返回就是同步非阻塞；如果不需要等待返回结果就是异步非阻塞。
举个生活中简单的例子，你妈妈让你烧水，小时候你比较笨啊，在哪里傻等着水开（同步阻塞）。等你稍微再长大一点，你知道每次烧水的空隙可以去干点其他事，然后只需要时不时来看看水开了没有（同步非阻塞）。后来，你们家用上了水开了会发出声音的壶，这样你就只需要听到响声后就知道水开了，在这期间你可以随便干自己的事情，你需要去倒水了（异步非阻塞）。
1. BIO (Blocking I/O) 最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。 当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。 典型的阻塞IO模型的例子为 data = socket.read(); 如果数据没有就绪，就会一直阻塞在read方法。
1.1 传统 BIO BIO通信（一请求一应答）模型图如下(图源网络，原出处不明)：
采用 BIO 通信模型 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。我们一般通过在 while(true) 循环中服务端会调用 accept() 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接，如上图所示。
如果要让 BIO 通信模型 能够同时处理多个客户端请求，就必须使用多线程（主要原因是 socket.accept()、 socket.read()、 socket.write() 涉及的三个主要函数都是同步阻塞的），也就是说它在接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的 一请求一应答通信模型 。我们可以设想一下如果这个连接不做任何事情的话就会造成不必要的线程开销，不过可以通过 线程池机制 改善，线程池还可以让线程的创建和回收成本相对较低。使用FixedThreadPool 可以有效的控制了线程的最大数量，保证了系统有限的资源的控制，实现了N(客户端请求数量):M(处理客户端请求的线程数量)的伪异步I/O模型（N 可以远远大于 M），下面一节"伪异步 BIO"中会详细介绍到。
...</p></div><footer class=entry-footer><span title='2022-04-06 21:12:41 +0000 UTC'>2022-04-06</span>&nbsp;·&nbsp;200 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to BIO,NIO,AIO" href=https://ethereal-lu.github.io/posts/java/java-%E8%BF%9B%E9%98%B6/bionioaio/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://ethereal-lu.github.io/posts/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://ethereal-lu.github.io/posts/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>