<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>编码 | lu</title>
<meta name=keywords content><meta name=description content="1、为什么使用编码
人类的语言并不适合计算机使用，所以就需要发明一种适合计算机的语言，这就是二进制。电脑读不懂人类语言，所以需要将人类语言转换为二进制语言，这就是编码；人类读不懂电脑的二进制语言，所以需要转换为人类语言，这就是解码。
2、为什么会乱码
编码与解码使用的规则不一样，就会乱码。即解码的时候，解码器不知道如何将当前的二进制转换为人类语言，就会乱码。
3、字符集的历史
3.1、百花齐放
ASCII 码占用了 0~127，即一个字节中的后 7 位。
IOS-8859-n 编码家族占用了 128~255，即利用了 ASCII 码未使用的第 1 位，因此IOS-8859-n 编码家族兼容ASCII 码。

至此一个字节的 8 位已全部占用，后来的编码必须使用多个字节。

GB2312：GB2312 并不兼容 ISO-8859-n 编码集，但是兼容 ASCII 编码。因为 ASCII 编码中的单字节字符一定是小于 128 的，所以最后我们就决定，中文的双字节字符都从 128 之后开始，也就是当发现字符连续两位都大于 128 时，就说明这是一个中文，指定了之后我们就把这种编码方式称之为 GB2312 编码。
GB2312 中收录的中文汉字都是简体字和常用字，对于一些生僻字以及繁体字没有收录，于是乎 GBK 出现了。
GBK： GBK 只要求第一位是大于 128，第二位可以小于 128，只要发现一个字节大于 128，那么紧随其后的一个字节就是和其作为一个整体作为中文字符。GBK兼容GB2312、ASCII，不兼容IOS-8859-n 。
3.2、Unicode
Unicode 不兼容以上任何编码。Unicode 字符最开始采用的是 UCS-2 标准，UCS-2 标准规定一个字符至少使用 2 个字节来表示。由于无法攘括全世界所有字符，后来又有了 UCS-4 标准，可以用 4 个字节来存储一个字符。
Unicode 编码只是定义了字符集，对于字符集具体应该如何存储并没有做要求。
UTF 系列编码就是对 Unicode 字符集的实现，只不过实现的方式有所区别，其中主要有：UTF-8，UTF-16，UTF-32 等类型。
3.2.1、UTF-32 编码
UTF-32 编码基本按照 Unicode字符集标准来实现，任何一个符号都占用 4 个字节。浪费严重。"><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A0%81/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A0%81/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A0%81/"><meta property="og:site_name" content="lu"><meta property="og:title" content="编码"><meta property="og:description" content="1、为什么使用编码 人类的语言并不适合计算机使用，所以就需要发明一种适合计算机的语言，这就是二进制。电脑读不懂人类语言，所以需要将人类语言转换为二进制语言，这就是编码；人类读不懂电脑的二进制语言，所以需要转换为人类语言，这就是解码。
2、为什么会乱码 编码与解码使用的规则不一样，就会乱码。即解码的时候，解码器不知道如何将当前的二进制转换为人类语言，就会乱码。
3、字符集的历史 3.1、百花齐放 ASCII 码占用了 0~127，即一个字节中的后 7 位。
IOS-8859-n 编码家族占用了 128~255，即利用了 ASCII 码未使用的第 1 位，因此IOS-8859-n 编码家族兼容ASCII 码。
至此一个字节的 8 位已全部占用，后来的编码必须使用多个字节。
GB2312：GB2312 并不兼容 ISO-8859-n 编码集，但是兼容 ASCII 编码。因为 ASCII 编码中的单字节字符一定是小于 128 的，所以最后我们就决定，中文的双字节字符都从 128 之后开始，也就是当发现字符连续两位都大于 128 时，就说明这是一个中文，指定了之后我们就把这种编码方式称之为 GB2312 编码。
GB2312 中收录的中文汉字都是简体字和常用字，对于一些生僻字以及繁体字没有收录，于是乎 GBK 出现了。
GBK： GBK 只要求第一位是大于 128，第二位可以小于 128，只要发现一个字节大于 128，那么紧随其后的一个字节就是和其作为一个整体作为中文字符。GBK兼容GB2312、ASCII，不兼容IOS-8859-n 。
3.2、Unicode Unicode 不兼容以上任何编码。Unicode 字符最开始采用的是 UCS-2 标准，UCS-2 标准规定一个字符至少使用 2 个字节来表示。由于无法攘括全世界所有字符，后来又有了 UCS-4 标准，可以用 4 个字节来存储一个字符。
Unicode 编码只是定义了字符集，对于字符集具体应该如何存储并没有做要求。
UTF 系列编码就是对 Unicode 字符集的实现，只不过实现的方式有所区别，其中主要有：UTF-8，UTF-16，UTF-32 等类型。
3.2.1、UTF-32 编码 UTF-32 编码基本按照 Unicode字符集标准来实现，任何一个符号都占用 4 个字节。浪费严重。"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-08T23:08:18+00:00"><meta property="article:modified_time" content="2022-04-08T23:08:18+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="编码"><meta name=twitter:description content="1、为什么使用编码
人类的语言并不适合计算机使用，所以就需要发明一种适合计算机的语言，这就是二进制。电脑读不懂人类语言，所以需要将人类语言转换为二进制语言，这就是编码；人类读不懂电脑的二进制语言，所以需要转换为人类语言，这就是解码。
2、为什么会乱码
编码与解码使用的规则不一样，就会乱码。即解码的时候，解码器不知道如何将当前的二进制转换为人类语言，就会乱码。
3、字符集的历史
3.1、百花齐放
ASCII 码占用了 0~127，即一个字节中的后 7 位。
IOS-8859-n 编码家族占用了 128~255，即利用了 ASCII 码未使用的第 1 位，因此IOS-8859-n 编码家族兼容ASCII 码。

至此一个字节的 8 位已全部占用，后来的编码必须使用多个字节。

GB2312：GB2312 并不兼容 ISO-8859-n 编码集，但是兼容 ASCII 编码。因为 ASCII 编码中的单字节字符一定是小于 128 的，所以最后我们就决定，中文的双字节字符都从 128 之后开始，也就是当发现字符连续两位都大于 128 时，就说明这是一个中文，指定了之后我们就把这种编码方式称之为 GB2312 编码。
GB2312 中收录的中文汉字都是简体字和常用字，对于一些生僻字以及繁体字没有收录，于是乎 GBK 出现了。
GBK： GBK 只要求第一位是大于 128，第二位可以小于 128，只要发现一个字节大于 128，那么紧随其后的一个字节就是和其作为一个整体作为中文字符。GBK兼容GB2312、ASCII，不兼容IOS-8859-n 。
3.2、Unicode
Unicode 不兼容以上任何编码。Unicode 字符最开始采用的是 UCS-2 标准，UCS-2 标准规定一个字符至少使用 2 个字节来表示。由于无法攘括全世界所有字符，后来又有了 UCS-4 标准，可以用 4 个字节来存储一个字符。
Unicode 编码只是定义了字符集，对于字符集具体应该如何存储并没有做要求。
UTF 系列编码就是对 Unicode 字符集的实现，只不过实现的方式有所区别，其中主要有：UTF-8，UTF-16，UTF-32 等类型。
3.2.1、UTF-32 编码
UTF-32 编码基本按照 Unicode字符集标准来实现，任何一个符号都占用 4 个字节。浪费严重。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ethereal-lu.github.io/posts/"},{"@type":"ListItem","position":2,"name":"编码","item":"https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A0%81/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"编码","name":"编码","description":"1、为什么使用编码 人类的语言并不适合计算机使用，所以就需要发明一种适合计算机的语言，这就是二进制。电脑读不懂人类语言，所以需要将人类语言转换为二进制语言，这就是编码；人类读不懂电脑的二进制语言，所以需要转换为人类语言，这就是解码。\n2、为什么会乱码 编码与解码使用的规则不一样，就会乱码。即解码的时候，解码器不知道如何将当前的二进制转换为人类语言，就会乱码。\n3、字符集的历史 3.1、百花齐放 ASCII 码占用了 0~127，即一个字节中的后 7 位。\nIOS-8859-n 编码家族占用了 128~255，即利用了 ASCII 码未使用的第 1 位，因此IOS-8859-n 编码家族兼容ASCII 码。\n至此一个字节的 8 位已全部占用，后来的编码必须使用多个字节。\nGB2312：GB2312 并不兼容 ISO-8859-n 编码集，但是兼容 ASCII 编码。因为 ASCII 编码中的单字节字符一定是小于 128 的，所以最后我们就决定，中文的双字节字符都从 128 之后开始，也就是当发现字符连续两位都大于 128 时，就说明这是一个中文，指定了之后我们就把这种编码方式称之为 GB2312 编码。\nGB2312 中收录的中文汉字都是简体字和常用字，对于一些生僻字以及繁体字没有收录，于是乎 GBK 出现了。\nGBK： GBK 只要求第一位是大于 128，第二位可以小于 128，只要发现一个字节大于 128，那么紧随其后的一个字节就是和其作为一个整体作为中文字符。GBK兼容GB2312、ASCII，不兼容IOS-8859-n 。\n3.2、Unicode Unicode 不兼容以上任何编码。Unicode 字符最开始采用的是 UCS-2 标准，UCS-2 标准规定一个字符至少使用 2 个字节来表示。由于无法攘括全世界所有字符，后来又有了 UCS-4 标准，可以用 4 个字节来存储一个字符。\nUnicode 编码只是定义了字符集，对于字符集具体应该如何存储并没有做要求。\nUTF 系列编码就是对 Unicode 字符集的实现，只不过实现的方式有所区别，其中主要有：UTF-8，UTF-16，UTF-32 等类型。\n3.2.1、UTF-32 编码 UTF-32 编码基本按照 Unicode字符集标准来实现，任何一个符号都占用 4 个字节。浪费严重。\n","keywords":[],"articleBody":"1、为什么使用编码 人类的语言并不适合计算机使用，所以就需要发明一种适合计算机的语言，这就是二进制。电脑读不懂人类语言，所以需要将人类语言转换为二进制语言，这就是编码；人类读不懂电脑的二进制语言，所以需要转换为人类语言，这就是解码。\n2、为什么会乱码 编码与解码使用的规则不一样，就会乱码。即解码的时候，解码器不知道如何将当前的二进制转换为人类语言，就会乱码。\n3、字符集的历史 3.1、百花齐放 ASCII 码占用了 0~127，即一个字节中的后 7 位。\nIOS-8859-n 编码家族占用了 128~255，即利用了 ASCII 码未使用的第 1 位，因此IOS-8859-n 编码家族兼容ASCII 码。\n至此一个字节的 8 位已全部占用，后来的编码必须使用多个字节。\nGB2312：GB2312 并不兼容 ISO-8859-n 编码集，但是兼容 ASCII 编码。因为 ASCII 编码中的单字节字符一定是小于 128 的，所以最后我们就决定，中文的双字节字符都从 128 之后开始，也就是当发现字符连续两位都大于 128 时，就说明这是一个中文，指定了之后我们就把这种编码方式称之为 GB2312 编码。\nGB2312 中收录的中文汉字都是简体字和常用字，对于一些生僻字以及繁体字没有收录，于是乎 GBK 出现了。\nGBK： GBK 只要求第一位是大于 128，第二位可以小于 128，只要发现一个字节大于 128，那么紧随其后的一个字节就是和其作为一个整体作为中文字符。GBK兼容GB2312、ASCII，不兼容IOS-8859-n 。\n3.2、Unicode Unicode 不兼容以上任何编码。Unicode 字符最开始采用的是 UCS-2 标准，UCS-2 标准规定一个字符至少使用 2 个字节来表示。由于无法攘括全世界所有字符，后来又有了 UCS-4 标准，可以用 4 个字节来存储一个字符。\nUnicode 编码只是定义了字符集，对于字符集具体应该如何存储并没有做要求。\nUTF 系列编码就是对 Unicode 字符集的实现，只不过实现的方式有所区别，其中主要有：UTF-8，UTF-16，UTF-32 等类型。\n3.2.1、UTF-32 编码 UTF-32 编码基本按照 Unicode字符集标准来实现，任何一个符号都占用 4 个字节。浪费严重。\n3.2.2、UTF-16 编码 UTF-16 编码相比较 UTF-32 做了一点改进，其采用 2 个字节或者 4 个字节来存储。大部分情况下 UTF-16 编码都是采用 2 个字节来存储，而当 2 个字节存储时，UTF-16 编码会将 Unicode 字符直接转成二进制进行存储，对于另外一些生僻字或者使用较少的符号，UTF-16 编码会采用 4 个字节来存储，但是采用四个字节存储时需要做一次编码转换。\n下表就是 UTF-16 编码的存储格式：\nUnicode 编码范围（16 进制） UTF-16 编码的二进制存储格式 0x0000 0000 - 0x0000 FFFF xxxxxxxx xxxxxxxx 0x0001 0000 - 0x0010 FFFF 110110xx xxxxxxxx 110111xx xxxxxxxx 即二字节存储时，直接存 Unicode 码，四字节时将 Unicode 码依次填充到表中的 x 处。\n一个汉字在 UTF-16 编码 中占 2 个或 4 个字节。 3.2.3、UTF-8 编码 UTF-8 是一种变长的编码，兼容了 ASCII 编码，为了实现变长这个特性，那么就必须要有一个规范来规定存储格式，这样当程序读了 2 个或者多个字节时能解析出这到底是表示多个单字节字符还是一个多字节字符。\nUTF-8 编码的存储规范如下表所示：\nUnicode 编码范围（16 进制） UTF-8 编码的二进制存储格式 0x0000 0000 - 0x0000 007F 0xxxxxxx 0x0000 0080 - 0x0000 07FF 110xxxxx 10xxxxxx 0x0000 0800 - 0x0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0x0001 0000 - 0x0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 接下来我们以 双 字为例来进行说明：\n双：对应的 Unicode 编码为 \\u53cc，转成二进制就是：101001111001100，这时候表格中的第一行只有 7 位存不下去，第二列也只有 11 位，也不够存储，所以只能存储到第三列，第三列有 16 位，从后往前依次填补 x 的位置，填完之后还有一位空余，直接补 0，最终得到：11100101 10001111 10001100，所以双 字就占用了 3 个字节，当然，有些生僻字会占用到四个字节。\n所以上面的 UTF-16 编码也是同理，如果当前字符采用的是两字节存储，那么直接转成二进制存储即可，位数不足直接补 0 即可，而当采用 4 个字节存储时，则需要和 UTF-8 一样进行一次转换，也就是说只能将其填充到 x 的位置，x 之外的是固定格式。\n需要注意的是：在 UTF-16 编码中，2 个字节也可能出现 4 字节中 110110xx 或者 110111xx 开头的格式，这两部分对应的区间分别是：D800~DBFF 和 DC00~DFFF，所以为了避免这种歧义的发生，这两部分区间是是专门空出来的，没有进行编码。\nUTF-8存储中，若字节的第一位是 0，表示一个字节即一个Unicode 字符；否则字节开头 1 有几个，就表示该Unicode 字符由几个字节组成。\n一个汉字在 UTF-8 编码 中占 3 个或 4 个字节。 4、为什么有时候乱码都是 ? 号 在 Java 开发中，经常会碰到乱码显示为 ? 号，比如下面这个例子：\nString name = \"双子孤狼\"; byte[] bytes = name.getBytes(StandardCharsets.ISO_8859_1); System.out.println(new String(bytes));//输出：???? 这个输出结果的原因是中文无法用 ISO_8859_1 编码进行存储，而示例中却强制用 ISO_8859_1 编码进行解码。\n在 Java 中提供了一个 ISO_8859_1 类用来解码，解码时当发现当前字符转成十进制之后大于 255 时就会直接不进行解码，转而直接赋一个默认值 63，所以上面的示例中的 byte 数组结果就是 63 63 63 63，而63 在 ASCII 中就恰好就对应了 ? 号。\n所以一般我们看到编码出现 ? 基本就说明当前是采用 ISO_8859_1 进行的解码，而当前的字符又大于 255。\n5、代码点和代码单元 在 Java 中的字符串是由 char 序列组成，而 char 又是采用 UTF-16 表示的 Unicode 代码点的代码单元。\n代码点：一个代码点等同于一个 Unicode 字符。 代码单元：在 UTF-16 中，两个字节表示一个代码单元，代码单元是最小的不可拆分的部分，所以如果在 UTF-8 中，一个代码单元就是一个字节，因为 UTF-8 中可以用一个字节表示一个字符。 平常我们调用字符串的 length() 方法，返回的就是代码单元数量，而不是代码点数量，所有如果碰到一些需要用 4 个字节来表示的繁体字，那么代码单元数就会大于代码点数，而想要获取代码点数量，可以通过其他方法获取，获取方式如下：\nString name = \"𤭢\";//\\uD852\\uDF62 System.out.println(name.length());//代码单元数，输出2 System.out.println(name.codePointCount(0, name.length()));//代码点数，输出1 6、Java 默认编码 文件编码：即用记事本或IDE打开文件后右下角的编码，一般为 UTF-8。\n编译编码：用 javac 编译源文件时，默认使用本地编码，即下方的file.encoding的值。但是若文件出现特殊字符，可能会编译失败，报错如下：\nTest.java:9: 错误: 编码GBK的不可映射字符 String s = \"鈫?1\"; 此时必须指定与文件编码一致的编码方式编译 javac -encoding UTF-8 Test.java。\n注意：编译需要先将原始文件中的字符解码，然后编译，最后统一使用UTF-8编码存为 class 文件，即 class 文件的文件编码一定是UTF-8编码。上述所说的本地编码和指定的编码都是对源文件解码的过程，报错也是在该解码阶段包的错。\n运行编码：字符在JVM运行时统一采用UTF-16格式进行编码存储，当对字符串 getBytes(Charset charset)获取字节数组时，若没有参数默认使用的本地编码。注意：String 内部是用 char 数组存储的，而数组中的每个字符是按UTF-16格式存储的，通过getBytes获取时，会先将字符按UTF-16解码获取其中的内容，再按参数指定的编码方式编码，将编码结果存放到byte数组中。\nJava 按照如下顺序获取默认编码defaultCharset也即本地编码：\n获取系统属性 file.encoding的值。如果获取到值就用其对应的编码方式，否则转2。\nSystem.out.println(System.getProperty(\"file.encoding\")); // GBK 如果没有获取到该属性的值，就使用 UTF-8。\n本文大部分摘自为了彻底理解乱码问题，一怒之下我把字符集历史扒了个底朝天 - 双子孤狼 - 博客园 (cnblogs.com)\n","wordCount":"369","inLanguage":"en","datePublished":"2022-04-08T23:08:18Z","dateModified":"2022-04-08T23:08:18Z","author":{"@type":"Person","name":"lu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A0%81/"},"publisher":{"@type":"Organization","name":"lu","logo":{"@type":"ImageObject","url":"https://ethereal-lu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="lu (Alt + H)">lu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethereal-lu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ethereal-lu.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">编码</h1><div class=post-meta><span title='2022-04-08 23:08:18 +0000 UTC'>2022-04-08</span>&nbsp;·&nbsp;369 words&nbsp;·&nbsp;lu</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1为什么使用编码>1、为什么使用编码</a></li><li><a href=#2为什么会乱码>2、为什么会乱码</a></li><li><a href=#3字符集的历史>3、字符集的历史</a><ul><li><a href=#31百花齐放>3.1、百花齐放</a></li><li><a href=#32unicode>3.2、Unicode</a></li></ul></li><li><a href=#4为什么有时候乱码都是--号>4、为什么有时候乱码都是 ? 号</a></li><li><a href=#5代码点和代码单元>5、代码点和代码单元</a></li><li><a href=#6java-默认编码>6、Java 默认编码</a></li></ul></nav></div></details></div><div class=post-content><h2 id=1为什么使用编码>1、为什么使用编码<a hidden class=anchor aria-hidden=true href=#1为什么使用编码>#</a></h2><p>人类的语言并不适合计算机使用，所以就需要发明一种适合计算机的语言，这就是二进制。电脑读不懂人类语言，所以需要将人类语言转换为二进制语言，这就是编码；人类读不懂电脑的二进制语言，所以需要转换为人类语言，这就是解码。</p><h2 id=2为什么会乱码>2、为什么会乱码<a hidden class=anchor aria-hidden=true href=#2为什么会乱码>#</a></h2><p>编码与解码使用的规则不一样，就会乱码。即解码的时候，解码器不知道如何将当前的二进制转换为人类语言，就会乱码。</p><h2 id=3字符集的历史>3、字符集的历史<a hidden class=anchor aria-hidden=true href=#3字符集的历史>#</a></h2><h3 id=31百花齐放>3.1、百花齐放<a hidden class=anchor aria-hidden=true href=#31百花齐放>#</a></h3><p><code>ASCII</code> 码占用了 0~127，即一个字节中的后 7 位。</p><p><code>IOS-8859-n</code> 编码家族占用了 128~255，即利用了 <code>ASCII</code> 码未使用的第 1 位，因此<code>IOS-8859-n</code> 编码家族兼容<code>ASCII</code> 码。</p><hr><p>至此一个字节的 8 位已全部占用，后来的编码必须使用多个字节。</p><hr><p><code>GB2312</code>：<code>GB2312</code> 并不兼容 <code>ISO-8859-n</code> 编码集，但是兼容 <code>ASCII</code> 编码。因为 <code>ASCII</code> 编码中的单字节字符一定是小于 <code>128</code> 的，所以最后我们就决定，中文的双字节字符都从 <code>128</code> 之后开始，也就是当发现字符连续两位都大于 <code>128</code> 时，就说明这是一个中文，指定了之后我们就把这种编码方式称之为 <code>GB2312</code> 编码。</p><p><code>GB2312</code> 中收录的中文汉字都是简体字和常用字，对于一些生僻字以及繁体字没有收录，于是乎 <code>GBK</code> 出现了。</p><p><code>GBK</code>： <code>GBK</code> 只要求第一位是大于 <code>128</code>，第二位可以小于 <code>128</code>，只要发现一个字节大于 <code>128</code>，那么紧随其后的一个字节就是和其作为一个整体作为中文字符。<code>GBK</code>兼容<code>GB2312</code>、<code>ASCII</code>，不兼容<code>IOS-8859-n</code> 。</p><h3 id=32unicode>3.2、Unicode<a hidden class=anchor aria-hidden=true href=#32unicode>#</a></h3><p><code>Unicode</code> 不兼容以上任何编码。<code>Unicode</code> 字符最开始采用的是 <code>UCS-2</code> 标准，<code>UCS-2</code> 标准规定一个字符至少使用 <code>2</code> 个字节来表示。由于无法攘括全世界所有字符，后来又有了 <code>UCS-4</code> 标准，可以用 <code>4</code> 个字节来存储一个字符。</p><p><code>Unicode</code> 编码只是定义了字符集，对于字符集具体应该如何存储并没有做要求。</p><p><code>UTF</code> 系列编码就是对 <code>Unicode</code> 字符集的实现，只不过实现的方式有所区别，其中主要有：<code>UTF-8</code>，<code>UTF-16</code>，<code>UTF-32</code> 等类型。</p><h4 id=321utf-32-编码>3.2.1、UTF-32 编码<a hidden class=anchor aria-hidden=true href=#321utf-32-编码>#</a></h4><p><code>UTF-32</code> 编码基本按照 <code>Unicode</code>字符集标准来实现，任何一个符号都占用 <code>4</code> 个字节。浪费严重。</p><h4 id=322utf-16-编码>3.2.2、UTF-16 编码<a hidden class=anchor aria-hidden=true href=#322utf-16-编码>#</a></h4><p><code>UTF-16</code> 编码相比较 <code>UTF-32</code> 做了一点改进，其采用 <code>2</code> 个字节或者 <code>4</code> 个字节来存储。大部分情况下 <code>UTF-16</code> 编码都是采用 <code>2</code> 个字节来存储，而当 <code>2</code> 个字节存储时，<code>UTF-16</code> 编码会将 <code>Unicode</code> 字符直接转成二进制进行存储，对于另外一些生僻字或者使用较少的符号，<code>UTF-16</code> 编码会采用 <code>4</code> 个字节来存储，但是采用四个字节存储时需要做一次编码转换。</p><p>下表就是 <code>UTF-16</code> 编码的存储格式：</p><table><thead><tr><th>Unicode 编码范围（16 进制）</th><th>UTF-16 编码的二进制存储格式</th></tr></thead><tbody><tr><td>0x0000 0000 - 0x0000 FFFF</td><td>xxxxxxxx xxxxxxxx</td></tr><tr><td>0x0001 0000 - 0x0010 FFFF</td><td>110110xx xxxxxxxx 110111xx xxxxxxxx</td></tr></tbody></table><p>即二字节存储时，直接存 <code>Unicode</code> 码，四字节时将 <code>Unicode</code> 码依次填充到表中的 x 处。</p><pre tabindex=0><code>一个汉字在 UTF-16 编码 中占 2 个或 4 个字节。
</code></pre><h4 id=323utf-8-编码>3.2.3、UTF-8 编码<a hidden class=anchor aria-hidden=true href=#323utf-8-编码>#</a></h4><p><code>UTF-8</code> 是一种变长的编码，兼容了 <code>ASCII</code> 编码，为了实现变长这个特性，那么就必须要有一个规范来规定存储格式，这样当程序读了 <code>2</code> 个或者多个字节时能解析出这到底是表示多个单字节字符还是一个多字节字符。</p><p><code>UTF-8</code> 编码的存储规范如下表所示：</p><table><thead><tr><th>Unicode 编码范围（16 进制）</th><th>UTF-8 编码的二进制存储格式</th></tr></thead><tbody><tr><td>0x0000 0000 - 0x0000 007F</td><td>0xxxxxxx</td></tr><tr><td>0x0000 0080 - 0x0000 07FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>0x0000 0800 - 0x0000 FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>0x0001 0000 - 0x0010 FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><p>接下来我们以 <code>双</code> 字为例来进行说明：</p><p>双：对应的 <code>Unicode</code> 编码为 <code>\u53cc</code>，转成二进制就是：<code>101001111001100</code>，这时候表格中的第一行只有 <code>7</code> 位存不下去，第二列也只有 <code>11</code> 位，也不够存储，所以只能存储到第三列，第三列有 <code>16</code> 位，从后往前依次填补 <code>x</code> 的位置，填完之后还有一位空余，直接补 <code>0</code>，最终得到：<strong>1110</strong>0101 <strong>10</strong>001111 <strong>10</strong>001100，所以<code>双</code> 字就占用了 <code>3</code> 个字节，当然，有些生僻字会占用到四个字节。</p><p>所以上面的 <code>UTF-16</code> 编码也是同理，如果当前字符采用的是两字节存储，那么直接转成二进制存储即可，位数不足直接补 <code>0</code> 即可，而当采用 <code>4</code> 个字节存储时，则需要和 <code>UTF-8</code> 一样进行一次转换，也就是说只能将其填充到 <code>x</code> 的位置，<code>x</code> 之外的是固定格式。</p><p>需要注意的是：在 <code>UTF-16</code> 编码中，<code>2</code> 个字节也可能出现 <code>4</code> 字节中 <code>110110xx</code> 或者 <code>110111xx</code> 开头的格式，这两部分对应的区间分别是：<code>D800~DBFF</code> 和 <code>DC00~DFFF</code>，所以为了避免这种歧义的发生，这两部分区间是是专门空出来的，没有进行编码。</p><p><code>UTF-8</code>存储中，若字节的第一位是 0，表示一个字节即一个<code>Unicode</code> 字符；否则字节开头 1 有几个，就表示该<code>Unicode</code> 字符由几个字节组成。</p><pre tabindex=0><code>一个汉字在 UTF-8 编码 中占 3 个或 4 个字节。
</code></pre><h2 id=4为什么有时候乱码都是--号>4、为什么有时候乱码都是 ? 号<a hidden class=anchor aria-hidden=true href=#4为什么有时候乱码都是--号>#</a></h2><p>在 <code>Java</code> 开发中，经常会碰到乱码显示为 <code>?</code> 号，比如下面这个例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>String name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;双子孤狼&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> bytes <span style=color:#f92672>=</span> name.<span style=color:#a6e22e>getBytes</span>(StandardCharsets.<span style=color:#a6e22e>ISO_8859_1</span>);
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#66d9ef>new</span> String(bytes));<span style=color:#75715e>//输出：????</span>
</span></span></code></pre></div><p>这个输出结果的原因是中文无法用 <code>ISO_8859_1</code> 编码进行存储，而示例中却强制用 <code>ISO_8859_1</code> 编码进行解码。</p><p>在 <code>Java</code> 中提供了一个 <code>ISO_8859_1</code> 类用来解码，解码时当发现当前字符转成十进制之后大于 <code>255</code> 时就会直接不进行解码，转而直接赋一个默认值 <code>63</code>，所以上面的示例中的 <code>byte</code> 数组结果就是 <code>63 63 63 63</code>，而<code>63</code> 在 <code>ASCII</code> 中就恰好就对应了 <code>?</code> 号。</p><p>所以一般我们看到编码出现 <code>?</code> 基本就说明当前是采用 <code>ISO_8859_1</code> 进行的解码，而当前的字符又大于 <code>255</code>。</p><h2 id=5代码点和代码单元>5、代码点和代码单元<a hidden class=anchor aria-hidden=true href=#5代码点和代码单元>#</a></h2><p>在 <code>Java</code> 中的字符串是由 <code>char</code> 序列组成，而 <code>char</code> 又是采用 <code>UTF-16</code> 表示的 <code>Unicode</code> 代码点的代码单元。</p><ul><li>代码点：一个代码点等同于一个 <code>Unicode</code> 字符。</li><li>代码单元：在 <code>UTF-16</code> 中，两个字节表示一个代码单元，代码单元是最小的不可拆分的部分，所以如果在 <code>UTF-8</code> 中，一个代码单元就是一个字节，因为 <code>UTF-8</code> 中可以用一个字节表示一个字符。</li></ul><p>平常我们调用字符串的 <code>length()</code> 方法，返回的就是代码单元数量，而不是代码点数量，所有如果碰到一些需要用 <code>4</code> 个字节来表示的繁体字，那么代码单元数就会大于代码点数，而想要获取代码点数量，可以通过其他方法获取，获取方式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>String name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;𤭢&#34;</span>;<span style=color:#75715e>//\uD852\uDF62</span>
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(name.<span style=color:#a6e22e>length</span>());<span style=color:#75715e>//代码单元数，输出2</span>
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(name.<span style=color:#a6e22e>codePointCount</span>(0, name.<span style=color:#a6e22e>length</span>()));<span style=color:#75715e>//代码点数，输出1</span>
</span></span></code></pre></div><h2 id=6java-默认编码>6、Java 默认编码<a hidden class=anchor aria-hidden=true href=#6java-默认编码>#</a></h2><ul><li><p>文件编码：即用记事本或IDE打开文件后右下角的编码，一般为 <code>UTF-8</code>。</p></li><li><p>编译编码：用 javac 编译源文件时，默认使用本地编码，即下方的<code>file.encoding</code>的值。但是若文件出现特殊字符，可能会编译失败，报错如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Test.<span style=color:#a6e22e>java</span>:9: 错误: 编码GBK的不可映射字符
</span></span><span style=display:flex><span>        String s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;鈫?1&#34;</span>;
</span></span></code></pre></div><p>此时必须指定与文件编码一致的编码方式编译 <code>javac -encoding UTF-8 Test.java</code>。</p><p><strong>注意：编译需要先将原始文件中的字符解码，然后编译，最后统一使用<code>UTF-8</code>编码存为 class 文件，即 class 文件的文件编码一定是<code>UTF-8</code>编码。上述所说的本地编码和指定的编码都是对源文件解码的过程，报错也是在该解码阶段包的错。</strong></p></li><li><p>运行编码：<strong>字符在JVM运行时统一采用<code>UTF-16</code>格式进行编码存储</strong>，当对字符串 <code>getBytes(Charset charset)</code>获取字节数组时，若没有参数默认使用的本地编码。注意：String 内部是用 char 数组存储的，而数组中的每个字符是按<code>UTF-16</code>格式存储的，通过getBytes获取时，会先将字符按<code>UTF-16</code>解码获取其中的内容，再按参数指定的编码方式编码，将编码结果存放到byte数组中。</p></li></ul><p>Java 按照如下顺序获取默认编码<code>defaultCharset</code>也即本地编码：</p><ol><li><p>获取系统属性 <code>file.encoding</code>的值。如果获取到值就用其对应的编码方式，否则转2。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(System.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;file.encoding&#34;</span>));      <span style=color:#75715e>// GBK</span>
</span></span></code></pre></div></li><li><p>如果没有获取到该属性的值，就使用 <code>UTF-8</code>。</p></li></ol><p>本文大部分摘自<a href=https://www.cnblogs.com/lonely-wolf/p/14676335.html>为了彻底理解乱码问题，一怒之下我把字符集历史扒了个底朝天 - 双子孤狼 - 博客园 (cnblogs.com)</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethereal-lu.github.io/posts/linux/linux%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B--fork%E6%96%B9%E6%B3%95/><span class=title>« Prev</span><br><span>linux创建子进程--fork()方法</span>
</a><a class=next href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/rabbitmq/rabbitmq/><span class=title>Next »</span><br><span>RabbitMQ基础</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>