<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>面经碎知识汇总 | lu</title>
<meta name=keywords content><meta name=description content="1、大文件上传
每个分块的文件内容都是通过 MultipartFile 来接收的，改接口的所有实现类都是通过包装 HttpServletRequest 来实现的，故该文件传输是通过 HTTP 协议实现的。
1.1、分片上传

先获取完整文件的 MD5 值，之后将文件分割成相同大小的数据块；
每次上传文件时都携带上 MD5 值、分块序号、文件内容等。
每收到一个分块，便将其存储到文件中，并将分块序号添加到 redis 中。
分块全部上传完成后，将所有分块合成一个完整文件，并将各分块删除。

1.2、断点续传
上传之前先访问一个用于检查的接口来检查已经上传了哪些分块，该接口会将 redis 中的已经上传的分块的序号返回给前端，前端只需根据该结果从未上传的分块开始上传即可实现断点续传。
2、线程抛异常
2.1、普通线程
一个普通线程在运行过程中出现了异常有以下两种场景：

如果该异常被捕获或抛出，则程序继续运行。
如果异常没有被捕获该线程将会停止执行。

Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler，并将线程和异常作为参数传递给该handler的uncaughtException()方法进行处理。因此，可以继承ThreadGroup类并重写其uncaughtException方法来处理异常。
2.2、线程池中的线程
线程池中的某个线程在运行过程中出现了异常有以下场景：

若线程被execute方法执行，则在线程出现异常时会将异常输出在控制台，若线程被submit方法执行，则线程出现异常时不会在控制台输出，必须调用Future.get()方法时，才会输出异常。
一个线程出现异常不会影响线程池里面其他线程的正常执行。
线程出现异常不是被回收而是线程池把这个线程移除掉，同时创建一个新的线程放到线程池中。

submit 内部调用了 execute，为何还有这种区别
因为 submit 方法会将任务封装为 FutureTask （FutureTask 会将 Runnable 通过适配器转为 Callable），而 FutureTask 会捕获线程运行中的异常，将其存储在线程结果信息中，当调用 get 方法时判断线程运行结果状态，有异常就抛出存储的异常信息，因此submit运行异常我们只能用get方法来拿到。
3、TCP 有什么值得改进的地方

TCP是基于四元组的（源IP，目的IP，源端口，目的端口），如果使用中途网络切换了或者连接超时重连后IP换了，那么四元组就改变了，就需要重新发起三次握手连接，所以此处值得改进
TCP保证有序性，如果响应队列中队头的报文没有返回，那么后续报文就会被阻塞。尽管HTTP1.1可以通过Pipelining在一条TCP连接中发送多次HTTP请求，以及HTTP2.0采用多路复用将请求拆分为多个帧传输，但是由于底层使用的还是TCP，因此还存在队头的帧没有传输后续帧被阻塞的情况。因此此处值得改进
TCP 的拥塞控制算法是在丢包之后才开始降低传输速度，而Google 的 BBR 拥塞控制算法是通过主动探测网络带宽和RTT来避免丢包

拥塞控制通过BBR改善，前两点可以通过QUIC协议改善。
QUIC（Quick UDP Internet Connection）是谷歌制定的一种基于UDP的低时延的传输层协议。
QUIC 在 UDP 的基础上融合了 TCP、TSL、HTTP2.0的协议的特性，使其既有低的连接时延，又有高的安全性。
客户端第一次连接服务器时，QUIC只需要1RTT（Round-Trip Time）的延迟就可以建立可靠安全的连接，之后客户端可以在本地缓存加密的认证信息，再次与服务器建立连接时可以实现0-RTT的连接建立延迟。QUIC同时复用了HTTP/2协议的多路复用功能，而且由于QUIC基于UDP所以避免了HTTP/2的队头阻塞。"><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/posts/%E9%9D%A2%E7%BB%8F/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity="sha256-1yREUm1+y9sAFUOKf6iQVKZYv3WdBULi5d+BzpS0k+4=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/posts/%E9%9D%A2%E7%BB%8F/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/posts/%E9%9D%A2%E7%BB%8F/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"><meta property="og:site_name" content="lu"><meta property="og:title" content="面经碎知识汇总"><meta property="og:description" content="1、大文件上传 每个分块的文件内容都是通过 MultipartFile 来接收的，改接口的所有实现类都是通过包装 HttpServletRequest 来实现的，故该文件传输是通过 HTTP 协议实现的。
1.1、分片上传 先获取完整文件的 MD5 值，之后将文件分割成相同大小的数据块； 每次上传文件时都携带上 MD5 值、分块序号、文件内容等。 每收到一个分块，便将其存储到文件中，并将分块序号添加到 redis 中。 分块全部上传完成后，将所有分块合成一个完整文件，并将各分块删除。 1.2、断点续传 上传之前先访问一个用于检查的接口来检查已经上传了哪些分块，该接口会将 redis 中的已经上传的分块的序号返回给前端，前端只需根据该结果从未上传的分块开始上传即可实现断点续传。
2、线程抛异常 2.1、普通线程 一个普通线程在运行过程中出现了异常有以下两种场景：
如果该异常被捕获或抛出，则程序继续运行。 如果异常没有被捕获该线程将会停止执行。 Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler，并将线程和异常作为参数传递给该handler的uncaughtException()方法进行处理。因此，可以继承ThreadGroup类并重写其uncaughtException方法来处理异常。
2.2、线程池中的线程 线程池中的某个线程在运行过程中出现了异常有以下场景：
若线程被execute方法执行，则在线程出现异常时会将异常输出在控制台，若线程被submit方法执行，则线程出现异常时不会在控制台输出，必须调用Future.get()方法时，才会输出异常。 一个线程出现异常不会影响线程池里面其他线程的正常执行。 线程出现异常不是被回收而是线程池把这个线程移除掉，同时创建一个新的线程放到线程池中。 submit 内部调用了 execute，为何还有这种区别
因为 submit 方法会将任务封装为 FutureTask （FutureTask 会将 Runnable 通过适配器转为 Callable），而 FutureTask 会捕获线程运行中的异常，将其存储在线程结果信息中，当调用 get 方法时判断线程运行结果状态，有异常就抛出存储的异常信息，因此submit运行异常我们只能用get方法来拿到。
3、TCP 有什么值得改进的地方 TCP是基于四元组的（源IP，目的IP，源端口，目的端口），如果使用中途网络切换了或者连接超时重连后IP换了，那么四元组就改变了，就需要重新发起三次握手连接，所以此处值得改进 TCP保证有序性，如果响应队列中队头的报文没有返回，那么后续报文就会被阻塞。尽管HTTP1.1可以通过Pipelining在一条TCP连接中发送多次HTTP请求，以及HTTP2.0采用多路复用将请求拆分为多个帧传输，但是由于底层使用的还是TCP，因此还存在队头的帧没有传输后续帧被阻塞的情况。因此此处值得改进 TCP 的拥塞控制算法是在丢包之后才开始降低传输速度，而Google 的 BBR 拥塞控制算法是通过主动探测网络带宽和RTT来避免丢包 拥塞控制通过BBR改善，前两点可以通过QUIC协议改善。
QUIC（Quick UDP Internet Connection）是谷歌制定的一种基于UDP的低时延的传输层协议。
QUIC 在 UDP 的基础上融合了 TCP、TSL、HTTP2.0的协议的特性，使其既有低的连接时延，又有高的安全性。
客户端第一次连接服务器时，QUIC只需要1RTT（Round-Trip Time）的延迟就可以建立可靠安全的连接，之后客户端可以在本地缓存加密的认证信息，再次与服务器建立连接时可以实现0-RTT的连接建立延迟。QUIC同时复用了HTTP/2协议的多路复用功能，而且由于QUIC基于UDP所以避免了HTTP/2的队头阻塞。"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-05T21:12:41+00:00"><meta property="article:modified_time" content="2022-04-05T21:12:41+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="面经碎知识汇总"><meta name=twitter:description content="1、大文件上传
每个分块的文件内容都是通过 MultipartFile 来接收的，改接口的所有实现类都是通过包装 HttpServletRequest 来实现的，故该文件传输是通过 HTTP 协议实现的。
1.1、分片上传

先获取完整文件的 MD5 值，之后将文件分割成相同大小的数据块；
每次上传文件时都携带上 MD5 值、分块序号、文件内容等。
每收到一个分块，便将其存储到文件中，并将分块序号添加到 redis 中。
分块全部上传完成后，将所有分块合成一个完整文件，并将各分块删除。

1.2、断点续传
上传之前先访问一个用于检查的接口来检查已经上传了哪些分块，该接口会将 redis 中的已经上传的分块的序号返回给前端，前端只需根据该结果从未上传的分块开始上传即可实现断点续传。
2、线程抛异常
2.1、普通线程
一个普通线程在运行过程中出现了异常有以下两种场景：

如果该异常被捕获或抛出，则程序继续运行。
如果异常没有被捕获该线程将会停止执行。

Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler，并将线程和异常作为参数传递给该handler的uncaughtException()方法进行处理。因此，可以继承ThreadGroup类并重写其uncaughtException方法来处理异常。
2.2、线程池中的线程
线程池中的某个线程在运行过程中出现了异常有以下场景：

若线程被execute方法执行，则在线程出现异常时会将异常输出在控制台，若线程被submit方法执行，则线程出现异常时不会在控制台输出，必须调用Future.get()方法时，才会输出异常。
一个线程出现异常不会影响线程池里面其他线程的正常执行。
线程出现异常不是被回收而是线程池把这个线程移除掉，同时创建一个新的线程放到线程池中。

submit 内部调用了 execute，为何还有这种区别
因为 submit 方法会将任务封装为 FutureTask （FutureTask 会将 Runnable 通过适配器转为 Callable），而 FutureTask 会捕获线程运行中的异常，将其存储在线程结果信息中，当调用 get 方法时判断线程运行结果状态，有异常就抛出存储的异常信息，因此submit运行异常我们只能用get方法来拿到。
3、TCP 有什么值得改进的地方

TCP是基于四元组的（源IP，目的IP，源端口，目的端口），如果使用中途网络切换了或者连接超时重连后IP换了，那么四元组就改变了，就需要重新发起三次握手连接，所以此处值得改进
TCP保证有序性，如果响应队列中队头的报文没有返回，那么后续报文就会被阻塞。尽管HTTP1.1可以通过Pipelining在一条TCP连接中发送多次HTTP请求，以及HTTP2.0采用多路复用将请求拆分为多个帧传输，但是由于底层使用的还是TCP，因此还存在队头的帧没有传输后续帧被阻塞的情况。因此此处值得改进
TCP 的拥塞控制算法是在丢包之后才开始降低传输速度，而Google 的 BBR 拥塞控制算法是通过主动探测网络带宽和RTT来避免丢包

拥塞控制通过BBR改善，前两点可以通过QUIC协议改善。
QUIC（Quick UDP Internet Connection）是谷歌制定的一种基于UDP的低时延的传输层协议。
QUIC 在 UDP 的基础上融合了 TCP、TSL、HTTP2.0的协议的特性，使其既有低的连接时延，又有高的安全性。
客户端第一次连接服务器时，QUIC只需要1RTT（Round-Trip Time）的延迟就可以建立可靠安全的连接，之后客户端可以在本地缓存加密的认证信息，再次与服务器建立连接时可以实现0-RTT的连接建立延迟。QUIC同时复用了HTTP/2协议的多路复用功能，而且由于QUIC基于UDP所以避免了HTTP/2的队头阻塞。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ethereal-lu.github.io/posts/"},{"@type":"ListItem","position":2,"name":"面经碎知识汇总","item":"https://ethereal-lu.github.io/posts/%E9%9D%A2%E7%BB%8F/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"面经碎知识汇总","name":"面经碎知识汇总","description":"1、大文件上传 每个分块的文件内容都是通过 MultipartFile 来接收的，改接口的所有实现类都是通过包装 HttpServletRequest 来实现的，故该文件传输是通过 HTTP 协议实现的。\n1.1、分片上传 先获取完整文件的 MD5 值，之后将文件分割成相同大小的数据块； 每次上传文件时都携带上 MD5 值、分块序号、文件内容等。 每收到一个分块，便将其存储到文件中，并将分块序号添加到 redis 中。 分块全部上传完成后，将所有分块合成一个完整文件，并将各分块删除。 1.2、断点续传 上传之前先访问一个用于检查的接口来检查已经上传了哪些分块，该接口会将 redis 中的已经上传的分块的序号返回给前端，前端只需根据该结果从未上传的分块开始上传即可实现断点续传。\n2、线程抛异常 2.1、普通线程 一个普通线程在运行过程中出现了异常有以下两种场景：\n如果该异常被捕获或抛出，则程序继续运行。 如果异常没有被捕获该线程将会停止执行。 Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler，并将线程和异常作为参数传递给该handler的uncaughtException()方法进行处理。因此，可以继承ThreadGroup类并重写其uncaughtException方法来处理异常。\n2.2、线程池中的线程 线程池中的某个线程在运行过程中出现了异常有以下场景：\n若线程被execute方法执行，则在线程出现异常时会将异常输出在控制台，若线程被submit方法执行，则线程出现异常时不会在控制台输出，必须调用Future.get()方法时，才会输出异常。 一个线程出现异常不会影响线程池里面其他线程的正常执行。 线程出现异常不是被回收而是线程池把这个线程移除掉，同时创建一个新的线程放到线程池中。 submit 内部调用了 execute，为何还有这种区别\n因为 submit 方法会将任务封装为 FutureTask （FutureTask 会将 Runnable 通过适配器转为 Callable），而 FutureTask 会捕获线程运行中的异常，将其存储在线程结果信息中，当调用 get 方法时判断线程运行结果状态，有异常就抛出存储的异常信息，因此submit运行异常我们只能用get方法来拿到。\n3、TCP 有什么值得改进的地方 TCP是基于四元组的（源IP，目的IP，源端口，目的端口），如果使用中途网络切换了或者连接超时重连后IP换了，那么四元组就改变了，就需要重新发起三次握手连接，所以此处值得改进 TCP保证有序性，如果响应队列中队头的报文没有返回，那么后续报文就会被阻塞。尽管HTTP1.1可以通过Pipelining在一条TCP连接中发送多次HTTP请求，以及HTTP2.0采用多路复用将请求拆分为多个帧传输，但是由于底层使用的还是TCP，因此还存在队头的帧没有传输后续帧被阻塞的情况。因此此处值得改进 TCP 的拥塞控制算法是在丢包之后才开始降低传输速度，而Google 的 BBR 拥塞控制算法是通过主动探测网络带宽和RTT来避免丢包 拥塞控制通过BBR改善，前两点可以通过QUIC协议改善。\nQUIC（Quick UDP Internet Connection）是谷歌制定的一种基于UDP的低时延的传输层协议。\nQUIC 在 UDP 的基础上融合了 TCP、TSL、HTTP2.0的协议的特性，使其既有低的连接时延，又有高的安全性。\n客户端第一次连接服务器时，QUIC只需要1RTT（Round-Trip Time）的延迟就可以建立可靠安全的连接，之后客户端可以在本地缓存加密的认证信息，再次与服务器建立连接时可以实现0-RTT的连接建立延迟。QUIC同时复用了HTTP/2协议的多路复用功能，而且由于QUIC基于UDP所以避免了HTTP/2的队头阻塞。\n","keywords":[],"articleBody":"1、大文件上传 每个分块的文件内容都是通过 MultipartFile 来接收的，改接口的所有实现类都是通过包装 HttpServletRequest 来实现的，故该文件传输是通过 HTTP 协议实现的。\n1.1、分片上传 先获取完整文件的 MD5 值，之后将文件分割成相同大小的数据块； 每次上传文件时都携带上 MD5 值、分块序号、文件内容等。 每收到一个分块，便将其存储到文件中，并将分块序号添加到 redis 中。 分块全部上传完成后，将所有分块合成一个完整文件，并将各分块删除。 1.2、断点续传 上传之前先访问一个用于检查的接口来检查已经上传了哪些分块，该接口会将 redis 中的已经上传的分块的序号返回给前端，前端只需根据该结果从未上传的分块开始上传即可实现断点续传。\n2、线程抛异常 2.1、普通线程 一个普通线程在运行过程中出现了异常有以下两种场景：\n如果该异常被捕获或抛出，则程序继续运行。 如果异常没有被捕获该线程将会停止执行。 Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler，并将线程和异常作为参数传递给该handler的uncaughtException()方法进行处理。因此，可以继承ThreadGroup类并重写其uncaughtException方法来处理异常。\n2.2、线程池中的线程 线程池中的某个线程在运行过程中出现了异常有以下场景：\n若线程被execute方法执行，则在线程出现异常时会将异常输出在控制台，若线程被submit方法执行，则线程出现异常时不会在控制台输出，必须调用Future.get()方法时，才会输出异常。 一个线程出现异常不会影响线程池里面其他线程的正常执行。 线程出现异常不是被回收而是线程池把这个线程移除掉，同时创建一个新的线程放到线程池中。 submit 内部调用了 execute，为何还有这种区别\n因为 submit 方法会将任务封装为 FutureTask （FutureTask 会将 Runnable 通过适配器转为 Callable），而 FutureTask 会捕获线程运行中的异常，将其存储在线程结果信息中，当调用 get 方法时判断线程运行结果状态，有异常就抛出存储的异常信息，因此submit运行异常我们只能用get方法来拿到。\n3、TCP 有什么值得改进的地方 TCP是基于四元组的（源IP，目的IP，源端口，目的端口），如果使用中途网络切换了或者连接超时重连后IP换了，那么四元组就改变了，就需要重新发起三次握手连接，所以此处值得改进 TCP保证有序性，如果响应队列中队头的报文没有返回，那么后续报文就会被阻塞。尽管HTTP1.1可以通过Pipelining在一条TCP连接中发送多次HTTP请求，以及HTTP2.0采用多路复用将请求拆分为多个帧传输，但是由于底层使用的还是TCP，因此还存在队头的帧没有传输后续帧被阻塞的情况。因此此处值得改进 TCP 的拥塞控制算法是在丢包之后才开始降低传输速度，而Google 的 BBR 拥塞控制算法是通过主动探测网络带宽和RTT来避免丢包 拥塞控制通过BBR改善，前两点可以通过QUIC协议改善。\nQUIC（Quick UDP Internet Connection）是谷歌制定的一种基于UDP的低时延的传输层协议。\nQUIC 在 UDP 的基础上融合了 TCP、TSL、HTTP2.0的协议的特性，使其既有低的连接时延，又有高的安全性。\n客户端第一次连接服务器时，QUIC只需要1RTT（Round-Trip Time）的延迟就可以建立可靠安全的连接，之后客户端可以在本地缓存加密的认证信息，再次与服务器建立连接时可以实现0-RTT的连接建立延迟。QUIC同时复用了HTTP/2协议的多路复用功能，而且由于QUIC基于UDP所以避免了HTTP/2的队头阻塞。\n4、进程切换为什么比线程慢 由于进程是资源分配的最小单位，因此切换进程就是切换资源，影响最大的就是虚拟地址空间的切换。由于页表的频繁访问，因此CPU会在MMU中做Cache，也就是TLB快表，如果线程切换，页表就要切换，此时Cache就失效了，因此导致程序变慢。而线程共享进程中的资源，线程的切换不会导致页表的切换。\n注：线程切换和进程切换都需要记录程序计数器、CPU寄存器。\n5、Token 前端使用用户名/密码登录成功后，服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位。\n5.1、浏览器数据存储 浏览器有三种数据存储方式，三者都存储在浏览器的目录下：\ncookie：过期前一直有效；域内共享；domain和path匹配就会自动携带。 localstorage：一直有效；域内共享；仅保存在本地，请求时不会自动携带。 sessionStorage ：浏览器窗口关闭之前有效；浏览器窗口内共享；仅保存在本地，请求时不会自动携带。 5.2、cookie 每个 cookie 中的domain和path这两个属性标识其所属的域名和路径，只有请求的域名和路径都相同才会自动携带 cookie；一个域内可以有多个cookie，它们的path可以不同。cookie 的 http-only 字段若为 true，则域内的 js 无法读写本域的 cookie，可以防止 xss 攻击，该字段只能由服务端设置。\n网页要发http请求时，浏览器会先检查是否有相应的cookie，有则自动添加在request header中的cookie字段中。这些是浏览器自动帮我们做的，无需在前端中通过 js 添加。\ncookie 只保存在客户端，不保存在服务端；服务端每次通过请求中的 cookie 判断用户登陆状态；客户端和服务端都可以设置 cookie。\n5.3、Session Session 必须搭配 Cookie 使用，此时 Cookie 只需要保存一个 sessionid 即可。如果浏览器禁止 Cookie，则会使用 Url 重写方式将 sessionid 放在 url 中进行传递。\nSession对应的类为javax.servlet.http.HttpSession类。每个客户端对应一个Session对象，具体看 servlet 章节。\nSession 存储在 Tomcat 中，在请求过程中 Tomcat 会解析请求中的 sessionId，然后根据 sessionId 获取 Session 信息并保存到 request 中。然后从 request 获取 session，如果存在 session 就说明用户已登录，否则就是登录过期或者未登录，需要新建 session。\n// 根据 request 获取 session HttpSession session = request.getSession(); session.setAttribute(\"name\",\"tom\"); session.getAttribute(\"name\"); // 使其失效；此外只有过期 session 才会失效，过期从最后一次访问服务端开始计时，默认 30 分钟。 session.invalidate(); 5.4、为什么要用 Token？ 避免CSRF攻击：由于 cookie 会在请求时自动携带，而token储存在localStorage，不会被自动携带，必须在 js 中手动添加；js 是基于事件的，只有点击页面内相关元素时才会触发 js 去添加 token，跨域请求无法触发 js 添加 token。 Token 可以是无状态的，可以在多个服务间共享 5.5、无状态 token 有状态 token 即项目中使用的 refresh_token 模型。 无状态 token 即所有状态信息都附加在 Token 上，多个服务端都使用相同的密钥和算法对 token 验证。为了实现用户注销时可控可以让前端在用户注销时删除对应的token。\n5.6、JWT Json web token (JWT)可以通过密码算法生成Token及验证Token。\nJWT生成的Token由三部分组成：\nheader（头部）：存放使用的加密算法，base64加密 payload（数据）：存放Token具体内容，有JWT固定字段，也有用户自定义存入的字段，base64加密 signature（签名）：将前两部分通过base64编码后使用头部的加密算法进行加盐散列的结果 因此，在payload不应该存入私密信息，因为客户端可以通过base64解密获取。三部分通过.连接\n解密时，服务端得到用户发来的Token，使用base64解码获取header和payload，再使用header中的加密算法及服务端存储的盐对前两部分加密，与signature比较，若不一致则验证失败。\n6、大文件读取 对于一个几十G的超大文件，如果全部读取到内存必然OOM。\n6.1、逐行读取 BufferReader：每次使用BufferReader的readLine方法读取一行数据。\nstream：也是一行数据\nStream\u003cString\u003e inputStream = Files.lines(Paths.get(\"test.txt\"), StandardCharsets.UTF_8) Apache Commons IO：也是一行数据，内部使用的还是BufferReader\nLineIterator fileContents = FileUtils.lineIterator(new File(\"test.txt\"), StandardCharsets.UTF_8.name()); 6.2、Spring Batch 知道有这么个东西即可。\n7、序列化ID 类需要序列化必须实现Serializable接口，否则报错。\n7.1、序列化ID的作用 java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地类中的serialVersionUID进行比较，如果相同则认为是一致的，便可以进行反序列化，否则就会报序列化版本不一致的异常。\n7.2、序列化ID如何产生 当类需要序列化时需要在类中显示定义long类型的serialVersionUID变量，如果没有显示定义，Java序列化机制会在编译时自动生成一个serialVersionUID，只要类不改变，每次编译生成的serialVersionUID是一致的。但是如果类的属性或方法等发生改变，再次编译生成的serialVersionUID就会改变。因此如果类发生改变，就会导致反序列化失败。解决办法即在类中显示定义serialVersionUID属性。\n8、单点登录 单点登录就是在多个系统中，用户只需一次登录，各个系统即可感知该用户已经登录。如淘宝和天猫\nCAS （Central Authentication Service）中心认证服务。\n假设目前有系统A和系统B两个系统以及一个认证系统，三者的域名均不同。\n当用户访问系统A时，系统A发现用户没有登录，于是重定向到认证中心，并将自己的地址作为参数传递。 认证中心发现用户未登录，将用户引导至登录页面，用户进行输入用户名和密码进行登录，用户与认证中心建立全局会话（生成一份Token，写到Cookie中，保存在浏览器上） 认证中心重定向回系统A，并把Token携带过去给系统A，系统A去认证中心验证这个Token是否正确，如果正确，则系统A和用户建立局部会话。到此，系统A和用户已经是登录状态了。 当用户访问系统B时，系统B发现用户没有登录，于是重定向到认证中心，并将自己的地址作为参数传递。 由于认证中心的Cookie已经保存在浏览器，因此此次重定向会携带Cookie，认证中心根据Cookie发现用户已登录，认证中心重定向回系统B，并把Token携带过去给系统B。 系统B去认证中心验证这个Token是否正确，如果正确，则系统B和用户建立局部会话。到此，系统B和用户已经是登录状态了。 用户与系统A、B建立会话后，每次请求携带Token，系统A、B再去认证中心认证Token是否正确。（是的吧）\n9、ThreadLocal 9.1、概述 ThreadLocal 存放的是本地线程变量，也就是共享变量的副本，其他线程无权访问该变量。\nThreadLocal 内部包含一个ThreadLocalMap的内部静态类。该内部类存放从ThreadLocal 到本地线程变量的映射。同时每个线程都持有一个ThreadLocalMap的引用，存放该线程所有的本地线程变量，注：一个ThreadLocal只能保存一个变量，而一个线程可以使用多个ThreadLocal来保存多个变量，每个线程只能访问到自己的ThreadLocalMap。\n9.2、get和set set方法首先获取到当前线程的ThreadLocalMap，如果当前线程是第一次使用ThreadLocal，即ThreadLocalMap为null，就会新建ThreadLocalMap并直接存入键值对；如果当前线程之前已经使用过ThreadLocal，现在又用一个新的ThreadLocal来存储其他的值，则ThreadLocalMap就不为null，通过hash定位到槽，如果槽为空，直接存入，否则以线性探测的方式解决碰撞，在探测的过程中如果发现键为null但值还存在，就将当前映射存储或迁移（当前ThreadLocal可能在之前由于碰撞存储在了后边，现在将他向前迁移，一边以后get时可以减少探测次数）到这个槽中，并对ThreadLocalMap进行一次死亡映射的清除。\nget方法首先获取到当前线程的ThreadLocalMap，然后以线性探测的方式找到键值对。同样在探测过程中清除死亡映射。\n9.3、内存泄漏 当我们通过 ThreadLocal\u003c?\u003e local = new ThreadLocal\u003c\u003e();创建一个ThreadLocal，并通过set存入值的时候，ThreadLocal就包含了两个引用，一个是我们显式声明的强引用，一个是存储在ThreadLocalMap中的弱引用。当ThreadLocal由程序员手动设置为null后，强引用就消失了，剩下的弱引用会在下次垃圾回收时清理掉，此时ThreadLocalMap中的键就为null，根据上方的get和set方法，他们会清理掉键为null的值，所以这种情况不会发生内存泄漏。\n但是如果使用的是线程池，线程使用后不会回收，则ThreadLocal一直保持着强引用也不会回收，那么其对应的值也不会回收，这时就会内存泄漏，同时由于使用了上一个线程的ThreadLocal，还可能引起逻辑错误。\n10、大文件修改 机器学习数据动辄上 10G ，需要实现一个在线修改数据的功能。\n调研 普通文件修改、RandomAccessFile、python 的 pandas 类库，最终都需要对整个文件重写，不可行。\n得到两种解决方案：\n以拼凑 sql 语句的方式为每个文件建一张表 将文件分割为多个小文件，修改时只需重写小文件，提交时将文件合并 继续找方法：mmap 内存映射–\u003e 不可行。\n在线修改文档的大致流程：后段将数据全部或部分传给前段、用户修改后前段将修改后的数据全部返回给后段\n11、Redis 连接超时 线上接口报500错误，检查日志后发现是 Redis 连接超时了。排查思路如下：\n看连接配置是否正确（ip，port，password） 看redis客户端的连接池是否耗尽（netstat -an | gerp 6379 | grep ESTABLISHED | wc -l）【原理没懂，面试暂时不说】 看redis服务器连接数是否达到最大（info clients 实际连接数；config get maxclients 最大连接数） 看是否为网络问题（堡垒机连接 redis ，执行简单命令测试一下） 检查代码问题，是否使用完后释放连接，没有释放可能造成连接泄漏 网络抖动 经过排查，都没有问题，而且不再报这个错了，所以暂时归为网络抖动；后来偶尔又报这个错，排查发现 redis 连接数确实比平时多很多，看日志发现是有大量的 Mysql 向 ES 同步请求（此处虚伪道歉并解释接口的作用及调用接口会建立 redis 连接）。而在之后统计发现并不是每次报错都是频繁调用该接口引起。最终将该问题判定为网络抖动原因或者 Mysql 向 ES 同步速度过快或其他原因导致的偶发性Redis 连接超时问题，由于偶发性超时不可避免，故在此处捕获异常并打印 Notice 级别的日志处理。\n998、场景设计类题目 1、设计一个秒杀场景可能会遇到什么问题？ 这条搭配着下一题看把。\n从流量入口出发，秒杀场景会有大量请求同时到达服务器，而服务器只有有限资源处理这些请求，同时还要尽可能快地处理，在入口处可能需要做一些鉴权、限流、缓存、日志和监控等。流量进入入口之后，需要做一些流量削峰、资源隔离、服务器优化和负载均衡，之后还有服务降级、服务限流、拒绝请求。到达扣减库存时，需要有缓存以及用分布式锁控制并发读写，同时考虑用阻塞队列、线程池的方式让用户先拿到秒杀资格，再通过异步计算返回给客户。\n2、如何设计秒杀场景？ 秒杀场景的关键就是面对大量的请求可以正常提供服务并做出快速响应，同时保证数据的一致性。\n流量过滤及削峰\n前端添加验证码或者答题可以起到错峰的效果 参加活动可以设置一些条件，通过条件以及一些其他黑名单等对流量进行校验过滤 将大量请求存入消息队列中，消费者订阅消费，起到削峰的作用 性能优化\n页面静态化，将活动页面缓存到CDN中，对这些静态资源的请求不进入服务器，减轻压力 活动预热，将活动库存提前加载到Redis中，查询全部走缓存 资源隔离，为秒杀活动单独部署一套系统，剥离一些无用逻辑 数据一致性\n关于何时减库存有两种方案：1、下单时减库存；2、支付时减库存。由于支付时减库存实现较为复杂并且秒杀场景下用户不支付的概率较低，因此一般选择下单时减库存的方式。\n具体减库存方案：\n由于已经将活动库存缓存到Redis中，故先查询Redis库存是否充足 先减数据库库存再减Redis库存，两个操作在一个事务中。（可以将多个扣减库存合并，减轻数据库压力） 先减库存再生成订单，防止订单生成了没有库存的超卖问题 质量保障\n服务降级：当请求量达到系统承受的能力时，需要对系统的一些非核心功能进行关闭操作，尽可能将资源留给秒杀核心链路。\n服务限流：限流的目的是通过对并发访问/请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，常用的有 QPS 限流。\n拒绝请求：如果服务降级、服务限流都不能解决问题，最后的兜底，那就是直接拒绝用户请求，比如直接给用户返回 “服务器繁忙，请稍后再试”等提示文案。只会发生在服务器负载过载时会启动，因此只会发生短暂不可用时刻，由于此时服务依然还在稳定运行中，等负载下降时，可以快速恢复正常服务。\n999、短问题 1、cpu特别高如何定位 先使用 top 命令定位到那个进程占用的 cpu 高，一般 cpu 占用高要么是 cpu 密集型任务，要么就是发生了死循环，定位到进程后可以使用 jstack 定位到异常代码的位置。\n2、sql执行慢的原因 如果 sql 平时正常只是偶尔执行慢，可能是网络抖动或者在等待锁。\n如果 sql 一直执行慢，那一般是 sql 语句本身有问题，可能的问题如下：\n没有使用索引；where 条件的字段没有索引，或者有索引但没有走上。 单表数据量过大 3、Spring事务失效的原因 @Transactional 修饰的方法必须是 public 修饰符 @Transactional 所在的类没有加载为 bean 使用 try...catch..捕获了事务的异常，但是没有抛出RuntimeExecption，事务不回滚 在类A里面有方法a 和方法b， 然后方法b上面用 @Transactional加了方法级别的事务，在方法a里面调用了方法b， 方法b里面的事务不会生效 数据库引擎是 MyISAM 4、什么原因导致频繁的youngGC？ 短时间内构造了大量小对象。\n5、日志为什么使用slf4j + logback slf4j只是一个日志标准，并不是日志系统的具体实现。slf4j只做两件事情：\n提供日志接口 提供获取具体日志对象的方法 slf4j-simple、logback都是slf4j的具体实现，log4j并不直接实现slf4j，但是有专门的一层桥接slf4j-log4j12来实现slf4j。\n项目中的日志采集分为两部分，一种是通过AspectJ将切入点抽取到注解中，这种方式获取的注解存入数据库中用于项目需求中的展示。另一种是通过slf4j + logback，在代码中手动获取日志，存放在文件中，具体的保存什么信息、文件存在哪里在logback.xml配置。\n6、TCP粘包 发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾。\n发生TCP粘包的原因有两种\n发送方写入缓冲区的速度大于发送的速度 接收方读取缓冲区的速度小于接收的速度 解决方案：由于TCP是按需发送与到达。可以给每条数据都设置固定的开始符与结束符；也可以在每条数据的开头指明该数据包的长度。\n7、java 方法内的局部变量是否安全 局部变量是存储在线程栈帧的局部变量表中，是线程私有的数据，因此是线程安全的。\n8、Arrays.sort(int[] a) 对于基本数据类型数组的排序，排序算法的选择和数组长度的关系如下：\n数组长度 所使用的排序算法 length \u003c 47 插入排序 47 \u003c= length \u003c 286 快速排序 length \u003e= 286 且数组基本有序 归并排序 length \u003e= 286 且数组基本无序 快速排序 对于引用数组的排序使用了TimSort算法，TimSort是一种归并排序算法，但是在小片段的合并中用了插入排序。因为数据量小时，归并排序需要递归拆分数组并比较，效率比插入排序低。\n9、如何了解前沿技术 OSCHINA（开源中国）、segmentfault、美团技术团队、谷歌开发者社区；公众号或知乎如 路人甲\n","wordCount":"447","inLanguage":"en","datePublished":"2022-04-05T21:12:41Z","dateModified":"2022-04-05T21:12:41Z","author":{"@type":"Person","name":"lu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ethereal-lu.github.io/posts/%E9%9D%A2%E7%BB%8F/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},"publisher":{"@type":"Organization","name":"lu","logo":{"@type":"ImageObject","url":"https://ethereal-lu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://ethereal-lu.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethereal-lu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ethereal-lu.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">面经碎知识汇总</h1><div class=post-meta><span title='2022-04-05 21:12:41 +0000 UTC'>2022-04-05</span>&nbsp;·&nbsp;447 words&nbsp;·&nbsp;lu</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1大文件上传>1、大文件上传</a><ul><li><a href=#11分片上传>1.1、分片上传</a></li><li><a href=#12断点续传>1.2、断点续传</a></li></ul></li><li><a href=#2线程抛异常>2、线程抛异常</a><ul><li><a href=#21普通线程>2.1、普通线程</a></li><li><a href=#22线程池中的线程>2.2、线程池中的线程</a></li></ul></li><li><a href=#3tcp-有什么值得改进的地方>3、TCP 有什么值得改进的地方</a></li><li><a href=#4进程切换为什么比线程慢>4、进程切换为什么比线程慢</a></li><li><a href=#5token>5、Token</a><ul><li><a href=#51浏览器数据存储>5.1、浏览器数据存储</a></li><li><a href=#52cookie>5.2、cookie</a></li><li><a href=#53session>5.3、Session</a></li><li><a href=#54为什么要用-token>5.4、为什么要用 Token？</a></li><li><a href=#55无状态-token>5.5、无状态 token</a></li><li><a href=#56jwt>5.6、JWT</a></li></ul></li><li><a href=#6大文件读取>6、大文件读取</a><ul><li><a href=#61逐行读取>6.1、逐行读取</a></li><li><a href=#62spring-batch>6.2、Spring Batch</a></li></ul></li><li><a href=#7序列化id>7、序列化ID</a><ul><li><a href=#71序列化id的作用>7.1、序列化ID的作用</a></li><li><a href=#72序列化id如何产生>7.2、序列化ID如何产生</a></li></ul></li><li><a href=#8单点登录>8、单点登录</a></li><li><a href=#9threadlocal>9、ThreadLocal</a><ul><li><a href=#91概述>9.1、概述</a></li><li><a href=#92get和set>9.2、get和set</a></li><li><a href=#93内存泄漏>9.3、内存泄漏</a></li></ul></li><li><a href=#10大文件修改>10、大文件修改</a></li><li><a href=#11redis-连接超时>11、Redis 连接超时</a></li><li><a href=#998场景设计类题目>998、场景设计类题目</a><ul><li><a href=#1设计一个秒杀场景可能会遇到什么问题>1、设计一个秒杀场景可能会遇到什么问题？</a></li><li><a href=#2如何设计秒杀场景>2、如何设计秒杀场景？</a></li></ul></li><li><a href=#999短问题>999、短问题</a><ul><li><a href=#1cpu特别高如何定位>1、cpu特别高如何定位</a></li><li><a href=#2sql执行慢的原因>2、sql执行慢的原因</a></li><li><a href=#3spring事务失效的原因>3、Spring事务失效的原因</a></li><li><a href=#4什么原因导致频繁的younggc>4、什么原因导致频繁的youngGC？</a></li><li><a href=#5日志为什么使用slf4j--logback>5、日志为什么使用slf4j + logback</a></li><li><a href=#6tcp粘包>6、TCP粘包</a></li><li><a href=#7java-方法内的局部变量是否安全>7、java 方法内的局部变量是否安全</a></li><li><a href=#8arrayssortint-a>8、Arrays.sort(int[] a)</a></li><li><a href=#9如何了解前沿技术>9、如何了解前沿技术</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=1大文件上传>1、大文件上传<a hidden class=anchor aria-hidden=true href=#1大文件上传>#</a></h2><p>每个分块的文件内容都是通过 MultipartFile 来接收的，改接口的所有实现类都是通过包装 HttpServletRequest 来实现的，故该文件传输是通过 HTTP 协议实现的。</p><h3 id=11分片上传>1.1、分片上传<a hidden class=anchor aria-hidden=true href=#11分片上传>#</a></h3><ul><li>先获取完整文件的 MD5 值，之后将文件分割成相同大小的数据块；</li><li>每次上传文件时都携带上 MD5 值、分块序号、文件内容等。</li><li>每收到一个分块，便将其存储到文件中，并将分块序号添加到 redis 中。</li><li>分块全部上传完成后，将所有分块合成一个完整文件，并将各分块删除。</li></ul><h3 id=12断点续传>1.2、断点续传<a hidden class=anchor aria-hidden=true href=#12断点续传>#</a></h3><p>上传之前先访问一个用于检查的接口来检查已经上传了哪些分块，该接口会将 redis 中的已经上传的分块的序号返回给前端，前端只需根据该结果从未上传的分块开始上传即可实现断点续传。</p><h2 id=2线程抛异常>2、线程抛异常<a hidden class=anchor aria-hidden=true href=#2线程抛异常>#</a></h2><h3 id=21普通线程>2.1、普通线程<a hidden class=anchor aria-hidden=true href=#21普通线程>#</a></h3><p>一个普通线程在运行过程中出现了异常有以下两种场景：</p><ol><li>如果该异常被捕获或抛出，则程序继续运行。</li><li>如果异常没有被捕获该线程将会停止执行。</li></ol><p>Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler，并将线程和异常作为参数传递给该handler的uncaughtException()方法进行处理。因此，可以继承ThreadGroup类并重写其uncaughtException方法来处理异常。</p><h3 id=22线程池中的线程>2.2、线程池中的线程<a hidden class=anchor aria-hidden=true href=#22线程池中的线程>#</a></h3><p>线程池中的某个线程在运行过程中出现了异常有以下场景：</p><ol><li>若线程被execute方法执行，则在线程出现异常时会将异常输出在控制台，若线程被submit方法执行，则线程出现异常时不会在控制台输出，必须调用Future.get()方法时，才会输出异常。</li><li>一个线程出现异常不会影响线程池里面其他线程的正常执行。</li><li>线程出现异常不是被回收而是线程池把这个线程移除掉，同时创建一个新的线程放到线程池中。</li></ol><p><strong>submit 内部调用了 execute，为何还有这种区别</strong></p><p>因为 submit 方法会将任务封装为 FutureTask （FutureTask 会将 Runnable 通过适配器转为 Callable），而 FutureTask 会捕获线程运行中的异常，将其存储在线程结果信息中，当调用 get 方法时判断线程运行结果状态，有异常就抛出存储的异常信息，因此submit运行异常我们只能用get方法来拿到。</p><h2 id=3tcp-有什么值得改进的地方>3、TCP 有什么值得改进的地方<a hidden class=anchor aria-hidden=true href=#3tcp-有什么值得改进的地方>#</a></h2><ul><li>TCP是基于四元组的（源IP，目的IP，源端口，目的端口），如果使用中途网络切换了或者连接超时重连后IP换了，那么四元组就改变了，就需要重新发起三次握手连接，所以此处值得改进</li><li>TCP保证有序性，如果响应队列中队头的报文没有返回，那么后续报文就会被阻塞。尽管HTTP1.1可以通过Pipelining在一条TCP连接中发送多次HTTP请求，以及HTTP2.0采用多路复用将请求拆分为多个帧传输，但是由于底层使用的还是TCP，因此还存在队头的帧没有传输后续帧被阻塞的情况。因此此处值得改进</li><li>TCP 的拥塞控制算法是在丢包之后才开始降低传输速度，而Google 的 BBR 拥塞控制算法是通过主动探测网络带宽和RTT来避免丢包</li></ul><p>拥塞控制通过BBR改善，前两点可以通过QUIC协议改善。</p><p>QUIC（Quick UDP Internet Connection）是谷歌制定的一种基于UDP的低时延的传输层协议。</p><p>QUIC 在 UDP 的基础上融合了 TCP、TSL、HTTP2.0的协议的特性，使其既有低的连接时延，又有高的安全性。</p><p>客户端第一次连接服务器时，QUIC只需要1RTT（Round-Trip Time）的延迟就可以建立可靠安全的连接，之后客户端可以在本地缓存加密的认证信息，再次与服务器建立连接时可以实现0-RTT的连接建立延迟。QUIC同时复用了HTTP/2协议的多路复用功能，而且由于QUIC基于UDP所以避免了HTTP/2的队头阻塞。</p><h2 id=4进程切换为什么比线程慢>4、进程切换为什么比线程慢<a hidden class=anchor aria-hidden=true href=#4进程切换为什么比线程慢>#</a></h2><p>由于进程是资源分配的最小单位，因此切换进程就是切换资源，影响最大的就是虚拟地址空间的切换。由于页表的频繁访问，因此CPU会在MMU中做Cache，也就是TLB快表，如果线程切换，页表就要切换，此时Cache就失效了，因此导致程序变慢。而线程共享进程中的资源，线程的切换不会导致页表的切换。</p><p>注：线程切换和进程切换都需要记录程序计数器、CPU寄存器。</p><h2 id=5token>5、Token<a hidden class=anchor aria-hidden=true href=#5token>#</a></h2><p>前端使用用户名/密码登录成功后，服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位。</p><h3 id=51浏览器数据存储>5.1、浏览器数据存储<a hidden class=anchor aria-hidden=true href=#51浏览器数据存储>#</a></h3><p>浏览器有三种数据存储方式，三者都存储在浏览器的目录下：</p><ul><li>cookie：过期前一直有效；域内共享；domain和path匹配就会自动携带。</li><li>localstorage：一直有效；域内共享；仅保存在本地，请求时不会自动携带。</li><li>sessionStorage ：浏览器窗口关闭之前有效；浏览器窗口内共享；仅保存在本地，请求时不会自动携带。</li></ul><h3 id=52cookie>5.2、cookie<a hidden class=anchor aria-hidden=true href=#52cookie>#</a></h3><p>每个 cookie 中的domain和path这两个属性标识其所属的域名和路径，只有请求的域名和路径都相同才会自动携带 cookie；一个域内可以有多个cookie，它们的path可以不同。cookie 的 http-only 字段若为 true，则域内的 js 无法读写本域的 cookie，可以防止 xss 攻击，该字段只能由服务端设置。</p><p>网页要发<code>http</code>请求时，浏览器会先检查是否有相应的<code>cookie</code>，有则自动添加在<code>request header</code>中的<code>cookie</code>字段中。这些是浏览器自动帮我们做的，无需在前端中通过 js 添加。</p><p>cookie 只保存在客户端，不保存在服务端；服务端每次通过请求中的 cookie 判断用户登陆状态；客户端和服务端都可以设置 cookie。</p><h3 id=53session>5.3、Session<a hidden class=anchor aria-hidden=true href=#53session>#</a></h3><p>Session 必须搭配 Cookie 使用，此时 Cookie 只需要保存一个 sessionid 即可。如果浏览器禁止 Cookie，则会使用 Url 重写方式将 sessionid 放在 url 中进行传递。</p><p>Session对应的类为javax.servlet.http.HttpSession类。每个客户端对应一个Session对象，具体看 servlet 章节。</p><p>Session 存储在 Tomcat 中，在请求过程中 Tomcat 会解析请求中的 sessionId，然后根据 sessionId 获取 Session 信息并保存到 request 中。然后从 request 获取 session，如果存在 session 就说明用户已登录，否则就是登录过期或者未登录，需要新建 session。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 根据 request 获取 session</span>
</span></span><span style=display:flex><span>HttpSession session <span style=color:#f92672>=</span> request.<span style=color:#a6e22e>getSession</span>();
</span></span><span style=display:flex><span>session.<span style=color:#a6e22e>setAttribute</span>(<span style=color:#e6db74>&#34;name&#34;</span>,<span style=color:#e6db74>&#34;tom&#34;</span>);
</span></span><span style=display:flex><span>session.<span style=color:#a6e22e>getAttribute</span>(<span style=color:#e6db74>&#34;name&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// 使其失效；此外只有过期 session 才会失效，过期从最后一次访问服务端开始计时，默认 30 分钟。</span>
</span></span><span style=display:flex><span>session.<span style=color:#a6e22e>invalidate</span>();
</span></span></code></pre></div><h3 id=54为什么要用-token>5.4、为什么要用 Token？<a hidden class=anchor aria-hidden=true href=#54为什么要用-token>#</a></h3><ol><li>避免CSRF攻击：由于 cookie 会在请求时自动携带，而token储存在<code>localStorage</code>，不会被自动携带，必须在 js 中手动添加；js 是基于事件的，只有点击页面内相关元素时才会触发 js 去添加 token，跨域请求无法触发 js 添加 token。</li><li>Token 可以是无状态的，可以在多个服务间共享</li></ol><h3 id=55无状态-token>5.5、无状态 token<a hidden class=anchor aria-hidden=true href=#55无状态-token>#</a></h3><p>有状态 token 即项目中使用的 refresh_token 模型。 无状态 token 即所有状态信息都附加在 Token 上，多个服务端都使用相同的密钥和算法对 token 验证。为了实现用户注销时可控可以让前端在用户注销时删除对应的token。</p><h3 id=56jwt>5.6、JWT<a hidden class=anchor aria-hidden=true href=#56jwt>#</a></h3><p>Json web token (JWT)可以通过密码算法生成Token及验证Token。</p><p>JWT生成的Token由三部分组成：</p><ul><li>header（头部）：存放使用的加密算法，base64加密</li><li>payload（数据）：存放Token具体内容，有JWT固定字段，也有用户自定义存入的字段，base64加密</li><li>signature（签名）：将前两部分通过base64编码后使用头部的加密算法进行加盐散列的结果</li></ul><p>因此，在payload不应该存入私密信息，因为客户端可以通过base64解密获取。三部分通过<code>.</code>连接</p><p>解密时，服务端得到用户发来的Token，使用base64解码获取header和payload，再使用header中的加密算法及服务端存储的盐对前两部分加密，与signature比较，若不一致则验证失败。</p><h2 id=6大文件读取>6、大文件读取<a hidden class=anchor aria-hidden=true href=#6大文件读取>#</a></h2><p>对于一个几十G的超大文件，如果全部读取到内存必然OOM。</p><h3 id=61逐行读取>6.1、逐行读取<a hidden class=anchor aria-hidden=true href=#61逐行读取>#</a></h3><ul><li><p>BufferReader：每次使用BufferReader的readLine方法读取一行数据。</p></li><li><p>stream：也是一行数据</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Stream<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> inputStream <span style=color:#f92672>=</span> Files.<span style=color:#a6e22e>lines</span>(Paths.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;test.txt&#34;</span>), StandardCharsets.<span style=color:#a6e22e>UTF_8</span>)
</span></span></code></pre></div></li><li><p>Apache Commons IO：也是一行数据，内部使用的还是BufferReader</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>LineIterator fileContents <span style=color:#f92672>=</span> FileUtils.<span style=color:#a6e22e>lineIterator</span>(<span style=color:#66d9ef>new</span> File(<span style=color:#e6db74>&#34;test.txt&#34;</span>), StandardCharsets.<span style=color:#a6e22e>UTF_8</span>.<span style=color:#a6e22e>name</span>());
</span></span></code></pre></div></li></ul><h3 id=62spring-batch>6.2、Spring Batch<a hidden class=anchor aria-hidden=true href=#62spring-batch>#</a></h3><p>知道有这么个东西即可。</p><h2 id=7序列化id>7、序列化ID<a hidden class=anchor aria-hidden=true href=#7序列化id>#</a></h2><p>类需要序列化必须实现Serializable接口，否则报错。</p><h3 id=71序列化id的作用>7.1、序列化ID的作用<a hidden class=anchor aria-hidden=true href=#71序列化id的作用>#</a></h3><p>java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地类中的serialVersionUID进行比较，如果相同则认为是一致的，便可以进行反序列化，否则就会报序列化版本不一致的异常。</p><h3 id=72序列化id如何产生>7.2、序列化ID如何产生<a hidden class=anchor aria-hidden=true href=#72序列化id如何产生>#</a></h3><p>当类需要序列化时需要在类中<strong>显示</strong>定义<code>long</code>类型的<code>serialVersionUID</code>变量，如果没有显示定义，Java序列化机制会在编译时自动生成一个serialVersionUID，只要类不改变，每次编译生成的serialVersionUID是一致的。但是如果类的属性或方法等发生改变，再次编译生成的serialVersionUID就会改变。因此如果类发生改变，就会导致反序列化失败。解决办法即在类中显示定义serialVersionUID属性。</p><h2 id=8单点登录>8、单点登录<a hidden class=anchor aria-hidden=true href=#8单点登录>#</a></h2><p><a href=https://zhuanlan.zhihu.com/p/66037342>单点登录</a>就是在多个系统中，用户只需一次登录，各个系统即可感知该用户已经登录。如淘宝和天猫</p><p>CAS （Central Authentication Service）中心认证服务。</p><p>假设目前有系统A和系统B两个系统以及一个认证系统，三者的域名均不同。</p><ol><li>当用户访问系统A时，系统A发现用户没有登录，于是重定向到认证中心，并将自己的地址作为参数传递。</li><li>认证中心发现用户未登录，将用户引导至登录页面，用户进行输入用户名和密码进行登录，用户与认证中心建立全局会话（生成一份Token，写到Cookie中，保存在浏览器上）</li><li>认证中心重定向回系统A，并把Token携带过去给系统A，系统A去认证中心验证这个Token是否正确，如果正确，则系统A和用户建立局部会话。到此，系统A和用户已经是登录状态了。</li><li>当用户访问系统B时，系统B发现用户没有登录，于是重定向到认证中心，并将自己的地址作为参数传递。</li><li>由于认证中心的Cookie已经保存在浏览器，因此此次重定向会携带Cookie，认证中心根据Cookie发现用户已登录，认证中心重定向回系统B，并把Token携带过去给系统B。</li><li>系统B去认证中心验证这个Token是否正确，如果正确，则系统B和用户建立局部会话。到此，系统B和用户已经是登录状态了。</li></ol><p>用户与系统A、B建立会话后，每次请求携带Token，系统A、B再去认证中心认证Token是否正确。（是的吧）</p><h2 id=9threadlocal>9、ThreadLocal<a hidden class=anchor aria-hidden=true href=#9threadlocal>#</a></h2><h3 id=91概述>9.1、概述<a hidden class=anchor aria-hidden=true href=#91概述>#</a></h3><p><code>ThreadLocal</code> 存放的是本地线程变量，也就是共享变量的副本，其他线程无权访问该变量。</p><p><code>ThreadLocal</code> 内部包含一个<code>ThreadLocalMap</code>的内部静态类。该内部类存放从<code>ThreadLocal</code> 到本地线程变量的映射。同时每个线程都持有一个<code>ThreadLocalMap</code>的引用，存放该线程所有的本地线程变量，注：一个<code>ThreadLocal</code>只能保存一个变量，而一个线程可以使用多个<code>ThreadLocal</code>来保存多个变量，每个线程只能访问到自己的<code>ThreadLocalMap</code>。</p><h3 id=92get和set>9.2、get和set<a hidden class=anchor aria-hidden=true href=#92get和set>#</a></h3><p>set方法首先获取到当前线程的<code>ThreadLocalMap</code>，如果当前线程是第一次使用<code>ThreadLocal</code>，即<code>ThreadLocalMap</code>为null，就会新建<code>ThreadLocalMap</code>并直接存入键值对；如果当前线程之前已经使用过<code>ThreadLocal</code>，现在又用一个新的<code>ThreadLocal</code>来存储其他的值，则<code>ThreadLocalMap</code>就不为null，通过<code>hash</code>定位到槽，如果槽为空，直接存入，否则以线性探测的方式解决碰撞，在探测的过程中如果发现键为null但值还存在，就将当前映射存储或迁移（当前<code>ThreadLocal</code>可能在之前由于碰撞存储在了后边，现在将他向前迁移，一边以后get时可以减少探测次数）到这个槽中，并对<code>ThreadLocalMap</code>进行一次死亡映射的清除。</p><p>get方法首先获取到当前线程的<code>ThreadLocalMap</code>，然后以线性探测的方式找到键值对。同样在探测过程中清除死亡映射。</p><h3 id=93内存泄漏>9.3、内存泄漏<a hidden class=anchor aria-hidden=true href=#93内存泄漏>#</a></h3><p>当我们通过 <code>ThreadLocal&lt;?> local = new ThreadLocal&lt;>();</code>创建一个<code>ThreadLocal</code>，并通过set存入值的时候，<code>ThreadLocal</code>就包含了两个引用，一个是我们显式声明的强引用，一个是存储在<code>ThreadLocalMap</code>中的弱引用。当<code>ThreadLocal</code>由程序员手动设置为null后，强引用就消失了，剩下的弱引用会在下次垃圾回收时清理掉，此时<code>ThreadLocalMap</code>中的键就为null，根据上方的get和set方法，他们会清理掉键为null的值，所以这种情况不会发生内存泄漏。</p><p>但是如果使用的是线程池，线程使用后不会回收，则<code>ThreadLocal</code>一直保持着强引用也不会回收，那么其对应的值也不会回收，这时就会内存泄漏，同时由于使用了上一个线程的<code>ThreadLocal</code>，还可能引起逻辑错误。</p><h2 id=10大文件修改>10、大文件修改<a hidden class=anchor aria-hidden=true href=#10大文件修改>#</a></h2><p>机器学习数据动辄上 10G ，需要实现一个在线修改数据的功能。</p><p>调研 普通文件修改、RandomAccessFile、python 的 pandas 类库，最终都需要对整个文件重写，不可行。</p><p>得到两种解决方案：</p><ul><li>以拼凑 sql 语句的方式为每个文件建一张表</li><li>将文件分割为多个小文件，修改时只需重写小文件，提交时将文件合并</li></ul><p>继续找方法：mmap 内存映射&ndash;> 不可行。</p><p>在线修改文档的大致流程：后段将数据全部或部分传给前段、用户修改后前段将修改后的数据全部返回给后段</p><h2 id=11redis-连接超时>11、Redis 连接超时<a hidden class=anchor aria-hidden=true href=#11redis-连接超时>#</a></h2><p>线上接口报500错误，检查日志后发现是 Redis 连接超时了。排查思路如下：</p><ol><li>看连接配置是否正确（ip，port，password）</li><li>看redis客户端的连接池是否耗尽（netstat -an | gerp 6379 | grep ESTABLISHED | wc -l）【原理没懂，面试暂时不说】</li><li>看redis服务器连接数是否达到最大（info clients 实际连接数；config get maxclients 最大连接数）</li><li>看是否为网络问题（堡垒机连接 redis ，执行简单命令测试一下）</li><li>检查代码问题，是否使用完后释放连接，没有释放可能造成连接泄漏</li><li>网络抖动</li></ol><p>经过排查，都没有问题，而且不再报这个错了，所以暂时归为网络抖动；后来偶尔又报这个错，排查发现 redis 连接数确实比平时多很多，看日志发现是有大量的 Mysql 向 ES 同步请求（此处虚伪道歉并解释接口的作用及调用接口会建立 redis 连接）。而在之后统计发现并不是每次报错都是频繁调用该接口引起。最终将该问题判定为网络抖动原因或者 Mysql 向 ES 同步速度过快或其他原因导致的偶发性Redis 连接超时问题，由于偶发性超时不可避免，故在此处捕获异常并打印 Notice 级别的日志处理。</p><h2 id=998场景设计类题目>998、场景设计类题目<a hidden class=anchor aria-hidden=true href=#998场景设计类题目>#</a></h2><h3 id=1设计一个秒杀场景可能会遇到什么问题>1、设计一个秒杀场景可能会遇到什么问题？<a hidden class=anchor aria-hidden=true href=#1设计一个秒杀场景可能会遇到什么问题>#</a></h3><p>这条搭配着下一题看把。</p><p>从流量入口出发，秒杀场景会有大量请求同时到达服务器，而服务器只有有限资源处理这些请求，同时还要尽可能快地处理，在入口处可能需要做一些鉴权、限流、缓存、日志和监控等。流量进入入口之后，需要做一些流量削峰、资源隔离、服务器优化和负载均衡，之后还有服务降级、服务限流、拒绝请求。到达扣减库存时，需要有缓存以及用分布式锁控制并发读写，同时考虑用阻塞队列、线程池的方式让用户先拿到秒杀资格，再通过异步计算返回给客户。</p><h3 id=2如何设计秒杀场景>2、如何设计秒杀场景？<a hidden class=anchor aria-hidden=true href=#2如何设计秒杀场景>#</a></h3><p>秒杀场景的关键就是面对大量的请求可以正常提供服务并做出快速响应，同时保证数据的一致性。</p><p><strong>流量过滤及削峰</strong></p><ol><li>前端添加验证码或者答题可以起到错峰的效果</li><li>参加活动可以设置一些条件，通过条件以及一些其他黑名单等对流量进行校验过滤</li><li>将大量请求存入消息队列中，消费者订阅消费，起到削峰的作用</li></ol><p><strong>性能优化</strong></p><ol><li>页面静态化，将活动页面缓存到CDN中，对这些静态资源的请求不进入服务器，减轻压力</li><li>活动预热，将活动库存提前加载到Redis中，查询全部走缓存</li><li>资源隔离，为秒杀活动单独部署一套系统，剥离一些无用逻辑</li></ol><p><strong>数据一致性</strong></p><p>关于何时减库存有两种方案：1、下单时减库存；2、支付时减库存。由于支付时减库存实现较为复杂并且秒杀场景下用户不支付的概率较低，因此一般选择下单时减库存的方式。</p><p>具体减库存方案：</p><ol><li>由于已经将活动库存缓存到Redis中，故先查询Redis库存是否充足</li><li>先减数据库库存再减Redis库存，两个操作在一个事务中。（可以将多个扣减库存合并，减轻数据库压力）</li><li>先减库存再生成订单，防止订单生成了没有库存的超卖问题</li></ol><p><strong>质量保障</strong></p><ul><li><p>服务降级：当请求量达到系统承受的能力时，需要对系统的一些非核心功能进行关闭操作，尽可能将资源留给秒杀核心链路。</p></li><li><p>服务限流：限流的目的是通过对并发访问/请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，常用的有 QPS 限流。</p></li><li><p><strong>拒绝请求</strong>：如果服务降级、服务限流都不能解决问题，最后的兜底，那就是直接拒绝用户请求，比如直接给用户返回 “服务器繁忙，请稍后再试”等提示文案。只会发生在服务器负载过载时会启动，因此只会发生短暂不可用时刻，由于此时服务依然还在稳定运行中，等负载下降时，可以快速恢复正常服务。</p></li></ul><h2 id=999短问题>999、短问题<a hidden class=anchor aria-hidden=true href=#999短问题>#</a></h2><h3 id=1cpu特别高如何定位>1、cpu特别高如何定位<a hidden class=anchor aria-hidden=true href=#1cpu特别高如何定位>#</a></h3><p>先使用 top 命令定位到那个进程占用的 cpu 高，一般 cpu 占用高要么是 cpu 密集型任务，要么就是发生了死循环，定位到进程后可以使用 jstack 定位到异常代码的位置。</p><h3 id=2sql执行慢的原因>2、sql执行慢的原因<a hidden class=anchor aria-hidden=true href=#2sql执行慢的原因>#</a></h3><p>如果 sql 平时正常只是偶尔执行慢，可能是网络抖动或者在等待锁。</p><p>如果 sql 一直执行慢，那一般是 sql 语句本身有问题，可能的问题如下：</p><ul><li>没有使用索引；where 条件的字段没有索引，或者有索引但没有走上。</li><li>单表数据量过大</li></ul><h3 id=3spring事务失效的原因>3、Spring事务失效的原因<a hidden class=anchor aria-hidden=true href=#3spring事务失效的原因>#</a></h3><ul><li>@Transactional 修饰的方法必须是 public 修饰符</li><li>@Transactional 所在的类没有加载为 bean</li><li>使用 <code>try...catch..</code>捕获了事务的异常，但是没有抛出<code>RuntimeExecption</code>，事务不回滚</li><li>在类A里面有方法a 和方法b， 然后方法b上面用 @Transactional加了方法级别的事务，在方法a里面调用了方法b， 方法b里面的事务不会生效</li><li>数据库引擎是 MyISAM</li></ul><h3 id=4什么原因导致频繁的younggc>4、什么原因导致频繁的youngGC？<a hidden class=anchor aria-hidden=true href=#4什么原因导致频繁的younggc>#</a></h3><p>短时间内构造了大量小对象。</p><h3 id=5日志为什么使用slf4j--logback>5、日志为什么使用slf4j + logback<a hidden class=anchor aria-hidden=true href=#5日志为什么使用slf4j--logback>#</a></h3><p><strong>slf4j只是一个日志标准，并不是日志系统的具体实现</strong>。slf4j只做两件事情：</p><ul><li>提供日志接口</li><li>提供获取具体日志对象的方法</li></ul><p>slf4j-simple、logback都是slf4j的具体实现，log4j并不直接实现slf4j，但是有专门的一层桥接slf4j-log4j12来实现slf4j。</p><p>项目中的日志采集分为两部分，一种是通过AspectJ将切入点抽取到注解中，这种方式获取的注解存入数据库中用于项目需求中的展示。另一种是通过slf4j + logback，在代码中手动获取日志，存放在文件中，具体的保存什么信息、文件存在哪里在logback.xml配置。</p><h3 id=6tcp粘包>6、TCP粘包<a hidden class=anchor aria-hidden=true href=#6tcp粘包>#</a></h3><p>发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾。</p><p>发生TCP粘包的原因有两种</p><ul><li>发送方写入缓冲区的速度大于发送的速度</li><li>接收方读取缓冲区的速度小于接收的速度</li></ul><p>解决方案：由于TCP是按需发送与到达。可以给每条数据都设置固定的开始符与结束符；也可以在每条数据的开头指明该数据包的长度。</p><h3 id=7java-方法内的局部变量是否安全>7、java 方法内的局部变量是否安全<a hidden class=anchor aria-hidden=true href=#7java-方法内的局部变量是否安全>#</a></h3><p>局部变量是存储在线程栈帧的局部变量表中，是线程私有的数据，因此是线程安全的。</p><h3 id=8arrayssortint-a>8、Arrays.sort(int[] a)<a hidden class=anchor aria-hidden=true href=#8arrayssortint-a>#</a></h3><p>对于基本数据类型数组的排序，排序算法的选择和数组长度的关系如下：</p><table><thead><tr><th>数组长度</th><th>所使用的排序算法</th></tr></thead><tbody><tr><td>length &lt; 47</td><td>插入排序</td></tr><tr><td>47 &lt;= length &lt; 286</td><td>快速排序</td></tr><tr><td>length >= 286 且数组基本有序</td><td>归并排序</td></tr><tr><td>length >= 286 且数组基本无序</td><td>快速排序</td></tr></tbody></table><p>对于引用数组的排序使用了TimSort算法，TimSort是一种归并排序算法，但是在小片段的合并中用了插入排序。因为数据量小时，归并排序需要递归拆分数组并比较，效率比插入排序低。</p><h3 id=9如何了解前沿技术>9、如何了解前沿技术<a hidden class=anchor aria-hidden=true href=#9如何了解前沿技术>#</a></h3><p>OSCHINA（开源中国）、segmentfault、美团技术团队、谷歌开发者社区；公众号或知乎如 路人甲</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethereal-lu.github.io/posts/java/java-%E8%BF%9B%E9%98%B6/bionioaio/><span class=title>« Prev</span><br><span>BIO,NIO,AIO</span>
</a><a class=next href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E7%AC%94%E8%AE%B0/><span class=title>Next »</span><br><span>Redis基础</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>