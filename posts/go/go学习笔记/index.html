<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go 基础 | lu</title>
<meta name=keywords content><meta name=description content='1、基础


包含有 main 函数的包，其包名必须是 main。包名与文件名没有任何关系。但在只包含一个main函数的项目中，一般文件名与包名一致


go 语句的末尾加不加分号都可以，建议不加


导包时推荐使用第二种


// 1
import "fmt"
import "time"
// 2
import (
	"fmt"
	"time"
)

函数体前的大括号必须与函数名在同一行，否则报错

func main() {
	fmt.Println("hello go")
}

同样 if else 中的 else 必须与 if 的末尾大括号在同一行，否则报错

if arr == nil {
    fmt.Println("空切片")
} else {
    fmt.Println("非空")
}
2、变量
2.1、变量声明
方法一二三既可以用于局部变量也可以用于全局变量，而方法四只能在函数体内用于局部变量
// 方法一：只声明，不显式赋值，默认值为0
var a int
fmt.Println(a)  // 0

// 方法二：声明并显式初始化
var b int = 100
fmt.Println(b)  // 100

// 方法三：初始化时省去数据类型，自动推导
var c = "abc"
fmt.Println(c)  // "abc"

// 方法四：省去 var 关键字，直接使用海象运算符类型推导（常用这种），表示声明并初始化
d := 4.5
fmt.Println(d)  // 4.5
fmt.Printf("type of d is %T\n", d)  // 格式化打印，%T 表示打印变量类型；此处输出为 float64
2.2、多个变量的声明
var aa, bb = 100, 200
var cc, dd = 4.5, "abc"

// 或者下面这种写法
var (
    ee = 300
    ff = true
)

// 也可以这样
gg, hh := 3, true
3、常量与枚举
func main() {
	// 常量（只读）
	const length = 10
	fmt.Println(length)
}

// const 定义枚举类型
const (
	// 在第一个枚举成员后赋值关键字 iota，之后的每行的成员的值自动加 1
	SPRING = iota   // iota 为常量 0
	SUMMER          // 1
	AUTUMN          // 2
	WINTER          // 3
)

const (
	// 也可以赋值 iota 的表达式，此时之后的成员都会在 iota 加一的基础上赋值表达式
	SPRING = iota * 10   // 0
	SUMMER               // 10
	AUTUMN               // 20
	WINTER               // 30
)

// iota 逐行累加；iota 只能出现在 const 的括号中
const (
	a, b = iota + 1, iota + 2  // iota = 0; a = 1; b = 2
	c, d                       // iota = 1; c = 2; d = 3
	e, f                       // iota = 2; e = 3; f = 4
	
	g, h = iota * 2, iota * 3  // iota = 3; g = 6; h = 9
	i, k                       // iota = 4; i = 8; k = 12
)
4、函数
若函数名首字母大写，表示 public；小写，表示 private'><meta name=author content="lu"><link rel=canonical href=http://localhost:1313/posts/go/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity="sha256-1yREUm1+y9sAFUOKf6iQVKZYv3WdBULi5d+BzpS0k+4=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/go/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/go/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="lu"><meta property="og:title" content="Go 基础"><meta property="og:description" content='1、基础 包含有 main 函数的包，其包名必须是 main。包名与文件名没有任何关系。但在只包含一个main函数的项目中，一般文件名与包名一致
go 语句的末尾加不加分号都可以，建议不加
导包时推荐使用第二种
// 1 import "fmt" import "time" // 2 import ( "fmt" "time" ) 函数体前的大括号必须与函数名在同一行，否则报错 func main() { fmt.Println("hello go") } 同样 if else 中的 else 必须与 if 的末尾大括号在同一行，否则报错 if arr == nil { fmt.Println("空切片") } else { fmt.Println("非空") } 2、变量 2.1、变量声明 方法一二三既可以用于局部变量也可以用于全局变量，而方法四只能在函数体内用于局部变量
// 方法一：只声明，不显式赋值，默认值为0 var a int fmt.Println(a) // 0 // 方法二：声明并显式初始化 var b int = 100 fmt.Println(b) // 100 // 方法三：初始化时省去数据类型，自动推导 var c = "abc" fmt.Println(c) // "abc" // 方法四：省去 var 关键字，直接使用海象运算符类型推导（常用这种），表示声明并初始化 d := 4.5 fmt.Println(d) // 4.5 fmt.Printf("type of d is %T\n", d) // 格式化打印，%T 表示打印变量类型；此处输出为 float64 2.2、多个变量的声明 var aa, bb = 100, 200 var cc, dd = 4.5, "abc" // 或者下面这种写法 var ( ee = 300 ff = true ) // 也可以这样 gg, hh := 3, true 3、常量与枚举 func main() { // 常量（只读） const length = 10 fmt.Println(length) } // const 定义枚举类型 const ( // 在第一个枚举成员后赋值关键字 iota，之后的每行的成员的值自动加 1 SPRING = iota // iota 为常量 0 SUMMER // 1 AUTUMN // 2 WINTER // 3 ) const ( // 也可以赋值 iota 的表达式，此时之后的成员都会在 iota 加一的基础上赋值表达式 SPRING = iota * 10 // 0 SUMMER // 10 AUTUMN // 20 WINTER // 30 ) // iota 逐行累加；iota 只能出现在 const 的括号中 const ( a, b = iota + 1, iota + 2 // iota = 0; a = 1; b = 2 c, d // iota = 1; c = 2; d = 3 e, f // iota = 2; e = 3; f = 4 g, h = iota * 2, iota * 3 // iota = 3; g = 6; h = 9 i, k // iota = 4; i = 8; k = 12 ) 4、函数 若函数名首字母大写，表示 public；小写，表示 private'><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-01-02T17:39:41+00:00"><meta property="article:modified_time" content="2021-01-02T17:39:41+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go 基础"><meta name=twitter:description content='1、基础


包含有 main 函数的包，其包名必须是 main。包名与文件名没有任何关系。但在只包含一个main函数的项目中，一般文件名与包名一致


go 语句的末尾加不加分号都可以，建议不加


导包时推荐使用第二种


// 1
import "fmt"
import "time"
// 2
import (
	"fmt"
	"time"
)

函数体前的大括号必须与函数名在同一行，否则报错

func main() {
	fmt.Println("hello go")
}

同样 if else 中的 else 必须与 if 的末尾大括号在同一行，否则报错

if arr == nil {
    fmt.Println("空切片")
} else {
    fmt.Println("非空")
}
2、变量
2.1、变量声明
方法一二三既可以用于局部变量也可以用于全局变量，而方法四只能在函数体内用于局部变量
// 方法一：只声明，不显式赋值，默认值为0
var a int
fmt.Println(a)  // 0

// 方法二：声明并显式初始化
var b int = 100
fmt.Println(b)  // 100

// 方法三：初始化时省去数据类型，自动推导
var c = "abc"
fmt.Println(c)  // "abc"

// 方法四：省去 var 关键字，直接使用海象运算符类型推导（常用这种），表示声明并初始化
d := 4.5
fmt.Println(d)  // 4.5
fmt.Printf("type of d is %T\n", d)  // 格式化打印，%T 表示打印变量类型；此处输出为 float64
2.2、多个变量的声明
var aa, bb = 100, 200
var cc, dd = 4.5, "abc"

// 或者下面这种写法
var (
    ee = 300
    ff = true
)

// 也可以这样
gg, hh := 3, true
3、常量与枚举
func main() {
	// 常量（只读）
	const length = 10
	fmt.Println(length)
}

// const 定义枚举类型
const (
	// 在第一个枚举成员后赋值关键字 iota，之后的每行的成员的值自动加 1
	SPRING = iota   // iota 为常量 0
	SUMMER          // 1
	AUTUMN          // 2
	WINTER          // 3
)

const (
	// 也可以赋值 iota 的表达式，此时之后的成员都会在 iota 加一的基础上赋值表达式
	SPRING = iota * 10   // 0
	SUMMER               // 10
	AUTUMN               // 20
	WINTER               // 30
)

// iota 逐行累加；iota 只能出现在 const 的括号中
const (
	a, b = iota + 1, iota + 2  // iota = 0; a = 1; b = 2
	c, d                       // iota = 1; c = 2; d = 3
	e, f                       // iota = 2; e = 3; f = 4
	
	g, h = iota * 2, iota * 3  // iota = 3; g = 6; h = 9
	i, k                       // iota = 4; i = 8; k = 12
)
4、函数
若函数名首字母大写，表示 public；小写，表示 private'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Go 基础","item":"http://localhost:1313/posts/go/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go 基础","name":"Go 基础","description":"1、基础 包含有 main 函数的包，其包名必须是 main。包名与文件名没有任何关系。但在只包含一个main函数的项目中，一般文件名与包名一致\ngo 语句的末尾加不加分号都可以，建议不加\n导包时推荐使用第二种\n// 1 import \u0026#34;fmt\u0026#34; import \u0026#34;time\u0026#34; // 2 import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) 函数体前的大括号必须与函数名在同一行，否则报错 func main() { fmt.Println(\u0026#34;hello go\u0026#34;) } 同样 if else 中的 else 必须与 if 的末尾大括号在同一行，否则报错 if arr == nil { fmt.Println(\u0026#34;空切片\u0026#34;) } else { fmt.Println(\u0026#34;非空\u0026#34;) } 2、变量 2.1、变量声明 方法一二三既可以用于局部变量也可以用于全局变量，而方法四只能在函数体内用于局部变量\n// 方法一：只声明，不显式赋值，默认值为0 var a int fmt.Println(a) // 0 // 方法二：声明并显式初始化 var b int = 100 fmt.Println(b) // 100 // 方法三：初始化时省去数据类型，自动推导 var c = \u0026#34;abc\u0026#34; fmt.Println(c) // \u0026#34;abc\u0026#34; // 方法四：省去 var 关键字，直接使用海象运算符类型推导（常用这种），表示声明并初始化 d := 4.5 fmt.Println(d) // 4.5 fmt.Printf(\u0026#34;type of d is %T\\n\u0026#34;, d) // 格式化打印，%T 表示打印变量类型；此处输出为 float64 2.2、多个变量的声明 var aa, bb = 100, 200 var cc, dd = 4.5, \u0026#34;abc\u0026#34; // 或者下面这种写法 var ( ee = 300 ff = true ) // 也可以这样 gg, hh := 3, true 3、常量与枚举 func main() { // 常量（只读） const length = 10 fmt.Println(length) } // const 定义枚举类型 const ( // 在第一个枚举成员后赋值关键字 iota，之后的每行的成员的值自动加 1 SPRING = iota // iota 为常量 0 SUMMER // 1 AUTUMN // 2 WINTER // 3 ) const ( // 也可以赋值 iota 的表达式，此时之后的成员都会在 iota 加一的基础上赋值表达式 SPRING = iota * 10 // 0 SUMMER // 10 AUTUMN // 20 WINTER // 30 ) // iota 逐行累加；iota 只能出现在 const 的括号中 const ( a, b = iota + 1, iota + 2 // iota = 0; a = 1; b = 2 c, d // iota = 1; c = 2; d = 3 e, f // iota = 2; e = 3; f = 4 g, h = iota * 2, iota * 3 // iota = 3; g = 6; h = 9 i, k // iota = 4; i = 8; k = 12 ) 4、函数 若函数名首字母大写，表示 public；小写，表示 private\n","keywords":[],"articleBody":"1、基础 包含有 main 函数的包，其包名必须是 main。包名与文件名没有任何关系。但在只包含一个main函数的项目中，一般文件名与包名一致\ngo 语句的末尾加不加分号都可以，建议不加\n导包时推荐使用第二种\n// 1 import \"fmt\" import \"time\" // 2 import ( \"fmt\" \"time\" ) 函数体前的大括号必须与函数名在同一行，否则报错 func main() { fmt.Println(\"hello go\") } 同样 if else 中的 else 必须与 if 的末尾大括号在同一行，否则报错 if arr == nil { fmt.Println(\"空切片\") } else { fmt.Println(\"非空\") } 2、变量 2.1、变量声明 方法一二三既可以用于局部变量也可以用于全局变量，而方法四只能在函数体内用于局部变量\n// 方法一：只声明，不显式赋值，默认值为0 var a int fmt.Println(a) // 0 // 方法二：声明并显式初始化 var b int = 100 fmt.Println(b) // 100 // 方法三：初始化时省去数据类型，自动推导 var c = \"abc\" fmt.Println(c) // \"abc\" // 方法四：省去 var 关键字，直接使用海象运算符类型推导（常用这种），表示声明并初始化 d := 4.5 fmt.Println(d) // 4.5 fmt.Printf(\"type of d is %T\\n\", d) // 格式化打印，%T 表示打印变量类型；此处输出为 float64 2.2、多个变量的声明 var aa, bb = 100, 200 var cc, dd = 4.5, \"abc\" // 或者下面这种写法 var ( ee = 300 ff = true ) // 也可以这样 gg, hh := 3, true 3、常量与枚举 func main() { // 常量（只读） const length = 10 fmt.Println(length) } // const 定义枚举类型 const ( // 在第一个枚举成员后赋值关键字 iota，之后的每行的成员的值自动加 1 SPRING = iota // iota 为常量 0 SUMMER // 1 AUTUMN // 2 WINTER // 3 ) const ( // 也可以赋值 iota 的表达式，此时之后的成员都会在 iota 加一的基础上赋值表达式 SPRING = iota * 10 // 0 SUMMER // 10 AUTUMN // 20 WINTER // 30 ) // iota 逐行累加；iota 只能出现在 const 的括号中 const ( a, b = iota + 1, iota + 2 // iota = 0; a = 1; b = 2 c, d // iota = 1; c = 2; d = 3 e, f // iota = 2; e = 3; f = 4 g, h = iota * 2, iota * 3 // iota = 3; g = 6; h = 9 i, k // iota = 4; i = 8; k = 12 ) 4、函数 若函数名首字母大写，表示 public；小写，表示 private\n4.1、单个返回值 结构：func 函数名(参数名 参数类型, 参数名 参数类型, …) 返回类型 { 函数体 }\nfunc function1(a string, b int) int { length := len(a) return length + b } func main() { c := function1(\"abc\", 3) fmt.Println(c) } 4.2、多个返回值，返回参数匿名 结构：func 函数名(参数名 参数类型, 参数名 参数类型, …) (返回类型, 返回类型, …) { 函数体 }\nfunc function2(a string, b int) (int, int) { length := len(a) return length, length + b } func main() { c, d := function2(\"abc\", 3) fmt.Println(c) fmt.Println(d) } 4.3、多个返回值，指定返回参数名 结构：func 函数名(参数名 参数类型, 参数名 参数类型, …) (返回参数名 返回类型, 返回参数名 返回类型, …) { 函数体 }\n注意：在这种方式中， r1 和 r2 在函数体内部是作为函数的形参存在的，它们默认值与其他局部变量一样，都是0。在函数体内可以任意调用。\nfunc function3(a string, b int) (r1 int, r2 int) { r1 = len(a) r2 = b + r1 return // 这种方式只写个 return 即可 } func main() { c, d := function3(\"abc\", 3) fmt.Println(c) fmt.Println(d) } // 若所有的返回类型都相同，可以这样写 func function3(a string, b int) (r1, r2 int) { ... } // 同样，若参数类型都相同，也可以这样写 func function3(a, b int) (r1, r2 int) { ... } 4.4、init 函数与 import 导包 先递归将所有依赖中的 init 函数执行完，再执行本包的 init ，最后执行 main 方法。\n4.4.1、匿名导包 同变量一样，若导入的包没有使用，编译器也会报错。\n若想使用某包的 init 方法，但不调用它的其他任何方法，可以匿名导包（在导入的包前加 下划线 空格）\nimport ( _ \"time\" ) // 此时即使不使用time包的任何函数，也会调用其 init 方法，且编译器不报错 4.4.2、导包起别名 import ( t \"time\" ) func main() { t.Sleep(2) } 4.4.3、省略包名调用函数 【不推荐使用】，若多个包有重名函数，会引发混乱。\n这种方式相当于将 time 包下的所有函数都导入本包中，调用时无需带上包名。 和 python 类似。\nimport ( . \"time\" ) func main() { Sleep(2) } 5、指针 go 中很少出现指针\ngo 的指针和 c 完全一样，同样支持二级指针等\nfunc changeValue(p *int) { *p = 10 } func main() { var a = 1 changeValue(\u0026a) fmt.Println(a) } 6、defer 可以在任何函数的任意行写一个 defer ，其后加任意一条语句。该关键字的作用类似于 C++ 的析构函数或 JAVA 的 try catch finally 中的finally，它会在函数的其他语句全部执行结束后执行（这里的其他语句包括 return 语句）\n若同一个函数中有多条 defer 修饰的语句，则这些语句按栈的顺序执行，即写在前面的语句靠后执行。\nfunc deferFunc() { defer fmt.Println(\"func defer\") fmt.Println(\"func\") } func main() { defer fmt.Println(\"defer 1\") defer fmt.Println(\"defer 2\") fmt.Println(\"code\") deferFunc() } 7、切片 slice 切片其实是一种动态数组\n7.1、数组 // 只声明，不初始化 var arr [10]int // 初始化 arr1 := [10]int{1, 2, 3, 4} // 普通 for 循环 for i := 0; i \u003c len(arr1); i++ { fmt.Println(arr1[i]) } // foreach，两个值分别为 下标和对应的值 for index, value := range arr1 { fmt.Println(\"index = \", index, \", value = \", value) } 注意：在 go 中，长度不同的数组会被视为不同的类型，如 [10]int 和 [4]int 是不同的类型；当数组作为参数时，必须指定数组的大小，且指定后其他长度的数组将不能传递过来。\n这是由于在 go 中，数组作为参数依然是值传递，即函数会根据参数的数组长度新建一个数组，并将传递过来的数组中的值拷贝到新建的数组中，因此它严格要求数组长度。\n// 下方代码编译时出错：Cannot use 'arr' (type [4]int) as the type [10]int func main() { arr := [4]int{1, 2, 3, 4} printArr(arr) } func printArr(arr [10]int) { for index, value := range arr { fmt.Println(\"index = \", index, \", value = \", value) } } 7.2、切片 如上，由于固定长度的数组在传递时较麻烦，因此一般使用动态数组（切片）。\n所谓动态数组即在声明时不显示指定数组的长度。\n使用动态数组时，函数的参数传递是引用传递。\nfunc main() { array := []int{1, 2, 3, 4} printArray(array) } func printArray(arr []int) { // 此处第一个变量名取下划线表示这是匿名，即不使用它。 for _, value := range arr { fmt.Println(value) } } 7.3、切片的声明 切片的底层依然是数组，切片名是指向数组头部的指针\n// 方式一：声明并初始化 slice := []int{1, 2, 3} // 方式二：只声明，不初始化。此时没有分配空间，需要使用 make 为其开辟空间 var slice []int slice = make([]int, 3) // 参数 -- 》 类型，数量 // 方式三：用 make 初始化 var slice []int = make([]int, 3) // 元素全为 0 // 方式四：推断 + make (一般采用这种) slice := make([]int, 3) 7.4、切片的扩容 在 go 中，切片有容量和长度之分。arr := make([]int, 3, 5)表示创建一个容量为 5，长度为 3 的切片。\n对于切片的读取操作只能在长度范围内进行，超出长度范围但在容量范围内的内存不能读取操作。\n如果切片当前长度已经用尽，可以使用 arr = append(arr, 1)在切片末尾追加元素，此时长度为 4， 容量为 5。\n如果多次追加后长度和容量相等，还想继续追加，依然使用 arr = append(arr, 1)，此时长度为 6， 容量为 10；即容量扩容为原来的 2 倍。一般每次追加一个元素时，容量是扩容 2 倍。\n切片的容量发生改变时，会新建切片，并将原切片的数据赋值到新地址。\n切片详细的扩容机制和多方面因素有关，如数据类型、每次追加元素的个数以及当前容量大小等，较为复杂。当需要时可以网上查。\narr := make([]int, 3)未显示设置容量时，长度和容量相等。\n7.5、切片的截取 go 的切片截取方式与 python 完全相同\na := []int{1, 2, 3, 4, 5, 6} b := a[1:4] // 左闭右开 c := a[:4] // 从 0 开始截取 d := a[1:] // 截取到末尾 e := a[:] // 全部截取 go 的截取共享内存空间，即此时若将 a[1] = 100，则 b[0] 的值也会变为 100。特殊地，若截取后 a 发生扩容，a 将指向新的内存，此时两者不共享内存，a 的值的改变不影响 b\n若想要不共享内存，需要手动创建一个新切片，再使用 copy 函数拷贝，如下：\nf := make([]int, 3) copy(f, a[1:4]) 8、map map 的变量名是指向内存地址的指针，map 作为函数参数时是引用传递。\n8.1、map 的声明定义 结构：map[键类型]值类型\n一般二三种用的多\n// 方式一：声明与初始化分开；make 初始分配10个空间，和切片一样，会自动扩容 var myMap map[int]string myMap = make(map[int]string, 10) // 方式二：海象运算符，声明并初始化；可以不指定初始空间大小，使用不变 myMap := make(map[int]string) // 方式三：声明时直接赋值 myMap := map[int]string { 1: \"java\", 2: \"python\", 3: \"go\", // 注意，go 最后一个元素之后也要加逗号 } 8.2、使用 capital := make(map[string]string) // 添加 capital[\"China\"] = \"Beijing\" capital[\"Japan\"] = \"Tokyo\" capital[\"USA\"] = \"NewYork\" // 遍历 for key, value := range capital { fmt.Println(key, value) } // 删除 delete(capital, \"Japan\") // 修改 capital[\"USA\"] = \"DC\" 9、面向对象 Go 语言中没有“类”的概念，但同样有面向对象，因为面向对象只是一种编程思想。\n9.1、结构体 type 关键字：用于声明一种新的数据类型\n若结构体中只有属性，不涉及方法时，go 的结构体与 c 完全一样\ntype Book struct { title string auth string } func main() { var book Book book.title = \"Golang\" book.auth = \"me\" } 9.2、封装 大写对应 public；小写对应 private，这适用于 结构体名、属性名、方法名。在 go 中叫导出与不被导出。\n// 类内部只允许定义属性，不允许定义方法；方法必须写在外面绑定到类 type Person struct { Name string Age int } // func 与方法名之间的括号表示该方法的接收者为 *Person，即该方法绑定到 Person 类 // 若接收者为 Person 表示是值传递，若接收者为 *Person 表示引用传递 // 可以将接收者视为该方法的第一个参数，这样理解后括号中即为(参数名，参数类型) func (person *Person) Show() { fmt.Println(\"Name = \", person.Name) fmt.Println(\"Age = \", person.Age) } func (person *Person) GetName() string { return person.Name } func (person *Person) SetName(newName string) { person.Name = newName } func main() { // 亦可 person := Person{\"shen zi\", 21} person := Person{Name: \"shen zi\", Age: 21} person.Show() person.SetName(\"lin hua\") person.Show() } 9.3、继承 type Female struct { Person // 继承 Person 结构体 cup string } // Show 重写父类方法 func (female *Female) Show() { female.Person.Show() fmt.Println(female.cup) } // Makeup 自定义新方法 func (female *Female) Makeup() { fmt.Println(female.Name, \"is makeup\") } func main() { // 亦可如此 // var female Female // female.Name = \"yin\" // female.Age = 20 // female.cup = \"36D\" female := Female{Person{\"yin\", 20}, \"36D\"} female.Makeup() // 调用子类方法 female.SetName(\"ying\") // 调用父类方法 female.Show() // 调用子类方法 } 9.4、多态 go 中只能通过接口实现多态。\n任何类只要实现了某接口中的所有方法，就将此类视为该接口的实现类，无需在类中引入接口名。\n// Animal 本质是一个指针 type Animal interface { Eat() GetName() string GetType() string } // Cat 具体的类 type Cat struct { Name string // 无需引入接口名 } // Cat 实现了 Animal 接口的所有方法，则 Cat 为 Animal 的实现类 func (cat *Cat) Eat() { fmt.Println(\"cat is eat\") } func (cat *Cat) GetName() string { return cat.Name } func (cat *Cat) GetType() string { return \"cat\" } func (cat *Cat) Sleep() { // Cat 自己的方法 fmt.Println(\"cat is sleep\") } // Dog 具体的类 type Dog struct { Name string } // 同样 Dog 也是 Animal 的实现类 func (dog *Dog) Eat() { fmt.Println(\"dog is eat\") } func (dog *Dog) GetName() string { return dog.Name } func (dog *Dog) GetType() string { return \"dog\" } func main() { var animal Animal animal = \u0026Cat{\"mimi\"} // 由于 Animal 本质是一个指针，故需要赋值地址 animal.Eat() animal = \u0026Dog{\"wang\"} animal.Eat() } 接口与接收者类型之间的关系有两个注意点：\n值接收者和指针接收者代表了两种完全不同的类型，其对接口的实现是独立的。 当类型对某接口实现时，要么是值接收者类型的对该接口的实现，要么是指针接收者类型对该接口的实现，二者只能选一个，不能共存。当为值接收者实现某方法时，GO编译器会自动的为其指针接收者也实现该方法。 type Animal interface { Eat() } type Dog struct { Name string } func (dog Dog) Eat() { fmt.Println(\"dog is eat\") } func main() { var animal Animal animal = \u0026Dog{\"wang\"} // 由于值接收者类型实现了该接口，故同样可以以引用的方式构造对象 animal.Eat() // 但调用方法时不论是值对象还是引用对象传递的都是值 animal = Dog{\"wang\"} animal.Eat() } 9.5、空接口 空接口 interface{} 是万能数据类型，类似于 java 的 Object。区别在于 Java 中只有引用类型继承了 Object，而在 go 中，包括 int、double、float 等在内的基础类型与引用类型以及自定义类型都继承了interface{}，即 go 中的所有类型都继承 interface{}。\nfunc Func(arg interface{}) { fmt.Println(arg) } type Film struct { Name string } func main() { film := Film{\"movie\"} Func(film) // {movie} Func(100) // 100 Func(\"abc\") // abc Func(3.14) // 3.14 } 9.6、类型断言 类型断言机制x.(T) 检查 x 的动态类型是否是 T，其中 x 必须是接口值（包括空接口）。\nfunc Func(arg interface{}) { // value 为 arg 的值；ok 为判断结果，bool 型，若断言正确为 true，错误为 false value, ok := arg.(string) if ok { fmt.Println(\"arg is string type, value = \", value) } else { fmt.Println(\"arg is not string type\") } } 10、反射 10.1、变量的 pair 结构 在 go 中，变量的内部构造有两部分，分别是 type 和 value，它俩构成变量的 pair 结构。其中 type 又可以分为静态类型和具体类型\n静态类型即声明时候的类型；具体类型是程序运行期间实际的类型。\nvar age int // int 是静态类型 var name string // string 也是静态类型 var i interface{} // i 的静态类型是 interface{} i = 18 // i 的静态类型是 interface{}，不会改变；具体类型变为 int i = \"张三\" // i 的静态类型是 interface{}，不会改变；具体类型变为 string 由于普通变量的类型不会动态改变，因此一般谈论接口变量的 pair 结构。接口变量的 type 为具体类型。\nvar i interface{} // pair 声明接口变量时， type 和 value 都指向空 i = \"张三\" // pair","wordCount":"2306","inLanguage":"en","datePublished":"2021-01-02T17:39:41Z","dateModified":"2021-01-02T17:39:41Z","author":{"@type":"Person","name":"lu"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/go/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"lu","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/categories/ title=categories><span>categories</span></a></li><li><a href=http://localhost:1313/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Go 基础</h1><div class=post-meta><span title='2021-01-02 17:39:41 +0000 UTC'>2021-01-02</span>&nbsp;·&nbsp;2306 words&nbsp;·&nbsp;lu</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1基础>1、基础</a></li><li><a href=#2变量>2、变量</a><ul><li><a href=#21变量声明>2.1、变量声明</a></li><li><a href=#22多个变量的声明>2.2、多个变量的声明</a></li></ul></li><li><a href=#3常量与枚举>3、常量与枚举</a></li><li><a href=#4函数>4、函数</a><ul><li><a href=#41单个返回值>4.1、单个返回值</a></li><li><a href=#42多个返回值返回参数匿名>4.2、多个返回值，返回参数匿名</a></li><li><a href=#43多个返回值指定返回参数名>4.3、多个返回值，指定返回参数名</a></li><li><a href=#44init-函数与-import-导包>4.4、init 函数与 import 导包</a></li></ul></li><li><a href=#5指针>5、指针</a></li><li><a href=#6defer>6、defer</a></li><li><a href=#7切片-slice>7、切片 slice</a><ul><li><a href=#71数组>7.1、数组</a></li><li><a href=#72切片>7.2、切片</a></li><li><a href=#73切片的声明>7.3、切片的声明</a></li><li><a href=#74切片的扩容>7.4、切片的扩容</a></li><li><a href=#75切片的截取>7.5、切片的截取</a></li></ul></li><li><a href=#8map>8、map</a><ul><li><a href=#81map-的声明定义>8.1、map 的声明定义</a></li><li><a href=#82使用>8.2、使用</a></li></ul></li><li><a href=#9面向对象>9、面向对象</a><ul><li><a href=#91结构体>9.1、结构体</a></li><li><a href=#92封装>9.2、封装</a></li><li><a href=#93继承>9.3、继承</a></li><li><a href=#94多态>9.4、多态</a></li><li><a href=#95空接口>9.5、空接口</a></li><li><a href=#96类型断言>9.6、类型断言</a></li></ul></li><li><a href=#10反射>10、反射</a><ul><li><a href=#101变量的-pair-结构>10.1、变量的 pair 结构</a></li><li><a href=#102reflect-包>10.2、reflect 包</a></li><li><a href=#103结构体标签>10.3、结构体标签</a></li></ul></li><li><a href=#11goroutine>11、goroutine</a><ul><li><a href=#111介绍>11.1、介绍</a></li><li><a href=#112创建-goroutine>11.2、创建 goroutine</a></li></ul></li><li><a href=#12channel>12、channel</a><ul><li><a href=#121channel-的定义与使用>12.1、channel 的定义与使用</a></li><li><a href=#122channel-的缓冲>12.2、channel 的缓冲</a></li><li><a href=#123关闭-channel>12.3、关闭 channel</a></li><li><a href=#124channel-与-range>12.4、channel 与 range</a></li><li><a href=#125channel-与-select>12.5、channel 与 select</a></li></ul></li><li><a href=#13go-modules>13、Go modules</a></li></ul></nav></div></details></div><div class=post-content><h2 id=1基础>1、基础<a hidden class=anchor aria-hidden=true href=#1基础>#</a></h2><ul><li><p>包含有 main 函数的包，其包名必须是 main。包名与文件名没有任何关系。但在只包含一个main函数的项目中，一般文件名与包名一致</p></li><li><p>go 语句的末尾加不加分号都可以，建议不加</p></li><li><p>导包时推荐使用第二种</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;time&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;time&#34;</span>
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><ul><li>函数体前的大括号必须与函数名在同一行，否则报错</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;hello go&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>同样 if else 中的 else 必须与 if 的末尾大括号在同一行，否则报错</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>arr</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;空切片&#34;</span>)
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;非空&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=2变量>2、变量<a hidden class=anchor aria-hidden=true href=#2变量>#</a></h2><h3 id=21变量声明>2.1、变量声明<a hidden class=anchor aria-hidden=true href=#21变量声明>#</a></h3><p>方法一二三既可以用于局部变量也可以用于全局变量，而方法四只能在函数体内用于局部变量</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 方法一：只声明，不显式赋值，默认值为0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>a</span>)  <span style=color:#75715e>// 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 方法二：声明并显式初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span> = <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>b</span>)  <span style=color:#75715e>// 100
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 方法三：初始化时省去数据类型，自动推导
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>c</span> = <span style=color:#e6db74>&#34;abc&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>c</span>)  <span style=color:#75715e>// &#34;abc&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 方法四：省去 var 关键字，直接使用海象运算符类型推导（常用这种），表示声明并初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>4.5</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>d</span>)  <span style=color:#75715e>// 4.5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;type of d is %T\n&#34;</span>, <span style=color:#a6e22e>d</span>)  <span style=color:#75715e>// 格式化打印，%T 表示打印变量类型；此处输出为 float64
</span></span></span></code></pre></div><h3 id=22多个变量的声明>2.2、多个变量的声明<a hidden class=anchor aria-hidden=true href=#22多个变量的声明>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>aa</span>, <span style=color:#a6e22e>bb</span> = <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>200</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>cc</span>, <span style=color:#a6e22e>dd</span> = <span style=color:#ae81ff>4.5</span>, <span style=color:#e6db74>&#34;abc&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 或者下面这种写法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ee</span> = <span style=color:#ae81ff>300</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ff</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 也可以这样
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>gg</span>, <span style=color:#a6e22e>hh</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>3</span>, <span style=color:#66d9ef>true</span>
</span></span></code></pre></div><h2 id=3常量与枚举>3、常量与枚举<a hidden class=anchor aria-hidden=true href=#3常量与枚举>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 常量（只读）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>length</span> = <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>length</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// const 定义枚举类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> (
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 在第一个枚举成员后赋值关键字 iota，之后的每行的成员的值自动加 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>SPRING</span> = <span style=color:#66d9ef>iota</span>   <span style=color:#75715e>// iota 为常量 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>SUMMER</span>          <span style=color:#75715e>// 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>AUTUMN</span>          <span style=color:#75715e>// 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>WINTER</span>          <span style=color:#75715e>// 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> (
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 也可以赋值 iota 的表达式，此时之后的成员都会在 iota 加一的基础上赋值表达式
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>SPRING</span> = <span style=color:#66d9ef>iota</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>   <span style=color:#75715e>// 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>SUMMER</span>               <span style=color:#75715e>// 10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>AUTUMN</span>               <span style=color:#75715e>// 20
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>WINTER</span>               <span style=color:#75715e>// 30
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// iota 逐行累加；iota 只能出现在 const 的括号中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> = <span style=color:#66d9ef>iota</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>iota</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>  <span style=color:#75715e>// iota = 0; a = 1; b = 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>d</span>                       <span style=color:#75715e>// iota = 1; c = 2; d = 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>e</span>, <span style=color:#a6e22e>f</span>                       <span style=color:#75715e>// iota = 2; e = 3; f = 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>h</span> = <span style=color:#66d9ef>iota</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>, <span style=color:#66d9ef>iota</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>3</span>  <span style=color:#75715e>// iota = 3; g = 6; h = 9
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>k</span>                       <span style=color:#75715e>// iota = 4; i = 8; k = 12
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>)
</span></span></code></pre></div><h2 id=4函数>4、函数<a hidden class=anchor aria-hidden=true href=#4函数>#</a></h2><p>若函数名首字母大写，表示 public；小写，表示 private</p><h3 id=41单个返回值>4.1、单个返回值<a hidden class=anchor aria-hidden=true href=#41单个返回值>#</a></h3><p>结构：func 函数名(参数名 参数类型, 参数名 参数类型, &mldr;) 返回类型 { 函数体 }</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>function1</span>(<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>length</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>a</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>length</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>b</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>function1</span>(<span style=color:#e6db74>&#34;abc&#34;</span>, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>c</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=42多个返回值返回参数匿名>4.2、多个返回值，返回参数匿名<a hidden class=anchor aria-hidden=true href=#42多个返回值返回参数匿名>#</a></h3><p>结构：func 函数名(参数名 参数类型, 参数名 参数类型, &mldr;) (返回类型, 返回类型, &mldr;) { 函数体 }</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>function2</span>(<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) (<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>length</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>a</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>length</span>, <span style=color:#a6e22e>length</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>b</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>function2</span>(<span style=color:#e6db74>&#34;abc&#34;</span>, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>c</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>d</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=43多个返回值指定返回参数名>4.3、多个返回值，指定返回参数名<a hidden class=anchor aria-hidden=true href=#43多个返回值指定返回参数名>#</a></h3><p>结构：func 函数名(参数名 参数类型, 参数名 参数类型, &mldr;) (返回参数名 返回类型, 返回参数名 返回类型, &mldr;) { 函数体 }</p><p>注意：在这种方式中， r1 和 r2 在函数体内部是作为函数的形参存在的，它们默认值与其他局部变量一样，都是0。在函数体内可以任意调用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>function3</span>(<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>r1</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>r2</span> <span style=color:#66d9ef>int</span>)  {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>r1</span> = len(<span style=color:#a6e22e>a</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>r2</span> = <span style=color:#a6e22e>b</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>r1</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span>           <span style=color:#75715e>// 这种方式只写个 return 即可
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>function3</span>(<span style=color:#e6db74>&#34;abc&#34;</span>, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>c</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>d</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 若所有的返回类型都相同，可以这样写
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>function3</span>(<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>r1</span>, <span style=color:#a6e22e>r2</span> <span style=color:#66d9ef>int</span>)  { <span style=color:#f92672>...</span> } 
</span></span><span style=display:flex><span><span style=color:#75715e>// 同样，若参数类型都相同，也可以这样写
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>function3</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>r1</span>, <span style=color:#a6e22e>r2</span> <span style=color:#66d9ef>int</span>)  { <span style=color:#f92672>...</span> } 
</span></span></code></pre></div><h3 id=44init-函数与-import-导包>4.4、init 函数与 import 导包<a hidden class=anchor aria-hidden=true href=#44init-函数与-import-导包>#</a></h3><p>先递归将所有依赖中的 init 函数执行完，再执行本包的 init ，最后执行 main 方法。</p><p><img alt=init与import loading=lazy src=/posts/go/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/init%E4%B8%8Eimport.jpg></p><h5 id=441匿名导包>4.4.1、匿名导包<a hidden class=anchor aria-hidden=true href=#441匿名导包>#</a></h5><p>同变量一样，若导入的包没有使用，编译器也会报错。</p><p>若想使用某包的 init 方法，但不调用它的其他任何方法，可以匿名导包（在导入的包前加 下划线 空格）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_</span> <span style=color:#e6db74>&#34;time&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// 此时即使不使用time包的任何函数，也会调用其 init 方法，且编译器不报错
</span></span></span></code></pre></div><h5 id=442导包起别名>4.4.2、导包起别名<a hidden class=anchor aria-hidden=true href=#442导包起别名>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>t</span> <span style=color:#e6db74>&#34;time&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=443省略包名调用函数>4.4.3、省略包名调用函数<a hidden class=anchor aria-hidden=true href=#443省略包名调用函数>#</a></h5><p><strong>【不推荐使用】</strong>，若多个包有重名函数，会引发混乱。</p><p>这种方式相当于将 time 包下的所有函数都导入本包中，调用时无需带上包名。 和 python 类似。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	. <span style=color:#e6db74>&#34;time&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=5指针>5、指针<a hidden class=anchor aria-hidden=true href=#5指针>#</a></h2><p>go 中很少出现指针</p><p>go 的指针和 c 完全一样，同样支持二级指针等</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>changeValue</span>(<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#f92672>*</span><span style=color:#a6e22e>p</span> = <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>changeValue</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>a</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>a</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=6defer>6、defer<a hidden class=anchor aria-hidden=true href=#6defer>#</a></h2><p>可以在任何函数的任意行写一个 defer ，其后加任意一条语句。该关键字的作用类似于 C++ 的析构函数或 JAVA 的 try catch finally 中的finally，它会在函数的其他语句全部执行结束后执行（这里的其他语句包括 return 语句）</p><p>若同一个函数中有多条 defer 修饰的语句，则这些语句按栈的顺序执行，即写在前面的语句靠后执行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>deferFunc</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;func defer&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;func&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;defer 1&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;defer 2&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;code&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>deferFunc</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=7切片-slice>7、切片 slice<a hidden class=anchor aria-hidden=true href=#7切片-slice>#</a></h2><p>切片其实是一种动态数组</p><h3 id=71数组>7.1、数组<a hidden class=anchor aria-hidden=true href=#71数组>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 只声明，不初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>arr</span> [<span style=color:#ae81ff>10</span>]<span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>arr1</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>10</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 普通 for 循环
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>arr1</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>arr1</span>[<span style=color:#a6e22e>i</span>])
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// foreach，两个值分别为 下标和对应的值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>index</span>, <span style=color:#a6e22e>value</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>arr1</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;index = &#34;</span>, <span style=color:#a6e22e>index</span>, <span style=color:#e6db74>&#34;, value = &#34;</span>, <span style=color:#a6e22e>value</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>注意</strong>：在 go 中，长度不同的数组会被视为不同的类型，如 [10]int 和 [4]int 是不同的类型；当数组作为参数时，必须指定数组的大小，且指定后其他长度的数组将不能传递过来。</p><p>这是由于在 go 中，数组作为参数依然是<strong>值传递</strong>，即函数会根据参数的数组长度新建一个数组，并将传递过来的数组中的值拷贝到新建的数组中，因此它严格要求数组长度。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 下方代码编译时出错：Cannot use &#39;arr&#39; (type [4]int) as the type [10]int
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>arr</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>4</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printArr</span>(<span style=color:#a6e22e>arr</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>printArr</span>(<span style=color:#a6e22e>arr</span> [<span style=color:#ae81ff>10</span>]<span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>index</span>, <span style=color:#a6e22e>value</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>arr</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;index = &#34;</span>, <span style=color:#a6e22e>index</span>, <span style=color:#e6db74>&#34;, value = &#34;</span>, <span style=color:#a6e22e>value</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=72切片>7.2、切片<a hidden class=anchor aria-hidden=true href=#72切片>#</a></h3><p>如上，由于固定长度的数组在传递时较麻烦，因此一般使用动态数组（切片）。</p><p>所谓动态数组即在声明时不显示指定数组的长度。</p><p>使用动态数组时，函数的参数传递是<strong>引用传递</strong>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>array</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printArray</span>(<span style=color:#a6e22e>array</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>printArray</span>(<span style=color:#a6e22e>arr</span> []<span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 此处第一个变量名取下划线表示这是匿名，即不使用它。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>value</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>arr</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>value</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=73切片的声明>7.3、切片的声明<a hidden class=anchor aria-hidden=true href=#73切片的声明>#</a></h3><p>切片的底层依然是数组，切片名是指向数组头部的指针</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 方式一：声明并初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>slice</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 方式二：只声明，不初始化。此时没有分配空间，需要使用 make 为其开辟空间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>slice</span> []<span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>slice</span> = make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>3</span>)      <span style=color:#75715e>// 参数  -- 》  类型，数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 方式三：用 make 初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>slice</span> []<span style=color:#66d9ef>int</span> = make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>3</span>)    <span style=color:#75715e>// 元素全为 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 方式四：推断 + make  (一般采用这种)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>slice</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>3</span>)
</span></span></code></pre></div><h3 id=74切片的扩容>7.4、切片的扩容<a hidden class=anchor aria-hidden=true href=#74切片的扩容>#</a></h3><p>在 go 中，切片有容量和长度之分。<code>arr := make([]int, 3, 5)</code>表示创建一个容量为 5，长度为 3 的切片。</p><p>对于切片的读取操作只能在长度范围内进行，超出长度范围但在容量范围内的内存不能读取操作。</p><p>如果切片当前长度已经用尽，可以使用 <code>arr = append(arr, 1)</code>在切片末尾追加元素，此时长度为 4， 容量为 5。</p><p>如果多次追加后长度和容量相等，还想继续追加，依然使用 <code>arr = append(arr, 1)</code>，此时长度为 6， 容量为 10；即容量扩容为原来的 2 倍。一般每次追加一个元素时，容量是扩容 2 倍。</p><p>切片的容量发生改变时，会新建切片，并将原切片的数据赋值到新地址。</p><p>切片详细的扩容机制和多方面因素有关，如数据类型、每次追加元素的个数以及当前容量大小等，较为复杂。当需要时可以网上查。</p><p><code>arr := make([]int, 3)</code>未显示设置容量时，长度和容量相等。</p><h3 id=75切片的截取>7.5、切片的截取<a hidden class=anchor aria-hidden=true href=#75切片的截取>#</a></h3><p>go 的切片截取方式与 python 完全相同</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span>[<span style=color:#ae81ff>1</span>:<span style=color:#ae81ff>4</span>]          <span style=color:#75715e>// 左闭右开
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span>[:<span style=color:#ae81ff>4</span>]           <span style=color:#75715e>// 从 0 开始截取
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span>[<span style=color:#ae81ff>1</span>:]           <span style=color:#75715e>// 截取到末尾
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span>[:]            <span style=color:#75715e>// 全部截取
</span></span></span></code></pre></div><p>go 的截取共享内存空间，即此时若将 <code>a[1] = 100</code>，则 b[0] 的值也会变为 100。特殊地，若截取后 a 发生扩容，a 将指向新的内存，此时两者不共享内存，a 的值的改变不影响 b</p><p>若想要不共享内存，需要手动创建一个新切片，再使用 copy 函数拷贝，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>f</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>copy(<span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>a</span>[<span style=color:#ae81ff>1</span>:<span style=color:#ae81ff>4</span>])
</span></span></code></pre></div><h2 id=8map>8、map<a hidden class=anchor aria-hidden=true href=#8map>#</a></h2><p>map 的变量名是指向内存地址的指针，map 作为函数参数时是引用传递。</p><h3 id=81map-的声明定义>8.1、map 的声明定义<a hidden class=anchor aria-hidden=true href=#81map-的声明定义>#</a></h3><p>结构：map[键类型]值类型</p><p>一般二三种用的多</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 方式一：声明与初始化分开；make 初始分配10个空间，和切片一样，会自动扩容
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>myMap</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>myMap</span> = make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#66d9ef>string</span>, <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 方式二：海象运算符，声明并初始化；可以不指定初始空间大小，使用不变
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>myMap</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#66d9ef>string</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 方式三：声明时直接赋值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>myMap</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>1</span>: <span style=color:#e6db74>&#34;java&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>2</span>: <span style=color:#e6db74>&#34;python&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>3</span>: <span style=color:#e6db74>&#34;go&#34;</span>,   <span style=color:#75715e>// 注意，go 最后一个元素之后也要加逗号
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=82使用>8.2、使用<a hidden class=anchor aria-hidden=true href=#82使用>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>capital</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 添加
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>capital</span>[<span style=color:#e6db74>&#34;China&#34;</span>] = <span style=color:#e6db74>&#34;Beijing&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>capital</span>[<span style=color:#e6db74>&#34;Japan&#34;</span>] = <span style=color:#e6db74>&#34;Tokyo&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>capital</span>[<span style=color:#e6db74>&#34;USA&#34;</span>] = <span style=color:#e6db74>&#34;NewYork&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 遍历
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>capital</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 删除
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>delete(<span style=color:#a6e22e>capital</span>, <span style=color:#e6db74>&#34;Japan&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 修改
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>capital</span>[<span style=color:#e6db74>&#34;USA&#34;</span>] = <span style=color:#e6db74>&#34;DC&#34;</span>
</span></span></code></pre></div><h2 id=9面向对象>9、面向对象<a hidden class=anchor aria-hidden=true href=#9面向对象>#</a></h2><p>Go 语言中没有“类”的概念，但同样有面向对象，因为面向对象只是一种编程思想。</p><h3 id=91结构体>9.1、结构体<a hidden class=anchor aria-hidden=true href=#91结构体>#</a></h3><p>type 关键字：用于声明一种新的数据类型</p><p>若结构体中只有属性，不涉及方法时，go 的结构体与 c 完全一样</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Book</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>title</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>auth</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>book</span> <span style=color:#a6e22e>Book</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>book</span>.<span style=color:#a6e22e>title</span> = <span style=color:#e6db74>&#34;Golang&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>book</span>.<span style=color:#a6e22e>auth</span> = <span style=color:#e6db74>&#34;me&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=92封装>9.2、封装<a hidden class=anchor aria-hidden=true href=#92封装>#</a></h3><p>大写对应 public；小写对应 private，这适用于 结构体名、属性名、方法名。在 go 中叫导出与不被导出。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 类内部只允许定义属性，不允许定义方法；方法必须写在外面绑定到类
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Person</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Age</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// func 与方法名之间的括号表示该方法的接收者为 *Person，即该方法绑定到 Person 类
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 若接收者为 Person 表示是值传递，若接收者为 *Person 表示引用传递
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 可以将接收者视为该方法的第一个参数，这样理解后括号中即为(参数名，参数类型)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>person</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Person</span>) <span style=color:#a6e22e>Show</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Name = &#34;</span>, <span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>Name</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Age = &#34;</span>, <span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>Age</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>person</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Person</span>) <span style=color:#a6e22e>GetName</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>Name</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>person</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Person</span>) <span style=color:#a6e22e>SetName</span>(<span style=color:#a6e22e>newName</span> <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>Name</span> = <span style=color:#a6e22e>newName</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 亦可 person := Person{&#34;shen zi&#34;, 21}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>person</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Person</span>{<span style=color:#a6e22e>Name</span>: <span style=color:#e6db74>&#34;shen zi&#34;</span>, <span style=color:#a6e22e>Age</span>: <span style=color:#ae81ff>21</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>Show</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>SetName</span>(<span style=color:#e6db74>&#34;lin hua&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>person</span>.<span style=color:#a6e22e>Show</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=93继承>9.3、继承<a hidden class=anchor aria-hidden=true href=#93继承>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Female</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Person</span>                  <span style=color:#75715e>// 继承 Person 结构体
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>cup</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Show 重写父类方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>female</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Female</span>) <span style=color:#a6e22e>Show</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>female</span>.<span style=color:#a6e22e>Person</span>.<span style=color:#a6e22e>Show</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>female</span>.<span style=color:#a6e22e>cup</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Makeup 自定义新方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>female</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Female</span>) <span style=color:#a6e22e>Makeup</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>female</span>.<span style=color:#a6e22e>Name</span>, <span style=color:#e6db74>&#34;is makeup&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 亦可如此
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// var female Female
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// female.Name = &#34;yin&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// female.Age = 20
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// female.cup = &#34;36D&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>female</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Female</span>{<span style=color:#a6e22e>Person</span>{<span style=color:#e6db74>&#34;yin&#34;</span>, <span style=color:#ae81ff>20</span>}, <span style=color:#e6db74>&#34;36D&#34;</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>female</span>.<span style=color:#a6e22e>Makeup</span>()            <span style=color:#75715e>// 调用子类方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>female</span>.<span style=color:#a6e22e>SetName</span>(<span style=color:#e6db74>&#34;ying&#34;</span>)     <span style=color:#75715e>// 调用父类方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>female</span>.<span style=color:#a6e22e>Show</span>()              <span style=color:#75715e>// 调用子类方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=94多态>9.4、多态<a hidden class=anchor aria-hidden=true href=#94多态>#</a></h3><p>go 中只能通过接口实现多态。</p><p><strong>任何类只要实现了某接口中的所有方法，就将此类视为该接口的实现类，无需在类中引入接口名。</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Animal 本质是一个指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Animal</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Eat</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>GetName</span>() <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>GetType</span>() <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Cat 具体的类
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Cat</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>    <span style=color:#75715e>// 无需引入接口名
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} 
</span></span><span style=display:flex><span><span style=color:#75715e>// Cat 实现了 Animal 接口的所有方法，则 Cat 为 Animal 的实现类
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>cat</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Cat</span>) <span style=color:#a6e22e>Eat</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;cat is eat&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>cat</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Cat</span>) <span style=color:#a6e22e>GetName</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>cat</span>.<span style=color:#a6e22e>Name</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>cat</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Cat</span>) <span style=color:#a6e22e>GetType</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;cat&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>cat</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Cat</span>) <span style=color:#a6e22e>Sleep</span>() {   <span style=color:#75715e>// Cat 自己的方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;cat is sleep&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Dog 具体的类
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Dog</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 同样 Dog 也是 Animal 的实现类
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>dog</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Dog</span>) <span style=color:#a6e22e>Eat</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;dog is eat&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>dog</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Dog</span>) <span style=color:#a6e22e>GetName</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>dog</span>.<span style=color:#a6e22e>Name</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>dog</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Dog</span>) <span style=color:#a6e22e>GetType</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;dog&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>animal</span> <span style=color:#a6e22e>Animal</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>animal</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Cat</span>{<span style=color:#e6db74>&#34;mimi&#34;</span>}    <span style=color:#75715e>// 由于 Animal 本质是一个指针，故需要赋值地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>animal</span>.<span style=color:#a6e22e>Eat</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>animal</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Dog</span>{<span style=color:#e6db74>&#34;wang&#34;</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>animal</span>.<span style=color:#a6e22e>Eat</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>接口与接收者类型之间的关系有两个注意点：</p><ul><li>值接收者和指针接收者代表了两种完全不同的类型，其对接口的实现是独立的。</li><li>当类型对某接口实现时，要么是值接收者类型的对该接口的实现，要么是指针接收者类型对该接口的实现，二者只能选一个，不能共存。当为值接收者实现某方法时，GO编译器会自动的为其指针接收者也实现该方法。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Animal</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Eat</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Dog</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>dog</span> <span style=color:#a6e22e>Dog</span>) <span style=color:#a6e22e>Eat</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;dog is eat&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>animal</span> <span style=color:#a6e22e>Animal</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>animal</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Dog</span>{<span style=color:#e6db74>&#34;wang&#34;</span>}    <span style=color:#75715e>// 由于值接收者类型实现了该接口，故同样可以以引用的方式构造对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>animal</span>.<span style=color:#a6e22e>Eat</span>()             <span style=color:#75715e>// 但调用方法时不论是值对象还是引用对象传递的都是值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>animal</span> = <span style=color:#a6e22e>Dog</span>{<span style=color:#e6db74>&#34;wang&#34;</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>animal</span>.<span style=color:#a6e22e>Eat</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=95空接口>9.5、空接口<a hidden class=anchor aria-hidden=true href=#95空接口>#</a></h3><p>空接口 <code>interface{}</code> 是万能数据类型，类似于 java 的 Object。区别在于 Java 中只有引用类型继承了 Object，而在 go 中，包括 int、double、float 等在内的基础类型与引用类型以及自定义类型都继承了<code>interface{}</code>，即 go 中的所有类型都继承 <code>interface{}</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Func</span>(<span style=color:#a6e22e>arg</span> <span style=color:#66d9ef>interface</span>{}) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>arg</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Film</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>film</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Film</span>{<span style=color:#e6db74>&#34;movie&#34;</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Func</span>(<span style=color:#a6e22e>film</span>)    <span style=color:#75715e>// {movie}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Func</span>(<span style=color:#ae81ff>100</span>)     <span style=color:#75715e>// 100
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Func</span>(<span style=color:#e6db74>&#34;abc&#34;</span>)   <span style=color:#75715e>// abc
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Func</span>(<span style=color:#ae81ff>3.14</span>)    <span style=color:#75715e>// 3.14
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=96类型断言>9.6、类型断言<a hidden class=anchor aria-hidden=true href=#96类型断言>#</a></h3><p>类型断言机制<code>x.(T)</code> 检查 x 的动态类型是否是 T，其中 x 必须是接口值（包括空接口）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Func</span>(<span style=color:#a6e22e>arg</span> <span style=color:#66d9ef>interface</span>{}) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// value 为 arg 的值；ok 为判断结果，bool 型，若断言正确为 true，错误为 false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>value</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>arg</span>.(<span style=color:#66d9ef>string</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;arg is string type, value = &#34;</span>, <span style=color:#a6e22e>value</span>)
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;arg is not string type&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=10反射>10、反射<a hidden class=anchor aria-hidden=true href=#10反射>#</a></h2><h3 id=101变量的-pair-结构>10.1、变量的 pair 结构<a hidden class=anchor aria-hidden=true href=#101变量的-pair-结构>#</a></h3><p>在 go 中，变量的内部构造有两部分，分别是 type 和 value，它俩构成变量的 pair 结构。其中 type 又可以分为静态类型和具体类型</p><p><img alt=变量结构 loading=lazy src=/posts/go/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8F%98%E9%87%8F%E7%BB%93%E6%9E%84.png></p><p>静态类型即声明时候的类型；具体类型是程序运行期间实际的类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>age</span> <span style=color:#66d9ef>int</span>   <span style=color:#75715e>// int 是静态类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>  <span style=color:#75715e>// string 也是静态类型
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>i</span> <span style=color:#66d9ef>interface</span>{}     <span style=color:#75715e>// i 的静态类型是 interface{}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>i</span> = <span style=color:#ae81ff>18</span>                <span style=color:#75715e>// i 的静态类型是 interface{}，不会改变；具体类型变为 int
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>i</span> = <span style=color:#e6db74>&#34;张三&#34;</span>            <span style=color:#75715e>// i 的静态类型是 interface{}，不会改变；具体类型变为 string
</span></span></span></code></pre></div><p>由于普通变量的类型不会动态改变，因此一般谈论接口变量的 pair 结构。接口变量的 type 为具体类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>i</span> <span style=color:#66d9ef>interface</span>{}     <span style=color:#75715e>// pair&lt;type:nil, value:nil&gt;  声明接口变量时， type 和 value 都指向空
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>i</span> = <span style=color:#e6db74>&#34;张三&#34;</span>            <span style=color:#75715e>// pair&lt;type:string, value:&#34;张三&#34;&gt;  赋值后，type 指向 string，value 指向 &#34;张三&#34;
</span></span></span></code></pre></div><p>当接口变量作为右值的时候，它会将自己的 pair 对传递给左值，且自身的 pair 对不变。</p><p>9.6 节中的断言类型就是通过获取变量的 pair 对，取它的具体类型来进行判断。</p><h3 id=102reflect-包>10.2、reflect 包<a hidden class=anchor aria-hidden=true href=#102reflect-包>#</a></h3><ul><li><code>func TypeOf(i interface{}) Type</code> 该方法获取变量的类型</li><li><code>func ValueOf(i interface{}) Value</code> 该方法获取变量的值</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;reflect&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>f</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>3.1415936</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>f</span>))       <span style=color:#75715e>// float64
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>f</span>))      <span style=color:#75715e>// 3.1415936
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>上述两方法不仅适用于基础类型，对于任意类型都适用</p><p>通过 Type 还可以获得属性和方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Apple</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Color</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Weight</span> <span style=color:#66d9ef>float32</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>apple</span> <span style=color:#a6e22e>Apple</span>) <span style=color:#a6e22e>GetName</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>apple</span>.<span style=color:#a6e22e>Name</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fruit</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Apple</span>{<span style=color:#e6db74>&#34;xia&#34;</span>, <span style=color:#e6db74>&#34;red&#34;</span>, <span style=color:#ae81ff>212.5</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fruitType</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>fruit</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fruitValue</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>fruit</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>fruitType</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>fruitValue</span>)
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 通过 Type 获得各属性；NumField() 获得属性数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>fruitType</span>.<span style=color:#a6e22e>NumField</span>(); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>field</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fruitType</span>.<span style=color:#a6e22e>Field</span>(<span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>value</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fruitValue</span>.<span style=color:#a6e22e>Field</span>(<span style=color:#a6e22e>i</span>).<span style=color:#a6e22e>Interface</span>()   <span style=color:#75715e>// Interface()：将当前值以空接口类型返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 属性中包含属性名、属性类型等
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%s: %v = %v\n&#34;</span>, <span style=color:#a6e22e>field</span>.<span style=color:#a6e22e>Name</span>, <span style=color:#a6e22e>field</span>, <span style=color:#a6e22e>value</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 通过 Type 获得各方法；这里只有当方法以值类型传入时才能获得，原因如下
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 参考源码：“对于非接口类型T或*T，返回的Method的type和Func字段描述了第一个参数为接收者的函数，并且只有导出的方法是可访问的。”
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 由于引用接收者本质是指针，它不包含方法，所以无法获得
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>fruitType</span>.<span style=color:#a6e22e>NumMethod</span>(); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>method</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fruitType</span>.<span style=color:#a6e22e>Method</span>(<span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%s: %v&#34;</span>, <span style=color:#a6e22e>method</span>.<span style=color:#a6e22e>Name</span>, <span style=color:#a6e22e>method</span>.<span style=color:#a6e22e>Type</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=103结构体标签>10.3、结构体标签<a hidden class=anchor aria-hidden=true href=#103结构体标签>#</a></h3><p>Struct Tag是存在于Struct下面成员的附加属性，它的定义永远都是以key-value的形式出现的，多个定义的情况下以空格分割。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Resume</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span>   <span style=color:#66d9ef>string</span>    <span style=color:#e6db74>`info:&#34;name&#34; doc:&#34;名字&#34;`</span>   <span style=color:#75715e>// 绑定多个 tag ，用空格分割
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Gender</span> <span style=color:#66d9ef>string</span>    <span style=color:#e6db74>`info:&#34;gender&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// tag := reflect.TypeOf(&amp;Resume{}).Elem()；与下面这句作用一样。当reflect.TypeOf()接收指针时，可通过Elem()获取指针指向的元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>tag</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>Resume</span>{})
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>tag</span>.<span style=color:#a6e22e>NumField</span>(); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>taginfo</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tag</span>.<span style=color:#a6e22e>Field</span>(<span style=color:#a6e22e>i</span>).<span style=color:#a6e22e>Tag</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;info&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>tagdoc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tag</span>.<span style=color:#a6e22e>Field</span>(<span style=color:#a6e22e>i</span>).<span style=color:#a6e22e>Tag</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;doc&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;info:&#34;</span>, <span style=color:#a6e22e>taginfo</span>, <span style=color:#e6db74>&#34; doc: &#34;</span>, <span style=color:#a6e22e>tagdoc</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在StructTag的应用中，使用最多的就是json的序列化了，序列化的包会读取tag内容，对json结果进行重命名输出。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;encoding/json&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Resume</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span>   <span style=color:#66d9ef>string</span>    <span style=color:#e6db74>`json:&#34;name&#34;`</span>       <span style=color:#75715e>// json 编码时会将该属性名替换为 tag 中的值 name；下同
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Gender</span> <span style=color:#66d9ef>string</span>    <span style=color:#e6db74>`json:&#34;gender&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Salary</span> <span style=color:#66d9ef>int</span>       <span style=color:#e6db74>`json:&#34;salary&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>resume</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Resume</span>{<span style=color:#e6db74>&#34;li&#34;</span>, <span style=color:#e6db74>&#34;male&#34;</span>, <span style=color:#ae81ff>1000</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 编码，将结构体转 json
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>jsonStr</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Marshal</span>(<span style=color:#a6e22e>resume</span>)  <span style=color:#75715e>// 该函数返回 json 编码。返回值为编码后的 json 串和错误
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;编码错误:&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;jsonStr = %s\n&#34;</span>, <span style=color:#a6e22e>jsonStr</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// jsonStr = {&#34;name&#34;:&#34;li&#34;,&#34;gender&#34;:&#34;male&#34;,&#34;salary&#34;:1000}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 解码，json 转为结构体
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>myResume</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Resume</span>{}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>jsonStr</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>myResume</span>)  <span style=color:#75715e>// 该函数解码 json 串，第二个参数必须为指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;解码错误:&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;结构体：%v\n&#34;</span>, <span style=color:#a6e22e>myResume</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 结构体：{li male 1000}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=11goroutine>11、goroutine<a hidden class=anchor aria-hidden=true href=#11goroutine>#</a></h2><h3 id=111介绍>11.1、介绍<a hidden class=anchor aria-hidden=true href=#111介绍>#</a></h3><p>Go 语言通过编译器运行时（runtime），从语言上支持了并发的特性。Go 语言的并发通过 <strong>goroutine</strong> 特性完成。goroutine 类似于线程，但是可以根据需要创建多个 goroutine 并发工作。goroutine 是由 Go 语言的运行时调度完成，而线程是由操作系统调度完成。</p><p>goroutine 可能发生并行执行；但 coroutine 始终顺序执行。</p><p>具体原理可以看这篇 &ndash;> <a href=https://www.zhihu.com/question/20862617>Golang 的 goroutine 是如何实现的？ - 知乎 (zhihu.com)</a></p><h3 id=112创建-goroutine>11.2、创建 goroutine<a hidden class=anchor aria-hidden=true href=#112创建-goroutine>#</a></h3><ul><li>调用普通方法</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newTask</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>time</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>time</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;func goroutine&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {        <span style=color:#75715e>// go 自动为每个 main 函数创建一个 goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>newTask</span>()    <span style=color:#75715e>// 使用 go 关键字后便会为该方法创建一个 goroutine，之后由调度器调度这两个方法的并发执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>time</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>time</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;main goroutine&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>接匿名方法</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) {    <span style=color:#75715e>// 方法的返回值需要配合 channel 接收
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>a</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>}(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>20</span>)    <span style=color:#75715e>// 匿名方法后传递参数列表会直接启动该匿名方法，同样适用于无参方法
</span></span></span></code></pre></div><p>结束一个 goroutine 线程的方法：</p><ul><li>执行完方法体自然结束</li><li>使用 return 结束</li><li>执行过程中调用 <code>runtime.Goexit()</code></li></ul><h2 id=12channel>12、channel<a hidden class=anchor aria-hidden=true href=#12channel>#</a></h2><h3 id=121channel-的定义与使用>12.1、channel 的定义与使用<a hidden class=anchor aria-hidden=true href=#121channel-的定义与使用>#</a></h3><p>通道在定义的时候必须指定类型</p><p>channel 会实现同步，保证代码逻辑正确</p><p>下方代码中会出现两种情况：</p><ol><li>main 线程先执行到 <code>num := &lt;- ch</code>，而此时匿名函数的线程还没有执行到<code>ch &lt;- 22</code>，main线程阻塞，等到通道有数据后再执行</li><li>匿名函数的线程全部执行完成，但此时main线程还没有执行到<code>num := &lt;- ch</code>，（由于此处管道没有缓冲）匿名函数的线程阻塞，直到通道数据被取走再执行 defer 并结束</li></ol><p>因此下方代码中<code>ch &lt;- 22 num := &lt;- ch defer fmt.Println("goroutine 结束") </code>这三句的顺序是确定不变的，从而保证了程序的逻辑正确性</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 定义一个 channel，该通道只能接收 int 类型的数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)   <span style=color:#75715e>// 无缓冲
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;goroutine 结束&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;goroutine 运行&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>22</span>   <span style=color:#75715e>// 向通道发送数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>num</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>ch</span>   <span style=color:#75715e>// 从通道接收数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>num</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=122channel-的缓冲>12.2、channel 的缓冲<a hidden class=anchor aria-hidden=true href=#122channel-的缓冲>#</a></h3><p>通道分为有缓冲和无缓冲两种</p><p>无缓冲通道的通信双方，不论谁先到达通道都会被阻塞，直到通信完成双方才会被释放</p><p>同一时刻，同时有 读、写两端把持 channel。
如果只有读端，没有写端，那么 “读端”阻塞。
如果只有写端，没有读端，那么 “写端”阻塞。</p><p><img alt=无缓存channel loading=lazy src=/posts/go/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%97%A0%E7%BC%93%E5%AD%98channel.jpg></p><p>有缓冲通道类似于生产者消费者模型，当缓冲为空时取值会被阻塞，或缓冲已满时放值会被阻塞，其余时候存和取的操作互不影响</p><p><img alt=有缓存channel loading=lazy src=/posts/go/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9C%89%E7%BC%93%E5%AD%98channel.jpg></p><p>在下方案例中，缓冲区大小为 3，若主go程先执行到<code>num := &lt;- c</code>则阻塞，直到子go程向通道放入数据（由于此处睡眠2秒，这种情况几乎不会发生）；当子go程向通道放入 3 个数据时，通道已满，它阻塞，直到主go程从通道取走一个元素才被唤醒继续放入。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>3</span>)    <span style=color:#75715e>// 定义缓冲为 3 的channel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;len(c)=&#34;</span>, len(<span style=color:#a6e22e>c</span>), <span style=color:#e6db74>&#34;, cap(c)=&#34;</span>, cap(<span style=color:#a6e22e>c</span>))  <span style=color:#75715e>// 同切片一样，len 为元素的个数，cap 为容量的大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;子go程结束&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>4</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>c</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;子go程运行中，传入数据i=&#34;</span>, <span style=color:#a6e22e>i</span>, <span style=color:#e6db74>&#34;, len(c)=&#34;</span>, len(<span style=color:#a6e22e>c</span>), <span style=color:#e6db74>&#34;, cap(c)=&#34;</span>, cap(<span style=color:#a6e22e>c</span>))
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>4</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>num</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>c</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;num=&#34;</span>, <span style=color:#a6e22e>num</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;main 结束&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=123关闭-channel>12.3、关闭 channel<a hidden class=anchor aria-hidden=true href=#123关闭-channel>#</a></h3><ul><li>channel 不像文件一样需要经常关闭，只有确定不再发送消息，或想显示结束range循环时才会关闭 channel</li><li>关闭 channel 后，无法向 channel 再发送数据（否则引发 panic 错误）</li><li>关闭 channel 后，可以继续从 channel 接收数据</li><li>对于 nil channel，无论收发都会阻塞</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)    <span style=color:#75715e>// 无缓冲
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>5</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>c</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		close(<span style=color:#a6e22e>c</span>)           <span style=color:#75715e>// 使用内置关键字 close 可以关闭 channel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}()                    <span style=color:#75715e>// 若不使用 close 关闭通道，则主go程在第六次取值时陷入阻塞且永远无法唤醒，出错
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// data 为从通道中取出的值；当通道未关闭时 ok 为 true，通道关闭后 ok 为 false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 这种语法表示先执行 data, ok := &lt;- c; 再对 ok 进行判断，data 和 ok 是 if 的局部变量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>c</span>; <span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>data</span>)
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;over&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=124channel-与-range>12.4、channel 与 range<a hidden class=anchor aria-hidden=true href=#124channel-与-range>#</a></h3><p>下方代码与 12.3 节的代码效果完全一样</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {	
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>5</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>c</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		close(<span style=color:#a6e22e>c</span>)
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 若通道没有关闭 range 会一直尝试阻塞地从通道中取数据并返回给 data
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>c</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>data</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;over&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=125channel-与-select>12.5、channel 与 select<a hidden class=anchor aria-hidden=true href=#125channel-与-select>#</a></h3><p>单流程下一个 go 只能监控一个 channel 的状态，select 可以完成监控多个 channel 的状态</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>select</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>communication</span> <span style=color:#a6e22e>clause</span>  :
</span></span><span style=display:flex><span>       <span style=color:#a6e22e>statement</span>(<span style=color:#a6e22e>s</span>);      
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>communication</span> <span style=color:#a6e22e>clause</span>  :
</span></span><span style=display:flex><span>       <span style=color:#a6e22e>statement</span>(<span style=color:#a6e22e>s</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 可以定义任意数量的 case */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>default</span> : <span style=color:#75715e>/* 可选 */</span>
</span></span><span style=display:flex><span>       <span style=color:#a6e22e>statement</span>(<span style=color:#a6e22e>s</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>select 语句的语法：</p><ul><li><p>每个 case 都必须是一个通信</p></li><li><p>所有 channel 表达式都会被求值</p></li><li><p>所有被发送的表达式都会被求值</p></li><li><p>如果任意某个通信可以进行，它就执行，其他被忽略。</p></li><li><p>如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。</p><p>否则：</p><ol><li>如果有 default 子句，则执行该语句。</li><li>如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。</li></ol></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>quit</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>6</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>c</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>quit</span> <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Fibonacci</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>quit</span>)    <span style=color:#75715e>// 通道做参数时，传递的是引用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Fibonacci</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>quit</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 在子go程中，i &lt; 6 时 c 通道一直可写，但 quit 通道不可读，因此一直执行第一条 case
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 当 i == 6 时，c 通道不可写，quit 通道可读，因此执行第二条 case 并返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>select</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>x</span>:
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span> = <span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>x</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>y</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>quit</span>:
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;quit&#34;</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=13go-modules>13、Go modules<a hidden class=anchor aria-hidden=true href=#13go-modules>#</a></h2><p>Go modules 是 go 的依赖解决方案，它的出现解决的依赖管理问题并且淘汰了 GOPATH。1.11版本出现；1.14版本成熟</p><p>设置环境变量</p><pre tabindex=0><code>GO111MODULE=on                       // 启用 Go modules；引用github项目时，直接 import github路径 会自动下载
GOPROXY=https://goproxy.cn,direct    // 设置代理，此处为七牛。direct表示若在七牛找不到会从引用的 github路径 下载
GOSUMDB                              // 不用管，会自动使用GOPROXY的网站对下载的包校验完整性与是否篡改
GOPRIVATE                            // 用于私有仓库或公司内部仓库，不通过GOPROXY下载也不校验，需要手动导包
</code></pre></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/java/spring5%E7%AC%94%E8%AE%B0/><span class=title>« Prev</span><br><span>Spring5学习笔记</span>
</a><a class=next href=http://localhost:1313/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/matplotlib%E5%AD%A6%E4%B9%A0/plt_quickstart/><span class=title>Next »</span><br><span></span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>