<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java学习笔记 | lu</title>
<meta name=keywords content><meta name=description content='数组：
    数组的初始化方式：
        1、动态初始化（指定长度）  数据类型[] 数组名 = new 数据类型[数组长度]；
        2、静态初始化（指定内容）  数据类型[] 数组名 = new 数据类型[] {元素1， 元素2， 元素3， ... }； 元素值可以是变量
             省略的静态初始化   数据类型[] 数组名 = {元素1， 元素2， 元素3， ... }；  该方式不允许拆分为2步，即先定义数组名，再经行赋值。
    直接打印数组名，打印的是数组的内存地址。
    支持下标索引。
    未初始化的默认初始值：
        整数类型： 0
        浮点类型： 0.0
        字符类型： &#39;\u0000&#39;
        布尔类型： false
        引用类型： null
    获取数组长度： 数组名.length;
    获取数组副本： 数组名.clone();

成员变量与局部变量：
    成员变量定义在类内，方法外。局部变量定义在方法内。
    成员变量不要写static关键字。???
    成员变量有默认值，而局部变量没有默认值。
    当成员变量与局部变量的命名冲突时，按照就近原则，优先使用局部变量。若想使用全局变量，使用this.成员变量名。

可变参数:
    使用前提：当方法的参数类型确定，但是参数个数不确定时，使用可变参数。
    使用格式：修饰符 返回值类型 方法名(数据类型...变量名) {}   例如:   public void func (int... num) {}
    原理：   可变参数底层是一个数组，根据传递参数个数的不同，会创建不同长度的数组，来存储这些参数。参数个数可以是0个或多个。
            因此，方法中的变量名其实就是数组的名字，可以作为数组使用。
    注意：   一个方法的参数列表中只能有一个可变参数。
            如果方法有多个参数，则可变参数必须放在参数末尾。

类的使用:
    1、导包：import 包路径.类名称   当类与当前文件处于同一个包中时，可以不用导包。只有java.lang下的包不需要导包，其他都需要导包。
                                            但实际使用中，可以不用手动导包，当你使用某个类时，系统会自动帮你导包。
    2、实例化： 类名称 对象名 = new 类名称();
    3、使用: 对象名.成员变量名        对象名.成员方法名(参数)

Private:
    Getter: 函数格式必须是 getXXX   如果变量是布尔类型，则使用isXXX
    Setter: 函数格式必须是 setXXX
    Private修饰构造函数时，外部不能再构造该类的实例，故只能在类内构造好全部实例并赋给static类型的变量。叫构造函数私有化

this: this是当前对象的引用，即this和对象是同一个东西。
    this.成员变量    调用本类成员变量    可以将类内的成员变量与方法中的同名局部变量区分。
    this.成员方法    调用本类成员方法
    this(...)      调用本类构造函数 --> 写在第一行，只能调用一个。  若子类使用了this(...)，则不再默认赠送super()。
super:
    super.成员变量   调用父类成员变量     可以将父类中的成员变量和子类中的同名成员变量区分。
    super.成员方法   调用父类成员变量
    super(...)     调用父类类构造函数 --> 写在第一行，只能调用一个。

构造函数：
    格式： public 类名（参数类型 参数名称 ， ...）{...}
    注意事项： 构造方法的名称和类名要严格相等，大小写敏感。
             构造方法没有返回值类型。
             若不明确定义构造函数，则会自动生成默认构造函数，若手动定义了任意形式的构造函数，编译器将不会再生成默认构造函数。
             构造函数支持重载
    继承中的构造函数:  构造链：同C++一样--> 祖宗 > 父类 > 子类        子类构造方法中若不显式调用super，则默认隐含一个 "super()" 调用。
                    子类构造函数可以显式地写 super([参数1，...]) 来调用父类的重载构造函数。且必须在方法体的第一行，即只能调用一个。

标准类：也叫做 Java Bean
    通常包含以下4部分内容：
        所有的成员变量都要使用private关键字。
        为每一个成员变量编写一对儿Getter/Setter方法
        编写一个无参构造函数
        编写一个全参构造函数
    点击 Code->Generate 或者 快捷键 alt + insert 可以自动生成上述内容

==：
    对于基本类型， == 比较的是值
    对于引用类型， == 比较的是地址

基本类型与字符串之间的转换：
    基本类型 --> 字符串
        1、基本数据类型的值+""  最简单的方式（工作中常用）
        2、使用包装类的静态方法   static String toString(int i)  将i变为字符串形式   如 Integer.toString(100);
        3、使用String类的静态方法   static String valueOf(int i)  将i变为字符串形式   如 String.valueOf(100);
    字符串 --> 基本类型
        使用包装类的静态方法 parseXX("字符串")
            Integer    static int parseInt(String s)     如 Integer.parseInt("100");
            ... ...

泛型:  泛型名字不一定是E，可以是任意大写字母。
    类: public class ClassName<E> { ... 在类内将需要的地方都用E代替}     实例化对象时确定类型
    方法: 修饰符 <E> 返回值类型 方法名(参数列表){ ... }                   调用方法时确定类型
    接口: 含有泛型的接口定义与类相同。  确定类型的方法：1、在实现类中确定类型   2、实现类依然沿用接口的泛型E，实现类创建对象时确定类型
    通配符: <?>  代表任意数据类型，
        使用: 例如当多个不同类型的ArrayList集合要作为参数调用同一个方法时，可以将参数设置为ArrayList<?> list方便接受任意类型。
        高级使用: ? extends E 表示 ? 只能是E的子类/本身
                 ? super E   表示 ? 只能是E的父类/本身

static:
    带上static的成员变量或函数，不属于对象，而是属于类，所有对象共享。
    类名.静态变量
    类名.静态方法()
    注意事项：静态不能直接访问非静态 --> 在内存中，先有静态，后有非静态
            静态不能使用this
    静态代码块：static{  ...  }  首次用到类时，静态代码块唯一执行一次。
              典型用途：一次性地对静态成员变量赋值。

override:
    在子类的覆盖重写方法前面加上 @override 可以检验该方法是否为重写方法（建议写上）
    子类方法的返回值的范围必须 小于等于 父类方法的返回值的范围。
    子类方法的权限必须 大于等于 父类方法的权限

权限：                public > protected > (default) > private     (default) 表示什么也不写，留空。
        同一个类        YES       YES          YES        YES     (我自己)
        同一个包        YES       YES          YES        NO      (我领居)
        不同包子类       YES       YES          NO         NO     (我儿子)
        不同包不同类     YES        NO          NO         NO      (陌生人)

abstract:
    抽象方法：只定义，不实现。加上abstract关键字，去掉大括号，直接分号结束。
    抽象类： 抽象方法所在的类，必须是抽象类。在class前加上abstract即可。但抽象类中不一定包含抽象方法（通常是有的）。
    使用步骤：
        抽象类不能直接创建对象。
        必须用一个子类继承抽象父类。
        子类必须覆盖重写抽象父类中的所有抽象方法。-->此处覆盖重写即实现：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。
        创建子类对象，并使用。

interface：
    概念：接口就是多个类的公共规范。是一种引用数据类型，最重要的就是其中的抽象方法。
    定义：public interface 接口名称 { ... }
    包含：常量、抽象方法、默认方法、静态方法、私有方法。
    常量：可以理解为成员变量，但是必须使用 public static final 三个关键字修饰，故相当于常量。
         public static final 数据类型 常量名称 = 值  （三个关键字可省略，但不能换为别的）
         注意：1、接口中的常量可以省略public static final，但写不写效果一样。
              2、接口中的常量必须手动赋值，不能不赋值。赋值之后无法改变。
              3、常量名称全部大写，由下划线连接。
         使用：接口名称.常量
    抽象方法：1、接口中的抽象方法，修饰符固定为 public abstract  (可省略，但不能换为别的)
            2、方法的三要素可随意定义。
    默认方法：public default 返回值类型 方法名(参数列表) {方法体} (public可省略，default不能省略)
            可以解决接口升级的问题。（不想改变实现类，但是接口中又想要添加新方法，则接口就可以用默认方法自己实现）（实现类可以覆盖重写默认方法）
            默认方法会被实现类继承，故可以通过实现类的对象访问默认方法。
    静态方法：public static 返回值类型 方法名(参数列表) {方法体}  (public可省略，static不能省略)
            使用：接口名称.静态方法(参数);  不能通过对象访问。
    私有方法：1、普通私有方法：解决多个默认方法之间的重复代码问题  private 返回值类型 方法名(参数列表) {方法体}
                只有接口中的默认方法能访问。
            2、静态私有方法：解决多个静态方法之间的重复代码问题  private static 返回值类型 方法名(参数列表) {方法体}
                只有接口中的默认方法和静态方法能访问。
    使用：1、接口不能直接使用，必须有一个“实现类”来“实现”该接口。  public class 实现类名称 implements 接口名称 {...}
         2、接口的实现类必须实现接口中的全部抽象方法。去掉abstract关键字，加上大括号实现体。
         3、创建实现类对象，使用。
    注意事项：1、接口没有静态代码块和构造方法。
            2、如果实现类没有覆盖重写所有接口中的所有方法，则该实现类自己就必须是抽象类。
            3、一个实现类可以实现多个接口  public class 类名 implements interface1, interface2 {}。
            4、若一个类实现的多个接口中有重名的抽象方法，则只需实现一个即可。
            5、若一个类实现的多个接口中有重名的默认方法，则该实现类必须对重名默认方法覆盖重写。
            6、若一个类的直接父类中的方法和它实现的接口中的默认方法重名，则优先使用直接父类的方法。 在java中【继承 优先于 接口】
            7、接口是多继承的。多个父接口当中的抽象方法如果重名，没关系。
                           多个父接口当中的默认方法如果重名，则子接口必须对重名的默认方法覆盖重写，【而且带着default关键字】


多态：（一个子类对象既有子类形态，又有父类形态）一个对象拥有多种形态，即【对象】的多态性。【多态性指的是对象，而不是类】
    代码中体现多态性： 父类引用指向子类对象。
    格式   父类名称 对象名 = new 子类名称();   或   接口名称 对象名 = new 实现类名称();
    【初步理解: 定义了一个指向子类对象的父类引用，这个引用指向的是子类的对象，但是只能访问父类大小的内存空间，所以它只能访问父类继承到子类当中的成员
              （包括成员变量和成员函数）的那部分内存空间，而不能访问子类独有的多出来的那部分内存空间，而对于被子类重写了的方法，该引用依然可以访问
              这部分内存，只是内存中的内容已经被改写了，所以访问到的是子类重写之后的方法。综上所述，该引用能访问的范围是所有从父类继承下来的变量和
              父类独有方法，以及被子类重写之后的方法。】
    多态对象访问成员变量： 对象名.成员变量  访问的是父类的成员变量，若没有则向上找，不会向下找。 不能用这种方法访问子类特有成员变量。
    多态对象访问成员函数： 若子类重写了父类的成员函数，则访问子类的成员函数。 若子类没有重写，则访问父类的成员函数，没有则向上找。 同样不能访问子类特有成员函数。
        记忆口诀；对于成员变量，等号左边是谁就优先用谁。对于成员方法，new的是谁就优先用谁。
    使用多态的好处：比如将父类的引用作为参数传入方法中，则该引用可以指向不同的子类对象使方法实现不同的功能，却不需要改变方法中的任何代码。

对象的向上转型： 在特定场合会自动向上转型，如方法参数要求为父类，但是传入一个子类对象也正确，这时就发生了自动向上转型。与int double发生自动类型转换原理一样。
    格式：与多态相同：父类名称 对象名 = new 子类名称();
    含义：创建一个子类对象，把它当作父类来看待使用。
    【向上转型一定是安全的】从小范围转向了大范围，如将小范围的猫向上转型为更大范围的动物。 类似于将short转换为int。
    弊端：不能访问子类特有方法。
对象的向下转型：其实是一个【还原】的动作。
    格式：   子类名称 对象名 = (子类名称) 父类对象;   (子类名称)必须有，不能省略。
    含义：   将向上转型之后的父类对象还原为本来的子类对象。
    注意：   只有本来是猫，向上转型为动物后，再向下转型为猫才是正确的。
            若本来不是猫，却硬要向下转型为猫就会出错(编译不会报错，但运行会出现异常ClassCastException)。
    instanceof:
        格式： 对象名 instanceof 类名
        作用： 返回一个布尔值，判断前面的对象能不能当作后面类的实例。
        应用： 在向下转型之前，判断需要转型的对象是不是目标类的对象，是则向下转型，不是则不转型。

final: 该关键字表示最终的，不可再改变的。
    用法: 修饰一个类、方法、局部变量、成员变量。
         修饰一个类： public final class 类名 {...}  不能有子类。
         修饰一个方法： 该方法不能被重写。   对于类和方法，abstract 和 final 不能同时使用，会矛盾。
         修饰一个局部变量： 一次赋值，终生不变。（可以先定义，再赋值。分两步）--对于基本类型，值不可变。对于引用类型，地址值不可变。
         修饰一个成员变量： 由于成员变量有默认值，所以不能分两步，必须当场手动赋值或通过构造函数赋值。
         修饰一个数组或集合： 该数组或集合不能再被赋值，但内部的数据还可以改变。

内部类： 一个类内部包含另一个类，即一个事物内部包含另一个事物。 例如 身体和心脏的关系
    分类： 成员内部类      局部内部类（包含匿名内部类）
    成员内部类：修饰符 class 外部类名称 { 修饰符 class 内部类名称 {...} ... }  内用外，随意访问。外用内，需要内部类对象。
             在main方法中使用：1、间接方式： 在外部类的方法中调用内部类，然后main通过访问外部类的方法调用内部类。
                            2、直接方式： 外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();
             当局部变量、内部类的成员变量、外部类的成员变量重名时：
                内部类的成员方法调用内部类的成员变量用this.内部成员变量。 内部类的成员方法调用外部类的成员变量用Outer.this.外部成员变量。
    局部内部类：如果一个类定义在方法内部，就是局部内部类。---只有当前所属的方法才能使用它，出了这个方法就不能使用了。
             格式：修饰符 class 外部类名称 {... 修饰符 返回值类型 外部类方法名称(参数列表) { class 内部局部类名称 {...} ... } ...}
             注意：若局部内部类要访问所在方法的局部变量，则该局部变量必须是【有效final的】（即可以不写final关键字，但是不能变）
                        因为局部内部类在堆中，生命周期长，而局部变量在栈中，生命周期短，所以不能变。
    【匿名内部类】：【用的最多】 如果接口的实现类（或者父类的子类）只需使用唯一的一次，则可以省略该类的定义，而改为使用匿名内部类。
             格式：接口名称 对象名 = new 接口名称() { 重写所有抽象方法 };
             注意：1、匿名内部类只能唯一【创建一次对象】。若想多次创建对象，就要单独定义实现类。
                  2、匿名对象只能唯一【调用一次方法】。若想多次调用方法，就要给对象起个名字。
                  3、匿名内部类是省略了实现类/子类名称。而匿名对象是省略了对象名称。他俩不是一回事。
             new 接口名() { 重写所有抽象方法 }.方法(参数);  即匿名内部类又匿名对象的使用方法。

异常:
    throw : 用于抛出异常，   例如: throw new NullPointerException("异常产生的原因")
        若抛出运行时异常，可不理会，默认由JVM处理
        若抛出编译器异常，则必须处理。throws或try-catch
    throws: 声明异常。  (用于甩锅)
        格式: 修饰符 返回值类型 方法名(参数列表) throws AAAException, BBBException... {throw new AAAException("原因")...}
        注意: 1、throws必须写在方法声明处
             2、throws后面必须是Exception或者是其子类
             3、throws后面必须声明方法内部抛出的所有异常
             4、若调用了一个声明抛出异常的方法，则必须处理这些异常。可以继续抛出，也可以自己处理。
    try-catch:  自己处理异常
        try可以抛出多个异常，这时需要使用多个catch来捕获异常。
        try中若产生异常，则try代码块中产生异常之后的代码不会执行，而跳转到catch。
        try中若没有产生异常，则执行完try中的代码继续执行try-catch之后的代码。
    finally: 不论是否发生异常，finally代码块中的代码一定会执行。
        格式 : try{} catch{} finally{}
        注意 : finally必须与try一起使用，一般用于资源释放。
               正是由于其有一定会执行到，所以若finally代码块中有return语句，则一定会返回finally中的结果。（要避免）
    注意 : 子类异常一定要与父类异常一致。

Thread : Thread类是描述线程的类，要实现多线程，必须继承Thread类
    每个线程拥有一个自己独立的栈，但是共享进程的堆空间。
    Thread.sleep(毫秒)                          // 静态方法  睡眠
    Thread thread = Thread.currentThread();     // 获取当前线程
    第一种方法： 创建Thread类的子类
        1、创建Thread类的子类，并重写run方法，其中设置线程的任务
        2、创建子类对象，并执行start方法  (执行start方法会创建一个新的栈空间，并在该栈空间中执行run方法)(每执行一次步骤2，就开启一个新的线程)
    第二种方法： 实现Runnable接口  (推荐使用这种)   --->  使用该方法时，Thread 类是咱们自定义类的静态代理类
        1、创建一个Runnable接口的实现类，并重写run方法，其中设置线程的任务
        2、创建对象，并将其作为参数传递给Thread类的构造方法，再调用start方法。 new Thread(new MyRunnable()).start();
        匿名内部类实现： new Thread(new Runnable(){重写run方法}).start();
    第三种方法： 实现Callable<V>接口  （面试可能会问到）
        Callable接口类似于Runnable，【Runnable不会返回结果，也不会抛出检查异常，Callable可以】
        1、创建一个Callable<V>接口的实现类，并重写call方法，其中设置线程的任务
        2、在使用的地方创建该类对象 obj 。
        3、ExecutorService executorService = Executors.newFixedThreadPool(5);  // 创建执行服务
        4、Future<V> future = executorService.submit(obj);                     // 提交执行
        5、V result = future.get();                                            // 获取结果
        6、executorService.shutdownNow();                                      // 关闭服务

同步：  多个对象访问同一个资源，可以并发读取，但当其中某一个对象要修改时，就必须实现同步
    所有的对象都拥有一把锁。
    
    锁对象选取总结为一句话就是 在同步代码中要改变谁就锁谁。
    方法一： 同步代码块：
        synchronized (锁对象) {访问共享数据的代码}  线程不仅要抢夺CUP，还要占用锁对象。同时拥有才能执行代码
        锁对象可以是任意对象，但必须是同一个对象，推荐将共享资源作为锁对象。线程占用锁对象后直到执行完毕才释放。
    方法二： 同步方法
        修饰符 synchronized 返回值类型 方法名 (参数列表) {访问共享数据的代码}     // 该方法即为同步方法
        首先将 访问共享数据的代码块 抽取出来，作为上述方法。
        同步方法的锁对象默认为 this ，即同步方法所在类的对象；创建该类的对象后，该对象调用同步方法时就会锁住对象自己。
        当同步方法同时也是静态方法时，锁对象为同步方法所在类的 Class 对象。
    方法三： Lock锁
        Lock是一个接口，有两个方法 void lock()  获取锁  和  void unlock()  释放锁
        它有一个实现类ReentrantLock（可重入锁）， 先实例化一个ReentrantLock对象。
        在出现安全问题代码之前用该对象调用 lock() 方法。在出现安全问题代码之后用该对象调用 unlock() 方法。
             lock() 和  unlock() 方法建议放在 try --- finally 代码块中
                
线程状态：
    线程停止：不推荐使用 Thread 类提供的 stop() 等方法。推荐自己通过一个标志位控制停止
                public class MyRunnable implements Runnable {
                    private boolean flag = true;
                    
                    @Override
                    public void run() {
                        while (flag) {
                            TODO...
                        }
                    }
                    
                    public void stop() {
                        flag = false;
                    }
                }
			通过调用自己实现的 stop 方法来停止线程
    下方所有方法都是 Thread 类中的方法！
    线程休眠：Thread.sleep(毫秒)      // sleep 不会释放锁、 wait 会释放锁。
    线程礼让： Thread.yield();  使当前线程从运行状态变为就绪状态，让 cpu 从所有就绪的线程中挑一个运行。
                礼让有可能不成功，因为 cpu 可能再挑选一次还是让当前线程继续执行。
    线程强制执行： join()    ，相当于插队，停止现在执行的线程，立刻执行自己的线程，且本线程执行结束才能执行其他线程
                public class MyRunnable implements Runnable {

                    @Override
                    public void run() {
                        for (int i = 0; i < 1000; i++) {
                            System.out.println("Runnable " + i);
                        }
                    }

                    public static void main(String[] args) throws InterruptedException {
                        MyRunnable myRunnable = new MyRunnable();
                        Thread thread = new Thread(myRunnable);
                        thread.start();

                        for (int i = 0; i < 500; i++) {
                            if (i == 200) {
                                thread.join();
                            }
                            System.out.println("主线程" + i);
                        }
                    }
                }
              在上方举例代码中，主线程执行到200之前，主线程和Runnable线程交替执行，当主线程执行到200次时，
              Runnable 线程插队接着执行，之后Runnable线程全部执行完毕后才由主线程继续执行。
     查看线程状态：Thread.State state = thread.getState();      // Thread.State 是一个枚举类型
     线程优先级：1 最小；10 最大；默认为5。优先级越高在就绪状态很大可能越早执行，但也不是一定。
     守护（daemon）线程：
         线程分为用户线程和守护线程。
         虚拟机必须保证用户线程执行完毕，但不用等待守护线程执行完毕。
         守护线程有：后台记录日志、监控内存、垃圾回收等
         private boolean daemon = false;    // 默认 daemon 属性是关闭的，即默认为用户线程
         thread.setDaemon(true);            // 可通过这样将线程设置为 守护线程。
         // 将线程设置为守护线程之后，虚拟机将不再保证该线程是否执行结束，
         // 即只要当用户线程执行结束后就将整个程序关闭，而不考虑守护线程此时是否已经执行完毕。

线程池 :   底层原理 ： 线程池就是一个容纳多个线程的容器，可由集合实现
    使用步骤: 1、使用线程池工厂类Executors里面的静态方法newFixedThreadPool生产一个指定线程数量的线程池，由ExecutorService接口接收。
             2、创建Runnable接口的实现类，重写run方法，设置线程任务。
             3、调用ExecutorService中的execute方法，传递线程任务，开启线程，执行run方法。
           例:   ExecutorService executorService = Executors.newFixedThreadPool(5);  // 创建服务
                 Runnable runnable = new Runnable() {  //此处虽然new 的是Runnable接口，但是立即重写了run方法，故相当于其实现类。
                     @Override
                     public void run() {
                         //线程任务
                     }
                 };
                 executorService.execute(runnable);                                  // 执行服务
                 executorService.shutdownNow();                                      // 关闭服务

	ExecutorService 中的 submit()方法和 execute()方法作用相同，只是适用于不同场景
      void execute(Runnable command)           // 执行任务，没有返回值，一般用于执行 Runnable
      <T> Future<T> submit(Callable<T> task);  // 执行任务，有返回值，一般用于执行 Callable


Lambda表达式 :  可推导，可省略
    格式：  () -> {}
    使用前提： 必须是接口，且接口中有且只有一个抽象方法  (有且只有一个抽象方法的接口，称为"函数式接口")
    可以省略的内容：
        1、(参数列表) 参数列表中的数据类型可以省略， 如果参数只有一个，则括号()也可以省略
        2、{方法体}   如果{}中的代码只有一行，无论是否有返回值，都可以省略 {}， return， 分号   （要省一起省）

注解:
    @override                    检测是否为覆盖重写
    @FunctionalInterface         检测是否为函数式接口


------------------------------------------------------------------------------------------------------------------

API使用：
    Scanner：
        功能：从键盘输入数据到程序。
        包路径：java.util.Scanner
        实例化：Scanner sc = new Scanner(System.in);  System.in 表示从键盘输入数据。
        方法：---其实键盘输入的一切东西都是字符串，使用不同的函数会将字符串转换为相应的类型。-->故若记不住也可以一直使用sc.next();之后再转换类型
            获取键盘输入的一个int数字： int num = sc.nextInt();
            获取键盘输入的一个字符串： String str = sc.next();
        读取文件内容：Scanner in = new Scanner(Paths.get("\u202AC:\\Users\\Lenovo\\Desktop\\1.txt"), StandardCharsets.UTF_8);
            之后再用in的各种方法。nextLine();   next();   nextInt(); 等


Random:
    功能: 获取随机数。
    实例化：Random rand = new Random();
    方法：int rand_num = rand.nextInt(n)  在[0, n)中随机取一个数字。----> m + rand.nextInt(n)取到[m, m + n）中的随机数。

ArrayList: [元素1， 元素2， 元素3， ...]
    功能：可变长的数组。
    泛型：装在集合中的元素必须是同一个类型，只能是引用类型，不能是基本类型。
    实例化：ArrayList<String> list = new ArrayList<>();
    注意事项：直接打印list输出的不是一个地址值，而是空的中括号。
            不支持下标索引，只能用get()方法获取。
    常用方法：list.add("李沁")  添加元素，返回一个boolean值，表示添加的动作是否成功。一定成功，可以不接受返回值。
            list.get(index)  根据索引获取元素，返回获取的元素。
            list.remove(index)  根据索引删除元素，返回被删除的元素。
            list.size()  获取集合长度。
    若想在ArrayList中存储基本类型，需要使用其包装类(引用类型)：
        基本类型         包装类
        byte            Byte
        short           Short
        ...             ...   （与上方一样，只需首字母大写）
        int             Integer    【特殊】
        char            Character  【特殊】
        ArrayList<Integer> list_int = ArrayList<>();
        //  自动装箱：int --> Integer     自动拆箱：integer --> int

String:
    功能：字符串（常量） --> Java中所有的双引号字符串都是String类的实例。
    实例化：直接创建： String str1 = "李沁";    在字符串常量池中， 其他实例化方式都在堆中，不在池里。
          使用空构造函数： String str2 = new String();
          根据字符数组创建： char[] charArray = { &#39;a&#39;, &#39;b&#39;, &#39;c&#39; };   String str3 = new String(charArray) // abc
          根据字节数组创建： byte[] byteArray = { 97, 98, 99 };   String str3 = new String(byteArray)    // abc
    方法：str1.equals(str2)  比较str1和str2的值是否相等，返回boolean。 常变量比较时推荐  常量.equals(变量)
         str1.equalsIgnoreCase(str2) 忽略大小写。
         str.length()   长度
         str.concat(str1)   拼接
         str.charAt(index)  根据索引返回字符
         str.indexOf(str1)  在str中查找str1，返回首次找到的索引值；若没有，返回-1
         str.substring(index)   截取，从index到末尾
         str.substring(int begin, int end)   截取，[begin, end)
         str.toCharArray()  转换为字符数组   str.getBytes()  转换为字节数组   用于遍历字符串
         str.replace(old, new)  用new替换str中的old
         str.split(regex)  切割，返回数组

Arrays:
    功能：与数组相关的类，提供大量静态方法，用来实现数组常见的操作。
    方法：
        Arrays.toString(数组)  将参数变成字符串 [元素1， 元素2，元素3，...]
        Arrays.deepToString(多维数组)  将参数变成字符串 [元素1， 元素2，元素3，...]
        Arrays.sort(数组)  排序。默认从小到大，自定义类型的排序需要Comparable或Comparator接口
        Arrays.equals(数组1， 数组2)    两个数组完全相等是返回ture

Math:
    功能：数学相关的类，提供大量静态方法，用来实现数学运算相关的操作。
    方法：
        Math.abs()     绝对值
        Math.ceil()    向上取整
        Math.floor()   向下取整
        Math.round()   四舍五入

Collection接口: 所有单列集合的顶层接口
    List接口:  1、有序（存入和取出的顺序一致）  2、允许元素重复  3、有索引
        Vector:(了解)
        Arraylist:(重点)  底层由数组实现，查询快，增删慢。
        LinkedList:(次之) 底层由链表实现，查询慢，增删快。
            特有方法:
                addFirst() == push()      addLast() == add()
                getFirst()                getLast()
                removeFirst() == pop()    removeLast()    这两种方法都会删除并返回
        共有方法：
            void add(int index, E element)    将元素添加到索引位置
            E get(int index)                  返回索引处的元素
            E remove(int index)               删除索引位置元素,并返回被删除的元素
            E set(int index, E element)       替换索引位置元素,并返回被替换前的元素
    Set接口:  1、不允许元素重复    2、没有索引
        TreeSet: (无序) (了解)        底层由二叉树实现，一般用于排序。
        HashSet: (无序) (重点)        底层由哈希表实现。(查询速度很快)
            注意: 使用HashCode存储自定义类型时，需要重写HashCode()和equals()。可通过alt + insert直接添加。才能保证元素不重复。
            LinkedHashSet: (有序) (次之)  底层由哈希表+链表实现。 extends HashSet
                比HashSet多了一条链表，用来记录元素的顺序
    共有方法：
        boolean add(E e)      添加，   无需接收
        boolean remove(E e)   删除，   若有e，删除并返回true。若没有e，无动作并返回false
        void clear()          清空。   但不删除集合。
        boolean contains(E e) 是否包含。
        boolean isEmpty()     是否为空。
        int size()            元素个数。
        Object[] toArray()    转为数组。

哈希值: 是一个十进制的整数，由操作系统随机给出的对象的逻辑地址值。
哈希表: 拉链法。由哈希值为元素组成数组（初始长度为16）。若哈希值相等，则以链表方式挂在该哈希值后面。当链表长度超过8时，变为红黑树。检索速度加快。

Collections :  是Collection的工具类，提供大量静态方法，用于操作集合。 以ArrayList为例: ArrayList<String> list = new ArrayList<>();
    addAll(Collection<T> c, T... elements) : 往集合中添加多个元素。  Collections.addAll(list, "a", "b", "c");
    shuffle(List<T> list) : 打乱顺序。                             Collections.shuffle(list);
    sort(List<T> list)    : 排序， 默认升序。                       Collections.sort(list);
        注意：若要对自定义类型排序，则被排序的类必须实现Comparable接口，重写compareTo方法来定义排序规则。  this - 参数 ： 升序
    (了解)另一种sort()： Collections.sort(arr, new Comparator<Integer>() {
                               @Override
                               public int compare(Integer o1, Integer o2) {
                                   return o1 - o2;
                               }
                           });     这种方法List接口中的方法类似-> arr.sort(new Comparator<Integer>() {...})

Iterator: 迭代器    是接口   也有泛型 --> Collection<String> array = new ArrayList<>();
                                        Iterator<String> it = array.iterator();
    常用方法:
        boolean hasNext()  是否有下一个元素。
        E next()           返回下一个元素。
    使用： Collection中的实现类为 iterator()
        1、实例化iterator    2、用hasNext()    3、用next()

增强for循环:  专门用来遍历数组与集合，由Iterator迭代器实现，遍历时不能做增删操作。
    for (元素数据类型 变量 : 集合或数组名) { ... }

Map:      --> 字典     键值对     key是唯一的
    HashMap: (无序)  底层为哈希表
        LinkedHashMap : (有序)  底层为哈希表+链表(保证顺序)
    方法:
        V put(K key, V value) : 添加，若key值不存在，则添加并返回null。若key值已存在，则更新value值，并返回被替换掉的value值。一般不接收返回值。
        V remove(K key)  : 删除，若key值存在，返回被删除的value。若key不存在，则返回null。
        V get(K key)     : 获取，若key值存在，返回对应的value。若key不存在，则返回null。
        boolean containsKey(k key)  :  判断是否包含指定的键。
        Set<K> keySet()   返回由键组成的Set，之后可以通过遍历Set来遍历Map。  for (K key : map.keySet()) { sout(key + map.get(key)) }
        Set<Map.Entry<K, V>> entrySet()  -->  for (Map.Entry<K, V> entry : map.entrySet()) {  也是遍历，看起来不好用的样子
                                                          System.out.println(entry.getKey() + &#39; &#39; + entry.getValue());}
    用Map存储自定义类型时，若自定义类型作为键，则必须将该类重写HashCode和equals方法，保证键是唯一的。
of方法：  static <E> List<E> of (E... elements)
    1、of方法只适用于List, Set, Map 接口。而不适用于他们的实现类
    2、of方法返回一个不能被操作的集合。因此适合初始化，且初始化后不能改变。
    3、Set 和 Map 调用of方法时不能有重复元素。

------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------

Object：   以下方法所有类都有，只是重写之后功能有所不同。
    toString()  直接打印对象的名字，就是调用对象的toString方法->得到对象的地址值。  没有意义。
                重写：可以和构造方法与Getter/Setter方法一样的步骤添加（重写）toString方法->打印出属性值。
    equals()    boolean equals(Object obj)  判断两个对象是否"相等"，返回布尔值。 比较两个对象的地址值，同上方的==作用一样。 没有意义。
                重写： 原理 --> 由于equals方法的参数类型为Object,所以默认向上转型了。若想比较两个对象的属性值，需要先向下转型。
                      同样可以 alt + insert 直接生成equals方法。 判断两对象的属性值是否都一样。
    hashCode()  返回对象的哈希码值
    // synchronized 能实现线程同步、但无法实现线程间通信、用如下 4 个方法可以实现线程间通信。
    wait()      等待。在被唤醒之前，放弃CPU的使用权    wait(毫秒值)  在被唤醒或到时间之前，放弃CPU的使用权
    notify()    唤醒。随机唤醒锁对象中的一个进程       notifyAll()  唤醒锁对象(对象监视器)中的所有进程   这两种常搭配同步机制使用

objects:  该工具类提供的方法是容忍空指针的。 若 a=null，则a.equals(b) 报错。而Objects.equals(a, b) 正常运行。
    Objects.requireNonNull(T obj)   查看obj是否为空，用来判断参数的合法性。

旧API :
    Date:     1970年1月1日 00:00:00 作为0时刻
        Date() 无参构造--> 获取当前时间。
        Date(long date)  有参构造 --> 输入毫秒值，输出相对于0时刻的日期。
        getTime()  把日期转换为毫秒

    DateFormat:    格式化日期。   抽象类。
        String format(Date date)    把日期格式化为字符串。
        Date parse(String source)   把符合的字符串解析为日期。
    
        SimpleDateFormat:    DateFormat的实现类
            SimpleDateFormat(String pattern)  有参构造  参数一般为 "yyyy-MM-dd HH:mm:ss"
            使用上方两个方法。 注意：用parse时，参数的模式必须与构造SimpleDateFormat对象时的模式完全一样，否则报错。
    
    Calendar:     日历类       抽象类
        getInstance()  静态方法   返回Calendar类的子类对象         Calendar instance = Calendar.getInstance();
            功能：使用默认时区和语言环境获得一个日历
        get(field)  返回给定字段的值。                  字段值有YEAR MONTH DATE HOUR MINTER SECOND 年月日时分秒   都是静态变量
        set(field, value)   将给定的日历字段设置为给定值
        add(field, amount)   修改指定的字段，通过amount的正负实现加减。
        Date getTime()      将Calendar转为Date对象
            原理：实际上该类中有一个fields数组，上述的方法都是在对该数组操作。字段值YEAR等固定为0，1，2等，作用是对该数组的索引。

新API
LocalDate, LocalTime, LocalDateTime : 之前的Date类和Calendar类都有缺陷。JDK8 新引入日期时间类
    由于LocalDateTime类使用较多，故以他为例，其余两种用法相同。
    构造方法： 1、LocalDateTime now = LocalDateTime.now();      获取当前时间
             2、LocalDateTime localDateTime = LocalDateTime.of(2020, 1, 20, 12, 20, 34);    获取指定时间
    常用方法：
        now.getDayOfMonth()                           获取对象是这个月的第几天。类似的方法获取其他属性。
        LocalDateTime time = now.withDayOfMonth(12);  使用类似方法设置属性。但是该语句执行后，time为修改后的值，而now的值不变。体现了时间的不可变性。
        LocalDateTime plusDays = now.plusDays(3);     使用类似方法修改属性，在原有基础上加3天。不可变性同上。
        LocalDateTime months = now.minusMonths(2);    使用类似方法修改属性，在原有基础上减2月。不可变性同上。
Instant 替换 Date 类
DateTimeFormatter :  类似于SimpleDateFormat     日期时间的格式化与解析
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");   构造
    String format = formatter.format(LocalDateTime.now());                              格式化
    TemporalAccessor parse = formatter.parse("2021-01-21 22:00:25");                    解析

System:  提供大量静态方法， 可以获取与系统相关的信息即服务
    static currentTimeMillis()    返回以毫秒为单位的当前时间, 用来测试程序的效率。
    static arraycopy(原数组， int 原数组起始位置， 目标数组， int 目标数组起始位置， int 要复制的数组元素的数量)  复制数组

StringBuilder:
    在String类中，字符串是常量，底层是被final修饰的数组。字符串相加时，占用内存多，效率低下。
    StringBuilder类是字符串缓冲区，可以提高字符串的操作效率（看成是一个长度可以变化的字符串）
        底层也是一个数组，但是没有被final修饰，可以改变长度。
        在内存中始终是一个数组，初始容量为16个字节，超出会自动扩容，占用空间少，效率高。
    构造函数：
        StringBuilder()  无参构造，空字符串。
        StringBuilder("abc")  有参构造，即参数的字符串。
    成员函数：
        append(任意类型)   添加到字符串，并返回自身。所以无需接收。
        toString()   将StringBuilder对象，转换为String对象。       通过StringBuilder的构造方法可以将String转换为StringBuilder.
        reverser()   翻转

File:    文件类，主要用于文件和目录的创建，查找和删除等操作     File类已被Path取代
    静态方法:
        static String	pathSeparator    路径分隔符    windows ; 分号      linux  : 冒号
        static String	separator        文件名称分隔符   Windows \ 反斜杠   Linux  / 正斜杠
    构造方法:
        File(String pathname)    路径名 ==> 文件/文件夹  相对/绝对  存在/不存在
        File(String parent, String child)  父路径，子路径
        File(File parent, String child)  父路径，子路径。父路径是File型，故可以使用其方法做调整
    常用方法:
        获取方法:
            String getAbsolutePath()  返回绝对路径名
            String getPath()          返回路径名
            String getName()          返回末尾文件/文件夹 名字
            long length()             返回文件大小（以字节为单位） 不能是文件夹，若路径不存在，返回0
        判断方法:
            boolean exists()          文件或文件夹是否真实存在
            boolean isDirectory()     路径是否以文件夹结尾   前提：真实存在
            boolean isFile()          路径是否以文件结尾     前提：真实存在
        创建删除:
            boolean creatNewFile()    不存在时创建文件     不能创建文件夹，路径必须存在
            boolean delete()          删除文件/文件夹
            boolean mkdir()           创建单级空文件夹
            boolean mkdirs()          创建单级/多级空文件夹     多级文件夹：父文件夹中包含子文件夹
        遍历文件夹:
            String[] list()           返回由所有文件或子目录组成的字符串数组
            File[] listFiles()        返回由所有文件或子目录封装而成的文件数组
    过滤器:
        File[] files = dir.listFiles(new FileFilter(){重写accept()方法，该方法中写入过滤规则，留下的返回ture，不要的返回false})
            可以写为Lambda表达式。

读取文件的方法：
        Scanner in = new Scanner(Paths.get("C:\\Users\\Lenovo\\Desktop\\1.txt"), StandardCharsets.UTF_8);
        String num = in.nextLine();

        BufferedReader reader = Files.newBufferedReader(Paths.get("C:\\Users\\Lenovo\\Desktop\\1.txt"), StandardCharsets.UTF_8);
        String str = reader.readLine();

（不好用）BufferedReader bufferedReader = new BufferedReader(new FileReader("C:\\Users\\Lenovo\\Desktop\\1.txt"));
        String s = bufferedReader.readLine();

Properties:  用来加载配置文件,  示例如下：
            Properties properties = new Properties();
            //  ClassLoader classLoader = Person.class.getClassLoader();  注释掉的两句作用与下一句一样
            //  InputStream is = classLoader.getResourceAsStream("jdbc.properties");  //  路径相对于src
            FileInputStream fis = new FileInputStream("src\\jdbc.properties");  // 路径相对于Module而不是src
            properties.load(fis);
            String user = properties.getProperty("user");
            String passwd = properties.getProperty("passwd");
            System.out.println(user + " " + passwd);

IO流:    （默认相对路径在Module下）
    基本流:
        OutputStream: 字节输出流  (一切都以字节为单位) (一次读写一个字节)  接口
            共有方法: write(byte[] bytes)    写入多个字节
                     close()
            FileOutputStream: 文件字节输出流
                构造方法: FileOutputStream(String name[, boolean append = false])
                            参数为路径，即写入的目标文件路径，如果没有该文件，会先创建该文件。若append为ture，则为追加写，否则会覆盖原文件
                         FileOutputStream(File file[, boolean append = false])    参数为文件，即写入的目标文件，append同上。
        InputStream: 字节输入流  接口
            共有方法: read()   读取一个字节,返回读到的内容，读到文件末尾返回-1
                     int read(byte[] bytes)   读取多个字节，将读取到的内容存入字节数组中，并返回读取的有效字节个数，读到文件末尾返回-1
                     close()
            FileInputStream: 文件字节输入流
                构造方法: FileInputStream(String name)
                         FileInputStream(File file)
        Reader: 字符输入流  抽象
            共有方法: read()    read(char[] c)   close()   作用和上述相同,包括返回-1等等都相同，只是读取单位变为字符。
            FileReader: 文件字符输入流  --->   只能读取IDEA默认编码格式文件(即UTF-8)
                构造方法: FileReader(String filename)     FileReader(File file)
        Writer: 字符输出流  抽象
            共有方法: write()  参数可以为单个字符，字符数组或字符串   close()
            FileWriter: 文件字符输出流
                构造方法: FileWriter(String filename[, boolean append = false])     FileWriter(File file[, boolean append = false])
                注意: 这里的write方法是将数据写入内存缓冲区(字符转为字节)，flash方法或close方法会数据刷新到文件。因此必须调用close()方法。
        Properties集合: 实现了Map<K, V>   唯一和IO流结合的集合
            该集合的默认键和值都是字符串类型。store方法能把集合中的数据存入硬盘，load方法会加载到该集合中。
    缓冲流:  创建一个缓冲区，减少系统IO次数，提高读写效率。
        BufferedInputStream:  字节缓冲输入流 extends InputStream        用read写入，close关闭。只需要关闭缓冲流，基本流会随之关闭。
            构造方法: BufferedInputStream(InputStream in[, int size])       read和write方法与基本流完全相同。
        BufferedOutputStream: 字节缓冲输出流 extends OutputStream       用write写入，close关闭
            构造方法: BufferedOutputStream(OutputStream out[, int size])
                参数可以传递FileOutputStream对象，可选参数size用于指定缓冲区大小
        BufferedWriter:  字符缓冲输出流 extends Writer
            构造方法: BufferedWriter(Writer out[, int size])  可传入FileWriter
            特有方法: void newLine()   无视系统差异，换行
        BufferedReader:  字符缓冲输入流 extends Reader
            构造方法: BufferedReader(Reader in[, int size])  可传入FileReader
            特有方法: String readLine()   读取一行数据，但不读取行末换行符。读到文件末尾返回null
    转换流:  可以指定编码/解码的码表
        OutputStreamWriter extends Writer:  步骤: 1、new对象 2、write()  3、close()
            构造方法: OutputStreamWriter(OutputStream out[, String charsetName])
                参数一般传递为FileOutputStream。可选字段为编码表名称，不区分大小写，默认为UTF-8
        InputStreamReader extends Reader:  步骤: 1、new对象 2、read()  3、close()
            构造方法: OutputStreamWriter(InputStream in[, String charsetName])
    (反)序列化流: 把对象以流的方式写入/读出到文件中     使用字节流
        ObjectOutputStream: extends OutputStream  对象的序列化流    把对象以流的方式写入到文件中保存，叫写对象，也叫对象的序列化。
            构造方法: ObjectOutputStream(OutputStream out)   参数一般传递为FileOutputStream。
            特有方法: void writeObject(Object obj)   此处参数也可以是由obj组成的集合，如ArrayList<Person> list
                被序列化的对象(即参数obj)必须实现Serializable接口，以激活(反)序列化功能。其为标记型接口，内部没有任何抽象方法。
        ObjectInputStream: extends InputStream   对象的反序列化流    把文件中保存的对象以流的方式读出来，叫读对象，也叫对象的反序列化。
            构造方法: ObjectInputStream(InputStream in)       参数一般传递为FileInputStream。
            特有方法: Object readObject()
        transient关键字: 瞬态关键字，被其修饰的成员变量不能被序列化，没有替他功能。static关键字也有这个功能。
        注意：为了避免InvalidClassException,在每个被序列化的对象中都显示声明一个序列号-> private static final long serialVersionUID = 42L
    打印流:  PrintStream                          System.out.println();

enum :    枚举类   类的对象只有确定的有限个，我们称之为枚举类   当需要定义一组常量时，强烈建议使用枚举类    默认继承java.lang.Enum
    定义：
        类似于接口的定义，创建Class包时，选项中就有Enum的选项。
        public enum Season {
            SPRING("春天", "warm"),                               默认由public static final 修饰
            SUMMER("夏天", "sun"),                                实例写在类的最前面
            AUTUMN("秋天", "cool"),                               实例之间用逗号分隔，最后一个结尾为分号
            WINTER("冬天", "cold");                               为什么不需要显示声明成员变量(由局部变量代替)，暂时不清楚
            Season(String seasonName, String seasonDec){}  }      构造函数默认由private修饰，可省略不写。
    静态方法：
        values()                   返回枚举类型的对象数组，方便用于遍历枚举值
        valueOf(String objName)    返回枚举类中对象名为objName的对象   如: Season winter = Season.valueOf("WINTER");
        toString()                 返回当前枚举类对象常量的名字

反射:    java.lang.Class
            程序由javac.exe编译后，会生成一个或多个字节码文件(.class结尾)。
            接着使用java.exe对某个字节码文件解释运行，就相当于将某个字节码文件加载到内存中，这个过程就叫类的加载，
            加载到内存中的类就叫运行时类，这个运行时类就是Class的一个实例。
            加载到内存中的运行时类会缓存一段时间，在此时间内以不同方式获取到的该运行时类的Class实例都是同一个。
        获取Class实例的方法：
            1、 Class clazz = Person.class;
            2、 Person person = new Person();     Class clazz = person.getClass();
            3、 Class clazz = Class.forName(类相对于src的全路径);   // 用的较多
        ClassLoader：引导类加载器--》加载java核心类库   引导类加载器无法获取到
                     扩展类加载器--》加载jar包      通过Class实例.getClassLoader()即可获得类加载器，如
                     系统类加载器--》加载自定义类    Person.class.getClassLoader()获取的即为系统类加载器
        无法创建实例的类型用  Class c = int.class;   double.class;    Math.class; 等
        ArrayList<Integer> list = new ArrayList<>();
        Class l1 = list.getClass();           得到ArrayList<Integer>类的Class实例
        l1.getDeclaredConstructors();         获取所有构造函数，去掉Declared为只获取public的构造函数
        l1.getDeclaredMethods();              获取所有函数，去掉Declared为只获取public的函数
        l1.getDeclaredFields();               获取所有属性，去掉Declared为只获取public的属性
        l1.getSuperclass();                   获取父类
        l1.getGenericSuperclass();            获取带泛型的父类
        li.getInterfaces();                   获取接口
        li.getPackage();                      获取包
        li.getAnnotations();                  获取注解
        for (Method method: l1.getDeclaredMethods()) {
           System.out.println(Modifier.toString(method.getModifiers()) + " " + method.getReturnType() + "  " +
                   method.getName() + "(" + Arrays.toString(method.getParameterTypes()) + ");");
        }
        Field f = l1.getDeclaredField("size");  根据属性名称获取特定的Field对象。
        f.setAccessible(true);                  使其变为可访问的
        Object v = f.get(list);


    Person person = new Person("alice", 21);    方法对象调用invoke方法来执行方法。
    Class p = person.getClass();                public Object invoke(Object obj, Object... args)
    Method m = p.getMethod("getName");          第一个参数为对象名，之后的参数为方法的参数。
    String s = (String) m.invoke(person);       调用的是静态方法时，第一个参数为null。

    代理的作用就是在不修改源码的情况下，对目标对象的方法增强。
    静态代理：接口 + 代理类 + 被代理类   --》  一个代理类只能对应一个被代理类         代理类与被代理类实现同样的接口
    动态代理：接口 + 代理类 + 多个被代理类   --》  一个代理类可以对应多个被代理类     代理类与被代理类实现同样的接口
        结合src/proxy/annotationProxy包下的例子理解
        1、根据自己需求创建一个被代理类对象（想象在项目中，要增强功能时，一定在之前已经使用过这个对象）
        2、根据这个被代理类对象，动态获取一个代理类对象（因此，没有显示的代理类，是被动态获取到的）
        3、使用代理类对象调用被代理类的方法。（具体原理看包中例子的注释）
'><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/posts/java/java%E7%AC%94%E8%AE%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity="sha256-1yREUm1+y9sAFUOKf6iQVKZYv3WdBULi5d+BzpS0k+4=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/posts/java/java%E7%AC%94%E8%AE%B0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/posts/java/java%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="lu"><meta property="og:title" content="Java学习笔记"><meta property="og:description" content='数组： 数组的初始化方式： 1、动态初始化（指定长度） 数据类型[] 数组名 = new 数据类型[数组长度]； 2、静态初始化（指定内容） 数据类型[] 数组名 = new 数据类型[] {元素1， 元素2， 元素3， ... }； 元素值可以是变量 省略的静态初始化 数据类型[] 数组名 = {元素1， 元素2， 元素3， ... }； 该方式不允许拆分为2步，即先定义数组名，再经行赋值。 直接打印数组名，打印的是数组的内存地址。 支持下标索引。 未初始化的默认初始值： 整数类型： 0 浮点类型： 0.0 字符类型： &#39;\u0000&#39; 布尔类型： false 引用类型： null 获取数组长度： 数组名.length; 获取数组副本： 数组名.clone(); 成员变量与局部变量： 成员变量定义在类内，方法外。局部变量定义在方法内。 成员变量不要写static关键字。??? 成员变量有默认值，而局部变量没有默认值。 当成员变量与局部变量的命名冲突时，按照就近原则，优先使用局部变量。若想使用全局变量，使用this.成员变量名。 可变参数: 使用前提：当方法的参数类型确定，但是参数个数不确定时，使用可变参数。 使用格式：修饰符 返回值类型 方法名(数据类型...变量名) {} 例如: public void func (int... num) {} 原理： 可变参数底层是一个数组，根据传递参数个数的不同，会创建不同长度的数组，来存储这些参数。参数个数可以是0个或多个。 因此，方法中的变量名其实就是数组的名字，可以作为数组使用。 注意： 一个方法的参数列表中只能有一个可变参数。 如果方法有多个参数，则可变参数必须放在参数末尾。 类的使用: 1、导包：import 包路径.类名称 当类与当前文件处于同一个包中时，可以不用导包。只有java.lang下的包不需要导包，其他都需要导包。 但实际使用中，可以不用手动导包，当你使用某个类时，系统会自动帮你导包。 2、实例化： 类名称 对象名 = new 类名称(); 3、使用: 对象名.成员变量名 对象名.成员方法名(参数) Private: Getter: 函数格式必须是 getXXX 如果变量是布尔类型，则使用isXXX Setter: 函数格式必须是 setXXX Private修饰构造函数时，外部不能再构造该类的实例，故只能在类内构造好全部实例并赋给static类型的变量。叫构造函数私有化 this: this是当前对象的引用，即this和对象是同一个东西。 this.成员变量 调用本类成员变量 可以将类内的成员变量与方法中的同名局部变量区分。 this.成员方法 调用本类成员方法 this(...) 调用本类构造函数 --> 写在第一行，只能调用一个。 若子类使用了this(...)，则不再默认赠送super()。 super: super.成员变量 调用父类成员变量 可以将父类中的成员变量和子类中的同名成员变量区分。 super.成员方法 调用父类成员变量 super(...) 调用父类类构造函数 --> 写在第一行，只能调用一个。 构造函数： 格式： public 类名（参数类型 参数名称 ， ...）{...} 注意事项： 构造方法的名称和类名要严格相等，大小写敏感。 构造方法没有返回值类型。 若不明确定义构造函数，则会自动生成默认构造函数，若手动定义了任意形式的构造函数，编译器将不会再生成默认构造函数。 构造函数支持重载 继承中的构造函数: 构造链：同C++一样--> 祖宗 > 父类 > 子类 子类构造方法中若不显式调用super，则默认隐含一个 "super()" 调用。 子类构造函数可以显式地写 super([参数1，...]) 来调用父类的重载构造函数。且必须在方法体的第一行，即只能调用一个。 标准类：也叫做 Java Bean 通常包含以下4部分内容： 所有的成员变量都要使用private关键字。 为每一个成员变量编写一对儿Getter/Setter方法 编写一个无参构造函数 编写一个全参构造函数 点击 Code->Generate 或者 快捷键 alt + insert 可以自动生成上述内容 ==： 对于基本类型， == 比较的是值 对于引用类型， == 比较的是地址 基本类型与字符串之间的转换： 基本类型 --> 字符串 1、基本数据类型的值+"" 最简单的方式（工作中常用） 2、使用包装类的静态方法 static String toString(int i) 将i变为字符串形式 如 Integer.toString(100); 3、使用String类的静态方法 static String valueOf(int i) 将i变为字符串形式 如 String.valueOf(100); 字符串 --> 基本类型 使用包装类的静态方法 parseXX("字符串") Integer static int parseInt(String s) 如 Integer.parseInt("100"); ... ... 泛型: 泛型名字不一定是E，可以是任意大写字母。 类: public class ClassName<E> { ... 在类内将需要的地方都用E代替} 实例化对象时确定类型 方法: 修饰符 <E> 返回值类型 方法名(参数列表){ ... } 调用方法时确定类型 接口: 含有泛型的接口定义与类相同。 确定类型的方法：1、在实现类中确定类型 2、实现类依然沿用接口的泛型E，实现类创建对象时确定类型 通配符: <?> 代表任意数据类型， 使用: 例如当多个不同类型的ArrayList集合要作为参数调用同一个方法时，可以将参数设置为ArrayList<?> list方便接受任意类型。 高级使用: ? extends E 表示 ? 只能是E的子类/本身 ? super E 表示 ? 只能是E的父类/本身 static: 带上static的成员变量或函数，不属于对象，而是属于类，所有对象共享。 类名.静态变量 类名.静态方法() 注意事项：静态不能直接访问非静态 --> 在内存中，先有静态，后有非静态 静态不能使用this 静态代码块：static{ ... } 首次用到类时，静态代码块唯一执行一次。 典型用途：一次性地对静态成员变量赋值。 override: 在子类的覆盖重写方法前面加上 @override 可以检验该方法是否为重写方法（建议写上） 子类方法的返回值的范围必须 小于等于 父类方法的返回值的范围。 子类方法的权限必须 大于等于 父类方法的权限 权限： public > protected > (default) > private (default) 表示什么也不写，留空。 同一个类 YES YES YES YES (我自己) 同一个包 YES YES YES NO (我领居) 不同包子类 YES YES NO NO (我儿子) 不同包不同类 YES NO NO NO (陌生人) abstract: 抽象方法：只定义，不实现。加上abstract关键字，去掉大括号，直接分号结束。 抽象类： 抽象方法所在的类，必须是抽象类。在class前加上abstract即可。但抽象类中不一定包含抽象方法（通常是有的）。 使用步骤： 抽象类不能直接创建对象。 必须用一个子类继承抽象父类。 子类必须覆盖重写抽象父类中的所有抽象方法。-->此处覆盖重写即实现：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。 创建子类对象，并使用。 interface： 概念：接口就是多个类的公共规范。是一种引用数据类型，最重要的就是其中的抽象方法。 定义：public interface 接口名称 { ... } 包含：常量、抽象方法、默认方法、静态方法、私有方法。 常量：可以理解为成员变量，但是必须使用 public static final 三个关键字修饰，故相当于常量。 public static final 数据类型 常量名称 = 值 （三个关键字可省略，但不能换为别的） 注意：1、接口中的常量可以省略public static final，但写不写效果一样。 2、接口中的常量必须手动赋值，不能不赋值。赋值之后无法改变。 3、常量名称全部大写，由下划线连接。 使用：接口名称.常量 抽象方法：1、接口中的抽象方法，修饰符固定为 public abstract (可省略，但不能换为别的) 2、方法的三要素可随意定义。 默认方法：public default 返回值类型 方法名(参数列表) {方法体} (public可省略，default不能省略) 可以解决接口升级的问题。（不想改变实现类，但是接口中又想要添加新方法，则接口就可以用默认方法自己实现）（实现类可以覆盖重写默认方法） 默认方法会被实现类继承，故可以通过实现类的对象访问默认方法。 静态方法：public static 返回值类型 方法名(参数列表) {方法体} (public可省略，static不能省略) 使用：接口名称.静态方法(参数); 不能通过对象访问。 私有方法：1、普通私有方法：解决多个默认方法之间的重复代码问题 private 返回值类型 方法名(参数列表) {方法体} 只有接口中的默认方法能访问。 2、静态私有方法：解决多个静态方法之间的重复代码问题 private static 返回值类型 方法名(参数列表) {方法体} 只有接口中的默认方法和静态方法能访问。 使用：1、接口不能直接使用，必须有一个“实现类”来“实现”该接口。 public class 实现类名称 implements 接口名称 {...} 2、接口的实现类必须实现接口中的全部抽象方法。去掉abstract关键字，加上大括号实现体。 3、创建实现类对象，使用。 注意事项：1、接口没有静态代码块和构造方法。 2、如果实现类没有覆盖重写所有接口中的所有方法，则该实现类自己就必须是抽象类。 3、一个实现类可以实现多个接口 public class 类名 implements interface1, interface2 {}。 4、若一个类实现的多个接口中有重名的抽象方法，则只需实现一个即可。 5、若一个类实现的多个接口中有重名的默认方法，则该实现类必须对重名默认方法覆盖重写。 6、若一个类的直接父类中的方法和它实现的接口中的默认方法重名，则优先使用直接父类的方法。 在java中【继承 优先于 接口】 7、接口是多继承的。多个父接口当中的抽象方法如果重名，没关系。 多个父接口当中的默认方法如果重名，则子接口必须对重名的默认方法覆盖重写，【而且带着default关键字】 多态：（一个子类对象既有子类形态，又有父类形态）一个对象拥有多种形态，即【对象】的多态性。【多态性指的是对象，而不是类】 代码中体现多态性： 父类引用指向子类对象。 格式 父类名称 对象名 = new 子类名称(); 或 接口名称 对象名 = new 实现类名称(); 【初步理解: 定义了一个指向子类对象的父类引用，这个引用指向的是子类的对象，但是只能访问父类大小的内存空间，所以它只能访问父类继承到子类当中的成员 （包括成员变量和成员函数）的那部分内存空间，而不能访问子类独有的多出来的那部分内存空间，而对于被子类重写了的方法，该引用依然可以访问 这部分内存，只是内存中的内容已经被改写了，所以访问到的是子类重写之后的方法。综上所述，该引用能访问的范围是所有从父类继承下来的变量和 父类独有方法，以及被子类重写之后的方法。】 多态对象访问成员变量： 对象名.成员变量 访问的是父类的成员变量，若没有则向上找，不会向下找。 不能用这种方法访问子类特有成员变量。 多态对象访问成员函数： 若子类重写了父类的成员函数，则访问子类的成员函数。 若子类没有重写，则访问父类的成员函数，没有则向上找。 同样不能访问子类特有成员函数。 记忆口诀；对于成员变量，等号左边是谁就优先用谁。对于成员方法，new的是谁就优先用谁。 使用多态的好处：比如将父类的引用作为参数传入方法中，则该引用可以指向不同的子类对象使方法实现不同的功能，却不需要改变方法中的任何代码。 对象的向上转型： 在特定场合会自动向上转型，如方法参数要求为父类，但是传入一个子类对象也正确，这时就发生了自动向上转型。与int double发生自动类型转换原理一样。 格式：与多态相同：父类名称 对象名 = new 子类名称(); 含义：创建一个子类对象，把它当作父类来看待使用。 【向上转型一定是安全的】从小范围转向了大范围，如将小范围的猫向上转型为更大范围的动物。 类似于将short转换为int。 弊端：不能访问子类特有方法。 对象的向下转型：其实是一个【还原】的动作。 格式： 子类名称 对象名 = (子类名称) 父类对象; (子类名称)必须有，不能省略。 含义： 将向上转型之后的父类对象还原为本来的子类对象。 注意： 只有本来是猫，向上转型为动物后，再向下转型为猫才是正确的。 若本来不是猫，却硬要向下转型为猫就会出错(编译不会报错，但运行会出现异常ClassCastException)。 instanceof: 格式： 对象名 instanceof 类名 作用： 返回一个布尔值，判断前面的对象能不能当作后面类的实例。 应用： 在向下转型之前，判断需要转型的对象是不是目标类的对象，是则向下转型，不是则不转型。 final: 该关键字表示最终的，不可再改变的。 用法: 修饰一个类、方法、局部变量、成员变量。 修饰一个类： public final class 类名 {...} 不能有子类。 修饰一个方法： 该方法不能被重写。 对于类和方法，abstract 和 final 不能同时使用，会矛盾。 修饰一个局部变量： 一次赋值，终生不变。（可以先定义，再赋值。分两步）--对于基本类型，值不可变。对于引用类型，地址值不可变。 修饰一个成员变量： 由于成员变量有默认值，所以不能分两步，必须当场手动赋值或通过构造函数赋值。 修饰一个数组或集合： 该数组或集合不能再被赋值，但内部的数据还可以改变。 内部类： 一个类内部包含另一个类，即一个事物内部包含另一个事物。 例如 身体和心脏的关系 分类： 成员内部类 局部内部类（包含匿名内部类） 成员内部类：修饰符 class 外部类名称 { 修饰符 class 内部类名称 {...} ... } 内用外，随意访问。外用内，需要内部类对象。 在main方法中使用：1、间接方式： 在外部类的方法中调用内部类，然后main通过访问外部类的方法调用内部类。 2、直接方式： 外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称(); 当局部变量、内部类的成员变量、外部类的成员变量重名时： 内部类的成员方法调用内部类的成员变量用this.内部成员变量。 内部类的成员方法调用外部类的成员变量用Outer.this.外部成员变量。 局部内部类：如果一个类定义在方法内部，就是局部内部类。---只有当前所属的方法才能使用它，出了这个方法就不能使用了。 格式：修饰符 class 外部类名称 {... 修饰符 返回值类型 外部类方法名称(参数列表) { class 内部局部类名称 {...} ... } ...} 注意：若局部内部类要访问所在方法的局部变量，则该局部变量必须是【有效final的】（即可以不写final关键字，但是不能变） 因为局部内部类在堆中，生命周期长，而局部变量在栈中，生命周期短，所以不能变。 【匿名内部类】：【用的最多】 如果接口的实现类（或者父类的子类）只需使用唯一的一次，则可以省略该类的定义，而改为使用匿名内部类。 格式：接口名称 对象名 = new 接口名称() { 重写所有抽象方法 }; 注意：1、匿名内部类只能唯一【创建一次对象】。若想多次创建对象，就要单独定义实现类。 2、匿名对象只能唯一【调用一次方法】。若想多次调用方法，就要给对象起个名字。 3、匿名内部类是省略了实现类/子类名称。而匿名对象是省略了对象名称。他俩不是一回事。 new 接口名() { 重写所有抽象方法 }.方法(参数); 即匿名内部类又匿名对象的使用方法。 异常: throw : 用于抛出异常， 例如: throw new NullPointerException("异常产生的原因") 若抛出运行时异常，可不理会，默认由JVM处理 若抛出编译器异常，则必须处理。throws或try-catch throws: 声明异常。 (用于甩锅) 格式: 修饰符 返回值类型 方法名(参数列表) throws AAAException, BBBException... {throw new AAAException("原因")...} 注意: 1、throws必须写在方法声明处 2、throws后面必须是Exception或者是其子类 3、throws后面必须声明方法内部抛出的所有异常 4、若调用了一个声明抛出异常的方法，则必须处理这些异常。可以继续抛出，也可以自己处理。 try-catch: 自己处理异常 try可以抛出多个异常，这时需要使用多个catch来捕获异常。 try中若产生异常，则try代码块中产生异常之后的代码不会执行，而跳转到catch。 try中若没有产生异常，则执行完try中的代码继续执行try-catch之后的代码。 finally: 不论是否发生异常，finally代码块中的代码一定会执行。 格式 : try{} catch{} finally{} 注意 : finally必须与try一起使用，一般用于资源释放。 正是由于其有一定会执行到，所以若finally代码块中有return语句，则一定会返回finally中的结果。（要避免） 注意 : 子类异常一定要与父类异常一致。 Thread : Thread类是描述线程的类，要实现多线程，必须继承Thread类 每个线程拥有一个自己独立的栈，但是共享进程的堆空间。 Thread.sleep(毫秒) // 静态方法 睡眠 Thread thread = Thread.currentThread(); // 获取当前线程 第一种方法： 创建Thread类的子类 1、创建Thread类的子类，并重写run方法，其中设置线程的任务 2、创建子类对象，并执行start方法 (执行start方法会创建一个新的栈空间，并在该栈空间中执行run方法)(每执行一次步骤2，就开启一个新的线程) 第二种方法： 实现Runnable接口 (推荐使用这种) ---> 使用该方法时，Thread 类是咱们自定义类的静态代理类 1、创建一个Runnable接口的实现类，并重写run方法，其中设置线程的任务 2、创建对象，并将其作为参数传递给Thread类的构造方法，再调用start方法。 new Thread(new MyRunnable()).start(); 匿名内部类实现： new Thread(new Runnable(){重写run方法}).start(); 第三种方法： 实现Callable<V>接口 （面试可能会问到） Callable接口类似于Runnable，【Runnable不会返回结果，也不会抛出检查异常，Callable可以】 1、创建一个Callable<V>接口的实现类，并重写call方法，其中设置线程的任务 2、在使用的地方创建该类对象 obj 。 3、ExecutorService executorService = Executors.newFixedThreadPool(5); // 创建执行服务 4、Future<V> future = executorService.submit(obj); // 提交执行 5、V result = future.get(); // 获取结果 6、executorService.shutdownNow(); // 关闭服务 同步： 多个对象访问同一个资源，可以并发读取，但当其中某一个对象要修改时，就必须实现同步 所有的对象都拥有一把锁。 锁对象选取总结为一句话就是 在同步代码中要改变谁就锁谁。 方法一： 同步代码块： synchronized (锁对象) {访问共享数据的代码} 线程不仅要抢夺CUP，还要占用锁对象。同时拥有才能执行代码 锁对象可以是任意对象，但必须是同一个对象，推荐将共享资源作为锁对象。线程占用锁对象后直到执行完毕才释放。 方法二： 同步方法 修饰符 synchronized 返回值类型 方法名 (参数列表) {访问共享数据的代码} // 该方法即为同步方法 首先将 访问共享数据的代码块 抽取出来，作为上述方法。 同步方法的锁对象默认为 this ，即同步方法所在类的对象；创建该类的对象后，该对象调用同步方法时就会锁住对象自己。 当同步方法同时也是静态方法时，锁对象为同步方法所在类的 Class 对象。 方法三： Lock锁 Lock是一个接口，有两个方法 void lock() 获取锁 和 void unlock() 释放锁 它有一个实现类ReentrantLock（可重入锁）， 先实例化一个ReentrantLock对象。 在出现安全问题代码之前用该对象调用 lock() 方法。在出现安全问题代码之后用该对象调用 unlock() 方法。 lock() 和 unlock() 方法建议放在 try --- finally 代码块中 线程状态： 线程停止：不推荐使用 Thread 类提供的 stop() 等方法。推荐自己通过一个标志位控制停止 public class MyRunnable implements Runnable { private boolean flag = true; @Override public void run() { while (flag) { TODO... } } public void stop() { flag = false; } } 通过调用自己实现的 stop 方法来停止线程 下方所有方法都是 Thread 类中的方法！ 线程休眠：Thread.sleep(毫秒) // sleep 不会释放锁、 wait 会释放锁。 线程礼让： Thread.yield(); 使当前线程从运行状态变为就绪状态，让 cpu 从所有就绪的线程中挑一个运行。 礼让有可能不成功，因为 cpu 可能再挑选一次还是让当前线程继续执行。 线程强制执行： join() ，相当于插队，停止现在执行的线程，立刻执行自己的线程，且本线程执行结束才能执行其他线程 public class MyRunnable implements Runnable { @Override public void run() { for (int i = 0; i < 1000; i++) { System.out.println("Runnable " + i); } } public static void main(String[] args) throws InterruptedException { MyRunnable myRunnable = new MyRunnable(); Thread thread = new Thread(myRunnable); thread.start(); for (int i = 0; i < 500; i++) { if (i == 200) { thread.join(); } System.out.println("主线程" + i); } } } 在上方举例代码中，主线程执行到200之前，主线程和Runnable线程交替执行，当主线程执行到200次时， Runnable 线程插队接着执行，之后Runnable线程全部执行完毕后才由主线程继续执行。 查看线程状态：Thread.State state = thread.getState(); // Thread.State 是一个枚举类型 线程优先级：1 最小；10 最大；默认为5。优先级越高在就绪状态很大可能越早执行，但也不是一定。 守护（daemon）线程： 线程分为用户线程和守护线程。 虚拟机必须保证用户线程执行完毕，但不用等待守护线程执行完毕。 守护线程有：后台记录日志、监控内存、垃圾回收等 private boolean daemon = false; // 默认 daemon 属性是关闭的，即默认为用户线程 thread.setDaemon(true); // 可通过这样将线程设置为 守护线程。 // 将线程设置为守护线程之后，虚拟机将不再保证该线程是否执行结束， // 即只要当用户线程执行结束后就将整个程序关闭，而不考虑守护线程此时是否已经执行完毕。 线程池 : 底层原理 ： 线程池就是一个容纳多个线程的容器，可由集合实现 使用步骤: 1、使用线程池工厂类Executors里面的静态方法newFixedThreadPool生产一个指定线程数量的线程池，由ExecutorService接口接收。 2、创建Runnable接口的实现类，重写run方法，设置线程任务。 3、调用ExecutorService中的execute方法，传递线程任务，开启线程，执行run方法。 例: ExecutorService executorService = Executors.newFixedThreadPool(5); // 创建服务 Runnable runnable = new Runnable() { //此处虽然new 的是Runnable接口，但是立即重写了run方法，故相当于其实现类。 @Override public void run() { //线程任务 } }; executorService.execute(runnable); // 执行服务 executorService.shutdownNow(); // 关闭服务 ExecutorService 中的 submit()方法和 execute()方法作用相同，只是适用于不同场景 void execute(Runnable command) // 执行任务，没有返回值，一般用于执行 Runnable <T> Future<T> submit(Callable<T> task); // 执行任务，有返回值，一般用于执行 Callable Lambda表达式 : 可推导，可省略 格式： () -> {} 使用前提： 必须是接口，且接口中有且只有一个抽象方法 (有且只有一个抽象方法的接口，称为"函数式接口") 可以省略的内容： 1、(参数列表) 参数列表中的数据类型可以省略， 如果参数只有一个，则括号()也可以省略 2、{方法体} 如果{}中的代码只有一行，无论是否有返回值，都可以省略 {}， return， 分号 （要省一起省） 注解: @override 检测是否为覆盖重写 @FunctionalInterface 检测是否为函数式接口 ------------------------------------------------------------------------------------------------------------------ API使用： Scanner： 功能：从键盘输入数据到程序。 包路径：java.util.Scanner 实例化：Scanner sc = new Scanner(System.in); System.in 表示从键盘输入数据。 方法：---其实键盘输入的一切东西都是字符串，使用不同的函数会将字符串转换为相应的类型。-->故若记不住也可以一直使用sc.next();之后再转换类型 获取键盘输入的一个int数字： int num = sc.nextInt(); 获取键盘输入的一个字符串： String str = sc.next(); 读取文件内容：Scanner in = new Scanner(Paths.get("\u202AC:\\Users\\Lenovo\\Desktop\\1.txt"), StandardCharsets.UTF_8); 之后再用in的各种方法。nextLine(); next(); nextInt(); 等 Random: 功能: 获取随机数。 实例化：Random rand = new Random(); 方法：int rand_num = rand.nextInt(n) 在[0, n)中随机取一个数字。----> m + rand.nextInt(n)取到[m, m + n）中的随机数。 ArrayList: [元素1， 元素2， 元素3， ...] 功能：可变长的数组。 泛型：装在集合中的元素必须是同一个类型，只能是引用类型，不能是基本类型。 实例化：ArrayList<String> list = new ArrayList<>(); 注意事项：直接打印list输出的不是一个地址值，而是空的中括号。 不支持下标索引，只能用get()方法获取。 常用方法：list.add("李沁") 添加元素，返回一个boolean值，表示添加的动作是否成功。一定成功，可以不接受返回值。 list.get(index) 根据索引获取元素，返回获取的元素。 list.remove(index) 根据索引删除元素，返回被删除的元素。 list.size() 获取集合长度。 若想在ArrayList中存储基本类型，需要使用其包装类(引用类型)： 基本类型 包装类 byte Byte short Short ... ... （与上方一样，只需首字母大写） int Integer 【特殊】 char Character 【特殊】 ArrayList<Integer> list_int = ArrayList<>(); // 自动装箱：int --> Integer 自动拆箱：integer --> int String: 功能：字符串（常量） --> Java中所有的双引号字符串都是String类的实例。 实例化：直接创建： String str1 = "李沁"; 在字符串常量池中， 其他实例化方式都在堆中，不在池里。 使用空构造函数： String str2 = new String(); 根据字符数组创建： char[] charArray = { &#39;a&#39;, &#39;b&#39;, &#39;c&#39; }; String str3 = new String(charArray) // abc 根据字节数组创建： byte[] byteArray = { 97, 98, 99 }; String str3 = new String(byteArray) // abc 方法：str1.equals(str2) 比较str1和str2的值是否相等，返回boolean。 常变量比较时推荐 常量.equals(变量) str1.equalsIgnoreCase(str2) 忽略大小写。 str.length() 长度 str.concat(str1) 拼接 str.charAt(index) 根据索引返回字符 str.indexOf(str1) 在str中查找str1，返回首次找到的索引值；若没有，返回-1 str.substring(index) 截取，从index到末尾 str.substring(int begin, int end) 截取，[begin, end) str.toCharArray() 转换为字符数组 str.getBytes() 转换为字节数组 用于遍历字符串 str.replace(old, new) 用new替换str中的old str.split(regex) 切割，返回数组 Arrays: 功能：与数组相关的类，提供大量静态方法，用来实现数组常见的操作。 方法： Arrays.toString(数组) 将参数变成字符串 [元素1， 元素2，元素3，...] Arrays.deepToString(多维数组) 将参数变成字符串 [元素1， 元素2，元素3，...] Arrays.sort(数组) 排序。默认从小到大，自定义类型的排序需要Comparable或Comparator接口 Arrays.equals(数组1， 数组2) 两个数组完全相等是返回ture Math: 功能：数学相关的类，提供大量静态方法，用来实现数学运算相关的操作。 方法： Math.abs() 绝对值 Math.ceil() 向上取整 Math.floor() 向下取整 Math.round() 四舍五入 Collection接口: 所有单列集合的顶层接口 List接口: 1、有序（存入和取出的顺序一致） 2、允许元素重复 3、有索引 Vector:(了解) Arraylist:(重点) 底层由数组实现，查询快，增删慢。 LinkedList:(次之) 底层由链表实现，查询慢，增删快。 特有方法: addFirst() == push() addLast() == add() getFirst() getLast() removeFirst() == pop() removeLast() 这两种方法都会删除并返回 共有方法： void add(int index, E element) 将元素添加到索引位置 E get(int index) 返回索引处的元素 E remove(int index) 删除索引位置元素,并返回被删除的元素 E set(int index, E element) 替换索引位置元素,并返回被替换前的元素 Set接口: 1、不允许元素重复 2、没有索引 TreeSet: (无序) (了解) 底层由二叉树实现，一般用于排序。 HashSet: (无序) (重点) 底层由哈希表实现。(查询速度很快) 注意: 使用HashCode存储自定义类型时，需要重写HashCode()和equals()。可通过alt + insert直接添加。才能保证元素不重复。 LinkedHashSet: (有序) (次之) 底层由哈希表+链表实现。 extends HashSet 比HashSet多了一条链表，用来记录元素的顺序 共有方法： boolean add(E e) 添加， 无需接收 boolean remove(E e) 删除， 若有e，删除并返回true。若没有e，无动作并返回false void clear() 清空。 但不删除集合。 boolean contains(E e) 是否包含。 boolean isEmpty() 是否为空。 int size() 元素个数。 Object[] toArray() 转为数组。 哈希值: 是一个十进制的整数，由操作系统随机给出的对象的逻辑地址值。 哈希表: 拉链法。由哈希值为元素组成数组（初始长度为16）。若哈希值相等，则以链表方式挂在该哈希值后面。当链表长度超过8时，变为红黑树。检索速度加快。 Collections : 是Collection的工具类，提供大量静态方法，用于操作集合。 以ArrayList为例: ArrayList<String> list = new ArrayList<>(); addAll(Collection<T> c, T... elements) : 往集合中添加多个元素。 Collections.addAll(list, "a", "b", "c"); shuffle(List<T> list) : 打乱顺序。 Collections.shuffle(list); sort(List<T> list) : 排序， 默认升序。 Collections.sort(list); 注意：若要对自定义类型排序，则被排序的类必须实现Comparable接口，重写compareTo方法来定义排序规则。 this - 参数 ： 升序 (了解)另一种sort()： Collections.sort(arr, new Comparator<Integer>() { @Override public int compare(Integer o1, Integer o2) { return o1 - o2; } }); 这种方法List接口中的方法类似-> arr.sort(new Comparator<Integer>() {...}) Iterator: 迭代器 是接口 也有泛型 --> Collection<String> array = new ArrayList<>(); Iterator<String> it = array.iterator(); 常用方法: boolean hasNext() 是否有下一个元素。 E next() 返回下一个元素。 使用： Collection中的实现类为 iterator() 1、实例化iterator 2、用hasNext() 3、用next() 增强for循环: 专门用来遍历数组与集合，由Iterator迭代器实现，遍历时不能做增删操作。 for (元素数据类型 变量 : 集合或数组名) { ... } Map: --> 字典 键值对 key是唯一的 HashMap: (无序) 底层为哈希表 LinkedHashMap : (有序) 底层为哈希表+链表(保证顺序) 方法: V put(K key, V value) : 添加，若key值不存在，则添加并返回null。若key值已存在，则更新value值，并返回被替换掉的value值。一般不接收返回值。 V remove(K key) : 删除，若key值存在，返回被删除的value。若key不存在，则返回null。 V get(K key) : 获取，若key值存在，返回对应的value。若key不存在，则返回null。 boolean containsKey(k key) : 判断是否包含指定的键。 Set<K> keySet() 返回由键组成的Set，之后可以通过遍历Set来遍历Map。 for (K key : map.keySet()) { sout(key + map.get(key)) } Set<Map.Entry<K, V>> entrySet() --> for (Map.Entry<K, V> entry : map.entrySet()) { 也是遍历，看起来不好用的样子 System.out.println(entry.getKey() + &#39; &#39; + entry.getValue());} 用Map存储自定义类型时，若自定义类型作为键，则必须将该类重写HashCode和equals方法，保证键是唯一的。 of方法： static <E> List<E> of (E... elements) 1、of方法只适用于List, Set, Map 接口。而不适用于他们的实现类 2、of方法返回一个不能被操作的集合。因此适合初始化，且初始化后不能改变。 3、Set 和 Map 调用of方法时不能有重复元素。 ------------------------------------------------------------------------------------------------------------------ ------------------------------------------------------------------------------------------------------------------ ------------------------------------------------------------------------------------------------------------------ ------------------------------------------------------------------------------------------------------------------ Object： 以下方法所有类都有，只是重写之后功能有所不同。 toString() 直接打印对象的名字，就是调用对象的toString方法->得到对象的地址值。 没有意义。 重写：可以和构造方法与Getter/Setter方法一样的步骤添加（重写）toString方法->打印出属性值。 equals() boolean equals(Object obj) 判断两个对象是否"相等"，返回布尔值。 比较两个对象的地址值，同上方的==作用一样。 没有意义。 重写： 原理 --> 由于equals方法的参数类型为Object,所以默认向上转型了。若想比较两个对象的属性值，需要先向下转型。 同样可以 alt + insert 直接生成equals方法。 判断两对象的属性值是否都一样。 hashCode() 返回对象的哈希码值 // synchronized 能实现线程同步、但无法实现线程间通信、用如下 4 个方法可以实现线程间通信。 wait() 等待。在被唤醒之前，放弃CPU的使用权 wait(毫秒值) 在被唤醒或到时间之前，放弃CPU的使用权 notify() 唤醒。随机唤醒锁对象中的一个进程 notifyAll() 唤醒锁对象(对象监视器)中的所有进程 这两种常搭配同步机制使用 objects: 该工具类提供的方法是容忍空指针的。 若 a=null，则a.equals(b) 报错。而Objects.equals(a, b) 正常运行。 Objects.requireNonNull(T obj) 查看obj是否为空，用来判断参数的合法性。 旧API : Date: 1970年1月1日 00:00:00 作为0时刻 Date() 无参构造--> 获取当前时间。 Date(long date) 有参构造 --> 输入毫秒值，输出相对于0时刻的日期。 getTime() 把日期转换为毫秒 DateFormat: 格式化日期。 抽象类。 String format(Date date) 把日期格式化为字符串。 Date parse(String source) 把符合的字符串解析为日期。 SimpleDateFormat: DateFormat的实现类 SimpleDateFormat(String pattern) 有参构造 参数一般为 "yyyy-MM-dd HH:mm:ss" 使用上方两个方法。 注意：用parse时，参数的模式必须与构造SimpleDateFormat对象时的模式完全一样，否则报错。 Calendar: 日历类 抽象类 getInstance() 静态方法 返回Calendar类的子类对象 Calendar instance = Calendar.getInstance(); 功能：使用默认时区和语言环境获得一个日历 get(field) 返回给定字段的值。 字段值有YEAR MONTH DATE HOUR MINTER SECOND 年月日时分秒 都是静态变量 set(field, value) 将给定的日历字段设置为给定值 add(field, amount) 修改指定的字段，通过amount的正负实现加减。 Date getTime() 将Calendar转为Date对象 原理：实际上该类中有一个fields数组，上述的方法都是在对该数组操作。字段值YEAR等固定为0，1，2等，作用是对该数组的索引。 新API LocalDate, LocalTime, LocalDateTime : 之前的Date类和Calendar类都有缺陷。JDK8 新引入日期时间类 由于LocalDateTime类使用较多，故以他为例，其余两种用法相同。 构造方法： 1、LocalDateTime now = LocalDateTime.now(); 获取当前时间 2、LocalDateTime localDateTime = LocalDateTime.of(2020, 1, 20, 12, 20, 34); 获取指定时间 常用方法： now.getDayOfMonth() 获取对象是这个月的第几天。类似的方法获取其他属性。 LocalDateTime time = now.withDayOfMonth(12); 使用类似方法设置属性。但是该语句执行后，time为修改后的值，而now的值不变。体现了时间的不可变性。 LocalDateTime plusDays = now.plusDays(3); 使用类似方法修改属性，在原有基础上加3天。不可变性同上。 LocalDateTime months = now.minusMonths(2); 使用类似方法修改属性，在原有基础上减2月。不可变性同上。 Instant 替换 Date 类 DateTimeFormatter : 类似于SimpleDateFormat 日期时间的格式化与解析 DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"); 构造 String format = formatter.format(LocalDateTime.now()); 格式化 TemporalAccessor parse = formatter.parse("2021-01-21 22:00:25"); 解析 System: 提供大量静态方法， 可以获取与系统相关的信息即服务 static currentTimeMillis() 返回以毫秒为单位的当前时间, 用来测试程序的效率。 static arraycopy(原数组， int 原数组起始位置， 目标数组， int 目标数组起始位置， int 要复制的数组元素的数量) 复制数组 StringBuilder: 在String类中，字符串是常量，底层是被final修饰的数组。字符串相加时，占用内存多，效率低下。 StringBuilder类是字符串缓冲区，可以提高字符串的操作效率（看成是一个长度可以变化的字符串） 底层也是一个数组，但是没有被final修饰，可以改变长度。 在内存中始终是一个数组，初始容量为16个字节，超出会自动扩容，占用空间少，效率高。 构造函数： StringBuilder() 无参构造，空字符串。 StringBuilder("abc") 有参构造，即参数的字符串。 成员函数： append(任意类型) 添加到字符串，并返回自身。所以无需接收。 toString() 将StringBuilder对象，转换为String对象。 通过StringBuilder的构造方法可以将String转换为StringBuilder. reverser() 翻转 File: 文件类，主要用于文件和目录的创建，查找和删除等操作 File类已被Path取代 静态方法: static String	pathSeparator 路径分隔符 windows ; 分号 linux : 冒号 static String	separator 文件名称分隔符 Windows \ 反斜杠 Linux / 正斜杠 构造方法: File(String pathname) 路径名 ==> 文件/文件夹 相对/绝对 存在/不存在 File(String parent, String child) 父路径，子路径 File(File parent, String child) 父路径，子路径。父路径是File型，故可以使用其方法做调整 常用方法: 获取方法: String getAbsolutePath() 返回绝对路径名 String getPath() 返回路径名 String getName() 返回末尾文件/文件夹 名字 long length() 返回文件大小（以字节为单位） 不能是文件夹，若路径不存在，返回0 判断方法: boolean exists() 文件或文件夹是否真实存在 boolean isDirectory() 路径是否以文件夹结尾 前提：真实存在 boolean isFile() 路径是否以文件结尾 前提：真实存在 创建删除: boolean creatNewFile() 不存在时创建文件 不能创建文件夹，路径必须存在 boolean delete() 删除文件/文件夹 boolean mkdir() 创建单级空文件夹 boolean mkdirs() 创建单级/多级空文件夹 多级文件夹：父文件夹中包含子文件夹 遍历文件夹: String[] list() 返回由所有文件或子目录组成的字符串数组 File[] listFiles() 返回由所有文件或子目录封装而成的文件数组 过滤器: File[] files = dir.listFiles(new FileFilter(){重写accept()方法，该方法中写入过滤规则，留下的返回ture，不要的返回false}) 可以写为Lambda表达式。 读取文件的方法： Scanner in = new Scanner(Paths.get("C:\\Users\\Lenovo\\Desktop\\1.txt"), StandardCharsets.UTF_8); String num = in.nextLine(); BufferedReader reader = Files.newBufferedReader(Paths.get("C:\\Users\\Lenovo\\Desktop\\1.txt"), StandardCharsets.UTF_8); String str = reader.readLine(); （不好用）BufferedReader bufferedReader = new BufferedReader(new FileReader("C:\\Users\\Lenovo\\Desktop\\1.txt")); String s = bufferedReader.readLine(); Properties: 用来加载配置文件, 示例如下： Properties properties = new Properties(); // ClassLoader classLoader = Person.class.getClassLoader(); 注释掉的两句作用与下一句一样 // InputStream is = classLoader.getResourceAsStream("jdbc.properties"); // 路径相对于src FileInputStream fis = new FileInputStream("src\\jdbc.properties"); // 路径相对于Module而不是src properties.load(fis); String user = properties.getProperty("user"); String passwd = properties.getProperty("passwd"); System.out.println(user + " " + passwd); IO流: （默认相对路径在Module下） 基本流: OutputStream: 字节输出流 (一切都以字节为单位) (一次读写一个字节) 接口 共有方法: write(byte[] bytes) 写入多个字节 close() FileOutputStream: 文件字节输出流 构造方法: FileOutputStream(String name[, boolean append = false]) 参数为路径，即写入的目标文件路径，如果没有该文件，会先创建该文件。若append为ture，则为追加写，否则会覆盖原文件 FileOutputStream(File file[, boolean append = false]) 参数为文件，即写入的目标文件，append同上。 InputStream: 字节输入流 接口 共有方法: read() 读取一个字节,返回读到的内容，读到文件末尾返回-1 int read(byte[] bytes) 读取多个字节，将读取到的内容存入字节数组中，并返回读取的有效字节个数，读到文件末尾返回-1 close() FileInputStream: 文件字节输入流 构造方法: FileInputStream(String name) FileInputStream(File file) Reader: 字符输入流 抽象 共有方法: read() read(char[] c) close() 作用和上述相同,包括返回-1等等都相同，只是读取单位变为字符。 FileReader: 文件字符输入流 ---> 只能读取IDEA默认编码格式文件(即UTF-8) 构造方法: FileReader(String filename) FileReader(File file) Writer: 字符输出流 抽象 共有方法: write() 参数可以为单个字符，字符数组或字符串 close() FileWriter: 文件字符输出流 构造方法: FileWriter(String filename[, boolean append = false]) FileWriter(File file[, boolean append = false]) 注意: 这里的write方法是将数据写入内存缓冲区(字符转为字节)，flash方法或close方法会数据刷新到文件。因此必须调用close()方法。 Properties集合: 实现了Map<K, V> 唯一和IO流结合的集合 该集合的默认键和值都是字符串类型。store方法能把集合中的数据存入硬盘，load方法会加载到该集合中。 缓冲流: 创建一个缓冲区，减少系统IO次数，提高读写效率。 BufferedInputStream: 字节缓冲输入流 extends InputStream 用read写入，close关闭。只需要关闭缓冲流，基本流会随之关闭。 构造方法: BufferedInputStream(InputStream in[, int size]) read和write方法与基本流完全相同。 BufferedOutputStream: 字节缓冲输出流 extends OutputStream 用write写入，close关闭 构造方法: BufferedOutputStream(OutputStream out[, int size]) 参数可以传递FileOutputStream对象，可选参数size用于指定缓冲区大小 BufferedWriter: 字符缓冲输出流 extends Writer 构造方法: BufferedWriter(Writer out[, int size]) 可传入FileWriter 特有方法: void newLine() 无视系统差异，换行 BufferedReader: 字符缓冲输入流 extends Reader 构造方法: BufferedReader(Reader in[, int size]) 可传入FileReader 特有方法: String readLine() 读取一行数据，但不读取行末换行符。读到文件末尾返回null 转换流: 可以指定编码/解码的码表 OutputStreamWriter extends Writer: 步骤: 1、new对象 2、write() 3、close() 构造方法: OutputStreamWriter(OutputStream out[, String charsetName]) 参数一般传递为FileOutputStream。可选字段为编码表名称，不区分大小写，默认为UTF-8 InputStreamReader extends Reader: 步骤: 1、new对象 2、read() 3、close() 构造方法: OutputStreamWriter(InputStream in[, String charsetName]) (反)序列化流: 把对象以流的方式写入/读出到文件中 使用字节流 ObjectOutputStream: extends OutputStream 对象的序列化流 把对象以流的方式写入到文件中保存，叫写对象，也叫对象的序列化。 构造方法: ObjectOutputStream(OutputStream out) 参数一般传递为FileOutputStream。 特有方法: void writeObject(Object obj) 此处参数也可以是由obj组成的集合，如ArrayList<Person> list 被序列化的对象(即参数obj)必须实现Serializable接口，以激活(反)序列化功能。其为标记型接口，内部没有任何抽象方法。 ObjectInputStream: extends InputStream 对象的反序列化流 把文件中保存的对象以流的方式读出来，叫读对象，也叫对象的反序列化。 构造方法: ObjectInputStream(InputStream in) 参数一般传递为FileInputStream。 特有方法: Object readObject() transient关键字: 瞬态关键字，被其修饰的成员变量不能被序列化，没有替他功能。static关键字也有这个功能。 注意：为了避免InvalidClassException,在每个被序列化的对象中都显示声明一个序列号-> private static final long serialVersionUID = 42L 打印流: PrintStream System.out.println(); enum : 枚举类 类的对象只有确定的有限个，我们称之为枚举类 当需要定义一组常量时，强烈建议使用枚举类 默认继承java.lang.Enum 定义： 类似于接口的定义，创建Class包时，选项中就有Enum的选项。 public enum Season { SPRING("春天", "warm"), 默认由public static final 修饰 SUMMER("夏天", "sun"), 实例写在类的最前面 AUTUMN("秋天", "cool"), 实例之间用逗号分隔，最后一个结尾为分号 WINTER("冬天", "cold"); 为什么不需要显示声明成员变量(由局部变量代替)，暂时不清楚 Season(String seasonName, String seasonDec){} } 构造函数默认由private修饰，可省略不写。 静态方法： values() 返回枚举类型的对象数组，方便用于遍历枚举值 valueOf(String objName) 返回枚举类中对象名为objName的对象 如: Season winter = Season.valueOf("WINTER"); toString() 返回当前枚举类对象常量的名字 反射: java.lang.Class 程序由javac.exe编译后，会生成一个或多个字节码文件(.class结尾)。 接着使用java.exe对某个字节码文件解释运行，就相当于将某个字节码文件加载到内存中，这个过程就叫类的加载， 加载到内存中的类就叫运行时类，这个运行时类就是Class的一个实例。 加载到内存中的运行时类会缓存一段时间，在此时间内以不同方式获取到的该运行时类的Class实例都是同一个。 获取Class实例的方法： 1、 Class clazz = Person.class; 2、 Person person = new Person(); Class clazz = person.getClass(); 3、 Class clazz = Class.forName(类相对于src的全路径); // 用的较多 ClassLoader：引导类加载器--》加载java核心类库 引导类加载器无法获取到 扩展类加载器--》加载jar包 通过Class实例.getClassLoader()即可获得类加载器，如 系统类加载器--》加载自定义类 Person.class.getClassLoader()获取的即为系统类加载器 无法创建实例的类型用 Class c = int.class; double.class; Math.class; 等 ArrayList<Integer> list = new ArrayList<>(); Class l1 = list.getClass(); 得到ArrayList<Integer>类的Class实例 l1.getDeclaredConstructors(); 获取所有构造函数，去掉Declared为只获取public的构造函数 l1.getDeclaredMethods(); 获取所有函数，去掉Declared为只获取public的函数 l1.getDeclaredFields(); 获取所有属性，去掉Declared为只获取public的属性 l1.getSuperclass(); 获取父类 l1.getGenericSuperclass(); 获取带泛型的父类 li.getInterfaces(); 获取接口 li.getPackage(); 获取包 li.getAnnotations(); 获取注解 for (Method method: l1.getDeclaredMethods()) { System.out.println(Modifier.toString(method.getModifiers()) + " " + method.getReturnType() + " " + method.getName() + "(" + Arrays.toString(method.getParameterTypes()) + ");"); } Field f = l1.getDeclaredField("size"); 根据属性名称获取特定的Field对象。 f.setAccessible(true); 使其变为可访问的 Object v = f.get(list); Person person = new Person("alice", 21); 方法对象调用invoke方法来执行方法。 Class p = person.getClass(); public Object invoke(Object obj, Object... args) Method m = p.getMethod("getName"); 第一个参数为对象名，之后的参数为方法的参数。 String s = (String) m.invoke(person); 调用的是静态方法时，第一个参数为null。 代理的作用就是在不修改源码的情况下，对目标对象的方法增强。 静态代理：接口 + 代理类 + 被代理类 --》 一个代理类只能对应一个被代理类 代理类与被代理类实现同样的接口 动态代理：接口 + 代理类 + 多个被代理类 --》 一个代理类可以对应多个被代理类 代理类与被代理类实现同样的接口 结合src/proxy/annotationProxy包下的例子理解 1、根据自己需求创建一个被代理类对象（想象在项目中，要增强功能时，一定在之前已经使用过这个对象） 2、根据这个被代理类对象，动态获取一个代理类对象（因此，没有显示的代理类，是被动态获取到的） 3、使用代理类对象调用被代理类的方法。（具体原理看包中例子的注释） '><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-20T17:39:41+00:00"><meta property="article:modified_time" content="2021-05-20T17:39:41+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java学习笔记"><meta name=twitter:description content='数组：
    数组的初始化方式：
        1、动态初始化（指定长度）  数据类型[] 数组名 = new 数据类型[数组长度]；
        2、静态初始化（指定内容）  数据类型[] 数组名 = new 数据类型[] {元素1， 元素2， 元素3， ... }； 元素值可以是变量
             省略的静态初始化   数据类型[] 数组名 = {元素1， 元素2， 元素3， ... }；  该方式不允许拆分为2步，即先定义数组名，再经行赋值。
    直接打印数组名，打印的是数组的内存地址。
    支持下标索引。
    未初始化的默认初始值：
        整数类型： 0
        浮点类型： 0.0
        字符类型： &#39;\u0000&#39;
        布尔类型： false
        引用类型： null
    获取数组长度： 数组名.length;
    获取数组副本： 数组名.clone();

成员变量与局部变量：
    成员变量定义在类内，方法外。局部变量定义在方法内。
    成员变量不要写static关键字。???
    成员变量有默认值，而局部变量没有默认值。
    当成员变量与局部变量的命名冲突时，按照就近原则，优先使用局部变量。若想使用全局变量，使用this.成员变量名。

可变参数:
    使用前提：当方法的参数类型确定，但是参数个数不确定时，使用可变参数。
    使用格式：修饰符 返回值类型 方法名(数据类型...变量名) {}   例如:   public void func (int... num) {}
    原理：   可变参数底层是一个数组，根据传递参数个数的不同，会创建不同长度的数组，来存储这些参数。参数个数可以是0个或多个。
            因此，方法中的变量名其实就是数组的名字，可以作为数组使用。
    注意：   一个方法的参数列表中只能有一个可变参数。
            如果方法有多个参数，则可变参数必须放在参数末尾。

类的使用:
    1、导包：import 包路径.类名称   当类与当前文件处于同一个包中时，可以不用导包。只有java.lang下的包不需要导包，其他都需要导包。
                                            但实际使用中，可以不用手动导包，当你使用某个类时，系统会自动帮你导包。
    2、实例化： 类名称 对象名 = new 类名称();
    3、使用: 对象名.成员变量名        对象名.成员方法名(参数)

Private:
    Getter: 函数格式必须是 getXXX   如果变量是布尔类型，则使用isXXX
    Setter: 函数格式必须是 setXXX
    Private修饰构造函数时，外部不能再构造该类的实例，故只能在类内构造好全部实例并赋给static类型的变量。叫构造函数私有化

this: this是当前对象的引用，即this和对象是同一个东西。
    this.成员变量    调用本类成员变量    可以将类内的成员变量与方法中的同名局部变量区分。
    this.成员方法    调用本类成员方法
    this(...)      调用本类构造函数 --> 写在第一行，只能调用一个。  若子类使用了this(...)，则不再默认赠送super()。
super:
    super.成员变量   调用父类成员变量     可以将父类中的成员变量和子类中的同名成员变量区分。
    super.成员方法   调用父类成员变量
    super(...)     调用父类类构造函数 --> 写在第一行，只能调用一个。

构造函数：
    格式： public 类名（参数类型 参数名称 ， ...）{...}
    注意事项： 构造方法的名称和类名要严格相等，大小写敏感。
             构造方法没有返回值类型。
             若不明确定义构造函数，则会自动生成默认构造函数，若手动定义了任意形式的构造函数，编译器将不会再生成默认构造函数。
             构造函数支持重载
    继承中的构造函数:  构造链：同C++一样--> 祖宗 > 父类 > 子类        子类构造方法中若不显式调用super，则默认隐含一个 "super()" 调用。
                    子类构造函数可以显式地写 super([参数1，...]) 来调用父类的重载构造函数。且必须在方法体的第一行，即只能调用一个。

标准类：也叫做 Java Bean
    通常包含以下4部分内容：
        所有的成员变量都要使用private关键字。
        为每一个成员变量编写一对儿Getter/Setter方法
        编写一个无参构造函数
        编写一个全参构造函数
    点击 Code->Generate 或者 快捷键 alt + insert 可以自动生成上述内容

==：
    对于基本类型， == 比较的是值
    对于引用类型， == 比较的是地址

基本类型与字符串之间的转换：
    基本类型 --> 字符串
        1、基本数据类型的值+""  最简单的方式（工作中常用）
        2、使用包装类的静态方法   static String toString(int i)  将i变为字符串形式   如 Integer.toString(100);
        3、使用String类的静态方法   static String valueOf(int i)  将i变为字符串形式   如 String.valueOf(100);
    字符串 --> 基本类型
        使用包装类的静态方法 parseXX("字符串")
            Integer    static int parseInt(String s)     如 Integer.parseInt("100");
            ... ...

泛型:  泛型名字不一定是E，可以是任意大写字母。
    类: public class ClassName<E> { ... 在类内将需要的地方都用E代替}     实例化对象时确定类型
    方法: 修饰符 <E> 返回值类型 方法名(参数列表){ ... }                   调用方法时确定类型
    接口: 含有泛型的接口定义与类相同。  确定类型的方法：1、在实现类中确定类型   2、实现类依然沿用接口的泛型E，实现类创建对象时确定类型
    通配符: <?>  代表任意数据类型，
        使用: 例如当多个不同类型的ArrayList集合要作为参数调用同一个方法时，可以将参数设置为ArrayList<?> list方便接受任意类型。
        高级使用: ? extends E 表示 ? 只能是E的子类/本身
                 ? super E   表示 ? 只能是E的父类/本身

static:
    带上static的成员变量或函数，不属于对象，而是属于类，所有对象共享。
    类名.静态变量
    类名.静态方法()
    注意事项：静态不能直接访问非静态 --> 在内存中，先有静态，后有非静态
            静态不能使用this
    静态代码块：static{  ...  }  首次用到类时，静态代码块唯一执行一次。
              典型用途：一次性地对静态成员变量赋值。

override:
    在子类的覆盖重写方法前面加上 @override 可以检验该方法是否为重写方法（建议写上）
    子类方法的返回值的范围必须 小于等于 父类方法的返回值的范围。
    子类方法的权限必须 大于等于 父类方法的权限

权限：                public > protected > (default) > private     (default) 表示什么也不写，留空。
        同一个类        YES       YES          YES        YES     (我自己)
        同一个包        YES       YES          YES        NO      (我领居)
        不同包子类       YES       YES          NO         NO     (我儿子)
        不同包不同类     YES        NO          NO         NO      (陌生人)

abstract:
    抽象方法：只定义，不实现。加上abstract关键字，去掉大括号，直接分号结束。
    抽象类： 抽象方法所在的类，必须是抽象类。在class前加上abstract即可。但抽象类中不一定包含抽象方法（通常是有的）。
    使用步骤：
        抽象类不能直接创建对象。
        必须用一个子类继承抽象父类。
        子类必须覆盖重写抽象父类中的所有抽象方法。-->此处覆盖重写即实现：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。
        创建子类对象，并使用。

interface：
    概念：接口就是多个类的公共规范。是一种引用数据类型，最重要的就是其中的抽象方法。
    定义：public interface 接口名称 { ... }
    包含：常量、抽象方法、默认方法、静态方法、私有方法。
    常量：可以理解为成员变量，但是必须使用 public static final 三个关键字修饰，故相当于常量。
         public static final 数据类型 常量名称 = 值  （三个关键字可省略，但不能换为别的）
         注意：1、接口中的常量可以省略public static final，但写不写效果一样。
              2、接口中的常量必须手动赋值，不能不赋值。赋值之后无法改变。
              3、常量名称全部大写，由下划线连接。
         使用：接口名称.常量
    抽象方法：1、接口中的抽象方法，修饰符固定为 public abstract  (可省略，但不能换为别的)
            2、方法的三要素可随意定义。
    默认方法：public default 返回值类型 方法名(参数列表) {方法体} (public可省略，default不能省略)
            可以解决接口升级的问题。（不想改变实现类，但是接口中又想要添加新方法，则接口就可以用默认方法自己实现）（实现类可以覆盖重写默认方法）
            默认方法会被实现类继承，故可以通过实现类的对象访问默认方法。
    静态方法：public static 返回值类型 方法名(参数列表) {方法体}  (public可省略，static不能省略)
            使用：接口名称.静态方法(参数);  不能通过对象访问。
    私有方法：1、普通私有方法：解决多个默认方法之间的重复代码问题  private 返回值类型 方法名(参数列表) {方法体}
                只有接口中的默认方法能访问。
            2、静态私有方法：解决多个静态方法之间的重复代码问题  private static 返回值类型 方法名(参数列表) {方法体}
                只有接口中的默认方法和静态方法能访问。
    使用：1、接口不能直接使用，必须有一个“实现类”来“实现”该接口。  public class 实现类名称 implements 接口名称 {...}
         2、接口的实现类必须实现接口中的全部抽象方法。去掉abstract关键字，加上大括号实现体。
         3、创建实现类对象，使用。
    注意事项：1、接口没有静态代码块和构造方法。
            2、如果实现类没有覆盖重写所有接口中的所有方法，则该实现类自己就必须是抽象类。
            3、一个实现类可以实现多个接口  public class 类名 implements interface1, interface2 {}。
            4、若一个类实现的多个接口中有重名的抽象方法，则只需实现一个即可。
            5、若一个类实现的多个接口中有重名的默认方法，则该实现类必须对重名默认方法覆盖重写。
            6、若一个类的直接父类中的方法和它实现的接口中的默认方法重名，则优先使用直接父类的方法。 在java中【继承 优先于 接口】
            7、接口是多继承的。多个父接口当中的抽象方法如果重名，没关系。
                           多个父接口当中的默认方法如果重名，则子接口必须对重名的默认方法覆盖重写，【而且带着default关键字】


多态：（一个子类对象既有子类形态，又有父类形态）一个对象拥有多种形态，即【对象】的多态性。【多态性指的是对象，而不是类】
    代码中体现多态性： 父类引用指向子类对象。
    格式   父类名称 对象名 = new 子类名称();   或   接口名称 对象名 = new 实现类名称();
    【初步理解: 定义了一个指向子类对象的父类引用，这个引用指向的是子类的对象，但是只能访问父类大小的内存空间，所以它只能访问父类继承到子类当中的成员
              （包括成员变量和成员函数）的那部分内存空间，而不能访问子类独有的多出来的那部分内存空间，而对于被子类重写了的方法，该引用依然可以访问
              这部分内存，只是内存中的内容已经被改写了，所以访问到的是子类重写之后的方法。综上所述，该引用能访问的范围是所有从父类继承下来的变量和
              父类独有方法，以及被子类重写之后的方法。】
    多态对象访问成员变量： 对象名.成员变量  访问的是父类的成员变量，若没有则向上找，不会向下找。 不能用这种方法访问子类特有成员变量。
    多态对象访问成员函数： 若子类重写了父类的成员函数，则访问子类的成员函数。 若子类没有重写，则访问父类的成员函数，没有则向上找。 同样不能访问子类特有成员函数。
        记忆口诀；对于成员变量，等号左边是谁就优先用谁。对于成员方法，new的是谁就优先用谁。
    使用多态的好处：比如将父类的引用作为参数传入方法中，则该引用可以指向不同的子类对象使方法实现不同的功能，却不需要改变方法中的任何代码。

对象的向上转型： 在特定场合会自动向上转型，如方法参数要求为父类，但是传入一个子类对象也正确，这时就发生了自动向上转型。与int double发生自动类型转换原理一样。
    格式：与多态相同：父类名称 对象名 = new 子类名称();
    含义：创建一个子类对象，把它当作父类来看待使用。
    【向上转型一定是安全的】从小范围转向了大范围，如将小范围的猫向上转型为更大范围的动物。 类似于将short转换为int。
    弊端：不能访问子类特有方法。
对象的向下转型：其实是一个【还原】的动作。
    格式：   子类名称 对象名 = (子类名称) 父类对象;   (子类名称)必须有，不能省略。
    含义：   将向上转型之后的父类对象还原为本来的子类对象。
    注意：   只有本来是猫，向上转型为动物后，再向下转型为猫才是正确的。
            若本来不是猫，却硬要向下转型为猫就会出错(编译不会报错，但运行会出现异常ClassCastException)。
    instanceof:
        格式： 对象名 instanceof 类名
        作用： 返回一个布尔值，判断前面的对象能不能当作后面类的实例。
        应用： 在向下转型之前，判断需要转型的对象是不是目标类的对象，是则向下转型，不是则不转型。

final: 该关键字表示最终的，不可再改变的。
    用法: 修饰一个类、方法、局部变量、成员变量。
         修饰一个类： public final class 类名 {...}  不能有子类。
         修饰一个方法： 该方法不能被重写。   对于类和方法，abstract 和 final 不能同时使用，会矛盾。
         修饰一个局部变量： 一次赋值，终生不变。（可以先定义，再赋值。分两步）--对于基本类型，值不可变。对于引用类型，地址值不可变。
         修饰一个成员变量： 由于成员变量有默认值，所以不能分两步，必须当场手动赋值或通过构造函数赋值。
         修饰一个数组或集合： 该数组或集合不能再被赋值，但内部的数据还可以改变。

内部类： 一个类内部包含另一个类，即一个事物内部包含另一个事物。 例如 身体和心脏的关系
    分类： 成员内部类      局部内部类（包含匿名内部类）
    成员内部类：修饰符 class 外部类名称 { 修饰符 class 内部类名称 {...} ... }  内用外，随意访问。外用内，需要内部类对象。
             在main方法中使用：1、间接方式： 在外部类的方法中调用内部类，然后main通过访问外部类的方法调用内部类。
                            2、直接方式： 外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();
             当局部变量、内部类的成员变量、外部类的成员变量重名时：
                内部类的成员方法调用内部类的成员变量用this.内部成员变量。 内部类的成员方法调用外部类的成员变量用Outer.this.外部成员变量。
    局部内部类：如果一个类定义在方法内部，就是局部内部类。---只有当前所属的方法才能使用它，出了这个方法就不能使用了。
             格式：修饰符 class 外部类名称 {... 修饰符 返回值类型 外部类方法名称(参数列表) { class 内部局部类名称 {...} ... } ...}
             注意：若局部内部类要访问所在方法的局部变量，则该局部变量必须是【有效final的】（即可以不写final关键字，但是不能变）
                        因为局部内部类在堆中，生命周期长，而局部变量在栈中，生命周期短，所以不能变。
    【匿名内部类】：【用的最多】 如果接口的实现类（或者父类的子类）只需使用唯一的一次，则可以省略该类的定义，而改为使用匿名内部类。
             格式：接口名称 对象名 = new 接口名称() { 重写所有抽象方法 };
             注意：1、匿名内部类只能唯一【创建一次对象】。若想多次创建对象，就要单独定义实现类。
                  2、匿名对象只能唯一【调用一次方法】。若想多次调用方法，就要给对象起个名字。
                  3、匿名内部类是省略了实现类/子类名称。而匿名对象是省略了对象名称。他俩不是一回事。
             new 接口名() { 重写所有抽象方法 }.方法(参数);  即匿名内部类又匿名对象的使用方法。

异常:
    throw : 用于抛出异常，   例如: throw new NullPointerException("异常产生的原因")
        若抛出运行时异常，可不理会，默认由JVM处理
        若抛出编译器异常，则必须处理。throws或try-catch
    throws: 声明异常。  (用于甩锅)
        格式: 修饰符 返回值类型 方法名(参数列表) throws AAAException, BBBException... {throw new AAAException("原因")...}
        注意: 1、throws必须写在方法声明处
             2、throws后面必须是Exception或者是其子类
             3、throws后面必须声明方法内部抛出的所有异常
             4、若调用了一个声明抛出异常的方法，则必须处理这些异常。可以继续抛出，也可以自己处理。
    try-catch:  自己处理异常
        try可以抛出多个异常，这时需要使用多个catch来捕获异常。
        try中若产生异常，则try代码块中产生异常之后的代码不会执行，而跳转到catch。
        try中若没有产生异常，则执行完try中的代码继续执行try-catch之后的代码。
    finally: 不论是否发生异常，finally代码块中的代码一定会执行。
        格式 : try{} catch{} finally{}
        注意 : finally必须与try一起使用，一般用于资源释放。
               正是由于其有一定会执行到，所以若finally代码块中有return语句，则一定会返回finally中的结果。（要避免）
    注意 : 子类异常一定要与父类异常一致。

Thread : Thread类是描述线程的类，要实现多线程，必须继承Thread类
    每个线程拥有一个自己独立的栈，但是共享进程的堆空间。
    Thread.sleep(毫秒)                          // 静态方法  睡眠
    Thread thread = Thread.currentThread();     // 获取当前线程
    第一种方法： 创建Thread类的子类
        1、创建Thread类的子类，并重写run方法，其中设置线程的任务
        2、创建子类对象，并执行start方法  (执行start方法会创建一个新的栈空间，并在该栈空间中执行run方法)(每执行一次步骤2，就开启一个新的线程)
    第二种方法： 实现Runnable接口  (推荐使用这种)   --->  使用该方法时，Thread 类是咱们自定义类的静态代理类
        1、创建一个Runnable接口的实现类，并重写run方法，其中设置线程的任务
        2、创建对象，并将其作为参数传递给Thread类的构造方法，再调用start方法。 new Thread(new MyRunnable()).start();
        匿名内部类实现： new Thread(new Runnable(){重写run方法}).start();
    第三种方法： 实现Callable<V>接口  （面试可能会问到）
        Callable接口类似于Runnable，【Runnable不会返回结果，也不会抛出检查异常，Callable可以】
        1、创建一个Callable<V>接口的实现类，并重写call方法，其中设置线程的任务
        2、在使用的地方创建该类对象 obj 。
        3、ExecutorService executorService = Executors.newFixedThreadPool(5);  // 创建执行服务
        4、Future<V> future = executorService.submit(obj);                     // 提交执行
        5、V result = future.get();                                            // 获取结果
        6、executorService.shutdownNow();                                      // 关闭服务

同步：  多个对象访问同一个资源，可以并发读取，但当其中某一个对象要修改时，就必须实现同步
    所有的对象都拥有一把锁。
    
    锁对象选取总结为一句话就是 在同步代码中要改变谁就锁谁。
    方法一： 同步代码块：
        synchronized (锁对象) {访问共享数据的代码}  线程不仅要抢夺CUP，还要占用锁对象。同时拥有才能执行代码
        锁对象可以是任意对象，但必须是同一个对象，推荐将共享资源作为锁对象。线程占用锁对象后直到执行完毕才释放。
    方法二： 同步方法
        修饰符 synchronized 返回值类型 方法名 (参数列表) {访问共享数据的代码}     // 该方法即为同步方法
        首先将 访问共享数据的代码块 抽取出来，作为上述方法。
        同步方法的锁对象默认为 this ，即同步方法所在类的对象；创建该类的对象后，该对象调用同步方法时就会锁住对象自己。
        当同步方法同时也是静态方法时，锁对象为同步方法所在类的 Class 对象。
    方法三： Lock锁
        Lock是一个接口，有两个方法 void lock()  获取锁  和  void unlock()  释放锁
        它有一个实现类ReentrantLock（可重入锁）， 先实例化一个ReentrantLock对象。
        在出现安全问题代码之前用该对象调用 lock() 方法。在出现安全问题代码之后用该对象调用 unlock() 方法。
             lock() 和  unlock() 方法建议放在 try --- finally 代码块中
                
线程状态：
    线程停止：不推荐使用 Thread 类提供的 stop() 等方法。推荐自己通过一个标志位控制停止
                public class MyRunnable implements Runnable {
                    private boolean flag = true;
                    
                    @Override
                    public void run() {
                        while (flag) {
                            TODO...
                        }
                    }
                    
                    public void stop() {
                        flag = false;
                    }
                }
			通过调用自己实现的 stop 方法来停止线程
    下方所有方法都是 Thread 类中的方法！
    线程休眠：Thread.sleep(毫秒)      // sleep 不会释放锁、 wait 会释放锁。
    线程礼让： Thread.yield();  使当前线程从运行状态变为就绪状态，让 cpu 从所有就绪的线程中挑一个运行。
                礼让有可能不成功，因为 cpu 可能再挑选一次还是让当前线程继续执行。
    线程强制执行： join()    ，相当于插队，停止现在执行的线程，立刻执行自己的线程，且本线程执行结束才能执行其他线程
                public class MyRunnable implements Runnable {

                    @Override
                    public void run() {
                        for (int i = 0; i < 1000; i++) {
                            System.out.println("Runnable " + i);
                        }
                    }

                    public static void main(String[] args) throws InterruptedException {
                        MyRunnable myRunnable = new MyRunnable();
                        Thread thread = new Thread(myRunnable);
                        thread.start();

                        for (int i = 0; i < 500; i++) {
                            if (i == 200) {
                                thread.join();
                            }
                            System.out.println("主线程" + i);
                        }
                    }
                }
              在上方举例代码中，主线程执行到200之前，主线程和Runnable线程交替执行，当主线程执行到200次时，
              Runnable 线程插队接着执行，之后Runnable线程全部执行完毕后才由主线程继续执行。
     查看线程状态：Thread.State state = thread.getState();      // Thread.State 是一个枚举类型
     线程优先级：1 最小；10 最大；默认为5。优先级越高在就绪状态很大可能越早执行，但也不是一定。
     守护（daemon）线程：
         线程分为用户线程和守护线程。
         虚拟机必须保证用户线程执行完毕，但不用等待守护线程执行完毕。
         守护线程有：后台记录日志、监控内存、垃圾回收等
         private boolean daemon = false;    // 默认 daemon 属性是关闭的，即默认为用户线程
         thread.setDaemon(true);            // 可通过这样将线程设置为 守护线程。
         // 将线程设置为守护线程之后，虚拟机将不再保证该线程是否执行结束，
         // 即只要当用户线程执行结束后就将整个程序关闭，而不考虑守护线程此时是否已经执行完毕。

线程池 :   底层原理 ： 线程池就是一个容纳多个线程的容器，可由集合实现
    使用步骤: 1、使用线程池工厂类Executors里面的静态方法newFixedThreadPool生产一个指定线程数量的线程池，由ExecutorService接口接收。
             2、创建Runnable接口的实现类，重写run方法，设置线程任务。
             3、调用ExecutorService中的execute方法，传递线程任务，开启线程，执行run方法。
           例:   ExecutorService executorService = Executors.newFixedThreadPool(5);  // 创建服务
                 Runnable runnable = new Runnable() {  //此处虽然new 的是Runnable接口，但是立即重写了run方法，故相当于其实现类。
                     @Override
                     public void run() {
                         //线程任务
                     }
                 };
                 executorService.execute(runnable);                                  // 执行服务
                 executorService.shutdownNow();                                      // 关闭服务

	ExecutorService 中的 submit()方法和 execute()方法作用相同，只是适用于不同场景
      void execute(Runnable command)           // 执行任务，没有返回值，一般用于执行 Runnable
      <T> Future<T> submit(Callable<T> task);  // 执行任务，有返回值，一般用于执行 Callable


Lambda表达式 :  可推导，可省略
    格式：  () -> {}
    使用前提： 必须是接口，且接口中有且只有一个抽象方法  (有且只有一个抽象方法的接口，称为"函数式接口")
    可以省略的内容：
        1、(参数列表) 参数列表中的数据类型可以省略， 如果参数只有一个，则括号()也可以省略
        2、{方法体}   如果{}中的代码只有一行，无论是否有返回值，都可以省略 {}， return， 分号   （要省一起省）

注解:
    @override                    检测是否为覆盖重写
    @FunctionalInterface         检测是否为函数式接口


------------------------------------------------------------------------------------------------------------------

API使用：
    Scanner：
        功能：从键盘输入数据到程序。
        包路径：java.util.Scanner
        实例化：Scanner sc = new Scanner(System.in);  System.in 表示从键盘输入数据。
        方法：---其实键盘输入的一切东西都是字符串，使用不同的函数会将字符串转换为相应的类型。-->故若记不住也可以一直使用sc.next();之后再转换类型
            获取键盘输入的一个int数字： int num = sc.nextInt();
            获取键盘输入的一个字符串： String str = sc.next();
        读取文件内容：Scanner in = new Scanner(Paths.get("\u202AC:\\Users\\Lenovo\\Desktop\\1.txt"), StandardCharsets.UTF_8);
            之后再用in的各种方法。nextLine();   next();   nextInt(); 等


Random:
    功能: 获取随机数。
    实例化：Random rand = new Random();
    方法：int rand_num = rand.nextInt(n)  在[0, n)中随机取一个数字。----> m + rand.nextInt(n)取到[m, m + n）中的随机数。

ArrayList: [元素1， 元素2， 元素3， ...]
    功能：可变长的数组。
    泛型：装在集合中的元素必须是同一个类型，只能是引用类型，不能是基本类型。
    实例化：ArrayList<String> list = new ArrayList<>();
    注意事项：直接打印list输出的不是一个地址值，而是空的中括号。
            不支持下标索引，只能用get()方法获取。
    常用方法：list.add("李沁")  添加元素，返回一个boolean值，表示添加的动作是否成功。一定成功，可以不接受返回值。
            list.get(index)  根据索引获取元素，返回获取的元素。
            list.remove(index)  根据索引删除元素，返回被删除的元素。
            list.size()  获取集合长度。
    若想在ArrayList中存储基本类型，需要使用其包装类(引用类型)：
        基本类型         包装类
        byte            Byte
        short           Short
        ...             ...   （与上方一样，只需首字母大写）
        int             Integer    【特殊】
        char            Character  【特殊】
        ArrayList<Integer> list_int = ArrayList<>();
        //  自动装箱：int --> Integer     自动拆箱：integer --> int

String:
    功能：字符串（常量） --> Java中所有的双引号字符串都是String类的实例。
    实例化：直接创建： String str1 = "李沁";    在字符串常量池中， 其他实例化方式都在堆中，不在池里。
          使用空构造函数： String str2 = new String();
          根据字符数组创建： char[] charArray = { &#39;a&#39;, &#39;b&#39;, &#39;c&#39; };   String str3 = new String(charArray) // abc
          根据字节数组创建： byte[] byteArray = { 97, 98, 99 };   String str3 = new String(byteArray)    // abc
    方法：str1.equals(str2)  比较str1和str2的值是否相等，返回boolean。 常变量比较时推荐  常量.equals(变量)
         str1.equalsIgnoreCase(str2) 忽略大小写。
         str.length()   长度
         str.concat(str1)   拼接
         str.charAt(index)  根据索引返回字符
         str.indexOf(str1)  在str中查找str1，返回首次找到的索引值；若没有，返回-1
         str.substring(index)   截取，从index到末尾
         str.substring(int begin, int end)   截取，[begin, end)
         str.toCharArray()  转换为字符数组   str.getBytes()  转换为字节数组   用于遍历字符串
         str.replace(old, new)  用new替换str中的old
         str.split(regex)  切割，返回数组

Arrays:
    功能：与数组相关的类，提供大量静态方法，用来实现数组常见的操作。
    方法：
        Arrays.toString(数组)  将参数变成字符串 [元素1， 元素2，元素3，...]
        Arrays.deepToString(多维数组)  将参数变成字符串 [元素1， 元素2，元素3，...]
        Arrays.sort(数组)  排序。默认从小到大，自定义类型的排序需要Comparable或Comparator接口
        Arrays.equals(数组1， 数组2)    两个数组完全相等是返回ture

Math:
    功能：数学相关的类，提供大量静态方法，用来实现数学运算相关的操作。
    方法：
        Math.abs()     绝对值
        Math.ceil()    向上取整
        Math.floor()   向下取整
        Math.round()   四舍五入

Collection接口: 所有单列集合的顶层接口
    List接口:  1、有序（存入和取出的顺序一致）  2、允许元素重复  3、有索引
        Vector:(了解)
        Arraylist:(重点)  底层由数组实现，查询快，增删慢。
        LinkedList:(次之) 底层由链表实现，查询慢，增删快。
            特有方法:
                addFirst() == push()      addLast() == add()
                getFirst()                getLast()
                removeFirst() == pop()    removeLast()    这两种方法都会删除并返回
        共有方法：
            void add(int index, E element)    将元素添加到索引位置
            E get(int index)                  返回索引处的元素
            E remove(int index)               删除索引位置元素,并返回被删除的元素
            E set(int index, E element)       替换索引位置元素,并返回被替换前的元素
    Set接口:  1、不允许元素重复    2、没有索引
        TreeSet: (无序) (了解)        底层由二叉树实现，一般用于排序。
        HashSet: (无序) (重点)        底层由哈希表实现。(查询速度很快)
            注意: 使用HashCode存储自定义类型时，需要重写HashCode()和equals()。可通过alt + insert直接添加。才能保证元素不重复。
            LinkedHashSet: (有序) (次之)  底层由哈希表+链表实现。 extends HashSet
                比HashSet多了一条链表，用来记录元素的顺序
    共有方法：
        boolean add(E e)      添加，   无需接收
        boolean remove(E e)   删除，   若有e，删除并返回true。若没有e，无动作并返回false
        void clear()          清空。   但不删除集合。
        boolean contains(E e) 是否包含。
        boolean isEmpty()     是否为空。
        int size()            元素个数。
        Object[] toArray()    转为数组。

哈希值: 是一个十进制的整数，由操作系统随机给出的对象的逻辑地址值。
哈希表: 拉链法。由哈希值为元素组成数组（初始长度为16）。若哈希值相等，则以链表方式挂在该哈希值后面。当链表长度超过8时，变为红黑树。检索速度加快。

Collections :  是Collection的工具类，提供大量静态方法，用于操作集合。 以ArrayList为例: ArrayList<String> list = new ArrayList<>();
    addAll(Collection<T> c, T... elements) : 往集合中添加多个元素。  Collections.addAll(list, "a", "b", "c");
    shuffle(List<T> list) : 打乱顺序。                             Collections.shuffle(list);
    sort(List<T> list)    : 排序， 默认升序。                       Collections.sort(list);
        注意：若要对自定义类型排序，则被排序的类必须实现Comparable接口，重写compareTo方法来定义排序规则。  this - 参数 ： 升序
    (了解)另一种sort()： Collections.sort(arr, new Comparator<Integer>() {
                               @Override
                               public int compare(Integer o1, Integer o2) {
                                   return o1 - o2;
                               }
                           });     这种方法List接口中的方法类似-> arr.sort(new Comparator<Integer>() {...})

Iterator: 迭代器    是接口   也有泛型 --> Collection<String> array = new ArrayList<>();
                                        Iterator<String> it = array.iterator();
    常用方法:
        boolean hasNext()  是否有下一个元素。
        E next()           返回下一个元素。
    使用： Collection中的实现类为 iterator()
        1、实例化iterator    2、用hasNext()    3、用next()

增强for循环:  专门用来遍历数组与集合，由Iterator迭代器实现，遍历时不能做增删操作。
    for (元素数据类型 变量 : 集合或数组名) { ... }

Map:      --> 字典     键值对     key是唯一的
    HashMap: (无序)  底层为哈希表
        LinkedHashMap : (有序)  底层为哈希表+链表(保证顺序)
    方法:
        V put(K key, V value) : 添加，若key值不存在，则添加并返回null。若key值已存在，则更新value值，并返回被替换掉的value值。一般不接收返回值。
        V remove(K key)  : 删除，若key值存在，返回被删除的value。若key不存在，则返回null。
        V get(K key)     : 获取，若key值存在，返回对应的value。若key不存在，则返回null。
        boolean containsKey(k key)  :  判断是否包含指定的键。
        Set<K> keySet()   返回由键组成的Set，之后可以通过遍历Set来遍历Map。  for (K key : map.keySet()) { sout(key + map.get(key)) }
        Set<Map.Entry<K, V>> entrySet()  -->  for (Map.Entry<K, V> entry : map.entrySet()) {  也是遍历，看起来不好用的样子
                                                          System.out.println(entry.getKey() + &#39; &#39; + entry.getValue());}
    用Map存储自定义类型时，若自定义类型作为键，则必须将该类重写HashCode和equals方法，保证键是唯一的。
of方法：  static <E> List<E> of (E... elements)
    1、of方法只适用于List, Set, Map 接口。而不适用于他们的实现类
    2、of方法返回一个不能被操作的集合。因此适合初始化，且初始化后不能改变。
    3、Set 和 Map 调用of方法时不能有重复元素。

------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------

Object：   以下方法所有类都有，只是重写之后功能有所不同。
    toString()  直接打印对象的名字，就是调用对象的toString方法->得到对象的地址值。  没有意义。
                重写：可以和构造方法与Getter/Setter方法一样的步骤添加（重写）toString方法->打印出属性值。
    equals()    boolean equals(Object obj)  判断两个对象是否"相等"，返回布尔值。 比较两个对象的地址值，同上方的==作用一样。 没有意义。
                重写： 原理 --> 由于equals方法的参数类型为Object,所以默认向上转型了。若想比较两个对象的属性值，需要先向下转型。
                      同样可以 alt + insert 直接生成equals方法。 判断两对象的属性值是否都一样。
    hashCode()  返回对象的哈希码值
    // synchronized 能实现线程同步、但无法实现线程间通信、用如下 4 个方法可以实现线程间通信。
    wait()      等待。在被唤醒之前，放弃CPU的使用权    wait(毫秒值)  在被唤醒或到时间之前，放弃CPU的使用权
    notify()    唤醒。随机唤醒锁对象中的一个进程       notifyAll()  唤醒锁对象(对象监视器)中的所有进程   这两种常搭配同步机制使用

objects:  该工具类提供的方法是容忍空指针的。 若 a=null，则a.equals(b) 报错。而Objects.equals(a, b) 正常运行。
    Objects.requireNonNull(T obj)   查看obj是否为空，用来判断参数的合法性。

旧API :
    Date:     1970年1月1日 00:00:00 作为0时刻
        Date() 无参构造--> 获取当前时间。
        Date(long date)  有参构造 --> 输入毫秒值，输出相对于0时刻的日期。
        getTime()  把日期转换为毫秒

    DateFormat:    格式化日期。   抽象类。
        String format(Date date)    把日期格式化为字符串。
        Date parse(String source)   把符合的字符串解析为日期。
    
        SimpleDateFormat:    DateFormat的实现类
            SimpleDateFormat(String pattern)  有参构造  参数一般为 "yyyy-MM-dd HH:mm:ss"
            使用上方两个方法。 注意：用parse时，参数的模式必须与构造SimpleDateFormat对象时的模式完全一样，否则报错。
    
    Calendar:     日历类       抽象类
        getInstance()  静态方法   返回Calendar类的子类对象         Calendar instance = Calendar.getInstance();
            功能：使用默认时区和语言环境获得一个日历
        get(field)  返回给定字段的值。                  字段值有YEAR MONTH DATE HOUR MINTER SECOND 年月日时分秒   都是静态变量
        set(field, value)   将给定的日历字段设置为给定值
        add(field, amount)   修改指定的字段，通过amount的正负实现加减。
        Date getTime()      将Calendar转为Date对象
            原理：实际上该类中有一个fields数组，上述的方法都是在对该数组操作。字段值YEAR等固定为0，1，2等，作用是对该数组的索引。

新API
LocalDate, LocalTime, LocalDateTime : 之前的Date类和Calendar类都有缺陷。JDK8 新引入日期时间类
    由于LocalDateTime类使用较多，故以他为例，其余两种用法相同。
    构造方法： 1、LocalDateTime now = LocalDateTime.now();      获取当前时间
             2、LocalDateTime localDateTime = LocalDateTime.of(2020, 1, 20, 12, 20, 34);    获取指定时间
    常用方法：
        now.getDayOfMonth()                           获取对象是这个月的第几天。类似的方法获取其他属性。
        LocalDateTime time = now.withDayOfMonth(12);  使用类似方法设置属性。但是该语句执行后，time为修改后的值，而now的值不变。体现了时间的不可变性。
        LocalDateTime plusDays = now.plusDays(3);     使用类似方法修改属性，在原有基础上加3天。不可变性同上。
        LocalDateTime months = now.minusMonths(2);    使用类似方法修改属性，在原有基础上减2月。不可变性同上。
Instant 替换 Date 类
DateTimeFormatter :  类似于SimpleDateFormat     日期时间的格式化与解析
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");   构造
    String format = formatter.format(LocalDateTime.now());                              格式化
    TemporalAccessor parse = formatter.parse("2021-01-21 22:00:25");                    解析

System:  提供大量静态方法， 可以获取与系统相关的信息即服务
    static currentTimeMillis()    返回以毫秒为单位的当前时间, 用来测试程序的效率。
    static arraycopy(原数组， int 原数组起始位置， 目标数组， int 目标数组起始位置， int 要复制的数组元素的数量)  复制数组

StringBuilder:
    在String类中，字符串是常量，底层是被final修饰的数组。字符串相加时，占用内存多，效率低下。
    StringBuilder类是字符串缓冲区，可以提高字符串的操作效率（看成是一个长度可以变化的字符串）
        底层也是一个数组，但是没有被final修饰，可以改变长度。
        在内存中始终是一个数组，初始容量为16个字节，超出会自动扩容，占用空间少，效率高。
    构造函数：
        StringBuilder()  无参构造，空字符串。
        StringBuilder("abc")  有参构造，即参数的字符串。
    成员函数：
        append(任意类型)   添加到字符串，并返回自身。所以无需接收。
        toString()   将StringBuilder对象，转换为String对象。       通过StringBuilder的构造方法可以将String转换为StringBuilder.
        reverser()   翻转

File:    文件类，主要用于文件和目录的创建，查找和删除等操作     File类已被Path取代
    静态方法:
        static String	pathSeparator    路径分隔符    windows ; 分号      linux  : 冒号
        static String	separator        文件名称分隔符   Windows \ 反斜杠   Linux  / 正斜杠
    构造方法:
        File(String pathname)    路径名 ==> 文件/文件夹  相对/绝对  存在/不存在
        File(String parent, String child)  父路径，子路径
        File(File parent, String child)  父路径，子路径。父路径是File型，故可以使用其方法做调整
    常用方法:
        获取方法:
            String getAbsolutePath()  返回绝对路径名
            String getPath()          返回路径名
            String getName()          返回末尾文件/文件夹 名字
            long length()             返回文件大小（以字节为单位） 不能是文件夹，若路径不存在，返回0
        判断方法:
            boolean exists()          文件或文件夹是否真实存在
            boolean isDirectory()     路径是否以文件夹结尾   前提：真实存在
            boolean isFile()          路径是否以文件结尾     前提：真实存在
        创建删除:
            boolean creatNewFile()    不存在时创建文件     不能创建文件夹，路径必须存在
            boolean delete()          删除文件/文件夹
            boolean mkdir()           创建单级空文件夹
            boolean mkdirs()          创建单级/多级空文件夹     多级文件夹：父文件夹中包含子文件夹
        遍历文件夹:
            String[] list()           返回由所有文件或子目录组成的字符串数组
            File[] listFiles()        返回由所有文件或子目录封装而成的文件数组
    过滤器:
        File[] files = dir.listFiles(new FileFilter(){重写accept()方法，该方法中写入过滤规则，留下的返回ture，不要的返回false})
            可以写为Lambda表达式。

读取文件的方法：
        Scanner in = new Scanner(Paths.get("C:\\Users\\Lenovo\\Desktop\\1.txt"), StandardCharsets.UTF_8);
        String num = in.nextLine();

        BufferedReader reader = Files.newBufferedReader(Paths.get("C:\\Users\\Lenovo\\Desktop\\1.txt"), StandardCharsets.UTF_8);
        String str = reader.readLine();

（不好用）BufferedReader bufferedReader = new BufferedReader(new FileReader("C:\\Users\\Lenovo\\Desktop\\1.txt"));
        String s = bufferedReader.readLine();

Properties:  用来加载配置文件,  示例如下：
            Properties properties = new Properties();
            //  ClassLoader classLoader = Person.class.getClassLoader();  注释掉的两句作用与下一句一样
            //  InputStream is = classLoader.getResourceAsStream("jdbc.properties");  //  路径相对于src
            FileInputStream fis = new FileInputStream("src\\jdbc.properties");  // 路径相对于Module而不是src
            properties.load(fis);
            String user = properties.getProperty("user");
            String passwd = properties.getProperty("passwd");
            System.out.println(user + " " + passwd);

IO流:    （默认相对路径在Module下）
    基本流:
        OutputStream: 字节输出流  (一切都以字节为单位) (一次读写一个字节)  接口
            共有方法: write(byte[] bytes)    写入多个字节
                     close()
            FileOutputStream: 文件字节输出流
                构造方法: FileOutputStream(String name[, boolean append = false])
                            参数为路径，即写入的目标文件路径，如果没有该文件，会先创建该文件。若append为ture，则为追加写，否则会覆盖原文件
                         FileOutputStream(File file[, boolean append = false])    参数为文件，即写入的目标文件，append同上。
        InputStream: 字节输入流  接口
            共有方法: read()   读取一个字节,返回读到的内容，读到文件末尾返回-1
                     int read(byte[] bytes)   读取多个字节，将读取到的内容存入字节数组中，并返回读取的有效字节个数，读到文件末尾返回-1
                     close()
            FileInputStream: 文件字节输入流
                构造方法: FileInputStream(String name)
                         FileInputStream(File file)
        Reader: 字符输入流  抽象
            共有方法: read()    read(char[] c)   close()   作用和上述相同,包括返回-1等等都相同，只是读取单位变为字符。
            FileReader: 文件字符输入流  --->   只能读取IDEA默认编码格式文件(即UTF-8)
                构造方法: FileReader(String filename)     FileReader(File file)
        Writer: 字符输出流  抽象
            共有方法: write()  参数可以为单个字符，字符数组或字符串   close()
            FileWriter: 文件字符输出流
                构造方法: FileWriter(String filename[, boolean append = false])     FileWriter(File file[, boolean append = false])
                注意: 这里的write方法是将数据写入内存缓冲区(字符转为字节)，flash方法或close方法会数据刷新到文件。因此必须调用close()方法。
        Properties集合: 实现了Map<K, V>   唯一和IO流结合的集合
            该集合的默认键和值都是字符串类型。store方法能把集合中的数据存入硬盘，load方法会加载到该集合中。
    缓冲流:  创建一个缓冲区，减少系统IO次数，提高读写效率。
        BufferedInputStream:  字节缓冲输入流 extends InputStream        用read写入，close关闭。只需要关闭缓冲流，基本流会随之关闭。
            构造方法: BufferedInputStream(InputStream in[, int size])       read和write方法与基本流完全相同。
        BufferedOutputStream: 字节缓冲输出流 extends OutputStream       用write写入，close关闭
            构造方法: BufferedOutputStream(OutputStream out[, int size])
                参数可以传递FileOutputStream对象，可选参数size用于指定缓冲区大小
        BufferedWriter:  字符缓冲输出流 extends Writer
            构造方法: BufferedWriter(Writer out[, int size])  可传入FileWriter
            特有方法: void newLine()   无视系统差异，换行
        BufferedReader:  字符缓冲输入流 extends Reader
            构造方法: BufferedReader(Reader in[, int size])  可传入FileReader
            特有方法: String readLine()   读取一行数据，但不读取行末换行符。读到文件末尾返回null
    转换流:  可以指定编码/解码的码表
        OutputStreamWriter extends Writer:  步骤: 1、new对象 2、write()  3、close()
            构造方法: OutputStreamWriter(OutputStream out[, String charsetName])
                参数一般传递为FileOutputStream。可选字段为编码表名称，不区分大小写，默认为UTF-8
        InputStreamReader extends Reader:  步骤: 1、new对象 2、read()  3、close()
            构造方法: OutputStreamWriter(InputStream in[, String charsetName])
    (反)序列化流: 把对象以流的方式写入/读出到文件中     使用字节流
        ObjectOutputStream: extends OutputStream  对象的序列化流    把对象以流的方式写入到文件中保存，叫写对象，也叫对象的序列化。
            构造方法: ObjectOutputStream(OutputStream out)   参数一般传递为FileOutputStream。
            特有方法: void writeObject(Object obj)   此处参数也可以是由obj组成的集合，如ArrayList<Person> list
                被序列化的对象(即参数obj)必须实现Serializable接口，以激活(反)序列化功能。其为标记型接口，内部没有任何抽象方法。
        ObjectInputStream: extends InputStream   对象的反序列化流    把文件中保存的对象以流的方式读出来，叫读对象，也叫对象的反序列化。
            构造方法: ObjectInputStream(InputStream in)       参数一般传递为FileInputStream。
            特有方法: Object readObject()
        transient关键字: 瞬态关键字，被其修饰的成员变量不能被序列化，没有替他功能。static关键字也有这个功能。
        注意：为了避免InvalidClassException,在每个被序列化的对象中都显示声明一个序列号-> private static final long serialVersionUID = 42L
    打印流:  PrintStream                          System.out.println();

enum :    枚举类   类的对象只有确定的有限个，我们称之为枚举类   当需要定义一组常量时，强烈建议使用枚举类    默认继承java.lang.Enum
    定义：
        类似于接口的定义，创建Class包时，选项中就有Enum的选项。
        public enum Season {
            SPRING("春天", "warm"),                               默认由public static final 修饰
            SUMMER("夏天", "sun"),                                实例写在类的最前面
            AUTUMN("秋天", "cool"),                               实例之间用逗号分隔，最后一个结尾为分号
            WINTER("冬天", "cold");                               为什么不需要显示声明成员变量(由局部变量代替)，暂时不清楚
            Season(String seasonName, String seasonDec){}  }      构造函数默认由private修饰，可省略不写。
    静态方法：
        values()                   返回枚举类型的对象数组，方便用于遍历枚举值
        valueOf(String objName)    返回枚举类中对象名为objName的对象   如: Season winter = Season.valueOf("WINTER");
        toString()                 返回当前枚举类对象常量的名字

反射:    java.lang.Class
            程序由javac.exe编译后，会生成一个或多个字节码文件(.class结尾)。
            接着使用java.exe对某个字节码文件解释运行，就相当于将某个字节码文件加载到内存中，这个过程就叫类的加载，
            加载到内存中的类就叫运行时类，这个运行时类就是Class的一个实例。
            加载到内存中的运行时类会缓存一段时间，在此时间内以不同方式获取到的该运行时类的Class实例都是同一个。
        获取Class实例的方法：
            1、 Class clazz = Person.class;
            2、 Person person = new Person();     Class clazz = person.getClass();
            3、 Class clazz = Class.forName(类相对于src的全路径);   // 用的较多
        ClassLoader：引导类加载器--》加载java核心类库   引导类加载器无法获取到
                     扩展类加载器--》加载jar包      通过Class实例.getClassLoader()即可获得类加载器，如
                     系统类加载器--》加载自定义类    Person.class.getClassLoader()获取的即为系统类加载器
        无法创建实例的类型用  Class c = int.class;   double.class;    Math.class; 等
        ArrayList<Integer> list = new ArrayList<>();
        Class l1 = list.getClass();           得到ArrayList<Integer>类的Class实例
        l1.getDeclaredConstructors();         获取所有构造函数，去掉Declared为只获取public的构造函数
        l1.getDeclaredMethods();              获取所有函数，去掉Declared为只获取public的函数
        l1.getDeclaredFields();               获取所有属性，去掉Declared为只获取public的属性
        l1.getSuperclass();                   获取父类
        l1.getGenericSuperclass();            获取带泛型的父类
        li.getInterfaces();                   获取接口
        li.getPackage();                      获取包
        li.getAnnotations();                  获取注解
        for (Method method: l1.getDeclaredMethods()) {
           System.out.println(Modifier.toString(method.getModifiers()) + " " + method.getReturnType() + "  " +
                   method.getName() + "(" + Arrays.toString(method.getParameterTypes()) + ");");
        }
        Field f = l1.getDeclaredField("size");  根据属性名称获取特定的Field对象。
        f.setAccessible(true);                  使其变为可访问的
        Object v = f.get(list);


    Person person = new Person("alice", 21);    方法对象调用invoke方法来执行方法。
    Class p = person.getClass();                public Object invoke(Object obj, Object... args)
    Method m = p.getMethod("getName");          第一个参数为对象名，之后的参数为方法的参数。
    String s = (String) m.invoke(person);       调用的是静态方法时，第一个参数为null。

    代理的作用就是在不修改源码的情况下，对目标对象的方法增强。
    静态代理：接口 + 代理类 + 被代理类   --》  一个代理类只能对应一个被代理类         代理类与被代理类实现同样的接口
    动态代理：接口 + 代理类 + 多个被代理类   --》  一个代理类可以对应多个被代理类     代理类与被代理类实现同样的接口
        结合src/proxy/annotationProxy包下的例子理解
        1、根据自己需求创建一个被代理类对象（想象在项目中，要增强功能时，一定在之前已经使用过这个对象）
        2、根据这个被代理类对象，动态获取一个代理类对象（因此，没有显示的代理类，是被动态获取到的）
        3、使用代理类对象调用被代理类的方法。（具体原理看包中例子的注释）
'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ethereal-lu.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Java学习笔记","item":"https://ethereal-lu.github.io/posts/java/java%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java学习笔记","name":"Java学习笔记","description":"数组： 数组的初始化方式： 1、动态初始化（指定长度） 数据类型[] 数组名 = new 数据类型[数组长度]； 2、静态初始化（指定内容） 数据类型[] 数组名 = new 数据类型[] {元素1， 元素2， 元素3， ... }； 元素值可以是变量 省略的静态初始化 数据类型[] 数组名 = {元素1， 元素2， 元素3， ... }； 该方式不允许拆分为2步，即先定义数组名，再经行赋值。 直接打印数组名，打印的是数组的内存地址。 支持下标索引。 未初始化的默认初始值： 整数类型： 0 浮点类型： 0.0 字符类型： \u0026#39;\\u0000\u0026#39; 布尔类型： false 引用类型： null 获取数组长度： 数组名.length; 获取数组副本： 数组名.clone(); 成员变量与局部变量： 成员变量定义在类内，方法外。局部变量定义在方法内。 成员变量不要写static关键字。??? 成员变量有默认值，而局部变量没有默认值。 当成员变量与局部变量的命名冲突时，按照就近原则，优先使用局部变量。若想使用全局变量，使用this.成员变量名。 可变参数: 使用前提：当方法的参数类型确定，但是参数个数不确定时，使用可变参数。 使用格式：修饰符 返回值类型 方法名(数据类型...变量名) {} 例如: public void func (int... num) {} 原理： 可变参数底层是一个数组，根据传递参数个数的不同，会创建不同长度的数组，来存储这些参数。参数个数可以是0个或多个。 因此，方法中的变量名其实就是数组的名字，可以作为数组使用。 注意： 一个方法的参数列表中只能有一个可变参数。 如果方法有多个参数，则可变参数必须放在参数末尾。 类的使用: 1、导包：import 包路径.类名称 当类与当前文件处于同一个包中时，可以不用导包。只有java.lang下的包不需要导包，其他都需要导包。 但实际使用中，可以不用手动导包，当你使用某个类时，系统会自动帮你导包。 2、实例化： 类名称 对象名 = new 类名称(); 3、使用: 对象名.成员变量名 对象名.成员方法名(参数) Private: Getter: 函数格式必须是 getXXX 如果变量是布尔类型，则使用isXXX Setter: 函数格式必须是 setXXX Private修饰构造函数时，外部不能再构造该类的实例，故只能在类内构造好全部实例并赋给static类型的变量。叫构造函数私有化 this: this是当前对象的引用，即this和对象是同一个东西。 this.成员变量 调用本类成员变量 可以将类内的成员变量与方法中的同名局部变量区分。 this.成员方法 调用本类成员方法 this(...) 调用本类构造函数 --\u0026gt; 写在第一行，只能调用一个。 若子类使用了this(...)，则不再默认赠送super()。 super: super.成员变量 调用父类成员变量 可以将父类中的成员变量和子类中的同名成员变量区分。 super.成员方法 调用父类成员变量 super(...) 调用父类类构造函数 --\u0026gt; 写在第一行，只能调用一个。 构造函数： 格式： public 类名（参数类型 参数名称 ， ...）{...} 注意事项： 构造方法的名称和类名要严格相等，大小写敏感。 构造方法没有返回值类型。 若不明确定义构造函数，则会自动生成默认构造函数，若手动定义了任意形式的构造函数，编译器将不会再生成默认构造函数。 构造函数支持重载 继承中的构造函数: 构造链：同C++一样--\u0026gt; 祖宗 \u0026gt; 父类 \u0026gt; 子类 子类构造方法中若不显式调用super，则默认隐含一个 \u0026#34;super()\u0026#34; 调用。 子类构造函数可以显式地写 super([参数1，...]) 来调用父类的重载构造函数。且必须在方法体的第一行，即只能调用一个。 标准类：也叫做 Java Bean 通常包含以下4部分内容： 所有的成员变量都要使用private关键字。 为每一个成员变量编写一对儿Getter/Setter方法 编写一个无参构造函数 编写一个全参构造函数 点击 Code-\u0026gt;Generate 或者 快捷键 alt + insert 可以自动生成上述内容 ==： 对于基本类型， == 比较的是值 对于引用类型， == 比较的是地址 基本类型与字符串之间的转换： 基本类型 --\u0026gt; 字符串 1、基本数据类型的值+\u0026#34;\u0026#34; 最简单的方式（工作中常用） 2、使用包装类的静态方法 static String toString(int i) 将i变为字符串形式 如 Integer.toString(100); 3、使用String类的静态方法 static String valueOf(int i) 将i变为字符串形式 如 String.valueOf(100); 字符串 --\u0026gt; 基本类型 使用包装类的静态方法 parseXX(\u0026#34;字符串\u0026#34;) Integer static int parseInt(String s) 如 Integer.parseInt(\u0026#34;100\u0026#34;); ... ... 泛型: 泛型名字不一定是E，可以是任意大写字母。 类: public class ClassName\u0026lt;E\u0026gt; { ... 在类内将需要的地方都用E代替} 实例化对象时确定类型 方法: 修饰符 \u0026lt;E\u0026gt; 返回值类型 方法名(参数列表){ ... } 调用方法时确定类型 接口: 含有泛型的接口定义与类相同。 确定类型的方法：1、在实现类中确定类型 2、实现类依然沿用接口的泛型E，实现类创建对象时确定类型 通配符: \u0026lt;?\u0026gt; 代表任意数据类型， 使用: 例如当多个不同类型的ArrayList集合要作为参数调用同一个方法时，可以将参数设置为ArrayList\u0026lt;?\u0026gt; list方便接受任意类型。 高级使用: ? extends E 表示 ? 只能是E的子类/本身 ? super E 表示 ? 只能是E的父类/本身 static: 带上static的成员变量或函数，不属于对象，而是属于类，所有对象共享。 类名.静态变量 类名.静态方法() 注意事项：静态不能直接访问非静态 --\u0026gt; 在内存中，先有静态，后有非静态 静态不能使用this 静态代码块：static{ ... } 首次用到类时，静态代码块唯一执行一次。 典型用途：一次性地对静态成员变量赋值。 override: 在子类的覆盖重写方法前面加上 @override 可以检验该方法是否为重写方法（建议写上） 子类方法的返回值的范围必须 小于等于 父类方法的返回值的范围。 子类方法的权限必须 大于等于 父类方法的权限 权限： public \u0026gt; protected \u0026gt; (default) \u0026gt; private (default) 表示什么也不写，留空。 同一个类 YES YES YES YES (我自己) 同一个包 YES YES YES NO (我领居) 不同包子类 YES YES NO NO (我儿子) 不同包不同类 YES NO NO NO (陌生人) abstract: 抽象方法：只定义，不实现。加上abstract关键字，去掉大括号，直接分号结束。 抽象类： 抽象方法所在的类，必须是抽象类。在class前加上abstract即可。但抽象类中不一定包含抽象方法（通常是有的）。 使用步骤： 抽象类不能直接创建对象。 必须用一个子类继承抽象父类。 子类必须覆盖重写抽象父类中的所有抽象方法。--\u0026gt;此处覆盖重写即实现：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。 创建子类对象，并使用。 interface： 概念：接口就是多个类的公共规范。是一种引用数据类型，最重要的就是其中的抽象方法。 定义：public interface 接口名称 { ... } 包含：常量、抽象方法、默认方法、静态方法、私有方法。 常量：可以理解为成员变量，但是必须使用 public static final 三个关键字修饰，故相当于常量。 public static final 数据类型 常量名称 = 值 （三个关键字可省略，但不能换为别的） 注意：1、接口中的常量可以省略public static final，但写不写效果一样。 2、接口中的常量必须手动赋值，不能不赋值。赋值之后无法改变。 3、常量名称全部大写，由下划线连接。 使用：接口名称.常量 抽象方法：1、接口中的抽象方法，修饰符固定为 public abstract (可省略，但不能换为别的) 2、方法的三要素可随意定义。 默认方法：public default 返回值类型 方法名(参数列表) {方法体} (public可省略，default不能省略) 可以解决接口升级的问题。（不想改变实现类，但是接口中又想要添加新方法，则接口就可以用默认方法自己实现）（实现类可以覆盖重写默认方法） 默认方法会被实现类继承，故可以通过实现类的对象访问默认方法。 静态方法：public static 返回值类型 方法名(参数列表) {方法体} (public可省略，static不能省略) 使用：接口名称.静态方法(参数); 不能通过对象访问。 私有方法：1、普通私有方法：解决多个默认方法之间的重复代码问题 private 返回值类型 方法名(参数列表) {方法体} 只有接口中的默认方法能访问。 2、静态私有方法：解决多个静态方法之间的重复代码问题 private static 返回值类型 方法名(参数列表) {方法体} 只有接口中的默认方法和静态方法能访问。 使用：1、接口不能直接使用，必须有一个“实现类”来“实现”该接口。 public class 实现类名称 implements 接口名称 {...} 2、接口的实现类必须实现接口中的全部抽象方法。去掉abstract关键字，加上大括号实现体。 3、创建实现类对象，使用。 注意事项：1、接口没有静态代码块和构造方法。 2、如果实现类没有覆盖重写所有接口中的所有方法，则该实现类自己就必须是抽象类。 3、一个实现类可以实现多个接口 public class 类名 implements interface1, interface2 {}。 4、若一个类实现的多个接口中有重名的抽象方法，则只需实现一个即可。 5、若一个类实现的多个接口中有重名的默认方法，则该实现类必须对重名默认方法覆盖重写。 6、若一个类的直接父类中的方法和它实现的接口中的默认方法重名，则优先使用直接父类的方法。 在java中【继承 优先于 接口】 7、接口是多继承的。多个父接口当中的抽象方法如果重名，没关系。 多个父接口当中的默认方法如果重名，则子接口必须对重名的默认方法覆盖重写，【而且带着default关键字】 多态：（一个子类对象既有子类形态，又有父类形态）一个对象拥有多种形态，即【对象】的多态性。【多态性指的是对象，而不是类】 代码中体现多态性： 父类引用指向子类对象。 格式 父类名称 对象名 = new 子类名称(); 或 接口名称 对象名 = new 实现类名称(); 【初步理解: 定义了一个指向子类对象的父类引用，这个引用指向的是子类的对象，但是只能访问父类大小的内存空间，所以它只能访问父类继承到子类当中的成员 （包括成员变量和成员函数）的那部分内存空间，而不能访问子类独有的多出来的那部分内存空间，而对于被子类重写了的方法，该引用依然可以访问 这部分内存，只是内存中的内容已经被改写了，所以访问到的是子类重写之后的方法。综上所述，该引用能访问的范围是所有从父类继承下来的变量和 父类独有方法，以及被子类重写之后的方法。】 多态对象访问成员变量： 对象名.成员变量 访问的是父类的成员变量，若没有则向上找，不会向下找。 不能用这种方法访问子类特有成员变量。 多态对象访问成员函数： 若子类重写了父类的成员函数，则访问子类的成员函数。 若子类没有重写，则访问父类的成员函数，没有则向上找。 同样不能访问子类特有成员函数。 记忆口诀；对于成员变量，等号左边是谁就优先用谁。对于成员方法，new的是谁就优先用谁。 使用多态的好处：比如将父类的引用作为参数传入方法中，则该引用可以指向不同的子类对象使方法实现不同的功能，却不需要改变方法中的任何代码。 对象的向上转型： 在特定场合会自动向上转型，如方法参数要求为父类，但是传入一个子类对象也正确，这时就发生了自动向上转型。与int double发生自动类型转换原理一样。 格式：与多态相同：父类名称 对象名 = new 子类名称(); 含义：创建一个子类对象，把它当作父类来看待使用。 【向上转型一定是安全的】从小范围转向了大范围，如将小范围的猫向上转型为更大范围的动物。 类似于将short转换为int。 弊端：不能访问子类特有方法。 对象的向下转型：其实是一个【还原】的动作。 格式： 子类名称 对象名 = (子类名称) 父类对象; (子类名称)必须有，不能省略。 含义： 将向上转型之后的父类对象还原为本来的子类对象。 注意： 只有本来是猫，向上转型为动物后，再向下转型为猫才是正确的。 若本来不是猫，却硬要向下转型为猫就会出错(编译不会报错，但运行会出现异常ClassCastException)。 instanceof: 格式： 对象名 instanceof 类名 作用： 返回一个布尔值，判断前面的对象能不能当作后面类的实例。 应用： 在向下转型之前，判断需要转型的对象是不是目标类的对象，是则向下转型，不是则不转型。 final: 该关键字表示最终的，不可再改变的。 用法: 修饰一个类、方法、局部变量、成员变量。 修饰一个类： public final class 类名 {...} 不能有子类。 修饰一个方法： 该方法不能被重写。 对于类和方法，abstract 和 final 不能同时使用，会矛盾。 修饰一个局部变量： 一次赋值，终生不变。（可以先定义，再赋值。分两步）--对于基本类型，值不可变。对于引用类型，地址值不可变。 修饰一个成员变量： 由于成员变量有默认值，所以不能分两步，必须当场手动赋值或通过构造函数赋值。 修饰一个数组或集合： 该数组或集合不能再被赋值，但内部的数据还可以改变。 内部类： 一个类内部包含另一个类，即一个事物内部包含另一个事物。 例如 身体和心脏的关系 分类： 成员内部类 局部内部类（包含匿名内部类） 成员内部类：修饰符 class 外部类名称 { 修饰符 class 内部类名称 {...} ... } 内用外，随意访问。外用内，需要内部类对象。 在main方法中使用：1、间接方式： 在外部类的方法中调用内部类，然后main通过访问外部类的方法调用内部类。 2、直接方式： 外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称(); 当局部变量、内部类的成员变量、外部类的成员变量重名时： 内部类的成员方法调用内部类的成员变量用this.内部成员变量。 内部类的成员方法调用外部类的成员变量用Outer.this.外部成员变量。 局部内部类：如果一个类定义在方法内部，就是局部内部类。---只有当前所属的方法才能使用它，出了这个方法就不能使用了。 格式：修饰符 class 外部类名称 {... 修饰符 返回值类型 外部类方法名称(参数列表) { class 内部局部类名称 {...} ... } ...} 注意：若局部内部类要访问所在方法的局部变量，则该局部变量必须是【有效final的】（即可以不写final关键字，但是不能变） 因为局部内部类在堆中，生命周期长，而局部变量在栈中，生命周期短，所以不能变。 【匿名内部类】：【用的最多】 如果接口的实现类（或者父类的子类）只需使用唯一的一次，则可以省略该类的定义，而改为使用匿名内部类。 格式：接口名称 对象名 = new 接口名称() { 重写所有抽象方法 }; 注意：1、匿名内部类只能唯一【创建一次对象】。若想多次创建对象，就要单独定义实现类。 2、匿名对象只能唯一【调用一次方法】。若想多次调用方法，就要给对象起个名字。 3、匿名内部类是省略了实现类/子类名称。而匿名对象是省略了对象名称。他俩不是一回事。 new 接口名() { 重写所有抽象方法 }.方法(参数); 即匿名内部类又匿名对象的使用方法。 异常: throw : 用于抛出异常， 例如: throw new NullPointerException(\u0026#34;异常产生的原因\u0026#34;) 若抛出运行时异常，可不理会，默认由JVM处理 若抛出编译器异常，则必须处理。throws或try-catch throws: 声明异常。 (用于甩锅) 格式: 修饰符 返回值类型 方法名(参数列表) throws AAAException, BBBException... {throw new AAAException(\u0026#34;原因\u0026#34;)...} 注意: 1、throws必须写在方法声明处 2、throws后面必须是Exception或者是其子类 3、throws后面必须声明方法内部抛出的所有异常 4、若调用了一个声明抛出异常的方法，则必须处理这些异常。可以继续抛出，也可以自己处理。 try-catch: 自己处理异常 try可以抛出多个异常，这时需要使用多个catch来捕获异常。 try中若产生异常，则try代码块中产生异常之后的代码不会执行，而跳转到catch。 try中若没有产生异常，则执行完try中的代码继续执行try-catch之后的代码。 finally: 不论是否发生异常，finally代码块中的代码一定会执行。 格式 : try{} catch{} finally{} 注意 : finally必须与try一起使用，一般用于资源释放。 正是由于其有一定会执行到，所以若finally代码块中有return语句，则一定会返回finally中的结果。（要避免） 注意 : 子类异常一定要与父类异常一致。 Thread : Thread类是描述线程的类，要实现多线程，必须继承Thread类 每个线程拥有一个自己独立的栈，但是共享进程的堆空间。 Thread.sleep(毫秒) // 静态方法 睡眠 Thread thread = Thread.currentThread(); // 获取当前线程 第一种方法： 创建Thread类的子类 1、创建Thread类的子类，并重写run方法，其中设置线程的任务 2、创建子类对象，并执行start方法 (执行start方法会创建一个新的栈空间，并在该栈空间中执行run方法)(每执行一次步骤2，就开启一个新的线程) 第二种方法： 实现Runnable接口 (推荐使用这种) ---\u0026gt; 使用该方法时，Thread 类是咱们自定义类的静态代理类 1、创建一个Runnable接口的实现类，并重写run方法，其中设置线程的任务 2、创建对象，并将其作为参数传递给Thread类的构造方法，再调用start方法。 new Thread(new MyRunnable()).start(); 匿名内部类实现： new Thread(new Runnable(){重写run方法}).start(); 第三种方法： 实现Callable\u0026lt;V\u0026gt;接口 （面试可能会问到） Callable接口类似于Runnable，【Runnable不会返回结果，也不会抛出检查异常，Callable可以】 1、创建一个Callable\u0026lt;V\u0026gt;接口的实现类，并重写call方法，其中设置线程的任务 2、在使用的地方创建该类对象 obj 。 3、ExecutorService executorService = Executors.newFixedThreadPool(5); // 创建执行服务 4、Future\u0026lt;V\u0026gt; future = executorService.submit(obj); // 提交执行 5、V result = future.get(); // 获取结果 6、executorService.shutdownNow(); // 关闭服务 同步： 多个对象访问同一个资源，可以并发读取，但当其中某一个对象要修改时，就必须实现同步 所有的对象都拥有一把锁。 锁对象选取总结为一句话就是 在同步代码中要改变谁就锁谁。 方法一： 同步代码块： synchronized (锁对象) {访问共享数据的代码} 线程不仅要抢夺CUP，还要占用锁对象。同时拥有才能执行代码 锁对象可以是任意对象，但必须是同一个对象，推荐将共享资源作为锁对象。线程占用锁对象后直到执行完毕才释放。 方法二： 同步方法 修饰符 synchronized 返回值类型 方法名 (参数列表) {访问共享数据的代码} // 该方法即为同步方法 首先将 访问共享数据的代码块 抽取出来，作为上述方法。 同步方法的锁对象默认为 this ，即同步方法所在类的对象；创建该类的对象后，该对象调用同步方法时就会锁住对象自己。 当同步方法同时也是静态方法时，锁对象为同步方法所在类的 Class 对象。 方法三： Lock锁 Lock是一个接口，有两个方法 void lock() 获取锁 和 void unlock() 释放锁 它有一个实现类ReentrantLock（可重入锁）， 先实例化一个ReentrantLock对象。 在出现安全问题代码之前用该对象调用 lock() 方法。在出现安全问题代码之后用该对象调用 unlock() 方法。 lock() 和 unlock() 方法建议放在 try --- finally 代码块中 线程状态： 线程停止：不推荐使用 Thread 类提供的 stop() 等方法。推荐自己通过一个标志位控制停止 public class MyRunnable implements Runnable { private boolean flag = true; @Override public void run() { while (flag) { TODO... } } public void stop() { flag = false; } } 通过调用自己实现的 stop 方法来停止线程 下方所有方法都是 Thread 类中的方法！ 线程休眠：Thread.sleep(毫秒) // sleep 不会释放锁、 wait 会释放锁。 线程礼让： Thread.yield(); 使当前线程从运行状态变为就绪状态，让 cpu 从所有就绪的线程中挑一个运行。 礼让有可能不成功，因为 cpu 可能再挑选一次还是让当前线程继续执行。 线程强制执行： join() ，相当于插队，停止现在执行的线程，立刻执行自己的线程，且本线程执行结束才能执行其他线程 public class MyRunnable implements Runnable { @Override public void run() { for (int i = 0; i \u0026lt; 1000; i++) { System.out.println(\u0026#34;Runnable \u0026#34; + i); } } public static void main(String[] args) throws InterruptedException { MyRunnable myRunnable = new MyRunnable(); Thread thread = new Thread(myRunnable); thread.start(); for (int i = 0; i \u0026lt; 500; i++) { if (i == 200) { thread.join(); } System.out.println(\u0026#34;主线程\u0026#34; + i); } } } 在上方举例代码中，主线程执行到200之前，主线程和Runnable线程交替执行，当主线程执行到200次时， Runnable 线程插队接着执行，之后Runnable线程全部执行完毕后才由主线程继续执行。 查看线程状态：Thread.State state = thread.getState(); // Thread.State 是一个枚举类型 线程优先级：1 最小；10 最大；默认为5。优先级越高在就绪状态很大可能越早执行，但也不是一定。 守护（daemon）线程： 线程分为用户线程和守护线程。 虚拟机必须保证用户线程执行完毕，但不用等待守护线程执行完毕。 守护线程有：后台记录日志、监控内存、垃圾回收等 private boolean daemon = false; // 默认 daemon 属性是关闭的，即默认为用户线程 thread.setDaemon(true); // 可通过这样将线程设置为 守护线程。 // 将线程设置为守护线程之后，虚拟机将不再保证该线程是否执行结束， // 即只要当用户线程执行结束后就将整个程序关闭，而不考虑守护线程此时是否已经执行完毕。 线程池 : 底层原理 ： 线程池就是一个容纳多个线程的容器，可由集合实现 使用步骤: 1、使用线程池工厂类Executors里面的静态方法newFixedThreadPool生产一个指定线程数量的线程池，由ExecutorService接口接收。 2、创建Runnable接口的实现类，重写run方法，设置线程任务。 3、调用ExecutorService中的execute方法，传递线程任务，开启线程，执行run方法。 例: ExecutorService executorService = Executors.newFixedThreadPool(5); // 创建服务 Runnable runnable = new Runnable() { //此处虽然new 的是Runnable接口，但是立即重写了run方法，故相当于其实现类。 @Override public void run() { //线程任务 } }; executorService.execute(runnable); // 执行服务 executorService.shutdownNow(); // 关闭服务 ExecutorService 中的 submit()方法和 execute()方法作用相同，只是适用于不同场景 void execute(Runnable command) // 执行任务，没有返回值，一般用于执行 Runnable \u0026lt;T\u0026gt; Future\u0026lt;T\u0026gt; submit(Callable\u0026lt;T\u0026gt; task); // 执行任务，有返回值，一般用于执行 Callable Lambda表达式 : 可推导，可省略 格式： () -\u0026gt; {} 使用前提： 必须是接口，且接口中有且只有一个抽象方法 (有且只有一个抽象方法的接口，称为\u0026#34;函数式接口\u0026#34;) 可以省略的内容： 1、(参数列表) 参数列表中的数据类型可以省略， 如果参数只有一个，则括号()也可以省略 2、{方法体} 如果{}中的代码只有一行，无论是否有返回值，都可以省略 {}， return， 分号 （要省一起省） 注解: @override 检测是否为覆盖重写 @FunctionalInterface 检测是否为函数式接口 ------------------------------------------------------------------------------------------------------------------ API使用： Scanner： 功能：从键盘输入数据到程序。 包路径：java.util.Scanner 实例化：Scanner sc = new Scanner(System.in); System.in 表示从键盘输入数据。 方法：---其实键盘输入的一切东西都是字符串，使用不同的函数会将字符串转换为相应的类型。--\u0026gt;故若记不住也可以一直使用sc.next();之后再转换类型 获取键盘输入的一个int数字： int num = sc.nextInt(); 获取键盘输入的一个字符串： String str = sc.next(); 读取文件内容：Scanner in = new Scanner(Paths.get(\u0026#34;\\u202AC:\\\\Users\\\\Lenovo\\\\Desktop\\\\1.txt\u0026#34;), StandardCharsets.UTF_8); 之后再用in的各种方法。nextLine(); next(); nextInt(); 等 Random: 功能: 获取随机数。 实例化：Random rand = new Random(); 方法：int rand_num = rand.nextInt(n) 在[0, n)中随机取一个数字。----\u0026gt; m + rand.nextInt(n)取到[m, m + n）中的随机数。 ArrayList: [元素1， 元素2， 元素3， ...] 功能：可变长的数组。 泛型：装在集合中的元素必须是同一个类型，只能是引用类型，不能是基本类型。 实例化：ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); 注意事项：直接打印list输出的不是一个地址值，而是空的中括号。 不支持下标索引，只能用get()方法获取。 常用方法：list.add(\u0026#34;李沁\u0026#34;) 添加元素，返回一个boolean值，表示添加的动作是否成功。一定成功，可以不接受返回值。 list.get(index) 根据索引获取元素，返回获取的元素。 list.remove(index) 根据索引删除元素，返回被删除的元素。 list.size() 获取集合长度。 若想在ArrayList中存储基本类型，需要使用其包装类(引用类型)： 基本类型 包装类 byte Byte short Short ... ... （与上方一样，只需首字母大写） int Integer 【特殊】 char Character 【特殊】 ArrayList\u0026lt;Integer\u0026gt; list_int = ArrayList\u0026lt;\u0026gt;(); // 自动装箱：int --\u0026gt; Integer 自动拆箱：integer --\u0026gt; int String: 功能：字符串（常量） --\u0026gt; Java中所有的双引号字符串都是String类的实例。 实例化：直接创建： String str1 = \u0026#34;李沁\u0026#34;; 在字符串常量池中， 其他实例化方式都在堆中，不在池里。 使用空构造函数： String str2 = new String(); 根据字符数组创建： char[] charArray = { \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39; }; String str3 = new String(charArray) // abc 根据字节数组创建： byte[] byteArray = { 97, 98, 99 }; String str3 = new String(byteArray) // abc 方法：str1.equals(str2) 比较str1和str2的值是否相等，返回boolean。 常变量比较时推荐 常量.equals(变量) str1.equalsIgnoreCase(str2) 忽略大小写。 str.length() 长度 str.concat(str1) 拼接 str.charAt(index) 根据索引返回字符 str.indexOf(str1) 在str中查找str1，返回首次找到的索引值；若没有，返回-1 str.substring(index) 截取，从index到末尾 str.substring(int begin, int end) 截取，[begin, end) str.toCharArray() 转换为字符数组 str.getBytes() 转换为字节数组 用于遍历字符串 str.replace(old, new) 用new替换str中的old str.split(regex) 切割，返回数组 Arrays: 功能：与数组相关的类，提供大量静态方法，用来实现数组常见的操作。 方法： Arrays.toString(数组) 将参数变成字符串 [元素1， 元素2，元素3，...] Arrays.deepToString(多维数组) 将参数变成字符串 [元素1， 元素2，元素3，...] Arrays.sort(数组) 排序。默认从小到大，自定义类型的排序需要Comparable或Comparator接口 Arrays.equals(数组1， 数组2) 两个数组完全相等是返回ture Math: 功能：数学相关的类，提供大量静态方法，用来实现数学运算相关的操作。 方法： Math.abs() 绝对值 Math.ceil() 向上取整 Math.floor() 向下取整 Math.round() 四舍五入 Collection接口: 所有单列集合的顶层接口 List接口: 1、有序（存入和取出的顺序一致） 2、允许元素重复 3、有索引 Vector:(了解) Arraylist:(重点) 底层由数组实现，查询快，增删慢。 LinkedList:(次之) 底层由链表实现，查询慢，增删快。 特有方法: addFirst() == push() addLast() == add() getFirst() getLast() removeFirst() == pop() removeLast() 这两种方法都会删除并返回 共有方法： void add(int index, E element) 将元素添加到索引位置 E get(int index) 返回索引处的元素 E remove(int index) 删除索引位置元素,并返回被删除的元素 E set(int index, E element) 替换索引位置元素,并返回被替换前的元素 Set接口: 1、不允许元素重复 2、没有索引 TreeSet: (无序) (了解) 底层由二叉树实现，一般用于排序。 HashSet: (无序) (重点) 底层由哈希表实现。(查询速度很快) 注意: 使用HashCode存储自定义类型时，需要重写HashCode()和equals()。可通过alt + insert直接添加。才能保证元素不重复。 LinkedHashSet: (有序) (次之) 底层由哈希表+链表实现。 extends HashSet 比HashSet多了一条链表，用来记录元素的顺序 共有方法： boolean add(E e) 添加， 无需接收 boolean remove(E e) 删除， 若有e，删除并返回true。若没有e，无动作并返回false void clear() 清空。 但不删除集合。 boolean contains(E e) 是否包含。 boolean isEmpty() 是否为空。 int size() 元素个数。 Object[] toArray() 转为数组。 哈希值: 是一个十进制的整数，由操作系统随机给出的对象的逻辑地址值。 哈希表: 拉链法。由哈希值为元素组成数组（初始长度为16）。若哈希值相等，则以链表方式挂在该哈希值后面。当链表长度超过8时，变为红黑树。检索速度加快。 Collections : 是Collection的工具类，提供大量静态方法，用于操作集合。 以ArrayList为例: ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); addAll(Collection\u0026lt;T\u0026gt; c, T... elements) : 往集合中添加多个元素。 Collections.addAll(list, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); shuffle(List\u0026lt;T\u0026gt; list) : 打乱顺序。 Collections.shuffle(list); sort(List\u0026lt;T\u0026gt; list) : 排序， 默认升序。 Collections.sort(list); 注意：若要对自定义类型排序，则被排序的类必须实现Comparable接口，重写compareTo方法来定义排序规则。 this - 参数 ： 升序 (了解)另一种sort()： Collections.sort(arr, new Comparator\u0026lt;Integer\u0026gt;() { @Override public int compare(Integer o1, Integer o2) { return o1 - o2; } }); 这种方法List接口中的方法类似-\u0026gt; arr.sort(new Comparator\u0026lt;Integer\u0026gt;() {...}) Iterator: 迭代器 是接口 也有泛型 --\u0026gt; Collection\u0026lt;String\u0026gt; array = new ArrayList\u0026lt;\u0026gt;(); Iterator\u0026lt;String\u0026gt; it = array.iterator(); 常用方法: boolean hasNext() 是否有下一个元素。 E next() 返回下一个元素。 使用： Collection中的实现类为 iterator() 1、实例化iterator 2、用hasNext() 3、用next() 增强for循环: 专门用来遍历数组与集合，由Iterator迭代器实现，遍历时不能做增删操作。 for (元素数据类型 变量 : 集合或数组名) { ... } Map: --\u0026gt; 字典 键值对 key是唯一的 HashMap: (无序) 底层为哈希表 LinkedHashMap : (有序) 底层为哈希表+链表(保证顺序) 方法: V put(K key, V value) : 添加，若key值不存在，则添加并返回null。若key值已存在，则更新value值，并返回被替换掉的value值。一般不接收返回值。 V remove(K key) : 删除，若key值存在，返回被删除的value。若key不存在，则返回null。 V get(K key) : 获取，若key值存在，返回对应的value。若key不存在，则返回null。 boolean containsKey(k key) : 判断是否包含指定的键。 Set\u0026lt;K\u0026gt; keySet() 返回由键组成的Set，之后可以通过遍历Set来遍历Map。 for (K key : map.keySet()) { sout(key + map.get(key)) } Set\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; entrySet() --\u0026gt; for (Map.Entry\u0026lt;K, V\u0026gt; entry : map.entrySet()) { 也是遍历，看起来不好用的样子 System.out.println(entry.getKey() + \u0026#39; \u0026#39; + entry.getValue());} 用Map存储自定义类型时，若自定义类型作为键，则必须将该类重写HashCode和equals方法，保证键是唯一的。 of方法： static \u0026lt;E\u0026gt; List\u0026lt;E\u0026gt; of (E... elements) 1、of方法只适用于List, Set, Map 接口。而不适用于他们的实现类 2、of方法返回一个不能被操作的集合。因此适合初始化，且初始化后不能改变。 3、Set 和 Map 调用of方法时不能有重复元素。 ------------------------------------------------------------------------------------------------------------------ ------------------------------------------------------------------------------------------------------------------ ------------------------------------------------------------------------------------------------------------------ ------------------------------------------------------------------------------------------------------------------ Object： 以下方法所有类都有，只是重写之后功能有所不同。 toString() 直接打印对象的名字，就是调用对象的toString方法-\u0026gt;得到对象的地址值。 没有意义。 重写：可以和构造方法与Getter/Setter方法一样的步骤添加（重写）toString方法-\u0026gt;打印出属性值。 equals() boolean equals(Object obj) 判断两个对象是否\u0026#34;相等\u0026#34;，返回布尔值。 比较两个对象的地址值，同上方的==作用一样。 没有意义。 重写： 原理 --\u0026gt; 由于equals方法的参数类型为Object,所以默认向上转型了。若想比较两个对象的属性值，需要先向下转型。 同样可以 alt + insert 直接生成equals方法。 判断两对象的属性值是否都一样。 hashCode() 返回对象的哈希码值 // synchronized 能实现线程同步、但无法实现线程间通信、用如下 4 个方法可以实现线程间通信。 wait() 等待。在被唤醒之前，放弃CPU的使用权 wait(毫秒值) 在被唤醒或到时间之前，放弃CPU的使用权 notify() 唤醒。随机唤醒锁对象中的一个进程 notifyAll() 唤醒锁对象(对象监视器)中的所有进程 这两种常搭配同步机制使用 objects: 该工具类提供的方法是容忍空指针的。 若 a=null，则a.equals(b) 报错。而Objects.equals(a, b) 正常运行。 Objects.requireNonNull(T obj) 查看obj是否为空，用来判断参数的合法性。 旧API : Date: 1970年1月1日 00:00:00 作为0时刻 Date() 无参构造--\u0026gt; 获取当前时间。 Date(long date) 有参构造 --\u0026gt; 输入毫秒值，输出相对于0时刻的日期。 getTime() 把日期转换为毫秒 DateFormat: 格式化日期。 抽象类。 String format(Date date) 把日期格式化为字符串。 Date parse(String source) 把符合的字符串解析为日期。 SimpleDateFormat: DateFormat的实现类 SimpleDateFormat(String pattern) 有参构造 参数一般为 \u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34; 使用上方两个方法。 注意：用parse时，参数的模式必须与构造SimpleDateFormat对象时的模式完全一样，否则报错。 Calendar: 日历类 抽象类 getInstance() 静态方法 返回Calendar类的子类对象 Calendar instance = Calendar.getInstance(); 功能：使用默认时区和语言环境获得一个日历 get(field) 返回给定字段的值。 字段值有YEAR MONTH DATE HOUR MINTER SECOND 年月日时分秒 都是静态变量 set(field, value) 将给定的日历字段设置为给定值 add(field, amount) 修改指定的字段，通过amount的正负实现加减。 Date getTime() 将Calendar转为Date对象 原理：实际上该类中有一个fields数组，上述的方法都是在对该数组操作。字段值YEAR等固定为0，1，2等，作用是对该数组的索引。 新API LocalDate, LocalTime, LocalDateTime : 之前的Date类和Calendar类都有缺陷。JDK8 新引入日期时间类 由于LocalDateTime类使用较多，故以他为例，其余两种用法相同。 构造方法： 1、LocalDateTime now = LocalDateTime.now(); 获取当前时间 2、LocalDateTime localDateTime = LocalDateTime.of(2020, 1, 20, 12, 20, 34); 获取指定时间 常用方法： now.getDayOfMonth() 获取对象是这个月的第几天。类似的方法获取其他属性。 LocalDateTime time = now.withDayOfMonth(12); 使用类似方法设置属性。但是该语句执行后，time为修改后的值，而now的值不变。体现了时间的不可变性。 LocalDateTime plusDays = now.plusDays(3); 使用类似方法修改属性，在原有基础上加3天。不可变性同上。 LocalDateTime months = now.minusMonths(2); 使用类似方法修改属性，在原有基础上减2月。不可变性同上。 Instant 替换 Date 类 DateTimeFormatter : 类似于SimpleDateFormat 日期时间的格式化与解析 DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); 构造 String format = formatter.format(LocalDateTime.now()); 格式化 TemporalAccessor parse = formatter.parse(\u0026#34;2021-01-21 22:00:25\u0026#34;); 解析 System: 提供大量静态方法， 可以获取与系统相关的信息即服务 static currentTimeMillis() 返回以毫秒为单位的当前时间, 用来测试程序的效率。 static arraycopy(原数组， int 原数组起始位置， 目标数组， int 目标数组起始位置， int 要复制的数组元素的数量) 复制数组 StringBuilder: 在String类中，字符串是常量，底层是被final修饰的数组。字符串相加时，占用内存多，效率低下。 StringBuilder类是字符串缓冲区，可以提高字符串的操作效率（看成是一个长度可以变化的字符串） 底层也是一个数组，但是没有被final修饰，可以改变长度。 在内存中始终是一个数组，初始容量为16个字节，超出会自动扩容，占用空间少，效率高。 构造函数： StringBuilder() 无参构造，空字符串。 StringBuilder(\u0026#34;abc\u0026#34;) 有参构造，即参数的字符串。 成员函数： append(任意类型) 添加到字符串，并返回自身。所以无需接收。 toString() 将StringBuilder对象，转换为String对象。 通过StringBuilder的构造方法可以将String转换为StringBuilder. reverser() 翻转 File: 文件类，主要用于文件和目录的创建，查找和删除等操作 File类已被Path取代 静态方法: static String\tpathSeparator 路径分隔符 windows ; 分号 linux : 冒号 static String\tseparator 文件名称分隔符 Windows \\ 反斜杠 Linux / 正斜杠 构造方法: File(String pathname) 路径名 ==\u0026gt; 文件/文件夹 相对/绝对 存在/不存在 File(String parent, String child) 父路径，子路径 File(File parent, String child) 父路径，子路径。父路径是File型，故可以使用其方法做调整 常用方法: 获取方法: String getAbsolutePath() 返回绝对路径名 String getPath() 返回路径名 String getName() 返回末尾文件/文件夹 名字 long length() 返回文件大小（以字节为单位） 不能是文件夹，若路径不存在，返回0 判断方法: boolean exists() 文件或文件夹是否真实存在 boolean isDirectory() 路径是否以文件夹结尾 前提：真实存在 boolean isFile() 路径是否以文件结尾 前提：真实存在 创建删除: boolean creatNewFile() 不存在时创建文件 不能创建文件夹，路径必须存在 boolean delete() 删除文件/文件夹 boolean mkdir() 创建单级空文件夹 boolean mkdirs() 创建单级/多级空文件夹 多级文件夹：父文件夹中包含子文件夹 遍历文件夹: String[] list() 返回由所有文件或子目录组成的字符串数组 File[] listFiles() 返回由所有文件或子目录封装而成的文件数组 过滤器: File[] files = dir.listFiles(new FileFilter(){重写accept()方法，该方法中写入过滤规则，留下的返回ture，不要的返回false}) 可以写为Lambda表达式。 读取文件的方法： Scanner in = new Scanner(Paths.get(\u0026#34;C:\\\\Users\\\\Lenovo\\\\Desktop\\\\1.txt\u0026#34;), StandardCharsets.UTF_8); String num = in.nextLine(); BufferedReader reader = Files.newBufferedReader(Paths.get(\u0026#34;C:\\\\Users\\\\Lenovo\\\\Desktop\\\\1.txt\u0026#34;), StandardCharsets.UTF_8); String str = reader.readLine(); （不好用）BufferedReader bufferedReader = new BufferedReader(new FileReader(\u0026#34;C:\\\\Users\\\\Lenovo\\\\Desktop\\\\1.txt\u0026#34;)); String s = bufferedReader.readLine(); Properties: 用来加载配置文件, 示例如下： Properties properties = new Properties(); // ClassLoader classLoader = Person.class.getClassLoader(); 注释掉的两句作用与下一句一样 // InputStream is = classLoader.getResourceAsStream(\u0026#34;jdbc.properties\u0026#34;); // 路径相对于src FileInputStream fis = new FileInputStream(\u0026#34;src\\\\jdbc.properties\u0026#34;); // 路径相对于Module而不是src properties.load(fis); String user = properties.getProperty(\u0026#34;user\u0026#34;); String passwd = properties.getProperty(\u0026#34;passwd\u0026#34;); System.out.println(user + \u0026#34; \u0026#34; + passwd); IO流: （默认相对路径在Module下） 基本流: OutputStream: 字节输出流 (一切都以字节为单位) (一次读写一个字节) 接口 共有方法: write(byte[] bytes) 写入多个字节 close() FileOutputStream: 文件字节输出流 构造方法: FileOutputStream(String name[, boolean append = false]) 参数为路径，即写入的目标文件路径，如果没有该文件，会先创建该文件。若append为ture，则为追加写，否则会覆盖原文件 FileOutputStream(File file[, boolean append = false]) 参数为文件，即写入的目标文件，append同上。 InputStream: 字节输入流 接口 共有方法: read() 读取一个字节,返回读到的内容，读到文件末尾返回-1 int read(byte[] bytes) 读取多个字节，将读取到的内容存入字节数组中，并返回读取的有效字节个数，读到文件末尾返回-1 close() FileInputStream: 文件字节输入流 构造方法: FileInputStream(String name) FileInputStream(File file) Reader: 字符输入流 抽象 共有方法: read() read(char[] c) close() 作用和上述相同,包括返回-1等等都相同，只是读取单位变为字符。 FileReader: 文件字符输入流 ---\u0026gt; 只能读取IDEA默认编码格式文件(即UTF-8) 构造方法: FileReader(String filename) FileReader(File file) Writer: 字符输出流 抽象 共有方法: write() 参数可以为单个字符，字符数组或字符串 close() FileWriter: 文件字符输出流 构造方法: FileWriter(String filename[, boolean append = false]) FileWriter(File file[, boolean append = false]) 注意: 这里的write方法是将数据写入内存缓冲区(字符转为字节)，flash方法或close方法会数据刷新到文件。因此必须调用close()方法。 Properties集合: 实现了Map\u0026lt;K, V\u0026gt; 唯一和IO流结合的集合 该集合的默认键和值都是字符串类型。store方法能把集合中的数据存入硬盘，load方法会加载到该集合中。 缓冲流: 创建一个缓冲区，减少系统IO次数，提高读写效率。 BufferedInputStream: 字节缓冲输入流 extends InputStream 用read写入，close关闭。只需要关闭缓冲流，基本流会随之关闭。 构造方法: BufferedInputStream(InputStream in[, int size]) read和write方法与基本流完全相同。 BufferedOutputStream: 字节缓冲输出流 extends OutputStream 用write写入，close关闭 构造方法: BufferedOutputStream(OutputStream out[, int size]) 参数可以传递FileOutputStream对象，可选参数size用于指定缓冲区大小 BufferedWriter: 字符缓冲输出流 extends Writer 构造方法: BufferedWriter(Writer out[, int size]) 可传入FileWriter 特有方法: void newLine() 无视系统差异，换行 BufferedReader: 字符缓冲输入流 extends Reader 构造方法: BufferedReader(Reader in[, int size]) 可传入FileReader 特有方法: String readLine() 读取一行数据，但不读取行末换行符。读到文件末尾返回null 转换流: 可以指定编码/解码的码表 OutputStreamWriter extends Writer: 步骤: 1、new对象 2、write() 3、close() 构造方法: OutputStreamWriter(OutputStream out[, String charsetName]) 参数一般传递为FileOutputStream。可选字段为编码表名称，不区分大小写，默认为UTF-8 InputStreamReader extends Reader: 步骤: 1、new对象 2、read() 3、close() 构造方法: OutputStreamWriter(InputStream in[, String charsetName]) (反)序列化流: 把对象以流的方式写入/读出到文件中 使用字节流 ObjectOutputStream: extends OutputStream 对象的序列化流 把对象以流的方式写入到文件中保存，叫写对象，也叫对象的序列化。 构造方法: ObjectOutputStream(OutputStream out) 参数一般传递为FileOutputStream。 特有方法: void writeObject(Object obj) 此处参数也可以是由obj组成的集合，如ArrayList\u0026lt;Person\u0026gt; list 被序列化的对象(即参数obj)必须实现Serializable接口，以激活(反)序列化功能。其为标记型接口，内部没有任何抽象方法。 ObjectInputStream: extends InputStream 对象的反序列化流 把文件中保存的对象以流的方式读出来，叫读对象，也叫对象的反序列化。 构造方法: ObjectInputStream(InputStream in) 参数一般传递为FileInputStream。 特有方法: Object readObject() transient关键字: 瞬态关键字，被其修饰的成员变量不能被序列化，没有替他功能。static关键字也有这个功能。 注意：为了避免InvalidClassException,在每个被序列化的对象中都显示声明一个序列号-\u0026gt; private static final long serialVersionUID = 42L 打印流: PrintStream System.out.println(); enum : 枚举类 类的对象只有确定的有限个，我们称之为枚举类 当需要定义一组常量时，强烈建议使用枚举类 默认继承java.lang.Enum 定义： 类似于接口的定义，创建Class包时，选项中就有Enum的选项。 public enum Season { SPRING(\u0026#34;春天\u0026#34;, \u0026#34;warm\u0026#34;), 默认由public static final 修饰 SUMMER(\u0026#34;夏天\u0026#34;, \u0026#34;sun\u0026#34;), 实例写在类的最前面 AUTUMN(\u0026#34;秋天\u0026#34;, \u0026#34;cool\u0026#34;), 实例之间用逗号分隔，最后一个结尾为分号 WINTER(\u0026#34;冬天\u0026#34;, \u0026#34;cold\u0026#34;); 为什么不需要显示声明成员变量(由局部变量代替)，暂时不清楚 Season(String seasonName, String seasonDec){} } 构造函数默认由private修饰，可省略不写。 静态方法： values() 返回枚举类型的对象数组，方便用于遍历枚举值 valueOf(String objName) 返回枚举类中对象名为objName的对象 如: Season winter = Season.valueOf(\u0026#34;WINTER\u0026#34;); toString() 返回当前枚举类对象常量的名字 反射: java.lang.Class 程序由javac.exe编译后，会生成一个或多个字节码文件(.class结尾)。 接着使用java.exe对某个字节码文件解释运行，就相当于将某个字节码文件加载到内存中，这个过程就叫类的加载， 加载到内存中的类就叫运行时类，这个运行时类就是Class的一个实例。 加载到内存中的运行时类会缓存一段时间，在此时间内以不同方式获取到的该运行时类的Class实例都是同一个。 获取Class实例的方法： 1、 Class clazz = Person.class; 2、 Person person = new Person(); Class clazz = person.getClass(); 3、 Class clazz = Class.forName(类相对于src的全路径); // 用的较多 ClassLoader：引导类加载器--》加载java核心类库 引导类加载器无法获取到 扩展类加载器--》加载jar包 通过Class实例.getClassLoader()即可获得类加载器，如 系统类加载器--》加载自定义类 Person.class.getClassLoader()获取的即为系统类加载器 无法创建实例的类型用 Class c = int.class; double.class; Math.class; 等 ArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); Class l1 = list.getClass(); 得到ArrayList\u0026lt;Integer\u0026gt;类的Class实例 l1.getDeclaredConstructors(); 获取所有构造函数，去掉Declared为只获取public的构造函数 l1.getDeclaredMethods(); 获取所有函数，去掉Declared为只获取public的函数 l1.getDeclaredFields(); 获取所有属性，去掉Declared为只获取public的属性 l1.getSuperclass(); 获取父类 l1.getGenericSuperclass(); 获取带泛型的父类 li.getInterfaces(); 获取接口 li.getPackage(); 获取包 li.getAnnotations(); 获取注解 for (Method method: l1.getDeclaredMethods()) { System.out.println(Modifier.toString(method.getModifiers()) + \u0026#34; \u0026#34; + method.getReturnType() + \u0026#34; \u0026#34; + method.getName() + \u0026#34;(\u0026#34; + Arrays.toString(method.getParameterTypes()) + \u0026#34;);\u0026#34;); } Field f = l1.getDeclaredField(\u0026#34;size\u0026#34;); 根据属性名称获取特定的Field对象。 f.setAccessible(true); 使其变为可访问的 Object v = f.get(list); Person person = new Person(\u0026#34;alice\u0026#34;, 21); 方法对象调用invoke方法来执行方法。 Class p = person.getClass(); public Object invoke(Object obj, Object... args) Method m = p.getMethod(\u0026#34;getName\u0026#34;); 第一个参数为对象名，之后的参数为方法的参数。 String s = (String) m.invoke(person); 调用的是静态方法时，第一个参数为null。 代理的作用就是在不修改源码的情况下，对目标对象的方法增强。 静态代理：接口 + 代理类 + 被代理类 --》 一个代理类只能对应一个被代理类 代理类与被代理类实现同样的接口 动态代理：接口 + 代理类 + 多个被代理类 --》 一个代理类可以对应多个被代理类 代理类与被代理类实现同样的接口 结合src/proxy/annotationProxy包下的例子理解 1、根据自己需求创建一个被代理类对象（想象在项目中，要增强功能时，一定在之前已经使用过这个对象） 2、根据这个被代理类对象，动态获取一个代理类对象（因此，没有显示的代理类，是被动态获取到的） 3、使用代理类对象调用被代理类的方法。（具体原理看包中例子的注释） ","keywords":[],"articleBody":"数组： 数组的初始化方式： 1、动态初始化（指定长度） 数据类型[] 数组名 = new 数据类型[数组长度]； 2、静态初始化（指定内容） 数据类型[] 数组名 = new 数据类型[] {元素1， 元素2， 元素3， ... }； 元素值可以是变量 省略的静态初始化 数据类型[] 数组名 = {元素1， 元素2， 元素3， ... }； 该方式不允许拆分为2步，即先定义数组名，再经行赋值。 直接打印数组名，打印的是数组的内存地址。 支持下标索引。 未初始化的默认初始值： 整数类型： 0 浮点类型： 0.0 字符类型： '\\u0000' 布尔类型： false 引用类型： null 获取数组长度： 数组名.length; 获取数组副本： 数组名.clone(); 成员变量与局部变量： 成员变量定义在类内，方法外。局部变量定义在方法内。 成员变量不要写static关键字。??? 成员变量有默认值，而局部变量没有默认值。 当成员变量与局部变量的命名冲突时，按照就近原则，优先使用局部变量。若想使用全局变量，使用this.成员变量名。 可变参数: 使用前提：当方法的参数类型确定，但是参数个数不确定时，使用可变参数。 使用格式：修饰符 返回值类型 方法名(数据类型...变量名) {} 例如: public void func (int... num) {} 原理： 可变参数底层是一个数组，根据传递参数个数的不同，会创建不同长度的数组，来存储这些参数。参数个数可以是0个或多个。 因此，方法中的变量名其实就是数组的名字，可以作为数组使用。 注意： 一个方法的参数列表中只能有一个可变参数。 如果方法有多个参数，则可变参数必须放在参数末尾。 类的使用: 1、导包：import 包路径.类名称 当类与当前文件处于同一个包中时，可以不用导包。只有java.lang下的包不需要导包，其他都需要导包。 但实际使用中，可以不用手动导包，当你使用某个类时，系统会自动帮你导包。 2、实例化： 类名称 对象名 = new 类名称(); 3、使用: 对象名.成员变量名 对象名.成员方法名(参数) Private: Getter: 函数格式必须是 getXXX 如果变量是布尔类型，则使用isXXX Setter: 函数格式必须是 setXXX Private修饰构造函数时，外部不能再构造该类的实例，故只能在类内构造好全部实例并赋给static类型的变量。叫构造函数私有化 this: this是当前对象的引用，即this和对象是同一个东西。 this.成员变量 调用本类成员变量 可以将类内的成员变量与方法中的同名局部变量区分。 this.成员方法 调用本类成员方法 this(...) 调用本类构造函数 --\u003e 写在第一行，只能调用一个。 若子类使用了this(...)，则不再默认赠送super()。 super: super.成员变量 调用父类成员变量 可以将父类中的成员变量和子类中的同名成员变量区分。 super.成员方法 调用父类成员变量 super(...) 调用父类类构造函数 --\u003e 写在第一行，只能调用一个。 构造函数： 格式： public 类名（参数类型 参数名称 ， ...）{...} 注意事项： 构造方法的名称和类名要严格相等，大小写敏感。 构造方法没有返回值类型。 若不明确定义构造函数，则会自动生成默认构造函数，若手动定义了任意形式的构造函数，编译器将不会再生成默认构造函数。 构造函数支持重载 继承中的构造函数: 构造链：同C++一样--\u003e 祖宗 \u003e 父类 \u003e 子类 子类构造方法中若不显式调用super，则默认隐含一个 \"super()\" 调用。 子类构造函数可以显式地写 super([参数1，...]) 来调用父类的重载构造函数。且必须在方法体的第一行，即只能调用一个。 标准类：也叫做 Java Bean 通常包含以下4部分内容： 所有的成员变量都要使用private关键字。 为每一个成员变量编写一对儿Getter/Setter方法 编写一个无参构造函数 编写一个全参构造函数 点击 Code-\u003eGenerate 或者 快捷键 alt + insert 可以自动生成上述内容 ==： 对于基本类型， == 比较的是值 对于引用类型， == 比较的是地址 基本类型与字符串之间的转换： 基本类型 --\u003e 字符串 1、基本数据类型的值+\"\" 最简单的方式（工作中常用） 2、使用包装类的静态方法 static String toString(int i) 将i变为字符串形式 如 Integer.toString(100); 3、使用String类的静态方法 static String valueOf(int i) 将i变为字符串形式 如 String.valueOf(100); 字符串 --\u003e 基本类型 使用包装类的静态方法 parseXX(\"字符串\") Integer static int parseInt(String s) 如 Integer.parseInt(\"100\"); ... ... 泛型: 泛型名字不一定是E，可以是任意大写字母。 类: public class ClassName\u003cE\u003e { ... 在类内将需要的地方都用E代替} 实例化对象时确定类型 方法: 修饰符 \u003cE\u003e 返回值类型 方法名(参数列表){ ... } 调用方法时确定类型 接口: 含有泛型的接口定义与类相同。 确定类型的方法：1、在实现类中确定类型 2、实现类依然沿用接口的泛型E，实现类创建对象时确定类型 通配符: \u003c?\u003e 代表任意数据类型， 使用: 例如当多个不同类型的ArrayList集合要作为参数调用同一个方法时，可以将参数设置为ArrayList\u003c?\u003e list方便接受任意类型。 高级使用: ? extends E 表示 ? 只能是E的子类/本身 ? super E 表示 ? 只能是E的父类/本身 static: 带上static的成员变量或函数，不属于对象，而是属于类，所有对象共享。 类名.静态变量 类名.静态方法() 注意事项：静态不能直接访问非静态 --\u003e 在内存中，先有静态，后有非静态 静态不能使用this 静态代码块：static{ ... } 首次用到类时，静态代码块唯一执行一次。 典型用途：一次性地对静态成员变量赋值。 override: 在子类的覆盖重写方法前面加上 @override 可以检验该方法是否为重写方法（建议写上） 子类方法的返回值的范围必须 小于等于 父类方法的返回值的范围。 子类方法的权限必须 大于等于 父类方法的权限 权限： public \u003e protected \u003e (default) \u003e private (default) 表示什么也不写，留空。 同一个类 YES YES YES YES (我自己) 同一个包 YES YES YES NO (我领居) 不同包子类 YES YES NO NO (我儿子) 不同包不同类 YES NO NO NO (陌生人) abstract: 抽象方法：只定义，不实现。加上abstract关键字，去掉大括号，直接分号结束。 抽象类： 抽象方法所在的类，必须是抽象类。在class前加上abstract即可。但抽象类中不一定包含抽象方法（通常是有的）。 使用步骤： 抽象类不能直接创建对象。 必须用一个子类继承抽象父类。 子类必须覆盖重写抽象父类中的所有抽象方法。--\u003e此处覆盖重写即实现：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。 创建子类对象，并使用。 interface： 概念：接口就是多个类的公共规范。是一种引用数据类型，最重要的就是其中的抽象方法。 定义：public interface 接口名称 { ... } 包含：常量、抽象方法、默认方法、静态方法、私有方法。 常量：可以理解为成员变量，但是必须使用 public static final 三个关键字修饰，故相当于常量。 public static final 数据类型 常量名称 = 值 （三个关键字可省略，但不能换为别的） 注意：1、接口中的常量可以省略public static final，但写不写效果一样。 2、接口中的常量必须手动赋值，不能不赋值。赋值之后无法改变。 3、常量名称全部大写，由下划线连接。 使用：接口名称.常量 抽象方法：1、接口中的抽象方法，修饰符固定为 public abstract (可省略，但不能换为别的) 2、方法的三要素可随意定义。 默认方法：public default 返回值类型 方法名(参数列表) {方法体} (public可省略，default不能省略) 可以解决接口升级的问题。（不想改变实现类，但是接口中又想要添加新方法，则接口就可以用默认方法自己实现）（实现类可以覆盖重写默认方法） 默认方法会被实现类继承，故可以通过实现类的对象访问默认方法。 静态方法：public static 返回值类型 方法名(参数列表) {方法体} (public可省略，static不能省略) 使用：接口名称.静态方法(参数); 不能通过对象访问。 私有方法：1、普通私有方法：解决多个默认方法之间的重复代码问题 private 返回值类型 方法名(参数列表) {方法体} 只有接口中的默认方法能访问。 2、静态私有方法：解决多个静态方法之间的重复代码问题 private static 返回值类型 方法名(参数列表) {方法体} 只有接口中的默认方法和静态方法能访问。 使用：1、接口不能直接使用，必须有一个“实现类”来“实现”该接口。 public class 实现类名称 implements 接口名称 {...} 2、接口的实现类必须实现接口中的全部抽象方法。去掉abstract关键字，加上大括号实现体。 3、创建实现类对象，使用。 注意事项：1、接口没有静态代码块和构造方法。 2、如果实现类没有覆盖重写所有接口中的所有方法，则该实现类自己就必须是抽象类。 3、一个实现类可以实现多个接口 public class 类名 implements interface1, interface2 {}。 4、若一个类实现的多个接口中有重名的抽象方法，则只需实现一个即可。 5、若一个类实现的多个接口中有重名的默认方法，则该实现类必须对重名默认方法覆盖重写。 6、若一个类的直接父类中的方法和它实现的接口中的默认方法重名，则优先使用直接父类的方法。 在java中【继承 优先于 接口】 7、接口是多继承的。多个父接口当中的抽象方法如果重名，没关系。 多个父接口当中的默认方法如果重名，则子接口必须对重名的默认方法覆盖重写，【而且带着default关键字】 多态：（一个子类对象既有子类形态，又有父类形态）一个对象拥有多种形态，即【对象】的多态性。【多态性指的是对象，而不是类】 代码中体现多态性： 父类引用指向子类对象。 格式 父类名称 对象名 = new 子类名称(); 或 接口名称 对象名 = new 实现类名称(); 【初步理解: 定义了一个指向子类对象的父类引用，这个引用指向的是子类的对象，但是只能访问父类大小的内存空间，所以它只能访问父类继承到子类当中的成员 （包括成员变量和成员函数）的那部分内存空间，而不能访问子类独有的多出来的那部分内存空间，而对于被子类重写了的方法，该引用依然可以访问 这部分内存，只是内存中的内容已经被改写了，所以访问到的是子类重写之后的方法。综上所述，该引用能访问的范围是所有从父类继承下来的变量和 父类独有方法，以及被子类重写之后的方法。】 多态对象访问成员变量： 对象名.成员变量 访问的是父类的成员变量，若没有则向上找，不会向下找。 不能用这种方法访问子类特有成员变量。 多态对象访问成员函数： 若子类重写了父类的成员函数，则访问子类的成员函数。 若子类没有重写，则访问父类的成员函数，没有则向上找。 同样不能访问子类特有成员函数。 记忆口诀；对于成员变量，等号左边是谁就优先用谁。对于成员方法，new的是谁就优先用谁。 使用多态的好处：比如将父类的引用作为参数传入方法中，则该引用可以指向不同的子类对象使方法实现不同的功能，却不需要改变方法中的任何代码。 对象的向上转型： 在特定场合会自动向上转型，如方法参数要求为父类，但是传入一个子类对象也正确，这时就发生了自动向上转型。与int double发生自动类型转换原理一样。 格式：与多态相同：父类名称 对象名 = new 子类名称(); 含义：创建一个子类对象，把它当作父类来看待使用。 【向上转型一定是安全的】从小范围转向了大范围，如将小范围的猫向上转型为更大范围的动物。 类似于将short转换为int。 弊端：不能访问子类特有方法。 对象的向下转型：其实是一个【还原】的动作。 格式： 子类名称 对象名 = (子类名称) 父类对象; (子类名称)必须有，不能省略。 含义： 将向上转型之后的父类对象还原为本来的子类对象。 注意： 只有本来是猫，向上转型为动物后，再向下转型为猫才是正确的。 若本来不是猫，却硬要向下转型为猫就会出错(编译不会报错，但运行会出现异常ClassCastException)。 instanceof: 格式： 对象名 instanceof 类名 作用： 返回一个布尔值，判断前面的对象能不能当作后面类的实例。 应用： 在向下转型之前，判断需要转型的对象是不是目标类的对象，是则向下转型，不是则不转型。 final: 该关键字表示最终的，不可再改变的。 用法: 修饰一个类、方法、局部变量、成员变量。 修饰一个类： public final class 类名 {...} 不能有子类。 修饰一个方法： 该方法不能被重写。 对于类和方法，abstract 和 final 不能同时使用，会矛盾。 修饰一个局部变量： 一次赋值，终生不变。（可以先定义，再赋值。分两步）--对于基本类型，值不可变。对于引用类型，地址值不可变。 修饰一个成员变量： 由于成员变量有默认值，所以不能分两步，必须当场手动赋值或通过构造函数赋值。 修饰一个数组或集合： 该数组或集合不能再被赋值，但内部的数据还可以改变。 内部类： 一个类内部包含另一个类，即一个事物内部包含另一个事物。 例如 身体和心脏的关系 分类： 成员内部类 局部内部类（包含匿名内部类） 成员内部类：修饰符 class 外部类名称 { 修饰符 class 内部类名称 {...} ... } 内用外，随意访问。外用内，需要内部类对象。 在main方法中使用：1、间接方式： 在外部类的方法中调用内部类，然后main通过访问外部类的方法调用内部类。 2、直接方式： 外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称(); 当局部变量、内部类的成员变量、外部类的成员变量重名时： 内部类的成员方法调用内部类的成员变量用this.内部成员变量。 内部类的成员方法调用外部类的成员变量用Outer.this.外部成员变量。 局部内部类：如果一个类定义在方法内部，就是局部内部类。---只有当前所属的方法才能使用它，出了这个方法就不能使用了。 格式：修饰符 class 外部类名称 {... 修饰符 返回值类型 外部类方法名称(参数列表) { class 内部局部类名称 {...} ... } ...} 注意：若局部内部类要访问所在方法的局部变量，则该局部变量必须是【有效final的】（即可以不写final关键字，但是不能变） 因为局部内部类在堆中，生命周期长，而局部变量在栈中，生命周期短，所以不能变。 【匿名内部类】：【用的最多】 如果接口的实现类（或者父类的子类）只需使用唯一的一次，则可以省略该类的定义，而改为使用匿名内部类。 格式：接口名称 对象名 = new 接口名称() { 重写所有抽象方法 }; 注意：1、匿名内部类只能唯一【创建一次对象】。若想多次创建对象，就要单独定义实现类。 2、匿名对象只能唯一【调用一次方法】。若想多次调用方法，就要给对象起个名字。 3、匿名内部类是省略了实现类/子类名称。而匿名对象是省略了对象名称。他俩不是一回事。 new 接口名() { 重写所有抽象方法 }.方法(参数); 即匿名内部类又匿名对象的使用方法。 异常: throw : 用于抛出异常， 例如: throw new NullPointerException(\"异常产生的原因\") 若抛出运行时异常，可不理会，默认由JVM处理 若抛出编译器异常，则必须处理。throws或try-catch throws: 声明异常。 (用于甩锅) 格式: 修饰符 返回值类型 方法名(参数列表) throws AAAException, BBBException... {throw new AAAException(\"原因\")...} 注意: 1、throws必须写在方法声明处 2、throws后面必须是Exception或者是其子类 3、throws后面必须声明方法内部抛出的所有异常 4、若调用了一个声明抛出异常的方法，则必须处理这些异常。可以继续抛出，也可以自己处理。 try-catch: 自己处理异常 try可以抛出多个异常，这时需要使用多个catch来捕获异常。 try中若产生异常，则try代码块中产生异常之后的代码不会执行，而跳转到catch。 try中若没有产生异常，则执行完try中的代码继续执行try-catch之后的代码。 finally: 不论是否发生异常，finally代码块中的代码一定会执行。 格式 : try{} catch{} finally{} 注意 : finally必须与try一起使用，一般用于资源释放。 正是由于其有一定会执行到，所以若finally代码块中有return语句，则一定会返回finally中的结果。（要避免） 注意 : 子类异常一定要与父类异常一致。 Thread : Thread类是描述线程的类，要实现多线程，必须继承Thread类 每个线程拥有一个自己独立的栈，但是共享进程的堆空间。 Thread.sleep(毫秒) // 静态方法 睡眠 Thread thread = Thread.currentThread(); // 获取当前线程 第一种方法： 创建Thread类的子类 1、创建Thread类的子类，并重写run方法，其中设置线程的任务 2、创建子类对象，并执行start方法 (执行start方法会创建一个新的栈空间，并在该栈空间中执行run方法)(每执行一次步骤2，就开启一个新的线程) 第二种方法： 实现Runnable接口 (推荐使用这种) ---\u003e 使用该方法时，Thread 类是咱们自定义类的静态代理类 1、创建一个Runnable接口的实现类，并重写run方法，其中设置线程的任务 2、创建对象，并将其作为参数传递给Thread类的构造方法，再调用start方法。 new Thread(new MyRunnable()).start(); 匿名内部类实现： new Thread(new Runnable(){重写run方法}).start(); 第三种方法： 实现Callable\u003cV\u003e接口 （面试可能会问到） Callable接口类似于Runnable，【Runnable不会返回结果，也不会抛出检查异常，Callable可以】 1、创建一个Callable\u003cV\u003e接口的实现类，并重写call方法，其中设置线程的任务 2、在使用的地方创建该类对象 obj 。 3、ExecutorService executorService = Executors.newFixedThreadPool(5); // 创建执行服务 4、Future\u003cV\u003e future = executorService.submit(obj); // 提交执行 5、V result = future.get(); // 获取结果 6、executorService.shutdownNow(); // 关闭服务 同步： 多个对象访问同一个资源，可以并发读取，但当其中某一个对象要修改时，就必须实现同步 所有的对象都拥有一把锁。 锁对象选取总结为一句话就是 在同步代码中要改变谁就锁谁。 方法一： 同步代码块： synchronized (锁对象) {访问共享数据的代码} 线程不仅要抢夺CUP，还要占用锁对象。同时拥有才能执行代码 锁对象可以是任意对象，但必须是同一个对象，推荐将共享资源作为锁对象。线程占用锁对象后直到执行完毕才释放。 方法二： 同步方法 修饰符 synchronized 返回值类型 方法名 (参数列表) {访问共享数据的代码} // 该方法即为同步方法 首先将 访问共享数据的代码块 抽取出来，作为上述方法。 同步方法的锁对象默认为 this ，即同步方法所在类的对象；创建该类的对象后，该对象调用同步方法时就会锁住对象自己。 当同步方法同时也是静态方法时，锁对象为同步方法所在类的 Class 对象。 方法三： Lock锁 Lock是一个接口，有两个方法 void lock() 获取锁 和 void unlock() 释放锁 它有一个实现类ReentrantLock（可重入锁）， 先实例化一个ReentrantLock对象。 在出现安全问题代码之前用该对象调用 lock() 方法。在出现安全问题代码之后用该对象调用 unlock() 方法。 lock() 和 unlock() 方法建议放在 try --- finally 代码块中 线程状态： 线程停止：不推荐使用 Thread 类提供的 stop() 等方法。推荐自己通过一个标志位控制停止 public class MyRunnable implements Runnable { private boolean flag = true; @Override public void run() { while (flag) { TODO... } } public void stop() { flag = false; } } 通过调用自己实现的 stop 方法来停止线程 下方所有方法都是 Thread 类中的方法！ 线程休眠：Thread.sleep(毫秒) // sleep 不会释放锁、 wait 会释放锁。 线程礼让： Thread.yield(); 使当前线程从运行状态变为就绪状态，让 cpu 从所有就绪的线程中挑一个运行。 礼让有可能不成功，因为 cpu 可能再挑选一次还是让当前线程继续执行。 线程强制执行： join() ，相当于插队，停止现在执行的线程，立刻执行自己的线程，且本线程执行结束才能执行其他线程 public class MyRunnable implements Runnable { @Override public void run() { for (int i = 0; i \u003c 1000; i++) { System.out.println(\"Runnable \" + i); } } public static void main(String[] args) throws InterruptedException { MyRunnable myRunnable = new MyRunnable(); Thread thread = new Thread(myRunnable); thread.start(); for (int i = 0; i \u003c 500; i++) { if (i == 200) { thread.join(); } System.out.println(\"主线程\" + i); } } } 在上方举例代码中，主线程执行到200之前，主线程和Runnable线程交替执行，当主线程执行到200次时， Runnable 线程插队接着执行，之后Runnable线程全部执行完毕后才由主线程继续执行。 查看线程状态：Thread.State state = thread.getState(); // Thread.State 是一个枚举类型 线程优先级：1 最小；10 最大；默认为5。优先级越高在就绪状态很大可能越早执行，但也不是一定。 守护（daemon）线程： 线程分为用户线程和守护线程。 虚拟机必须保证用户线程执行完毕，但不用等待守护线程执行完毕。 守护线程有：后台记录日志、监控内存、垃圾回收等 private boolean daemon = false; // 默认 daemon 属性是关闭的，即默认为用户线程 thread.setDaemon(true); // 可通过这样将线程设置为 守护线程。 // 将线程设置为守护线程之后，虚拟机将不再保证该线程是否执行结束， // 即只要当用户线程执行结束后就将整个程序关闭，而不考虑守护线程此时是否已经执行完毕。 线程池 : 底层原理 ： 线程池就是一个容纳多个线程的容器，可由集合实现 使用步骤: 1、使用线程池工厂类Executors里面的静态方法newFixedThreadPool生产一个指定线程数量的线程池，由ExecutorService接口接收。 2、创建Runnable接口的实现类，重写run方法，设置线程任务。 3、调用ExecutorService中的execute方法，传递线程任务，开启线程，执行run方法。 例: ExecutorService executorService = Executors.newFixedThreadPool(5); // 创建服务 Runnable runnable = new Runnable() { //此处虽然new 的是Runnable接口，但是立即重写了run方法，故相当于其实现类。 @Override public void run() { //线程任务 } }; executorService.execute(runnable); // 执行服务 executorService.shutdownNow(); // 关闭服务 ExecutorService 中的 submit()方法和 execute()方法作用相同，只是适用于不同场景 void execute(Runnable command) // 执行任务，没有返回值，一般用于执行 Runnable \u003cT\u003e Future\u003cT\u003e submit(Callable\u003cT\u003e task); // 执行任务，有返回值，一般用于执行 Callable Lambda表达式 : 可推导，可省略 格式： () -\u003e {} 使用前提： 必须是接口，且接口中有且只有一个抽象方法 (有且只有一个抽象方法的接口，称为\"函数式接口\") 可以省略的内容： 1、(参数列表) 参数列表中的数据类型可以省略， 如果参数只有一个，则括号()也可以省略 2、{方法体} 如果{}中的代码只有一行，无论是否有返回值，都可以省略 {}， return， 分号 （要省一起省） 注解: @override 检测是否为覆盖重写 @FunctionalInterface 检测是否为函数式接口 ------------------------------------------------------------------------------------------------------------------ API使用： Scanner： 功能：从键盘输入数据到程序。 包路径：java.util.Scanner 实例化：Scanner sc = new Scanner(System.in); System.in 表示从键盘输入数据。 方法：---其实键盘输入的一切东西都是字符串，使用不同的函数会将字符串转换为相应的类型。--\u003e故若记不住也可以一直使用sc.next();之后再转换类型 获取键盘输入的一个int数字： int num = sc.nextInt(); 获取键盘输入的一个字符串： String str = sc.next(); 读取文件内容：Scanner in = new Scanner(Paths.get(\"\\u202AC:\\\\Users\\\\Lenovo\\\\Desktop\\\\1.txt\"), StandardCharsets.UTF_8); 之后再用in的各种方法。nextLine(); next(); nextInt(); 等 Random: 功能: 获取随机数。 实例化：Random rand = new Random(); 方法：int rand_num = rand.nextInt(n) 在[0, n)中随机取一个数字。----\u003e m + rand.nextInt(n)取到[m, m + n）中的随机数。 ArrayList: [元素1， 元素2， 元素3， ...] 功能：可变长的数组。 泛型：装在集合中的元素必须是同一个类型，只能是引用类型，不能是基本类型。 实例化：ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); 注意事项：直接打印list输出的不是一个地址值，而是空的中括号。 不支持下标索引，只能用get()方法获取。 常用方法：list.add(\"李沁\") 添加元素，返回一个boolean值，表示添加的动作是否成功。一定成功，可以不接受返回值。 list.get(index) 根据索引获取元素，返回获取的元素。 list.remove(index) 根据索引删除元素，返回被删除的元素。 list.size() 获取集合长度。 若想在ArrayList中存储基本类型，需要使用其包装类(引用类型)： 基本类型 包装类 byte Byte short Short ... ... （与上方一样，只需首字母大写） int Integer 【特殊】 char Character 【特殊】 ArrayList\u003cInteger\u003e list_int = ArrayList\u003c\u003e(); // 自动装箱：int --\u003e Integer 自动拆箱：integer --\u003e int String: 功能：字符串（常量） --\u003e Java中所有的双引号字符串都是String类的实例。 实例化：直接创建： String str1 = \"李沁\"; 在字符串常量池中， 其他实例化方式都在堆中，不在池里。 使用空构造函数： String str2 = new String(); 根据字符数组创建： char[] charArray = { 'a', 'b', 'c' }; String str3 = new String(charArray) // abc 根据字节数组创建： byte[] byteArray = { 97, 98, 99 }; String str3 = new String(byteArray) // abc 方法：str1.equals(str2) 比较str1和str2的值是否相等，返回boolean。 常变量比较时推荐 常量.equals(变量) str1.equalsIgnoreCase(str2) 忽略大小写。 str.length() 长度 str.concat(str1) 拼接 str.charAt(index) 根据索引返回字符 str.indexOf(str1) 在str中查找str1，返回首次找到的索引值；若没有，返回-1 str.substring(index) 截取，从index到末尾 str.substring(int begin, int end) 截取，[begin, end) str.toCharArray() 转换为字符数组 str.getBytes() 转换为字节数组 用于遍历字符串 str.replace(old, new) 用new替换str中的old str.split(regex) 切割，返回数组 Arrays: 功能：与数组相关的类，提供大量静态方法，用来实现数组常见的操作。 方法： Arrays.toString(数组) 将参数变成字符串 [元素1， 元素2，元素3，...] Arrays.deepToString(多维数组) 将参数变成字符串 [元素1， 元素2，元素3，...] Arrays.sort(数组) 排序。默认从小到大，自定义类型的排序需要Comparable或Comparator接口 Arrays.equals(数组1， 数组2) 两个数组完全相等是返回ture Math: 功能：数学相关的类，提供大量静态方法，用来实现数学运算相关的操作。 方法： Math.abs() 绝对值 Math.ceil() 向上取整 Math.floor() 向下取整 Math.round() 四舍五入 Collection接口: 所有单列集合的顶层接口 List接口: 1、有序（存入和取出的顺序一致） 2、允许元素重复 3、有索引 Vector:(了解) Arraylist:(重点) 底层由数组实现，查询快，增删慢。 LinkedList:(次之) 底层由链表实现，查询慢，增删快。 特有方法: addFirst() == push() addLast() == add() getFirst() getLast() removeFirst() == pop() removeLast() 这两种方法都会删除并返回 共有方法： void add(int index, E element) 将元素添加到索引位置 E get(int index) 返回索引处的元素 E remove(int index) 删除索引位置元素,并返回被删除的元素 E set(int index, E element) 替换索引位置元素,并返回被替换前的元素 Set接口: 1、不允许元素重复 2、没有索引 TreeSet: (无序) (了解) 底层由二叉树实现，一般用于排序。 HashSet: (无序) (重点) 底层由哈希表实现。(查询速度很快) 注意: 使用HashCode存储自定义类型时，需要重写HashCode()和equals()。可通过alt + insert直接添加。才能保证元素不重复。 LinkedHashSet: (有序) (次之) 底层由哈希表+链表实现。 extends HashSet 比HashSet多了一条链表，用来记录元素的顺序 共有方法： boolean add(E e) 添加， 无需接收 boolean remove(E e) 删除， 若有e，删除并返回true。若没有e，无动作并返回false void clear() 清空。 但不删除集合。 boolean contains(E e) 是否包含。 boolean isEmpty() 是否为空。 int size() 元素个数。 Object[] toArray() 转为数组。 哈希值: 是一个十进制的整数，由操作系统随机给出的对象的逻辑地址值。 哈希表: 拉链法。由哈希值为元素组成数组（初始长度为16）。若哈希值相等，则以链表方式挂在该哈希值后面。当链表长度超过8时，变为红黑树。检索速度加快。 Collections : 是Collection的工具类，提供大量静态方法，用于操作集合。 以ArrayList为例: ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); addAll(Collection\u003cT\u003e c, T... elements) : 往集合中添加多个元素。 Collections.addAll(list, \"a\", \"b\", \"c\"); shuffle(List\u003cT\u003e list) : 打乱顺序。 Collections.shuffle(list); sort(List\u003cT\u003e list) : 排序， 默认升序。 Collections.sort(list); 注意：若要对自定义类型排序，则被排序的类必须实现Comparable接口，重写compareTo方法来定义排序规则。 this - 参数 ： 升序 (了解)另一种sort()： Collections.sort(arr, new Comparator\u003cInteger\u003e() { @Override public int compare(Integer o1, Integer o2) { return o1 - o2; } }); 这种方法List接口中的方法类似-\u003e arr.sort(new Comparator\u003cInteger\u003e() {...}) Iterator: 迭代器 是接口 也有泛型 --\u003e Collection\u003cString\u003e array = new ArrayList\u003c\u003e(); Iterator\u003cString\u003e it = array.iterator(); 常用方法: boolean hasNext() 是否有下一个元素。 E next() 返回下一个元素。 使用： Collection中的实现类为 iterator() 1、实例化iterator 2、用hasNext() 3、用next() 增强for循环: 专门用来遍历数组与集合，由Iterator迭代器实现，遍历时不能做增删操作。 for (元素数据类型 变量 : 集合或数组名) { ... } Map: --\u003e 字典 键值对 key是唯一的 HashMap: (无序) 底层为哈希表 LinkedHashMap : (有序) 底层为哈希表+链表(保证顺序) 方法: V put(K key, V value) : 添加，若key值不存在，则添加并返回null。若key值已存在，则更新value值，并返回被替换掉的value值。一般不接收返回值。 V remove(K key) : 删除，若key值存在，返回被删除的value。若key不存在，则返回null。 V get(K key) : 获取，若key值存在，返回对应的value。若key不存在，则返回null。 boolean containsKey(k key) : 判断是否包含指定的键。 Set\u003cK\u003e keySet() 返回由键组成的Set，之后可以通过遍历Set来遍历Map。 for (K key : map.keySet()) { sout(key + map.get(key)) } Set\u003cMap.Entry\u003cK, V\u003e\u003e entrySet() --\u003e for (Map.Entry\u003cK, V\u003e entry : map.entrySet()) { 也是遍历，看起来不好用的样子 System.out.println(entry.getKey() + ' ' + entry.getValue());} 用Map存储自定义类型时，若自定义类型作为键，则必须将该类重写HashCode和equals方法，保证键是唯一的。 of方法： static \u003cE\u003e List\u003cE\u003e of (E... elements) 1、of方法只适用于List, Set, Map 接口。而不适用于他们的实现类 2、of方法返回一个不能被操作的集合。因此适合初始化，且初始化后不能改变。 3、Set 和 Map 调用of方法时不能有重复元素。 ------------------------------------------------------------------------------------------------------------------ ------------------------------------------------------------------------------------------------------------------ ------------------------------------------------------------------------------------------------------------------ ------------------------------------------------------------------------------------------------------------------ Object： 以下方法所有类都有，只是重写之后功能有所不同。 toString() 直接打印对象的名字，就是调用对象的toString方法-\u003e得到对象的地址值。 没有意义。 重写：可以和构造方法与Getter/Setter方法一样的步骤添加（重写）toString方法-\u003e打印出属性值。 equals() boolean equals(Object obj) 判断两个对象是否\"相等\"，返回布尔值。 比较两个对象的地址值，同上方的==作用一样。 没有意义。 重写： 原理 --\u003e 由于equals方法的参数类型为Object,所以默认向上转型了。若想比较两个对象的属性值，需要先向下转型。 同样可以 alt + insert 直接生成equals方法。 判断两对象的属性值是否都一样。 hashCode() 返回对象的哈希码值 // synchronized 能实现线程同步、但无法实现线程间通信、用如下 4 个方法可以实现线程间通信。 wait() 等待。在被唤醒之前，放弃CPU的使用权 wait(毫秒值) 在被唤醒或到时间之前，放弃CPU的使用权 notify() 唤醒。随机唤醒锁对象中的一个进程 notifyAll() 唤醒锁对象(对象监视器)中的所有进程 这两种常搭配同步机制使用 objects: 该工具类提供的方法是容忍空指针的。 若 a=null，则a.equals(b) 报错。而Objects.equals(a, b) 正常运行。 Objects.requireNonNull(T obj) 查看obj是否为空，用来判断参数的合法性。 旧API : Date: 1970年1月1日 00:00:00 作为0时刻 Date() 无参构造--\u003e 获取当前时间。 Date(long date) 有参构造 --\u003e 输入毫秒值，输出相对于0时刻的日期。 getTime() 把日期转换为毫秒 DateFormat: 格式化日期。 抽象类。 String format(Date date) 把日期格式化为字符串。 Date parse(String source) 把符合的字符串解析为日期。 SimpleDateFormat: DateFormat的实现类 SimpleDateFormat(String pattern) 有参构造 参数一般为 \"yyyy-MM-dd HH:mm:ss\" 使用上方两个方法。 注意：用parse时，参数的模式必须与构造SimpleDateFormat对象时的模式完全一样，否则报错。 Calendar: 日历类 抽象类 getInstance() 静态方法 返回Calendar类的子类对象 Calendar instance = Calendar.getInstance(); 功能：使用默认时区和语言环境获得一个日历 get(field) 返回给定字段的值。 字段值有YEAR MONTH DATE HOUR MINTER SECOND 年月日时分秒 都是静态变量 set(field, value) 将给定的日历字段设置为给定值 add(field, amount) 修改指定的字段，通过amount的正负实现加减。 Date getTime() 将Calendar转为Date对象 原理：实际上该类中有一个fields数组，上述的方法都是在对该数组操作。字段值YEAR等固定为0，1，2等，作用是对该数组的索引。 新API LocalDate, LocalTime, LocalDateTime : 之前的Date类和Calendar类都有缺陷。JDK8 新引入日期时间类 由于LocalDateTime类使用较多，故以他为例，其余两种用法相同。 构造方法： 1、LocalDateTime now = LocalDateTime.now(); 获取当前时间 2、LocalDateTime localDateTime = LocalDateTime.of(2020, 1, 20, 12, 20, 34); 获取指定时间 常用方法： now.getDayOfMonth() 获取对象是这个月的第几天。类似的方法获取其他属性。 LocalDateTime time = now.withDayOfMonth(12); 使用类似方法设置属性。但是该语句执行后，time为修改后的值，而now的值不变。体现了时间的不可变性。 LocalDateTime plusDays = now.plusDays(3); 使用类似方法修改属性，在原有基础上加3天。不可变性同上。 LocalDateTime months = now.minusMonths(2); 使用类似方法修改属性，在原有基础上减2月。不可变性同上。 Instant 替换 Date 类 DateTimeFormatter : 类似于SimpleDateFormat 日期时间的格式化与解析 DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"); 构造 String format = formatter.format(LocalDateTime.now()); 格式化 TemporalAccessor parse = formatter.parse(\"2021-01-21 22:00:25\"); 解析 System: 提供大量静态方法， 可以获取与系统相关的信息即服务 static currentTimeMillis() 返回以毫秒为单位的当前时间, 用来测试程序的效率。 static arraycopy(原数组， int 原数组起始位置， 目标数组， int 目标数组起始位置， int 要复制的数组元素的数量) 复制数组 StringBuilder: 在String类中，字符串是常量，底层是被final修饰的数组。字符串相加时，占用内存多，效率低下。 StringBuilder类是字符串缓冲区，可以提高字符串的操作效率（看成是一个长度可以变化的字符串） 底层也是一个数组，但是没有被final修饰，可以改变长度。 在内存中始终是一个数组，初始容量为16个字节，超出会自动扩容，占用空间少，效率高。 构造函数： StringBuilder() 无参构造，空字符串。 StringBuilder(\"abc\") 有参构造，即参数的字符串。 成员函数： append(任意类型) 添加到字符串，并返回自身。所以无需接收。 toString() 将StringBuilder对象，转换为String对象。 通过StringBuilder的构造方法可以将String转换为StringBuilder. reverser() 翻转 File: 文件类，主要用于文件和目录的创建，查找和删除等操作 File类已被Path取代 静态方法: static String\tpathSeparator 路径分隔符 windows ; 分号 linux : 冒号 static String\tseparator 文件名称分隔符 Windows \\ 反斜杠 Linux / 正斜杠 构造方法: File(String pathname) 路径名 ==\u003e 文件/文件夹 相对/绝对 存在/不存在 File(String parent, String child) 父路径，子路径 File(File parent, String child) 父路径，子路径。父路径是File型，故可以使用其方法做调整 常用方法: 获取方法: String getAbsolutePath() 返回绝对路径名 String getPath() 返回路径名 String getName() 返回末尾文件/文件夹 名字 long length() 返回文件大小（以字节为单位） 不能是文件夹，若路径不存在，返回0 判断方法: boolean exists() 文件或文件夹是否真实存在 boolean isDirectory() 路径是否以文件夹结尾 前提：真实存在 boolean isFile() 路径是否以文件结尾 前提：真实存在 创建删除: boolean creatNewFile() 不存在时创建文件 不能创建文件夹，路径必须存在 boolean delete() 删除文件/文件夹 boolean mkdir() 创建单级空文件夹 boolean mkdirs() 创建单级/多级空文件夹 多级文件夹：父文件夹中包含子文件夹 遍历文件夹: String[] list() 返回由所有文件或子目录组成的字符串数组 File[] listFiles() 返回由所有文件或子目录封装而成的文件数组 过滤器: File[] files = dir.listFiles(new FileFilter(){重写accept()方法，该方法中写入过滤规则，留下的返回ture，不要的返回false}) 可以写为Lambda表达式。 读取文件的方法： Scanner in = new Scanner(Paths.get(\"C:\\\\Users\\\\Lenovo\\\\Desktop\\\\1.txt\"), StandardCharsets.UTF_8); String num = in.nextLine(); BufferedReader reader = Files.newBufferedReader(Paths.get(\"C:\\\\Users\\\\Lenovo\\\\Desktop\\\\1.txt\"), StandardCharsets.UTF_8); String str = reader.readLine(); （不好用）BufferedReader bufferedReader = new BufferedReader(new FileReader(\"C:\\\\Users\\\\Lenovo\\\\Desktop\\\\1.txt\")); String s = bufferedReader.readLine(); Properties: 用来加载配置文件, 示例如下： Properties properties = new Properties(); // ClassLoader classLoader = Person.class.getClassLoader(); 注释掉的两句作用与下一句一样 // InputStream is = classLoader.getResourceAsStream(\"jdbc.properties\"); // 路径相对于src FileInputStream fis = new FileInputStream(\"src\\\\jdbc.properties\"); // 路径相对于Module而不是src properties.load(fis); String user = properties.getProperty(\"user\"); String passwd = properties.getProperty(\"passwd\"); System.out.println(user + \" \" + passwd); IO流: （默认相对路径在Module下） 基本流: OutputStream: 字节输出流 (一切都以字节为单位) (一次读写一个字节) 接口 共有方法: write(byte[] bytes) 写入多个字节 close() FileOutputStream: 文件字节输出流 构造方法: FileOutputStream(String name[, boolean append = false]) 参数为路径，即写入的目标文件路径，如果没有该文件，会先创建该文件。若append为ture，则为追加写，否则会覆盖原文件 FileOutputStream(File file[, boolean append = false]) 参数为文件，即写入的目标文件，append同上。 InputStream: 字节输入流 接口 共有方法: read() 读取一个字节,返回读到的内容，读到文件末尾返回-1 int read(byte[] bytes) 读取多个字节，将读取到的内容存入字节数组中，并返回读取的有效字节个数，读到文件末尾返回-1 close() FileInputStream: 文件字节输入流 构造方法: FileInputStream(String name) FileInputStream(File file) Reader: 字符输入流 抽象 共有方法: read() read(char[] c) close() 作用和上述相同,包括返回-1等等都相同，只是读取单位变为字符。 FileReader: 文件字符输入流 ---\u003e 只能读取IDEA默认编码格式文件(即UTF-8) 构造方法: FileReader(String filename) FileReader(File file) Writer: 字符输出流 抽象 共有方法: write() 参数可以为单个字符，字符数组或字符串 close() FileWriter: 文件字符输出流 构造方法: FileWriter(String filename[, boolean append = false]) FileWriter(File file[, boolean append = false]) 注意: 这里的write方法是将数据写入内存缓冲区(字符转为字节)，flash方法或close方法会数据刷新到文件。因此必须调用close()方法。 Properties集合: 实现了Map\u003cK, V\u003e 唯一和IO流结合的集合 该集合的默认键和值都是字符串类型。store方法能把集合中的数据存入硬盘，load方法会加载到该集合中。 缓冲流: 创建一个缓冲区，减少系统IO次数，提高读写效率。 BufferedInputStream: 字节缓冲输入流 extends InputStream 用read写入，close关闭。只需要关闭缓冲流，基本流会随之关闭。 构造方法: BufferedInputStream(InputStream in[, int size]) read和write方法与基本流完全相同。 BufferedOutputStream: 字节缓冲输出流 extends OutputStream 用write写入，close关闭 构造方法: BufferedOutputStream(OutputStream out[, int size]) 参数可以传递FileOutputStream对象，可选参数size用于指定缓冲区大小 BufferedWriter: 字符缓冲输出流 extends Writer 构造方法: BufferedWriter(Writer out[, int size]) 可传入FileWriter 特有方法: void newLine() 无视系统差异，换行 BufferedReader: 字符缓冲输入流 extends Reader 构造方法: BufferedReader(Reader in[, int size]) 可传入FileReader 特有方法: String readLine() 读取一行数据，但不读取行末换行符。读到文件末尾返回null 转换流: 可以指定编码/解码的码表 OutputStreamWriter extends Writer: 步骤: 1、new对象 2、write() 3、close() 构造方法: OutputStreamWriter(OutputStream out[, String charsetName]) 参数一般传递为FileOutputStream。可选字段为编码表名称，不区分大小写，默认为UTF-8 InputStreamReader extends Reader: 步骤: 1、new对象 2、read() 3、close() 构造方法: OutputStreamWriter(InputStream in[, String charsetName]) (反)序列化流: 把对象以流的方式写入/读出到文件中 使用字节流 ObjectOutputStream: extends OutputStream 对象的序列化流 把对象以流的方式写入到文件中保存，叫写对象，也叫对象的序列化。 构造方法: ObjectOutputStream(OutputStream out) 参数一般传递为FileOutputStream。 特有方法: void writeObject(Object obj) 此处参数也可以是由obj组成的集合，如ArrayList\u003cPerson\u003e list 被序列化的对象(即参数obj)必须实现Serializable接口，以激活(反)序列化功能。其为标记型接口，内部没有任何抽象方法。 ObjectInputStream: extends InputStream 对象的反序列化流 把文件中保存的对象以流的方式读出来，叫读对象，也叫对象的反序列化。 构造方法: ObjectInputStream(InputStream in) 参数一般传递为FileInputStream。 特有方法: Object readObject() transient关键字: 瞬态关键字，被其修饰的成员变量不能被序列化，没有替他功能。static关键字也有这个功能。 注意：为了避免InvalidClassException,在每个被序列化的对象中都显示声明一个序列号-\u003e private static final long serialVersionUID = 42L 打印流: PrintStream System.out.println(); enum : 枚举类 类的对象只有确定的有限个，我们称之为枚举类 当需要定义一组常量时，强烈建议使用枚举类 默认继承java.lang.Enum 定义： 类似于接口的定义，创建Class包时，选项中就有Enum的选项。 public enum Season { SPRING(\"春天\", \"warm\"), 默认由public static final 修饰 SUMMER(\"夏天\", \"sun\"), 实例写在类的最前面 AUTUMN(\"秋天\", \"cool\"), 实例之间用逗号分隔，最后一个结尾为分号 WINTER(\"冬天\", \"cold\"); 为什么不需要显示声明成员变量(由局部变量代替)，暂时不清楚 Season(String seasonName, String seasonDec){} } 构造函数默认由private修饰，可省略不写。 静态方法： values() 返回枚举类型的对象数组，方便用于遍历枚举值 valueOf(String objName) 返回枚举类中对象名为objName的对象 如: Season winter = Season.valueOf(\"WINTER\"); toString() 返回当前枚举类对象常量的名字 反射: java.lang.Class 程序由javac.exe编译后，会生成一个或多个字节码文件(.class结尾)。 接着使用java.exe对某个字节码文件解释运行，就相当于将某个字节码文件加载到内存中，这个过程就叫类的加载， 加载到内存中的类就叫运行时类，这个运行时类就是Class的一个实例。 加载到内存中的运行时类会缓存一段时间，在此时间内以不同方式获取到的该运行时类的Class实例都是同一个。 获取Class实例的方法： 1、 Class clazz = Person.class; 2、 Person person = new Person(); Class clazz = person.getClass(); 3、 Class clazz = Class.forName(类相对于src的全路径); // 用的较多 ClassLoader：引导类加载器--》加载java核心类库 引导类加载器无法获取到 扩展类加载器--》加载jar包 通过Class实例.getClassLoader()即可获得类加载器，如 系统类加载器--》加载自定义类 Person.class.getClassLoader()获取的即为系统类加载器 无法创建实例的类型用 Class c = int.class; double.class; Math.class; 等 ArrayList\u003cInteger\u003e list = new ArrayList\u003c\u003e(); Class l1 = list.getClass(); 得到ArrayList\u003cInteger\u003e类的Class实例 l1.getDeclaredConstructors(); 获取所有构造函数，去掉Declared为只获取public的构造函数 l1.getDeclaredMethods(); 获取所有函数，去掉Declared为只获取public的函数 l1.getDeclaredFields(); 获取所有属性，去掉Declared为只获取public的属性 l1.getSuperclass(); 获取父类 l1.getGenericSuperclass(); 获取带泛型的父类 li.getInterfaces(); 获取接口 li.getPackage(); 获取包 li.getAnnotations(); 获取注解 for (Method method: l1.getDeclaredMethods()) { System.out.println(Modifier.toString(method.getModifiers()) + \" \" + method.getReturnType() + \" \" + method.getName() + \"(\" + Arrays.toString(method.getParameterTypes()) + \");\"); } Field f = l1.getDeclaredField(\"size\"); 根据属性名称获取特定的Field对象。 f.setAccessible(true); 使其变为可访问的 Object v = f.get(list); Person person = new Person(\"alice\", 21); 方法对象调用invoke方法来执行方法。 Class p = person.getClass(); public Object invoke(Object obj, Object... args) Method m = p.getMethod(\"getName\"); 第一个参数为对象名，之后的参数为方法的参数。 String s = (String) m.invoke(person); 调用的是静态方法时，第一个参数为null。 代理的作用就是在不修改源码的情况下，对目标对象的方法增强。 静态代理：接口 + 代理类 + 被代理类 --》 一个代理类只能对应一个被代理类 代理类与被代理类实现同样的接口 动态代理：接口 + 代理类 + 多个被代理类 --》 一个代理类可以对应多个被代理类 代理类与被代理类实现同样的接口 结合src/proxy/annotationProxy包下的例子理解 1、根据自己需求创建一个被代理类对象（想象在项目中，要增强功能时，一定在之前已经使用过这个对象） 2、根据这个被代理类对象，动态获取一个代理类对象（因此，没有显示的代理类，是被动态获取到的） 3、使用代理类对象调用被代理类的方法。（具体原理看包中例子的注释） ","wordCount":"2258","inLanguage":"en","datePublished":"2021-05-20T17:39:41Z","dateModified":"2021-05-20T17:39:41Z","author":{"@type":"Person","name":"lu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ethereal-lu.github.io/posts/java/java%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"lu","logo":{"@type":"ImageObject","url":"https://ethereal-lu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://ethereal-lu.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethereal-lu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ethereal-lu.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Java学习笔记</h1><div class=post-meta><span title='2021-05-20 17:39:41 +0000 UTC'>2021-05-20</span>&nbsp;·&nbsp;2258 words&nbsp;·&nbsp;lu</div></header><div class=post-content><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>数组<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>    数组的初始化方式<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>        1<span style=color:#960050;background-color:#1e0010>、</span>动态初始化<span style=color:#960050;background-color:#1e0010>（</span>指定长度<span style=color:#960050;background-color:#1e0010>）</span>  数据类型<span style=color:#f92672>[]</span> 数组名 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> 数据类型<span style=color:#f92672>[</span>数组长度<span style=color:#f92672>]</span><span style=color:#960050;background-color:#1e0010>；</span>
</span></span><span style=display:flex><span>        2<span style=color:#960050;background-color:#1e0010>、</span>静态初始化<span style=color:#960050;background-color:#1e0010>（</span>指定内容<span style=color:#960050;background-color:#1e0010>）</span>  数据类型<span style=color:#f92672>[]</span> 数组名 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> 数据类型<span style=color:#f92672>[]</span> {元素1<span style=color:#960050;background-color:#1e0010>，</span> 元素2<span style=color:#960050;background-color:#1e0010>，</span> 元素3<span style=color:#960050;background-color:#1e0010>，</span> ... }<span style=color:#960050;background-color:#1e0010>；</span> 元素值可以是变量
</span></span><span style=display:flex><span>             省略的静态初始化   数据类型<span style=color:#f92672>[]</span> 数组名 <span style=color:#f92672>=</span> {元素1<span style=color:#960050;background-color:#1e0010>，</span> 元素2<span style=color:#960050;background-color:#1e0010>，</span> 元素3<span style=color:#960050;background-color:#1e0010>，</span> ... }<span style=color:#960050;background-color:#1e0010>；</span>  该方式不允许拆分为2步<span style=color:#960050;background-color:#1e0010>，</span>即先定义数组名<span style=color:#960050;background-color:#1e0010>，</span>再经行赋值<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    直接打印数组名<span style=color:#960050;background-color:#1e0010>，</span>打印的是数组的内存地址<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    支持下标索引<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    未初始化的默认初始值<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>        整数类型<span style=color:#960050;background-color:#1e0010>：</span> 0
</span></span><span style=display:flex><span>        浮点类型<span style=color:#960050;background-color:#1e0010>：</span> 0.<span style=color:#a6e22e>0</span>
</span></span><span style=display:flex><span>        字符类型<span style=color:#960050;background-color:#1e0010>：</span> <span style=color:#e6db74>&#39;\u0000&#39;</span>
</span></span><span style=display:flex><span>        布尔类型<span style=color:#960050;background-color:#1e0010>：</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>        引用类型<span style=color:#960050;background-color:#1e0010>：</span> <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>    获取数组长度<span style=color:#960050;background-color:#1e0010>：</span> 数组名.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>    获取数组副本<span style=color:#960050;background-color:#1e0010>：</span> 数组名.<span style=color:#a6e22e>clone</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>成员变量与局部变量<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>    成员变量定义在类内<span style=color:#960050;background-color:#1e0010>，</span>方法外<span style=color:#960050;background-color:#1e0010>。</span>局部变量定义在方法内<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    成员变量不要写static关键字<span style=color:#960050;background-color:#1e0010>。</span><span style=color:#f92672>???</span>
</span></span><span style=display:flex><span>    成员变量有默认值<span style=color:#960050;background-color:#1e0010>，</span>而局部变量没有默认值<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    当成员变量与局部变量的命名冲突时<span style=color:#960050;background-color:#1e0010>，</span>按照就近原则<span style=color:#960050;background-color:#1e0010>，</span>优先使用局部变量<span style=color:#960050;background-color:#1e0010>。</span>若想使用全局变量<span style=color:#960050;background-color:#1e0010>，</span>使用this.<span style=color:#a6e22e>成员变量名</span><span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>可变参数:
</span></span><span style=display:flex><span>    使用前提<span style=color:#960050;background-color:#1e0010>：</span>当方法的参数类型确定<span style=color:#960050;background-color:#1e0010>，</span>但是参数个数不确定时<span style=color:#960050;background-color:#1e0010>，</span>使用可变参数<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    使用格式<span style=color:#960050;background-color:#1e0010>：</span>修饰符 返回值类型 <span style=color:#a6e22e>方法名</span>(数据类型...<span style=color:#a6e22e>变量名</span>) {}   例如:   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func</span> (<span style=color:#66d9ef>int</span>... num) {}
</span></span><span style=display:flex><span>    原理<span style=color:#960050;background-color:#1e0010>：</span>   可变参数底层是一个数组<span style=color:#960050;background-color:#1e0010>，</span>根据传递参数个数的不同<span style=color:#960050;background-color:#1e0010>，</span>会创建不同长度的数组<span style=color:#960050;background-color:#1e0010>，</span>来存储这些参数<span style=color:#960050;background-color:#1e0010>。</span>参数个数可以是0个或多个<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>            因此<span style=color:#960050;background-color:#1e0010>，</span>方法中的变量名其实就是数组的名字<span style=color:#960050;background-color:#1e0010>，</span>可以作为数组使用<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    注意<span style=color:#960050;background-color:#1e0010>：</span>   一个方法的参数列表中只能有一个可变参数<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>            如果方法有多个参数<span style=color:#960050;background-color:#1e0010>，</span>则可变参数必须放在参数末尾<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>类的使用:
</span></span><span style=display:flex><span>    1<span style=color:#960050;background-color:#1e0010>、</span>导包<span style=color:#960050;background-color:#1e0010>：</span><span style=color:#f92672>import</span> 包路径.类名称   当类与当前文件处于同一个包中时<span style=color:#960050;background-color:#1e0010>，</span>可以不用导包<span style=color:#960050;background-color:#1e0010>。</span>只有java.<span style=color:#a6e22e>lang下的包不需要导包</span><span style=color:#960050;background-color:#1e0010>，</span>其他都需要导包<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>                                            但实际使用中<span style=color:#960050;background-color:#1e0010>，</span>可以不用手动导包<span style=color:#960050;background-color:#1e0010>，</span>当你使用某个类时<span style=color:#960050;background-color:#1e0010>，</span>系统会自动帮你导包<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    2<span style=color:#960050;background-color:#1e0010>、</span>实例化<span style=color:#960050;background-color:#1e0010>：</span> 类名称 对象名 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> 类名称();
</span></span><span style=display:flex><span>    3<span style=color:#960050;background-color:#1e0010>、</span>使用: 对象名.<span style=color:#a6e22e>成员变量名</span>        对象名.<span style=color:#a6e22e>成员方法名</span>(参数)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Private:
</span></span><span style=display:flex><span>    Getter: 函数格式必须是 getXXX   如果变量是布尔类型<span style=color:#960050;background-color:#1e0010>，</span>则使用isXXX
</span></span><span style=display:flex><span>    Setter: 函数格式必须是 setXXX
</span></span><span style=display:flex><span>    Private修饰构造函数时<span style=color:#960050;background-color:#1e0010>，</span>外部不能再构造该类的实例<span style=color:#960050;background-color:#1e0010>，</span>故只能在类内构造好全部实例并赋给static类型的变量<span style=color:#960050;background-color:#1e0010>。</span>叫构造函数私有化
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>this: this是当前对象的引用<span style=color:#960050;background-color:#1e0010>，</span>即this和对象是同一个东西<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>成员变量</span>    调用本类成员变量    可以将类内的成员变量与方法中的同名局部变量区分<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>成员方法</span>    调用本类成员方法
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>this</span>(...)      调用本类构造函数 <span style=color:#f92672>--&gt;</span> 写在第一行<span style=color:#960050;background-color:#1e0010>，</span>只能调用一个<span style=color:#960050;background-color:#1e0010>。</span>  若子类使用了this(...)<span style=color:#960050;background-color:#1e0010>，</span>则不再默认赠送super()<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>super</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>成员变量</span>   调用父类成员变量     可以将父类中的成员变量和子类中的同名成员变量区分<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>成员方法</span>   调用父类成员变量
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>super</span>(...)     调用父类类构造函数 <span style=color:#f92672>--&gt;</span> 写在第一行<span style=color:#960050;background-color:#1e0010>，</span>只能调用一个<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>构造函数<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>    格式<span style=color:#960050;background-color:#1e0010>：</span> <span style=color:#66d9ef>public</span> 类名<span style=color:#960050;background-color:#1e0010>（</span>参数类型 参数名称 <span style=color:#960050;background-color:#1e0010>，</span> ...<span style=color:#960050;background-color:#1e0010>）</span>{...}
</span></span><span style=display:flex><span>    注意事项<span style=color:#960050;background-color:#1e0010>：</span> 构造方法的名称和类名要严格相等<span style=color:#960050;background-color:#1e0010>，</span>大小写敏感<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>             构造方法没有返回值类型<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>             若不明确定义构造函数<span style=color:#960050;background-color:#1e0010>，</span>则会自动生成默认构造函数<span style=color:#960050;background-color:#1e0010>，</span>若手动定义了任意形式的构造函数<span style=color:#960050;background-color:#1e0010>，</span>编译器将不会再生成默认构造函数<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>             构造函数支持重载
</span></span><span style=display:flex><span>    继承中的构造函数:  构造链<span style=color:#960050;background-color:#1e0010>：</span>同C<span style=color:#f92672>++</span>一样<span style=color:#f92672>--&gt;</span> 祖宗 <span style=color:#f92672>&gt;</span> 父类 <span style=color:#f92672>&gt;</span> 子类        子类构造方法中若不显式调用super<span style=color:#960050;background-color:#1e0010>，</span>则默认隐含一个 <span style=color:#e6db74>&#34;super()&#34;</span> 调用<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>                    子类构造函数可以显式地写 <span style=color:#a6e22e>super</span>(<span style=color:#f92672>[</span>参数1<span style=color:#960050;background-color:#1e0010>，</span>...<span style=color:#f92672>]</span>) 来调用父类的重载构造函数<span style=color:#960050;background-color:#1e0010>。</span>且必须在方法体的第一行<span style=color:#960050;background-color:#1e0010>，</span>即只能调用一个<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>标准类<span style=color:#960050;background-color:#1e0010>：</span>也叫做 Java Bean
</span></span><span style=display:flex><span>    通常包含以下4部分内容<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>        所有的成员变量都要使用private关键字<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        为每一个成员变量编写一对儿Getter<span style=color:#f92672>/</span>Setter方法
</span></span><span style=display:flex><span>        编写一个无参构造函数
</span></span><span style=display:flex><span>        编写一个全参构造函数
</span></span><span style=display:flex><span>    点击 Code<span style=color:#f92672>-&gt;</span>Generate 或者 快捷键 alt <span style=color:#f92672>+</span> insert 可以自动生成上述内容
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>==</span><span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>    对于基本类型<span style=color:#960050;background-color:#1e0010>，</span> <span style=color:#f92672>==</span> 比较的是值
</span></span><span style=display:flex><span>    对于引用类型<span style=color:#960050;background-color:#1e0010>，</span> <span style=color:#f92672>==</span> 比较的是地址
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>基本类型与字符串之间的转换<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>    基本类型 <span style=color:#f92672>--&gt;</span> 字符串
</span></span><span style=display:flex><span>        1<span style=color:#960050;background-color:#1e0010>、</span>基本数据类型的值<span style=color:#f92672>+</span><span style=color:#e6db74>&#34;&#34;</span>  最简单的方式<span style=color:#960050;background-color:#1e0010>（</span>工作中常用<span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span>        2<span style=color:#960050;background-color:#1e0010>、</span>使用包装类的静态方法   <span style=color:#66d9ef>static</span> String <span style=color:#a6e22e>toString</span>(<span style=color:#66d9ef>int</span> i)  将i变为字符串形式   如 Integer.<span style=color:#a6e22e>toString</span>(100);
</span></span><span style=display:flex><span>        3<span style=color:#960050;background-color:#1e0010>、</span>使用String类的静态方法   <span style=color:#66d9ef>static</span> String <span style=color:#a6e22e>valueOf</span>(<span style=color:#66d9ef>int</span> i)  将i变为字符串形式   如 String.<span style=color:#a6e22e>valueOf</span>(100);
</span></span><span style=display:flex><span>    字符串 <span style=color:#f92672>--&gt;</span> 基本类型
</span></span><span style=display:flex><span>        使用包装类的静态方法 <span style=color:#a6e22e>parseXX</span>(<span style=color:#e6db74>&#34;字符串&#34;</span>)
</span></span><span style=display:flex><span>            Integer    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>parseInt</span>(String s)     如 Integer.<span style=color:#a6e22e>parseInt</span>(<span style=color:#e6db74>&#34;100&#34;</span>);
</span></span><span style=display:flex><span>            ... ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>泛型:  泛型名字不一定是E<span style=color:#960050;background-color:#1e0010>，</span>可以是任意大写字母<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    类: <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ClassName</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> { ... 在类内将需要的地方都用E代替}     实例化对象时确定类型
</span></span><span style=display:flex><span>    方法: 修饰符 <span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> 返回值类型 <span style=color:#a6e22e>方法名</span>(参数列表){ ... }                   调用方法时确定类型
</span></span><span style=display:flex><span>    接口: 含有泛型的接口定义与类相同<span style=color:#960050;background-color:#1e0010>。</span>  确定类型的方法<span style=color:#960050;background-color:#1e0010>：</span>1<span style=color:#960050;background-color:#1e0010>、</span>在实现类中确定类型   2<span style=color:#960050;background-color:#1e0010>、</span>实现类依然沿用接口的泛型E<span style=color:#960050;background-color:#1e0010>，</span>实现类创建对象时确定类型
</span></span><span style=display:flex><span>    通配符: <span style=color:#f92672>&lt;?&gt;</span>  代表任意数据类型<span style=color:#960050;background-color:#1e0010>，</span>
</span></span><span style=display:flex><span>        使用: 例如当多个不同类型的ArrayList集合要作为参数调用同一个方法时<span style=color:#960050;background-color:#1e0010>，</span>可以将参数设置为ArrayList<span style=color:#f92672>&lt;?&gt;</span> list方便接受任意类型<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        高级使用: <span style=color:#f92672>?</span> <span style=color:#66d9ef>extends</span> E 表示 <span style=color:#f92672>?</span> 只能是E的子类<span style=color:#f92672>/</span>本身
</span></span><span style=display:flex><span>                 <span style=color:#f92672>?</span> <span style=color:#66d9ef>super</span> E   表示 <span style=color:#f92672>?</span> 只能是E的父类<span style=color:#f92672>/</span>本身
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>static:
</span></span><span style=display:flex><span>    带上static的成员变量或函数<span style=color:#960050;background-color:#1e0010>，</span>不属于对象<span style=color:#960050;background-color:#1e0010>，</span>而是属于类<span style=color:#960050;background-color:#1e0010>，</span>所有对象共享<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    类名.<span style=color:#a6e22e>静态变量</span>
</span></span><span style=display:flex><span>    类名.<span style=color:#a6e22e>静态方法</span>()
</span></span><span style=display:flex><span>    注意事项<span style=color:#960050;background-color:#1e0010>：</span>静态不能直接访问非静态 <span style=color:#f92672>--&gt;</span> 在内存中<span style=color:#960050;background-color:#1e0010>，</span>先有静态<span style=color:#960050;background-color:#1e0010>，</span>后有非静态
</span></span><span style=display:flex><span>            静态不能使用this
</span></span><span style=display:flex><span>    静态代码块<span style=color:#960050;background-color:#1e0010>：</span><span style=color:#66d9ef>static</span>{  ...  }  首次用到类时<span style=color:#960050;background-color:#1e0010>，</span>静态代码块唯一执行一次<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>              典型用途<span style=color:#960050;background-color:#1e0010>：</span>一次性地对静态成员变量赋值<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>override:
</span></span><span style=display:flex><span>    在子类的覆盖重写方法前面加上 <span style=color:#a6e22e>@override</span> 可以检验该方法是否为重写方法<span style=color:#960050;background-color:#1e0010>（</span>建议写上<span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span>    子类方法的返回值的范围必须 小于等于 父类方法的返回值的范围<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    子类方法的权限必须 大于等于 父类方法的权限
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>权限<span style=color:#960050;background-color:#1e0010>：</span>                <span style=color:#66d9ef>public</span> <span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>protected</span> <span style=color:#f92672>&gt;</span> (<span style=color:#66d9ef>default</span>) <span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>private</span>     (<span style=color:#66d9ef>default</span>) 表示什么也不写<span style=color:#960050;background-color:#1e0010>，</span>留空<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        同一个类        YES       YES          YES        <span style=color:#a6e22e>YES</span>     (我自己)
</span></span><span style=display:flex><span>        同一个包        YES       YES          YES        <span style=color:#a6e22e>NO</span>      (我领居)
</span></span><span style=display:flex><span>        不同包子类       YES       YES          NO         <span style=color:#a6e22e>NO</span>     (我儿子)
</span></span><span style=display:flex><span>        不同包不同类     YES        NO          NO         <span style=color:#a6e22e>NO</span>      (陌生人)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>abstract:
</span></span><span style=display:flex><span>    抽象方法<span style=color:#960050;background-color:#1e0010>：</span>只定义<span style=color:#960050;background-color:#1e0010>，</span>不实现<span style=color:#960050;background-color:#1e0010>。</span>加上abstract关键字<span style=color:#960050;background-color:#1e0010>，</span>去掉大括号<span style=color:#960050;background-color:#1e0010>，</span>直接分号结束<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    抽象类<span style=color:#960050;background-color:#1e0010>：</span> 抽象方法所在的类<span style=color:#960050;background-color:#1e0010>，</span>必须是抽象类<span style=color:#960050;background-color:#1e0010>。</span>在class前加上abstract即可<span style=color:#960050;background-color:#1e0010>。</span>但抽象类中不一定包含抽象方法<span style=color:#960050;background-color:#1e0010>（</span>通常是有的<span style=color:#960050;background-color:#1e0010>）。</span>
</span></span><span style=display:flex><span>    使用步骤<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>        抽象类不能直接创建对象<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        必须用一个子类继承抽象父类<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        子类必须覆盖重写抽象父类中的所有抽象方法<span style=color:#960050;background-color:#1e0010>。</span><span style=color:#f92672>--&gt;</span>此处覆盖重写即实现<span style=color:#960050;background-color:#1e0010>：</span>子类去掉抽象方法的abstract关键字<span style=color:#960050;background-color:#1e0010>，</span>然后补上方法体大括号<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        创建子类对象<span style=color:#960050;background-color:#1e0010>，</span>并使用<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>interface</span><span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>概念</span><span style=color:#960050;background-color:#1e0010>：</span>接口就是多个类的公共规范<span style=color:#960050;background-color:#1e0010>。</span>是一种引用数据类型<span style=color:#960050;background-color:#1e0010>，</span>最重要的就是其中的抽象方法<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    定义<span style=color:#960050;background-color:#1e0010>：</span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>接口名称</span> { ... }
</span></span><span style=display:flex><span>    包含<span style=color:#960050;background-color:#1e0010>：</span>常量<span style=color:#960050;background-color:#1e0010>、</span>抽象方法<span style=color:#960050;background-color:#1e0010>、</span>默认方法<span style=color:#960050;background-color:#1e0010>、</span>静态方法<span style=color:#960050;background-color:#1e0010>、</span>私有方法<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    常量<span style=color:#960050;background-color:#1e0010>：</span>可以理解为成员变量<span style=color:#960050;background-color:#1e0010>，</span>但是必须使用 <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> 三个关键字修饰<span style=color:#960050;background-color:#1e0010>，</span>故相当于常量<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> 数据类型 常量名称 <span style=color:#f92672>=</span> 值  <span style=color:#960050;background-color:#1e0010>（</span>三个关键字可省略<span style=color:#960050;background-color:#1e0010>，</span>但不能换为别的<span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span>         注意<span style=color:#960050;background-color:#1e0010>：</span>1<span style=color:#960050;background-color:#1e0010>、</span>接口中的常量可以省略public <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span><span style=color:#960050;background-color:#1e0010>，</span>但写不写效果一样<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>              2<span style=color:#960050;background-color:#1e0010>、</span>接口中的常量必须手动赋值<span style=color:#960050;background-color:#1e0010>，</span>不能不赋值<span style=color:#960050;background-color:#1e0010>。</span>赋值之后无法改变<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>              3<span style=color:#960050;background-color:#1e0010>、</span>常量名称全部大写<span style=color:#960050;background-color:#1e0010>，</span>由下划线连接<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>         使用<span style=color:#960050;background-color:#1e0010>：</span>接口名称.<span style=color:#a6e22e>常量</span>
</span></span><span style=display:flex><span>    抽象方法<span style=color:#960050;background-color:#1e0010>：</span>1<span style=color:#960050;background-color:#1e0010>、</span>接口中的抽象方法<span style=color:#960050;background-color:#1e0010>，</span>修饰符固定为 <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>abstract</span>  (可省略<span style=color:#960050;background-color:#1e0010>，</span>但不能换为别的)
</span></span><span style=display:flex><span>            2<span style=color:#960050;background-color:#1e0010>、</span>方法的三要素可随意定义<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    默认方法<span style=color:#960050;background-color:#1e0010>：</span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>default</span> 返回值类型 <span style=color:#a6e22e>方法名</span>(参数列表) {方法体} (public可省略<span style=color:#960050;background-color:#1e0010>，</span>default不能省略)
</span></span><span style=display:flex><span>            可以解决接口升级的问题<span style=color:#960050;background-color:#1e0010>。（</span>不想改变实现类<span style=color:#960050;background-color:#1e0010>，</span>但是接口中又想要添加新方法<span style=color:#960050;background-color:#1e0010>，</span>则接口就可以用默认方法自己实现<span style=color:#960050;background-color:#1e0010>）（</span>实现类可以覆盖重写默认方法<span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span>            默认方法会被实现类继承<span style=color:#960050;background-color:#1e0010>，</span>故可以通过实现类的对象访问默认方法<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    静态方法<span style=color:#960050;background-color:#1e0010>：</span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> 返回值类型 <span style=color:#a6e22e>方法名</span>(参数列表) {方法体}  (public可省略<span style=color:#960050;background-color:#1e0010>，</span>static不能省略)
</span></span><span style=display:flex><span>            使用<span style=color:#960050;background-color:#1e0010>：</span>接口名称.<span style=color:#a6e22e>静态方法</span>(参数);  不能通过对象访问<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    私有方法<span style=color:#960050;background-color:#1e0010>：</span>1<span style=color:#960050;background-color:#1e0010>、</span>普通私有方法<span style=color:#960050;background-color:#1e0010>：</span>解决多个默认方法之间的重复代码问题  <span style=color:#66d9ef>private</span> 返回值类型 <span style=color:#a6e22e>方法名</span>(参数列表) {方法体}
</span></span><span style=display:flex><span>                只有接口中的默认方法能访问<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>            2<span style=color:#960050;background-color:#1e0010>、</span>静态私有方法<span style=color:#960050;background-color:#1e0010>：</span>解决多个静态方法之间的重复代码问题  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> 返回值类型 <span style=color:#a6e22e>方法名</span>(参数列表) {方法体}
</span></span><span style=display:flex><span>                只有接口中的默认方法和静态方法能访问<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    使用<span style=color:#960050;background-color:#1e0010>：</span>1<span style=color:#960050;background-color:#1e0010>、</span>接口不能直接使用<span style=color:#960050;background-color:#1e0010>，</span>必须有一个<span style=color:#960050;background-color:#1e0010>“</span>实现类<span style=color:#960050;background-color:#1e0010>”</span>来<span style=color:#960050;background-color:#1e0010>“</span>实现<span style=color:#960050;background-color:#1e0010>”</span>该接口<span style=color:#960050;background-color:#1e0010>。</span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>实现类名称</span> <span style=color:#66d9ef>implements</span> 接口名称 {...}
</span></span><span style=display:flex><span>         2<span style=color:#960050;background-color:#1e0010>、</span>接口的实现类必须实现接口中的全部抽象方法<span style=color:#960050;background-color:#1e0010>。</span>去掉abstract关键字<span style=color:#960050;background-color:#1e0010>，</span>加上大括号实现体<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>         3<span style=color:#960050;background-color:#1e0010>、</span>创建实现类对象<span style=color:#960050;background-color:#1e0010>，</span>使用<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    注意事项<span style=color:#960050;background-color:#1e0010>：</span>1<span style=color:#960050;background-color:#1e0010>、</span>接口没有静态代码块和构造方法<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>            2<span style=color:#960050;background-color:#1e0010>、</span>如果实现类没有覆盖重写所有接口中的所有方法<span style=color:#960050;background-color:#1e0010>，</span>则该实现类自己就必须是抽象类<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>            3<span style=color:#960050;background-color:#1e0010>、</span>一个实现类可以实现多个接口  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>类名</span> <span style=color:#66d9ef>implements</span> interface1, interface2 {}<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>            4<span style=color:#960050;background-color:#1e0010>、</span>若一个类实现的多个接口中有重名的抽象方法<span style=color:#960050;background-color:#1e0010>，</span>则只需实现一个即可<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>            5<span style=color:#960050;background-color:#1e0010>、</span>若一个类实现的多个接口中有重名的默认方法<span style=color:#960050;background-color:#1e0010>，</span>则该实现类必须对重名默认方法覆盖重写<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>            6<span style=color:#960050;background-color:#1e0010>、</span>若一个类的直接父类中的方法和它实现的接口中的默认方法重名<span style=color:#960050;background-color:#1e0010>，</span>则优先使用直接父类的方法<span style=color:#960050;background-color:#1e0010>。</span> 在java中<span style=color:#960050;background-color:#1e0010>【</span>继承 优先于 接口<span style=color:#960050;background-color:#1e0010>】</span>
</span></span><span style=display:flex><span>            7<span style=color:#960050;background-color:#1e0010>、</span>接口是多继承的<span style=color:#960050;background-color:#1e0010>。</span>多个父接口当中的抽象方法如果重名<span style=color:#960050;background-color:#1e0010>，</span>没关系<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>                           多个父接口当中的默认方法如果重名<span style=color:#960050;background-color:#1e0010>，</span>则子接口必须对重名的默认方法覆盖重写<span style=color:#960050;background-color:#1e0010>，【</span>而且带着default关键字<span style=color:#960050;background-color:#1e0010>】</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>多态<span style=color:#960050;background-color:#1e0010>：（</span>一个子类对象既有子类形态<span style=color:#960050;background-color:#1e0010>，</span>又有父类形态<span style=color:#960050;background-color:#1e0010>）</span>一个对象拥有多种形态<span style=color:#960050;background-color:#1e0010>，</span>即<span style=color:#960050;background-color:#1e0010>【</span>对象<span style=color:#960050;background-color:#1e0010>】</span>的多态性<span style=color:#960050;background-color:#1e0010>。【</span>多态性指的是对象<span style=color:#960050;background-color:#1e0010>，</span>而不是类<span style=color:#960050;background-color:#1e0010>】</span>
</span></span><span style=display:flex><span>    代码中体现多态性<span style=color:#960050;background-color:#1e0010>：</span> 父类引用指向子类对象<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    格式   父类名称 对象名 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> 子类名称();   或   接口名称 对象名 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> 实现类名称();
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>【</span>初步理解: 定义了一个指向子类对象的父类引用<span style=color:#960050;background-color:#1e0010>，</span>这个引用指向的是子类的对象<span style=color:#960050;background-color:#1e0010>，</span>但是只能访问父类大小的内存空间<span style=color:#960050;background-color:#1e0010>，</span>所以它只能访问父类继承到子类当中的成员
</span></span><span style=display:flex><span>              <span style=color:#960050;background-color:#1e0010>（</span>包括成员变量和成员函数<span style=color:#960050;background-color:#1e0010>）</span>的那部分内存空间<span style=color:#960050;background-color:#1e0010>，</span>而不能访问子类独有的多出来的那部分内存空间<span style=color:#960050;background-color:#1e0010>，</span>而对于被子类重写了的方法<span style=color:#960050;background-color:#1e0010>，</span>该引用依然可以访问
</span></span><span style=display:flex><span>              这部分内存<span style=color:#960050;background-color:#1e0010>，</span>只是内存中的内容已经被改写了<span style=color:#960050;background-color:#1e0010>，</span>所以访问到的是子类重写之后的方法<span style=color:#960050;background-color:#1e0010>。</span>综上所述<span style=color:#960050;background-color:#1e0010>，</span>该引用能访问的范围是所有从父类继承下来的变量和
</span></span><span style=display:flex><span>              父类独有方法<span style=color:#960050;background-color:#1e0010>，</span>以及被子类重写之后的方法<span style=color:#960050;background-color:#1e0010>。】</span>
</span></span><span style=display:flex><span>    多态对象访问成员变量<span style=color:#960050;background-color:#1e0010>：</span> 对象名.<span style=color:#a6e22e>成员变量</span>  访问的是父类的成员变量<span style=color:#960050;background-color:#1e0010>，</span>若没有则向上找<span style=color:#960050;background-color:#1e0010>，</span>不会向下找<span style=color:#960050;background-color:#1e0010>。</span> 不能用这种方法访问子类特有成员变量<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    多态对象访问成员函数<span style=color:#960050;background-color:#1e0010>：</span> 若子类重写了父类的成员函数<span style=color:#960050;background-color:#1e0010>，</span>则访问子类的成员函数<span style=color:#960050;background-color:#1e0010>。</span> 若子类没有重写<span style=color:#960050;background-color:#1e0010>，</span>则访问父类的成员函数<span style=color:#960050;background-color:#1e0010>，</span>没有则向上找<span style=color:#960050;background-color:#1e0010>。</span> 同样不能访问子类特有成员函数<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        记忆口诀<span style=color:#960050;background-color:#1e0010>；</span>对于成员变量<span style=color:#960050;background-color:#1e0010>，</span>等号左边是谁就优先用谁<span style=color:#960050;background-color:#1e0010>。</span>对于成员方法<span style=color:#960050;background-color:#1e0010>，</span>new的是谁就优先用谁<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    使用多态的好处<span style=color:#960050;background-color:#1e0010>：</span>比如将父类的引用作为参数传入方法中<span style=color:#960050;background-color:#1e0010>，</span>则该引用可以指向不同的子类对象使方法实现不同的功能<span style=color:#960050;background-color:#1e0010>，</span>却不需要改变方法中的任何代码<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>对象的向上转型<span style=color:#960050;background-color:#1e0010>：</span> 在特定场合会自动向上转型<span style=color:#960050;background-color:#1e0010>，</span>如方法参数要求为父类<span style=color:#960050;background-color:#1e0010>，</span>但是传入一个子类对象也正确<span style=color:#960050;background-color:#1e0010>，</span>这时就发生了自动向上转型<span style=color:#960050;background-color:#1e0010>。</span>与int double发生自动类型转换原理一样<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    格式<span style=color:#960050;background-color:#1e0010>：</span>与多态相同<span style=color:#960050;background-color:#1e0010>：</span>父类名称 对象名 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> 子类名称();
</span></span><span style=display:flex><span>    含义<span style=color:#960050;background-color:#1e0010>：</span>创建一个子类对象<span style=color:#960050;background-color:#1e0010>，</span>把它当作父类来看待使用<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>【</span>向上转型一定是安全的<span style=color:#960050;background-color:#1e0010>】</span>从小范围转向了大范围<span style=color:#960050;background-color:#1e0010>，</span>如将小范围的猫向上转型为更大范围的动物<span style=color:#960050;background-color:#1e0010>。</span> 类似于将short转换为int<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    弊端<span style=color:#960050;background-color:#1e0010>：</span>不能访问子类特有方法<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>对象的向下转型<span style=color:#960050;background-color:#1e0010>：</span>其实是一个<span style=color:#960050;background-color:#1e0010>【</span>还原<span style=color:#960050;background-color:#1e0010>】</span>的动作<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    格式<span style=color:#960050;background-color:#1e0010>：</span>   子类名称 对象名 <span style=color:#f92672>=</span> (子类名称) 父类对象;   (子类名称)必须有<span style=color:#960050;background-color:#1e0010>，</span>不能省略<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    含义<span style=color:#960050;background-color:#1e0010>：</span>   将向上转型之后的父类对象还原为本来的子类对象<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    注意<span style=color:#960050;background-color:#1e0010>：</span>   只有本来是猫<span style=color:#960050;background-color:#1e0010>，</span>向上转型为动物后<span style=color:#960050;background-color:#1e0010>，</span>再向下转型为猫才是正确的<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>            若本来不是猫<span style=color:#960050;background-color:#1e0010>，</span>却硬要向下转型为猫就会出错(编译不会报错<span style=color:#960050;background-color:#1e0010>，</span>但运行会出现异常ClassCastException)<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>instanceof</span>:
</span></span><span style=display:flex><span>        格式<span style=color:#960050;background-color:#1e0010>：</span> 对象名 <span style=color:#66d9ef>instanceof</span> 类名
</span></span><span style=display:flex><span>        作用<span style=color:#960050;background-color:#1e0010>：</span> 返回一个布尔值<span style=color:#960050;background-color:#1e0010>，</span>判断前面的对象能不能当作后面类的实例<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        应用<span style=color:#960050;background-color:#1e0010>：</span> 在向下转型之前<span style=color:#960050;background-color:#1e0010>，</span>判断需要转型的对象是不是目标类的对象<span style=color:#960050;background-color:#1e0010>，</span>是则向下转型<span style=color:#960050;background-color:#1e0010>，</span>不是则不转型<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>final: 该关键字表示最终的<span style=color:#960050;background-color:#1e0010>，</span>不可再改变的<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    用法: 修饰一个类<span style=color:#960050;background-color:#1e0010>、</span>方法<span style=color:#960050;background-color:#1e0010>、</span>局部变量<span style=color:#960050;background-color:#1e0010>、</span>成员变量<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>         修饰一个类<span style=color:#960050;background-color:#1e0010>：</span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>类名</span> {...}  不能有子类<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>         修饰一个方法<span style=color:#960050;background-color:#1e0010>：</span> 该方法不能被重写<span style=color:#960050;background-color:#1e0010>。</span>   对于类和方法<span style=color:#960050;background-color:#1e0010>，</span><span style=color:#66d9ef>abstract</span> 和 <span style=color:#66d9ef>final</span> 不能同时使用<span style=color:#960050;background-color:#1e0010>，</span>会矛盾<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>         修饰一个局部变量<span style=color:#960050;background-color:#1e0010>：</span> 一次赋值<span style=color:#960050;background-color:#1e0010>，</span>终生不变<span style=color:#960050;background-color:#1e0010>。（</span>可以先定义<span style=color:#960050;background-color:#1e0010>，</span>再赋值<span style=color:#960050;background-color:#1e0010>。</span>分两步<span style=color:#960050;background-color:#1e0010>）</span><span style=color:#f92672>--</span>对于基本类型<span style=color:#960050;background-color:#1e0010>，</span>值不可变<span style=color:#960050;background-color:#1e0010>。</span>对于引用类型<span style=color:#960050;background-color:#1e0010>，</span>地址值不可变<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>         修饰一个成员变量<span style=color:#960050;background-color:#1e0010>：</span> 由于成员变量有默认值<span style=color:#960050;background-color:#1e0010>，</span>所以不能分两步<span style=color:#960050;background-color:#1e0010>，</span>必须当场手动赋值或通过构造函数赋值<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>         修饰一个数组或集合<span style=color:#960050;background-color:#1e0010>：</span> 该数组或集合不能再被赋值<span style=color:#960050;background-color:#1e0010>，</span>但内部的数据还可以改变<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>内部类<span style=color:#960050;background-color:#1e0010>：</span> 一个类内部包含另一个类<span style=color:#960050;background-color:#1e0010>，</span>即一个事物内部包含另一个事物<span style=color:#960050;background-color:#1e0010>。</span> 例如 身体和心脏的关系
</span></span><span style=display:flex><span>    分类<span style=color:#960050;background-color:#1e0010>：</span> 成员内部类      局部内部类<span style=color:#960050;background-color:#1e0010>（</span>包含匿名内部类<span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span>    成员内部类<span style=color:#960050;background-color:#1e0010>：</span>修饰符 <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>外部类名称</span> { 修饰符 <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>内部类名称</span> {...} ... }  内用外<span style=color:#960050;background-color:#1e0010>，</span>随意访问<span style=color:#960050;background-color:#1e0010>。</span>外用内<span style=color:#960050;background-color:#1e0010>，</span>需要内部类对象<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>             在main方法中使用<span style=color:#960050;background-color:#1e0010>：</span>1<span style=color:#960050;background-color:#1e0010>、</span>间接方式<span style=color:#960050;background-color:#1e0010>：</span> 在外部类的方法中调用内部类<span style=color:#960050;background-color:#1e0010>，</span>然后main通过访问外部类的方法调用内部类<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>                            2<span style=color:#960050;background-color:#1e0010>、</span>直接方式<span style=color:#960050;background-color:#1e0010>：</span> 外部类名称.<span style=color:#a6e22e>内部类名称</span> 对象名 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> 外部类名称().<span style=color:#a6e22e>new</span> 内部类名称();
</span></span><span style=display:flex><span>             当局部变量<span style=color:#960050;background-color:#1e0010>、</span>内部类的成员变量<span style=color:#960050;background-color:#1e0010>、</span>外部类的成员变量重名时<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>                内部类的成员方法调用内部类的成员变量用this.<span style=color:#a6e22e>内部成员变量</span><span style=color:#960050;background-color:#1e0010>。</span> 内部类的成员方法调用外部类的成员变量用Outer.<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>外部成员变量</span><span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    局部内部类<span style=color:#960050;background-color:#1e0010>：</span>如果一个类定义在方法内部<span style=color:#960050;background-color:#1e0010>，</span>就是局部内部类<span style=color:#960050;background-color:#1e0010>。</span><span style=color:#f92672>---</span>只有当前所属的方法才能使用它<span style=color:#960050;background-color:#1e0010>，</span>出了这个方法就不能使用了<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>             格式<span style=color:#960050;background-color:#1e0010>：</span>修饰符 <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>外部类名称</span> {... 修饰符 返回值类型 <span style=color:#a6e22e>外部类方法名称</span>(参数列表) { <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>内部局部类名称</span> {...} ... } ...}
</span></span><span style=display:flex><span>             注意<span style=color:#960050;background-color:#1e0010>：</span>若局部内部类要访问所在方法的局部变量<span style=color:#960050;background-color:#1e0010>，</span>则该局部变量必须是<span style=color:#960050;background-color:#1e0010>【</span>有效final的<span style=color:#960050;background-color:#1e0010>】（</span>即可以不写final关键字<span style=color:#960050;background-color:#1e0010>，</span>但是不能变<span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span>                        因为局部内部类在堆中<span style=color:#960050;background-color:#1e0010>，</span>生命周期长<span style=color:#960050;background-color:#1e0010>，</span>而局部变量在栈中<span style=color:#960050;background-color:#1e0010>，</span>生命周期短<span style=color:#960050;background-color:#1e0010>，</span>所以不能变<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>【</span>匿名内部类<span style=color:#960050;background-color:#1e0010>】：【</span>用的最多<span style=color:#960050;background-color:#1e0010>】</span> 如果接口的实现类<span style=color:#960050;background-color:#1e0010>（</span>或者父类的子类<span style=color:#960050;background-color:#1e0010>）</span>只需使用唯一的一次<span style=color:#960050;background-color:#1e0010>，</span>则可以省略该类的定义<span style=color:#960050;background-color:#1e0010>，</span>而改为使用匿名内部类<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>             格式<span style=color:#960050;background-color:#1e0010>：</span>接口名称 对象名 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> 接口名称() { 重写所有抽象方法 };
</span></span><span style=display:flex><span>             注意<span style=color:#960050;background-color:#1e0010>：</span>1<span style=color:#960050;background-color:#1e0010>、</span>匿名内部类只能唯一<span style=color:#960050;background-color:#1e0010>【</span>创建一次对象<span style=color:#960050;background-color:#1e0010>】。</span>若想多次创建对象<span style=color:#960050;background-color:#1e0010>，</span>就要单独定义实现类<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>                  2<span style=color:#960050;background-color:#1e0010>、</span>匿名对象只能唯一<span style=color:#960050;background-color:#1e0010>【</span>调用一次方法<span style=color:#960050;background-color:#1e0010>】。</span>若想多次调用方法<span style=color:#960050;background-color:#1e0010>，</span>就要给对象起个名字<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>                  3<span style=color:#960050;background-color:#1e0010>、</span>匿名内部类是省略了实现类<span style=color:#f92672>/</span>子类名称<span style=color:#960050;background-color:#1e0010>。</span>而匿名对象是省略了对象名称<span style=color:#960050;background-color:#1e0010>。</span>他俩不是一回事<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>new</span> 接口名() { 重写所有抽象方法 }.<span style=color:#a6e22e>方法</span>(参数);  即匿名内部类又匿名对象的使用方法<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>异常:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> : 用于抛出异常<span style=color:#960050;background-color:#1e0010>，</span>   例如: <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException(<span style=color:#e6db74>&#34;异常产生的原因&#34;</span>)
</span></span><span style=display:flex><span>        若抛出运行时异常<span style=color:#960050;background-color:#1e0010>，</span>可不理会<span style=color:#960050;background-color:#1e0010>，</span>默认由JVM处理
</span></span><span style=display:flex><span>        若抛出编译器异常<span style=color:#960050;background-color:#1e0010>，</span>则必须处理<span style=color:#960050;background-color:#1e0010>。</span>throws或try<span style=color:#f92672>-</span><span style=color:#66d9ef>catch</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throws</span>: 声明异常<span style=color:#960050;background-color:#1e0010>。</span>  (用于甩锅)
</span></span><span style=display:flex><span>        格式: 修饰符 返回值类型 <span style=color:#a6e22e>方法名</span>(参数列表) <span style=color:#66d9ef>throws</span> AAAException, BBBException... {<span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> AAAException(<span style=color:#e6db74>&#34;原因&#34;</span>)...}
</span></span><span style=display:flex><span>        注意: 1<span style=color:#960050;background-color:#1e0010>、</span>throws必须写在方法声明处
</span></span><span style=display:flex><span>             2<span style=color:#960050;background-color:#1e0010>、</span>throws后面必须是Exception或者是其子类
</span></span><span style=display:flex><span>             3<span style=color:#960050;background-color:#1e0010>、</span>throws后面必须声明方法内部抛出的所有异常
</span></span><span style=display:flex><span>             4<span style=color:#960050;background-color:#1e0010>、</span>若调用了一个声明抛出异常的方法<span style=color:#960050;background-color:#1e0010>，</span>则必须处理这些异常<span style=color:#960050;background-color:#1e0010>。</span>可以继续抛出<span style=color:#960050;background-color:#1e0010>，</span>也可以自己处理<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span><span style=color:#f92672>-</span><span style=color:#66d9ef>catch</span>:  自己处理异常
</span></span><span style=display:flex><span>        try可以抛出多个异常<span style=color:#960050;background-color:#1e0010>，</span>这时需要使用多个catch来捕获异常<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        try中若产生异常<span style=color:#960050;background-color:#1e0010>，</span>则try代码块中产生异常之后的代码不会执行<span style=color:#960050;background-color:#1e0010>，</span>而跳转到catch<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        try中若没有产生异常<span style=color:#960050;background-color:#1e0010>，</span>则执行完try中的代码继续执行try<span style=color:#f92672>-</span>catch之后的代码<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>finally</span>: 不论是否发生异常<span style=color:#960050;background-color:#1e0010>，</span>finally代码块中的代码一定会执行<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        格式 : <span style=color:#66d9ef>try</span>{} <span style=color:#66d9ef>catch</span>{} <span style=color:#66d9ef>finally</span>{}
</span></span><span style=display:flex><span>        注意 : finally必须与try一起使用<span style=color:#960050;background-color:#1e0010>，</span>一般用于资源释放<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>               正是由于其有一定会执行到<span style=color:#960050;background-color:#1e0010>，</span>所以若finally代码块中有return语句<span style=color:#960050;background-color:#1e0010>，</span>则一定会返回finally中的结果<span style=color:#960050;background-color:#1e0010>。（</span>要避免<span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span>    注意 : 子类异常一定要与父类异常一致<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Thread : Thread类是描述线程的类<span style=color:#960050;background-color:#1e0010>，</span>要实现多线程<span style=color:#960050;background-color:#1e0010>，</span>必须继承Thread类
</span></span><span style=display:flex><span>    每个线程拥有一个自己独立的栈<span style=color:#960050;background-color:#1e0010>，</span>但是共享进程的堆空间<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    Thread.<span style=color:#a6e22e>sleep</span>(毫秒)                          <span style=color:#75715e>// 静态方法  睡眠</span>
</span></span><span style=display:flex><span>    Thread thread <span style=color:#f92672>=</span> Thread.<span style=color:#a6e22e>currentThread</span>();     <span style=color:#75715e>// 获取当前线程</span>
</span></span><span style=display:flex><span>    第一种方法<span style=color:#960050;background-color:#1e0010>：</span> 创建Thread类的子类
</span></span><span style=display:flex><span>        1<span style=color:#960050;background-color:#1e0010>、</span>创建Thread类的子类<span style=color:#960050;background-color:#1e0010>，</span>并重写run方法<span style=color:#960050;background-color:#1e0010>，</span>其中设置线程的任务
</span></span><span style=display:flex><span>        2<span style=color:#960050;background-color:#1e0010>、</span>创建子类对象<span style=color:#960050;background-color:#1e0010>，</span>并执行start方法  (执行start方法会创建一个新的栈空间<span style=color:#960050;background-color:#1e0010>，</span>并在该栈空间中执行run方法)(每执行一次步骤2<span style=color:#960050;background-color:#1e0010>，</span>就开启一个新的线程)
</span></span><span style=display:flex><span>    第二种方法<span style=color:#960050;background-color:#1e0010>：</span> 实现Runnable接口  (推荐使用这种)   <span style=color:#f92672>---&gt;</span>  使用该方法时<span style=color:#960050;background-color:#1e0010>，</span>Thread 类是咱们自定义类的静态代理类
</span></span><span style=display:flex><span>        1<span style=color:#960050;background-color:#1e0010>、</span>创建一个Runnable接口的实现类<span style=color:#960050;background-color:#1e0010>，</span>并重写run方法<span style=color:#960050;background-color:#1e0010>，</span>其中设置线程的任务
</span></span><span style=display:flex><span>        2<span style=color:#960050;background-color:#1e0010>、</span>创建对象<span style=color:#960050;background-color:#1e0010>，</span>并将其作为参数传递给Thread类的构造方法<span style=color:#960050;background-color:#1e0010>，</span>再调用start方法<span style=color:#960050;background-color:#1e0010>。</span> <span style=color:#66d9ef>new</span> Thread(<span style=color:#66d9ef>new</span> MyRunnable()).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        匿名内部类实现<span style=color:#960050;background-color:#1e0010>：</span> <span style=color:#66d9ef>new</span> Thread(<span style=color:#66d9ef>new</span> Runnable(){重写run方法}).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>    第三种方法<span style=color:#960050;background-color:#1e0010>：</span> 实现Callable<span style=color:#f92672>&lt;</span>V<span style=color:#f92672>&gt;</span>接口  <span style=color:#960050;background-color:#1e0010>（</span>面试可能会问到<span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span>        Callable接口类似于Runnable<span style=color:#960050;background-color:#1e0010>，【</span>Runnable不会返回结果<span style=color:#960050;background-color:#1e0010>，</span>也不会抛出检查异常<span style=color:#960050;background-color:#1e0010>，</span>Callable可以<span style=color:#960050;background-color:#1e0010>】</span>
</span></span><span style=display:flex><span>        1<span style=color:#960050;background-color:#1e0010>、</span>创建一个Callable<span style=color:#f92672>&lt;</span>V<span style=color:#f92672>&gt;</span>接口的实现类<span style=color:#960050;background-color:#1e0010>，</span>并重写call方法<span style=color:#960050;background-color:#1e0010>，</span>其中设置线程的任务
</span></span><span style=display:flex><span>        2<span style=color:#960050;background-color:#1e0010>、</span>在使用的地方创建该类对象 obj <span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        3<span style=color:#960050;background-color:#1e0010>、</span>ExecutorService executorService <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newFixedThreadPool</span>(5);  <span style=color:#75715e>// 创建执行服务</span>
</span></span><span style=display:flex><span>        4<span style=color:#960050;background-color:#1e0010>、</span>Future<span style=color:#f92672>&lt;</span>V<span style=color:#f92672>&gt;</span> future <span style=color:#f92672>=</span> executorService.<span style=color:#a6e22e>submit</span>(obj);                     <span style=color:#75715e>// 提交执行</span>
</span></span><span style=display:flex><span>        5<span style=color:#960050;background-color:#1e0010>、</span>V result <span style=color:#f92672>=</span> future.<span style=color:#a6e22e>get</span>();                                            <span style=color:#75715e>// 获取结果</span>
</span></span><span style=display:flex><span>        6<span style=color:#960050;background-color:#1e0010>、</span>executorService.<span style=color:#a6e22e>shutdownNow</span>();                                      <span style=color:#75715e>// 关闭服务</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>同步<span style=color:#960050;background-color:#1e0010>：</span>  多个对象访问同一个资源<span style=color:#960050;background-color:#1e0010>，</span>可以并发读取<span style=color:#960050;background-color:#1e0010>，</span>但当其中某一个对象要修改时<span style=color:#960050;background-color:#1e0010>，</span>就必须实现同步
</span></span><span style=display:flex><span>    所有的对象都拥有一把锁<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    锁对象选取总结为一句话就是 在同步代码中要改变谁就锁谁<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    方法一<span style=color:#960050;background-color:#1e0010>：</span> 同步代码块<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span> (锁对象) {访问共享数据的代码}  线程不仅要抢夺CUP<span style=color:#960050;background-color:#1e0010>，</span>还要占用锁对象<span style=color:#960050;background-color:#1e0010>。</span>同时拥有才能执行代码
</span></span><span style=display:flex><span>        锁对象可以是任意对象<span style=color:#960050;background-color:#1e0010>，</span>但必须是同一个对象<span style=color:#960050;background-color:#1e0010>，</span>推荐将共享资源作为锁对象<span style=color:#960050;background-color:#1e0010>。</span>线程占用锁对象后直到执行完毕才释放<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    方法二<span style=color:#960050;background-color:#1e0010>：</span> 同步方法
</span></span><span style=display:flex><span>        修饰符 <span style=color:#66d9ef>synchronized</span> 返回值类型 <span style=color:#a6e22e>方法名</span> (参数列表) {访问共享数据的代码}     <span style=color:#75715e>// 该方法即为同步方法</span>
</span></span><span style=display:flex><span>        首先将 访问共享数据的代码块 抽取出来<span style=color:#960050;background-color:#1e0010>，</span>作为上述方法<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        同步方法的锁对象默认为 <span style=color:#66d9ef>this</span> <span style=color:#960050;background-color:#1e0010>，</span>即同步方法所在类的对象<span style=color:#960050;background-color:#1e0010>；</span>创建该类的对象后<span style=color:#960050;background-color:#1e0010>，</span>该对象调用同步方法时就会锁住对象自己<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        当同步方法同时也是静态方法时<span style=color:#960050;background-color:#1e0010>，</span>锁对象为同步方法所在类的 Class 对象<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    方法三<span style=color:#960050;background-color:#1e0010>：</span> Lock锁
</span></span><span style=display:flex><span>        Lock是一个接口<span style=color:#960050;background-color:#1e0010>，</span>有两个方法 <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>lock</span>()  获取锁  和  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>unlock</span>()  释放锁
</span></span><span style=display:flex><span>        它有一个实现类ReentrantLock<span style=color:#960050;background-color:#1e0010>（</span>可重入锁<span style=color:#960050;background-color:#1e0010>），</span> 先实例化一个ReentrantLock对象<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        在出现安全问题代码之前用该对象调用 <span style=color:#a6e22e>lock</span>() 方法<span style=color:#960050;background-color:#1e0010>。</span>在出现安全问题代码之后用该对象调用 <span style=color:#a6e22e>unlock</span>() 方法<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>             lock() 和  <span style=color:#a6e22e>unlock</span>() 方法建议放在 <span style=color:#66d9ef>try</span> <span style=color:#f92672>---</span> <span style=color:#66d9ef>finally</span> 代码块中
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>线程状态<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>    线程停止<span style=color:#960050;background-color:#1e0010>：</span>不推荐使用 Thread 类提供的 <span style=color:#a6e22e>stop</span>() 等方法<span style=color:#960050;background-color:#1e0010>。</span>推荐自己通过一个标志位控制停止
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyRunnable</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> flag <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>while</span> (flag) {
</span></span><span style=display:flex><span>                            TODO...
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>stop</span>() {
</span></span><span style=display:flex><span>                        flag <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>			通过调用自己实现的 stop 方法来停止线程
</span></span><span style=display:flex><span>    下方所有方法都是 Thread 类中的方法<span style=color:#960050;background-color:#1e0010>！</span>
</span></span><span style=display:flex><span>    线程休眠<span style=color:#960050;background-color:#1e0010>：</span>Thread.<span style=color:#a6e22e>sleep</span>(毫秒)      <span style=color:#75715e>// sleep 不会释放锁、 wait 会释放锁。</span>
</span></span><span style=display:flex><span>    线程礼让<span style=color:#960050;background-color:#1e0010>：</span> Thread.<span style=color:#a6e22e>yield</span>();  使当前线程从运行状态变为就绪状态<span style=color:#960050;background-color:#1e0010>，</span>让 cpu 从所有就绪的线程中挑一个运行<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>                礼让有可能不成功<span style=color:#960050;background-color:#1e0010>，</span>因为 cpu 可能再挑选一次还是让当前线程继续执行<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    线程强制执行<span style=color:#960050;background-color:#1e0010>：</span> join()    <span style=color:#960050;background-color:#1e0010>，</span>相当于插队<span style=color:#960050;background-color:#1e0010>，</span>停止现在执行的线程<span style=color:#960050;background-color:#1e0010>，</span>立刻执行自己的线程<span style=color:#960050;background-color:#1e0010>，</span>且本线程执行结束才能执行其他线程
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyRunnable</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 1000; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Runnable &#34;</span> <span style=color:#f92672>+</span> i);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>                        MyRunnable myRunnable <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyRunnable();
</span></span><span style=display:flex><span>                        Thread thread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(myRunnable);
</span></span><span style=display:flex><span>                        thread.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 500; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>==</span> 200) {
</span></span><span style=display:flex><span>                                thread.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;主线程&#34;</span> <span style=color:#f92672>+</span> i);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>              在上方举例代码中<span style=color:#960050;background-color:#1e0010>，</span>主线程执行到200之前<span style=color:#960050;background-color:#1e0010>，</span>主线程和Runnable线程交替执行<span style=color:#960050;background-color:#1e0010>，</span>当主线程执行到200次时<span style=color:#960050;background-color:#1e0010>，</span>
</span></span><span style=display:flex><span>              Runnable 线程插队接着执行<span style=color:#960050;background-color:#1e0010>，</span>之后Runnable线程全部执行完毕后才由主线程继续执行<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>     查看线程状态<span style=color:#960050;background-color:#1e0010>：</span>Thread.<span style=color:#a6e22e>State</span> state <span style=color:#f92672>=</span> thread.<span style=color:#a6e22e>getState</span>();      <span style=color:#75715e>// Thread.State 是一个枚举类型</span>
</span></span><span style=display:flex><span>     线程优先级<span style=color:#960050;background-color:#1e0010>：</span>1 最小<span style=color:#960050;background-color:#1e0010>；</span>10 最大<span style=color:#960050;background-color:#1e0010>；</span>默认为5<span style=color:#960050;background-color:#1e0010>。</span>优先级越高在就绪状态很大可能越早执行<span style=color:#960050;background-color:#1e0010>，</span>但也不是一定<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>     守护<span style=color:#960050;background-color:#1e0010>（</span>daemon<span style=color:#960050;background-color:#1e0010>）</span>线程<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>         线程分为用户线程和守护线程<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>         虚拟机必须保证用户线程执行完毕<span style=color:#960050;background-color:#1e0010>，</span>但不用等待守护线程执行完毕<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>         守护线程有<span style=color:#960050;background-color:#1e0010>：</span>后台记录日志<span style=color:#960050;background-color:#1e0010>、</span>监控内存<span style=color:#960050;background-color:#1e0010>、</span>垃圾回收等
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> daemon <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;    <span style=color:#75715e>// 默认 daemon 属性是关闭的，即默认为用户线程</span>
</span></span><span style=display:flex><span>         thread.<span style=color:#a6e22e>setDaemon</span>(<span style=color:#66d9ef>true</span>);            <span style=color:#75715e>// 可通过这样将线程设置为 守护线程。</span>
</span></span><span style=display:flex><span>         <span style=color:#75715e>// 将线程设置为守护线程之后，虚拟机将不再保证该线程是否执行结束，</span>
</span></span><span style=display:flex><span>         <span style=color:#75715e>// 即只要当用户线程执行结束后就将整个程序关闭，而不考虑守护线程此时是否已经执行完毕。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>线程池 :   底层原理 <span style=color:#960050;background-color:#1e0010>：</span> 线程池就是一个容纳多个线程的容器<span style=color:#960050;background-color:#1e0010>，</span>可由集合实现
</span></span><span style=display:flex><span>    使用步骤: 1<span style=color:#960050;background-color:#1e0010>、</span>使用线程池工厂类Executors里面的静态方法newFixedThreadPool生产一个指定线程数量的线程池<span style=color:#960050;background-color:#1e0010>，</span>由ExecutorService接口接收<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>             2<span style=color:#960050;background-color:#1e0010>、</span>创建Runnable接口的实现类<span style=color:#960050;background-color:#1e0010>，</span>重写run方法<span style=color:#960050;background-color:#1e0010>，</span>设置线程任务<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>             3<span style=color:#960050;background-color:#1e0010>、</span>调用ExecutorService中的execute方法<span style=color:#960050;background-color:#1e0010>，</span>传递线程任务<span style=color:#960050;background-color:#1e0010>，</span>开启线程<span style=color:#960050;background-color:#1e0010>，</span>执行run方法<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>           例:   ExecutorService executorService <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newFixedThreadPool</span>(5);  <span style=color:#75715e>// 创建服务</span>
</span></span><span style=display:flex><span>                 Runnable runnable <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Runnable() {  <span style=color:#75715e>//此处虽然new 的是Runnable接口，但是立即重写了run方法，故相当于其实现类。</span>
</span></span><span style=display:flex><span>                     <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>                     <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>                         <span style=color:#75715e>//线程任务</span>
</span></span><span style=display:flex><span>                     }
</span></span><span style=display:flex><span>                 };
</span></span><span style=display:flex><span>                 executorService.<span style=color:#a6e22e>execute</span>(runnable);                                  <span style=color:#75715e>// 执行服务</span>
</span></span><span style=display:flex><span>                 executorService.<span style=color:#a6e22e>shutdownNow</span>();                                      <span style=color:#75715e>// 关闭服务</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	ExecutorService 中的 <span style=color:#a6e22e>submit</span>()方法和 <span style=color:#a6e22e>execute</span>()方法作用相同<span style=color:#960050;background-color:#1e0010>，</span>只是适用于不同场景
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>execute</span>(Runnable command)           <span style=color:#75715e>// 执行任务，没有返回值，一般用于执行 Runnable</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Future<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>submit</span>(Callable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> task);  <span style=color:#75715e>// 执行任务，有返回值，一般用于执行 Callable</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Lambda表达式 :  可推导<span style=color:#960050;background-color:#1e0010>，</span>可省略
</span></span><span style=display:flex><span>    格式<span style=color:#960050;background-color:#1e0010>：</span>  () <span style=color:#f92672>-&gt;</span> {}
</span></span><span style=display:flex><span>    使用前提<span style=color:#960050;background-color:#1e0010>：</span> 必须是接口<span style=color:#960050;background-color:#1e0010>，</span>且接口中有且只有一个抽象方法  (有且只有一个抽象方法的接口<span style=color:#960050;background-color:#1e0010>，</span>称为<span style=color:#e6db74>&#34;函数式接口&#34;</span>)
</span></span><span style=display:flex><span>    可以省略的内容<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>        1<span style=color:#960050;background-color:#1e0010>、</span>(参数列表) 参数列表中的数据类型可以省略<span style=color:#960050;background-color:#1e0010>，</span> 如果参数只有一个<span style=color:#960050;background-color:#1e0010>，</span>则括号()也可以省略
</span></span><span style=display:flex><span>        2<span style=color:#960050;background-color:#1e0010>、</span>{方法体}   如果{}中的代码只有一行<span style=color:#960050;background-color:#1e0010>，</span>无论是否有返回值<span style=color:#960050;background-color:#1e0010>，</span>都可以省略 {}<span style=color:#960050;background-color:#1e0010>，</span> <span style=color:#66d9ef>return</span><span style=color:#960050;background-color:#1e0010>，</span> 分号   <span style=color:#960050;background-color:#1e0010>（</span>要省一起省<span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>注解:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@override</span>                    检测是否为覆盖重写
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@FunctionalInterface</span>         检测是否为函数式接口
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>------------------------------------------------------------------------------------------------------------------</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>API使用<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>    Scanner<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>        功能<span style=color:#960050;background-color:#1e0010>：</span>从键盘输入数据到程序<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        包路径<span style=color:#960050;background-color:#1e0010>：</span>java.<span style=color:#a6e22e>util</span>.<span style=color:#a6e22e>Scanner</span>
</span></span><span style=display:flex><span>        实例化<span style=color:#960050;background-color:#1e0010>：</span>Scanner sc <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Scanner(System.<span style=color:#a6e22e>in</span>);  System.<span style=color:#a6e22e>in</span> 表示从键盘输入数据<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        方法<span style=color:#960050;background-color:#1e0010>：</span><span style=color:#f92672>---</span>其实键盘输入的一切东西都是字符串<span style=color:#960050;background-color:#1e0010>，</span>使用不同的函数会将字符串转换为相应的类型<span style=color:#960050;background-color:#1e0010>。</span><span style=color:#f92672>--&gt;</span>故若记不住也可以一直使用sc.<span style=color:#a6e22e>next</span>();之后再转换类型
</span></span><span style=display:flex><span>            获取键盘输入的一个int数字<span style=color:#960050;background-color:#1e0010>：</span> <span style=color:#66d9ef>int</span> num <span style=color:#f92672>=</span> sc.<span style=color:#a6e22e>nextInt</span>();
</span></span><span style=display:flex><span>            获取键盘输入的一个字符串<span style=color:#960050;background-color:#1e0010>：</span> String str <span style=color:#f92672>=</span> sc.<span style=color:#a6e22e>next</span>();
</span></span><span style=display:flex><span>        读取文件内容<span style=color:#960050;background-color:#1e0010>：</span>Scanner in <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Scanner(Paths.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;\u202AC:\\Users\\Lenovo\\Desktop\\1.txt&#34;</span>), StandardCharsets.<span style=color:#a6e22e>UTF_8</span>);
</span></span><span style=display:flex><span>            之后再用in的各种方法<span style=color:#960050;background-color:#1e0010>。</span>nextLine();   next();   nextInt(); 等
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Random:
</span></span><span style=display:flex><span>    功能: 获取随机数<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    实例化<span style=color:#960050;background-color:#1e0010>：</span>Random rand <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Random();
</span></span><span style=display:flex><span>    方法<span style=color:#960050;background-color:#1e0010>：</span><span style=color:#66d9ef>int</span> rand_num <span style=color:#f92672>=</span> rand.<span style=color:#a6e22e>nextInt</span>(n)  在<span style=color:#f92672>[</span>0, n)中随机取一个数字<span style=color:#960050;background-color:#1e0010>。</span><span style=color:#f92672>----&gt;</span> m <span style=color:#f92672>+</span> rand.<span style=color:#a6e22e>nextInt</span>(n)取到<span style=color:#f92672>[</span>m, m <span style=color:#f92672>+</span> n<span style=color:#960050;background-color:#1e0010>）</span>中的随机数<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ArrayList: <span style=color:#f92672>[</span>元素1<span style=color:#960050;background-color:#1e0010>，</span> 元素2<span style=color:#960050;background-color:#1e0010>，</span> 元素3<span style=color:#960050;background-color:#1e0010>，</span> ...<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    功能<span style=color:#960050;background-color:#1e0010>：</span>可变长的数组<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    泛型<span style=color:#960050;background-color:#1e0010>：</span>装在集合中的元素必须是同一个类型<span style=color:#960050;background-color:#1e0010>，</span>只能是引用类型<span style=color:#960050;background-color:#1e0010>，</span>不能是基本类型<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    实例化<span style=color:#960050;background-color:#1e0010>：</span>ArrayList<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> list <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    注意事项<span style=color:#960050;background-color:#1e0010>：</span>直接打印list输出的不是一个地址值<span style=color:#960050;background-color:#1e0010>，</span>而是空的中括号<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>            不支持下标索引<span style=color:#960050;background-color:#1e0010>，</span>只能用get()方法获取<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    常用方法<span style=color:#960050;background-color:#1e0010>：</span>list.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;李沁&#34;</span>)  添加元素<span style=color:#960050;background-color:#1e0010>，</span>返回一个boolean值<span style=color:#960050;background-color:#1e0010>，</span>表示添加的动作是否成功<span style=color:#960050;background-color:#1e0010>。</span>一定成功<span style=color:#960050;background-color:#1e0010>，</span>可以不接受返回值<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>            list.<span style=color:#a6e22e>get</span>(index)  根据索引获取元素<span style=color:#960050;background-color:#1e0010>，</span>返回获取的元素<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>            list.<span style=color:#a6e22e>remove</span>(index)  根据索引删除元素<span style=color:#960050;background-color:#1e0010>，</span>返回被删除的元素<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>            list.<span style=color:#a6e22e>size</span>()  获取集合长度<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    若想在ArrayList中存储基本类型<span style=color:#960050;background-color:#1e0010>，</span>需要使用其包装类(引用类型)<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>        基本类型         包装类
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span>            Byte
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>short</span>           Short
</span></span><span style=display:flex><span>        ...             ...   <span style=color:#960050;background-color:#1e0010>（</span>与上方一样<span style=color:#960050;background-color:#1e0010>，</span>只需首字母大写<span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span>             Integer    <span style=color:#960050;background-color:#1e0010>【</span>特殊<span style=color:#960050;background-color:#1e0010>】</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span>            Character  <span style=color:#960050;background-color:#1e0010>【</span>特殊<span style=color:#960050;background-color:#1e0010>】</span>
</span></span><span style=display:flex><span>        ArrayList<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> list_int <span style=color:#f92672>=</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>//  自动装箱：int --&gt; Integer     自动拆箱：integer --&gt; int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>String:
</span></span><span style=display:flex><span>    功能<span style=color:#960050;background-color:#1e0010>：</span>字符串<span style=color:#960050;background-color:#1e0010>（</span>常量<span style=color:#960050;background-color:#1e0010>）</span> <span style=color:#f92672>--&gt;</span> Java中所有的双引号字符串都是String类的实例<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    实例化<span style=color:#960050;background-color:#1e0010>：</span>直接创建<span style=color:#960050;background-color:#1e0010>：</span> String str1 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;李沁&#34;</span>;    在字符串常量池中<span style=color:#960050;background-color:#1e0010>，</span> 其他实例化方式都在堆中<span style=color:#960050;background-color:#1e0010>，</span>不在池里<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>          使用空构造函数<span style=color:#960050;background-color:#1e0010>：</span> String str2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> String();
</span></span><span style=display:flex><span>          根据字符数组创建<span style=color:#960050;background-color:#1e0010>：</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>[]</span> charArray <span style=color:#f92672>=</span> { <span style=color:#e6db74>&#39;a&#39;</span>, <span style=color:#e6db74>&#39;b&#39;</span>, <span style=color:#e6db74>&#39;c&#39;</span> };   String str3 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> String(charArray) <span style=color:#75715e>// abc</span>
</span></span><span style=display:flex><span>          根据字节数组创建<span style=color:#960050;background-color:#1e0010>：</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> byteArray <span style=color:#f92672>=</span> { 97, 98, 99 };   String str3 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> String(byteArray)    <span style=color:#75715e>// abc</span>
</span></span><span style=display:flex><span>    方法<span style=color:#960050;background-color:#1e0010>：</span>str1.<span style=color:#a6e22e>equals</span>(str2)  比较str1和str2的值是否相等<span style=color:#960050;background-color:#1e0010>，</span>返回boolean<span style=color:#960050;background-color:#1e0010>。</span> 常变量比较时推荐  常量.<span style=color:#a6e22e>equals</span>(变量)
</span></span><span style=display:flex><span>         str1.<span style=color:#a6e22e>equalsIgnoreCase</span>(str2) 忽略大小写<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>         str.<span style=color:#a6e22e>length</span>()   长度
</span></span><span style=display:flex><span>         str.<span style=color:#a6e22e>concat</span>(str1)   拼接
</span></span><span style=display:flex><span>         str.<span style=color:#a6e22e>charAt</span>(index)  根据索引返回字符
</span></span><span style=display:flex><span>         str.<span style=color:#a6e22e>indexOf</span>(str1)  在str中查找str1<span style=color:#960050;background-color:#1e0010>，</span>返回首次找到的索引值<span style=color:#960050;background-color:#1e0010>；</span>若没有<span style=color:#960050;background-color:#1e0010>，</span>返回<span style=color:#f92672>-</span>1
</span></span><span style=display:flex><span>         str.<span style=color:#a6e22e>substring</span>(index)   截取<span style=color:#960050;background-color:#1e0010>，</span>从index到末尾
</span></span><span style=display:flex><span>         str.<span style=color:#a6e22e>substring</span>(<span style=color:#66d9ef>int</span> begin, <span style=color:#66d9ef>int</span> end)   截取<span style=color:#960050;background-color:#1e0010>，</span><span style=color:#f92672>[</span>begin, end)
</span></span><span style=display:flex><span>         str.<span style=color:#a6e22e>toCharArray</span>()  转换为字符数组   str.<span style=color:#a6e22e>getBytes</span>()  转换为字节数组   用于遍历字符串
</span></span><span style=display:flex><span>         str.<span style=color:#a6e22e>replace</span>(old, <span style=color:#66d9ef>new</span>)  用new替换str中的old
</span></span><span style=display:flex><span>         str.<span style=color:#a6e22e>split</span>(regex)  切割<span style=color:#960050;background-color:#1e0010>，</span>返回数组
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Arrays:
</span></span><span style=display:flex><span>    功能<span style=color:#960050;background-color:#1e0010>：</span>与数组相关的类<span style=color:#960050;background-color:#1e0010>，</span>提供大量静态方法<span style=color:#960050;background-color:#1e0010>，</span>用来实现数组常见的操作<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    方法<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>        Arrays.<span style=color:#a6e22e>toString</span>(数组)  将参数变成字符串 <span style=color:#f92672>[</span>元素1<span style=color:#960050;background-color:#1e0010>，</span> 元素2<span style=color:#960050;background-color:#1e0010>，</span>元素3<span style=color:#960050;background-color:#1e0010>，</span>...<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>        Arrays.<span style=color:#a6e22e>deepToString</span>(多维数组)  将参数变成字符串 <span style=color:#f92672>[</span>元素1<span style=color:#960050;background-color:#1e0010>，</span> 元素2<span style=color:#960050;background-color:#1e0010>，</span>元素3<span style=color:#960050;background-color:#1e0010>，</span>...<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>        Arrays.<span style=color:#a6e22e>sort</span>(数组)  排序<span style=color:#960050;background-color:#1e0010>。</span>默认从小到大<span style=color:#960050;background-color:#1e0010>，</span>自定义类型的排序需要Comparable或Comparator接口
</span></span><span style=display:flex><span>        Arrays.<span style=color:#a6e22e>equals</span>(数组1<span style=color:#960050;background-color:#1e0010>，</span> 数组2)    两个数组完全相等是返回ture
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Math:
</span></span><span style=display:flex><span>    功能<span style=color:#960050;background-color:#1e0010>：</span>数学相关的类<span style=color:#960050;background-color:#1e0010>，</span>提供大量静态方法<span style=color:#960050;background-color:#1e0010>，</span>用来实现数学运算相关的操作<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    方法<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>        Math.<span style=color:#a6e22e>abs</span>()     绝对值
</span></span><span style=display:flex><span>        Math.<span style=color:#a6e22e>ceil</span>()    向上取整
</span></span><span style=display:flex><span>        Math.<span style=color:#a6e22e>floor</span>()   向下取整
</span></span><span style=display:flex><span>        Math.<span style=color:#a6e22e>round</span>()   四舍五入
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Collection接口: 所有单列集合的顶层接口
</span></span><span style=display:flex><span>    List接口:  1<span style=color:#960050;background-color:#1e0010>、</span>有序<span style=color:#960050;background-color:#1e0010>（</span>存入和取出的顺序一致<span style=color:#960050;background-color:#1e0010>）</span>  2<span style=color:#960050;background-color:#1e0010>、</span>允许元素重复  3<span style=color:#960050;background-color:#1e0010>、</span>有索引
</span></span><span style=display:flex><span>        Vector:(了解)
</span></span><span style=display:flex><span>        Arraylist:(重点)  底层由数组实现<span style=color:#960050;background-color:#1e0010>，</span>查询快<span style=color:#960050;background-color:#1e0010>，</span>增删慢<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        LinkedList:(次之) 底层由链表实现<span style=color:#960050;background-color:#1e0010>，</span>查询慢<span style=color:#960050;background-color:#1e0010>，</span>增删快<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>            特有方法:
</span></span><span style=display:flex><span>                addFirst() <span style=color:#f92672>==</span> push()      addLast() <span style=color:#f92672>==</span> add()
</span></span><span style=display:flex><span>                getFirst()                getLast()
</span></span><span style=display:flex><span>                removeFirst() <span style=color:#f92672>==</span> pop()    removeLast()    这两种方法都会删除并返回
</span></span><span style=display:flex><span>        共有方法<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> index, E element)    将元素添加到索引位置
</span></span><span style=display:flex><span>            E <span style=color:#a6e22e>get</span>(<span style=color:#66d9ef>int</span> index)                  返回索引处的元素
</span></span><span style=display:flex><span>            E <span style=color:#a6e22e>remove</span>(<span style=color:#66d9ef>int</span> index)               删除索引位置元素,并返回被删除的元素
</span></span><span style=display:flex><span>            E <span style=color:#a6e22e>set</span>(<span style=color:#66d9ef>int</span> index, E element)       替换索引位置元素,并返回被替换前的元素
</span></span><span style=display:flex><span>    Set接口:  1<span style=color:#960050;background-color:#1e0010>、</span>不允许元素重复    2<span style=color:#960050;background-color:#1e0010>、</span>没有索引
</span></span><span style=display:flex><span>        TreeSet: (无序) (了解)        底层由二叉树实现<span style=color:#960050;background-color:#1e0010>，</span>一般用于排序<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        HashSet: (无序) (重点)        底层由哈希表实现<span style=color:#960050;background-color:#1e0010>。</span>(查询速度很快)
</span></span><span style=display:flex><span>            注意: 使用HashCode存储自定义类型时<span style=color:#960050;background-color:#1e0010>，</span>需要重写HashCode()和equals()<span style=color:#960050;background-color:#1e0010>。</span>可通过alt <span style=color:#f92672>+</span> insert直接添加<span style=color:#960050;background-color:#1e0010>。</span>才能保证元素不重复<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>            LinkedHashSet: (有序) (次之)  底层由哈希表<span style=color:#f92672>+</span>链表实现<span style=color:#960050;background-color:#1e0010>。</span> <span style=color:#66d9ef>extends</span> HashSet
</span></span><span style=display:flex><span>                比HashSet多了一条链表<span style=color:#960050;background-color:#1e0010>，</span>用来记录元素的顺序
</span></span><span style=display:flex><span>    共有方法<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>add</span>(E e)      添加<span style=color:#960050;background-color:#1e0010>，</span>   无需接收
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>remove</span>(E e)   删除<span style=color:#960050;background-color:#1e0010>，</span>   若有e<span style=color:#960050;background-color:#1e0010>，</span>删除并返回true<span style=color:#960050;background-color:#1e0010>。</span>若没有e<span style=color:#960050;background-color:#1e0010>，</span>无动作并返回false
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>clear</span>()          清空<span style=color:#960050;background-color:#1e0010>。</span>   但不删除集合<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>contains</span>(E e) 是否包含<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isEmpty</span>()     是否为空<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>size</span>()            元素个数<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        Object<span style=color:#f92672>[]</span> <span style=color:#a6e22e>toArray</span>()    转为数组<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>哈希值: 是一个十进制的整数<span style=color:#960050;background-color:#1e0010>，</span>由操作系统随机给出的对象的逻辑地址值<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>哈希表: 拉链法<span style=color:#960050;background-color:#1e0010>。</span>由哈希值为元素组成数组<span style=color:#960050;background-color:#1e0010>（</span>初始长度为16<span style=color:#960050;background-color:#1e0010>）。</span>若哈希值相等<span style=color:#960050;background-color:#1e0010>，</span>则以链表方式挂在该哈希值后面<span style=color:#960050;background-color:#1e0010>。</span>当链表长度超过8时<span style=color:#960050;background-color:#1e0010>，</span>变为红黑树<span style=color:#960050;background-color:#1e0010>。</span>检索速度加快<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Collections :  是Collection的工具类<span style=color:#960050;background-color:#1e0010>，</span>提供大量静态方法<span style=color:#960050;background-color:#1e0010>，</span>用于操作集合<span style=color:#960050;background-color:#1e0010>。</span> 以ArrayList为例: ArrayList<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> list <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    addAll(Collection<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> c, T... elements) : 往集合中添加多个元素<span style=color:#960050;background-color:#1e0010>。</span>  Collections.<span style=color:#a6e22e>addAll</span>(list, <span style=color:#e6db74>&#34;a&#34;</span>, <span style=color:#e6db74>&#34;b&#34;</span>, <span style=color:#e6db74>&#34;c&#34;</span>);
</span></span><span style=display:flex><span>    shuffle(List<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> list) : 打乱顺序<span style=color:#960050;background-color:#1e0010>。</span>                             Collections.<span style=color:#a6e22e>shuffle</span>(list);
</span></span><span style=display:flex><span>    sort(List<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> list)    : 排序<span style=color:#960050;background-color:#1e0010>，</span> 默认升序<span style=color:#960050;background-color:#1e0010>。</span>                       Collections.<span style=color:#a6e22e>sort</span>(list);
</span></span><span style=display:flex><span>        注意<span style=color:#960050;background-color:#1e0010>：</span>若要对自定义类型排序<span style=color:#960050;background-color:#1e0010>，</span>则被排序的类必须实现Comparable接口<span style=color:#960050;background-color:#1e0010>，</span>重写compareTo方法来定义排序规则<span style=color:#960050;background-color:#1e0010>。</span>  <span style=color:#66d9ef>this</span> <span style=color:#f92672>-</span> 参数 <span style=color:#960050;background-color:#1e0010>：</span> 升序
</span></span><span style=display:flex><span>    (了解)另一种sort()<span style=color:#960050;background-color:#1e0010>：</span> Collections.<span style=color:#a6e22e>sort</span>(arr, <span style=color:#66d9ef>new</span> Comparator<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span>() {
</span></span><span style=display:flex><span>                               <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>                               <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>compare</span>(Integer o1, Integer o2) {
</span></span><span style=display:flex><span>                                   <span style=color:#66d9ef>return</span> o1 <span style=color:#f92672>-</span> o2;
</span></span><span style=display:flex><span>                               }
</span></span><span style=display:flex><span>                           });     这种方法List接口中的方法类似<span style=color:#f92672>-&gt;</span> arr.<span style=color:#a6e22e>sort</span>(<span style=color:#66d9ef>new</span> Comparator<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span>() {...})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Iterator: 迭代器    是接口   也有泛型 <span style=color:#f92672>--&gt;</span> Collection<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> array <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>                                        Iterator<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> it <span style=color:#f92672>=</span> array.<span style=color:#a6e22e>iterator</span>();
</span></span><span style=display:flex><span>    常用方法:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>hasNext</span>()  是否有下一个元素<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        E <span style=color:#a6e22e>next</span>()           返回下一个元素<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    使用<span style=color:#960050;background-color:#1e0010>：</span> Collection中的实现类为 <span style=color:#a6e22e>iterator</span>()
</span></span><span style=display:flex><span>        1<span style=color:#960050;background-color:#1e0010>、</span>实例化iterator    2<span style=color:#960050;background-color:#1e0010>、</span>用hasNext()    3<span style=color:#960050;background-color:#1e0010>、</span>用next()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>增强for循环:  专门用来遍历数组与集合<span style=color:#960050;background-color:#1e0010>，</span>由Iterator迭代器实现<span style=color:#960050;background-color:#1e0010>，</span>遍历时不能做增删操作<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (元素数据类型 变量 : 集合或数组名) { ... }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Map:      <span style=color:#f92672>--&gt;</span> 字典     键值对     key是唯一的
</span></span><span style=display:flex><span>    HashMap: (无序)  底层为哈希表
</span></span><span style=display:flex><span>        LinkedHashMap : (有序)  底层为哈希表<span style=color:#f92672>+</span>链表(保证顺序)
</span></span><span style=display:flex><span>    方法:
</span></span><span style=display:flex><span>        V <span style=color:#a6e22e>put</span>(K key, V value) : 添加<span style=color:#960050;background-color:#1e0010>，</span>若key值不存在<span style=color:#960050;background-color:#1e0010>，</span>则添加并返回null<span style=color:#960050;background-color:#1e0010>。</span>若key值已存在<span style=color:#960050;background-color:#1e0010>，</span>则更新value值<span style=color:#960050;background-color:#1e0010>，</span>并返回被替换掉的value值<span style=color:#960050;background-color:#1e0010>。</span>一般不接收返回值<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        V <span style=color:#a6e22e>remove</span>(K key)  : 删除<span style=color:#960050;background-color:#1e0010>，</span>若key值存在<span style=color:#960050;background-color:#1e0010>，</span>返回被删除的value<span style=color:#960050;background-color:#1e0010>。</span>若key不存在<span style=color:#960050;background-color:#1e0010>，</span>则返回null<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        V <span style=color:#a6e22e>get</span>(K key)     : 获取<span style=color:#960050;background-color:#1e0010>，</span>若key值存在<span style=color:#960050;background-color:#1e0010>，</span>返回对应的value<span style=color:#960050;background-color:#1e0010>。</span>若key不存在<span style=color:#960050;background-color:#1e0010>，</span>则返回null<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>containsKey</span>(k key)  :  判断是否包含指定的键<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        Set<span style=color:#f92672>&lt;</span>K<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>keySet</span>()   返回由键组成的Set<span style=color:#960050;background-color:#1e0010>，</span>之后可以通过遍历Set来遍历Map<span style=color:#960050;background-color:#1e0010>。</span>  <span style=color:#66d9ef>for</span> (K key : map.<span style=color:#a6e22e>keySet</span>()) { sout(key <span style=color:#f92672>+</span> map.<span style=color:#a6e22e>get</span>(key)) }
</span></span><span style=display:flex><span>        Set<span style=color:#f92672>&lt;</span>Map.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>K, V<span style=color:#f92672>&gt;&gt;</span> <span style=color:#a6e22e>entrySet</span>()  <span style=color:#f92672>--&gt;</span>  <span style=color:#66d9ef>for</span> (Map.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>K, V<span style=color:#f92672>&gt;</span> entry : map.<span style=color:#a6e22e>entrySet</span>()) {  也是遍历<span style=color:#960050;background-color:#1e0010>，</span>看起来不好用的样子
</span></span><span style=display:flex><span>                                                          System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(entry.<span style=color:#a6e22e>getKey</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>+</span> entry.<span style=color:#a6e22e>getValue</span>());}
</span></span><span style=display:flex><span>    用Map存储自定义类型时<span style=color:#960050;background-color:#1e0010>，</span>若自定义类型作为键<span style=color:#960050;background-color:#1e0010>，</span>则必须将该类重写HashCode和equals方法<span style=color:#960050;background-color:#1e0010>，</span>保证键是唯一的<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>of方法<span style=color:#960050;background-color:#1e0010>：</span>  <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> List<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>of</span> (E... elements)
</span></span><span style=display:flex><span>    1<span style=color:#960050;background-color:#1e0010>、</span>of方法只适用于List, Set, Map 接口<span style=color:#960050;background-color:#1e0010>。</span>而不适用于他们的实现类
</span></span><span style=display:flex><span>    2<span style=color:#960050;background-color:#1e0010>、</span>of方法返回一个不能被操作的集合<span style=color:#960050;background-color:#1e0010>。</span>因此适合初始化<span style=color:#960050;background-color:#1e0010>，</span>且初始化后不能改变<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    3<span style=color:#960050;background-color:#1e0010>、</span>Set 和 Map 调用of方法时不能有重复元素<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>------------------------------------------------------------------------------------------------------------------</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>------------------------------------------------------------------------------------------------------------------</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>------------------------------------------------------------------------------------------------------------------</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>------------------------------------------------------------------------------------------------------------------</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Object<span style=color:#960050;background-color:#1e0010>：</span>   以下方法所有类都有<span style=color:#960050;background-color:#1e0010>，</span>只是重写之后功能有所不同<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    toString()  直接打印对象的名字<span style=color:#960050;background-color:#1e0010>，</span>就是调用对象的toString方法<span style=color:#f92672>-&gt;</span>得到对象的地址值<span style=color:#960050;background-color:#1e0010>。</span>  没有意义<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>                重写<span style=color:#960050;background-color:#1e0010>：</span>可以和构造方法与Getter<span style=color:#f92672>/</span>Setter方法一样的步骤添加<span style=color:#960050;background-color:#1e0010>（</span>重写<span style=color:#960050;background-color:#1e0010>）</span>toString方法<span style=color:#f92672>-&gt;</span>打印出属性值<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    equals()    <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>equals</span>(Object obj)  判断两个对象是否<span style=color:#e6db74>&#34;相等&#34;</span><span style=color:#960050;background-color:#1e0010>，</span>返回布尔值<span style=color:#960050;background-color:#1e0010>。</span> 比较两个对象的地址值<span style=color:#960050;background-color:#1e0010>，</span>同上方的<span style=color:#f92672>==</span>作用一样<span style=color:#960050;background-color:#1e0010>。</span> 没有意义<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>                重写<span style=color:#960050;background-color:#1e0010>：</span> 原理 <span style=color:#f92672>--&gt;</span> 由于equals方法的参数类型为Object,所以默认向上转型了<span style=color:#960050;background-color:#1e0010>。</span>若想比较两个对象的属性值<span style=color:#960050;background-color:#1e0010>，</span>需要先向下转型<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>                      同样可以 alt <span style=color:#f92672>+</span> insert 直接生成equals方法<span style=color:#960050;background-color:#1e0010>。</span> 判断两对象的属性值是否都一样<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    hashCode()  返回对象的哈希码值
</span></span><span style=display:flex><span>    <span style=color:#75715e>// synchronized 能实现线程同步、但无法实现线程间通信、用如下 4 个方法可以实现线程间通信。</span>
</span></span><span style=display:flex><span>    wait()      等待<span style=color:#960050;background-color:#1e0010>。</span>在被唤醒之前<span style=color:#960050;background-color:#1e0010>，</span>放弃CPU的使用权    <span style=color:#a6e22e>wait</span>(毫秒值)  在被唤醒或到时间之前<span style=color:#960050;background-color:#1e0010>，</span>放弃CPU的使用权
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>notify</span>()    唤醒<span style=color:#960050;background-color:#1e0010>。</span>随机唤醒锁对象中的一个进程       <span style=color:#a6e22e>notifyAll</span>()  唤醒锁对象(对象监视器)中的所有进程   这两种常搭配同步机制使用
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>objects:  该工具类提供的方法是容忍空指针的<span style=color:#960050;background-color:#1e0010>。</span> 若 a<span style=color:#f92672>=</span><span style=color:#66d9ef>null</span><span style=color:#960050;background-color:#1e0010>，</span>则a.<span style=color:#a6e22e>equals</span>(b) 报错<span style=color:#960050;background-color:#1e0010>。</span>而Objects.<span style=color:#a6e22e>equals</span>(a, b) 正常运行<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    Objects.<span style=color:#a6e22e>requireNonNull</span>(T obj)   查看obj是否为空<span style=color:#960050;background-color:#1e0010>，</span>用来判断参数的合法性<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>旧API :
</span></span><span style=display:flex><span>    Date:     1970年1月1日 00:00:00 作为0时刻
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Date</span>() 无参构造<span style=color:#f92672>--&gt;</span> 获取当前时间<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        Date(<span style=color:#66d9ef>long</span> date)  有参构造 <span style=color:#f92672>--&gt;</span> 输入毫秒值<span style=color:#960050;background-color:#1e0010>，</span>输出相对于0时刻的日期<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        getTime()  把日期转换为毫秒
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    DateFormat:    格式化日期<span style=color:#960050;background-color:#1e0010>。</span>   抽象类<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        String <span style=color:#a6e22e>format</span>(Date date)    把日期格式化为字符串<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        Date <span style=color:#a6e22e>parse</span>(String source)   把符合的字符串解析为日期<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        SimpleDateFormat:    DateFormat的实现类
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>SimpleDateFormat</span>(String pattern)  有参构造  参数一般为 <span style=color:#e6db74>&#34;yyyy-MM-dd HH:mm:ss&#34;</span>
</span></span><span style=display:flex><span>            使用上方两个方法<span style=color:#960050;background-color:#1e0010>。</span> 注意<span style=color:#960050;background-color:#1e0010>：</span>用parse时<span style=color:#960050;background-color:#1e0010>，</span>参数的模式必须与构造SimpleDateFormat对象时的模式完全一样<span style=color:#960050;background-color:#1e0010>，</span>否则报错<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Calendar:     日历类       抽象类
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>getInstance</span>()  静态方法   返回Calendar类的子类对象         Calendar instance <span style=color:#f92672>=</span> Calendar.<span style=color:#a6e22e>getInstance</span>();
</span></span><span style=display:flex><span>            功能<span style=color:#960050;background-color:#1e0010>：</span>使用默认时区和语言环境获得一个日历
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>get</span>(field)  返回给定字段的值<span style=color:#960050;background-color:#1e0010>。</span>                  字段值有YEAR MONTH DATE HOUR MINTER SECOND 年月日时分秒   都是静态变量
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>set</span>(field, value)   将给定的日历字段设置为给定值
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>add</span>(field, amount)   修改指定的字段<span style=color:#960050;background-color:#1e0010>，</span>通过amount的正负实现加减<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        Date <span style=color:#a6e22e>getTime</span>()      将Calendar转为Date对象
</span></span><span style=display:flex><span>            原理<span style=color:#960050;background-color:#1e0010>：</span>实际上该类中有一个fields数组<span style=color:#960050;background-color:#1e0010>，</span>上述的方法都是在对该数组操作<span style=color:#960050;background-color:#1e0010>。</span>字段值YEAR等固定为0<span style=color:#960050;background-color:#1e0010>，</span>1<span style=color:#960050;background-color:#1e0010>，</span>2等<span style=color:#960050;background-color:#1e0010>，</span>作用是对该数组的索引<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>新API
</span></span><span style=display:flex><span>LocalDate, LocalTime, LocalDateTime : 之前的Date类和Calendar类都有缺陷<span style=color:#960050;background-color:#1e0010>。</span>JDK8 新引入日期时间类
</span></span><span style=display:flex><span>    由于LocalDateTime类使用较多<span style=color:#960050;background-color:#1e0010>，</span>故以他为例<span style=color:#960050;background-color:#1e0010>，</span>其余两种用法相同<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    构造方法<span style=color:#960050;background-color:#1e0010>：</span> 1<span style=color:#960050;background-color:#1e0010>、</span>LocalDateTime now <span style=color:#f92672>=</span> LocalDateTime.<span style=color:#a6e22e>now</span>();      获取当前时间
</span></span><span style=display:flex><span>             2<span style=color:#960050;background-color:#1e0010>、</span>LocalDateTime localDateTime <span style=color:#f92672>=</span> LocalDateTime.<span style=color:#a6e22e>of</span>(2020, 1, 20, 12, 20, 34);    获取指定时间
</span></span><span style=display:flex><span>    常用方法<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>        now.<span style=color:#a6e22e>getDayOfMonth</span>()                           获取对象是这个月的第几天<span style=color:#960050;background-color:#1e0010>。</span>类似的方法获取其他属性<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        LocalDateTime time <span style=color:#f92672>=</span> now.<span style=color:#a6e22e>withDayOfMonth</span>(12);  使用类似方法设置属性<span style=color:#960050;background-color:#1e0010>。</span>但是该语句执行后<span style=color:#960050;background-color:#1e0010>，</span>time为修改后的值<span style=color:#960050;background-color:#1e0010>，</span>而now的值不变<span style=color:#960050;background-color:#1e0010>。</span>体现了时间的不可变性<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        LocalDateTime plusDays <span style=color:#f92672>=</span> now.<span style=color:#a6e22e>plusDays</span>(3);     使用类似方法修改属性<span style=color:#960050;background-color:#1e0010>，</span>在原有基础上加3天<span style=color:#960050;background-color:#1e0010>。</span>不可变性同上<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        LocalDateTime months <span style=color:#f92672>=</span> now.<span style=color:#a6e22e>minusMonths</span>(2);    使用类似方法修改属性<span style=color:#960050;background-color:#1e0010>，</span>在原有基础上减2月<span style=color:#960050;background-color:#1e0010>。</span>不可变性同上<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>Instant 替换 Date 类
</span></span><span style=display:flex><span>DateTimeFormatter :  类似于SimpleDateFormat     日期时间的格式化与解析
</span></span><span style=display:flex><span>    DateTimeFormatter formatter <span style=color:#f92672>=</span> DateTimeFormatter.<span style=color:#a6e22e>ofPattern</span>(<span style=color:#e6db74>&#34;yyyy-MM-dd HH:mm:ss&#34;</span>);   构造
</span></span><span style=display:flex><span>    String format <span style=color:#f92672>=</span> formatter.<span style=color:#a6e22e>format</span>(LocalDateTime.<span style=color:#a6e22e>now</span>());                              格式化
</span></span><span style=display:flex><span>    TemporalAccessor parse <span style=color:#f92672>=</span> formatter.<span style=color:#a6e22e>parse</span>(<span style=color:#e6db74>&#34;2021-01-21 22:00:25&#34;</span>);                    解析
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>System:  提供大量静态方法<span style=color:#960050;background-color:#1e0010>，</span> 可以获取与系统相关的信息即服务
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#a6e22e>currentTimeMillis</span>()    返回以毫秒为单位的当前时间, 用来测试程序的效率<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#a6e22e>arraycopy</span>(原数组<span style=color:#960050;background-color:#1e0010>，</span> <span style=color:#66d9ef>int</span> 原数组起始位置<span style=color:#960050;background-color:#1e0010>，</span> 目标数组<span style=color:#960050;background-color:#1e0010>，</span> <span style=color:#66d9ef>int</span> 目标数组起始位置<span style=color:#960050;background-color:#1e0010>，</span> <span style=color:#66d9ef>int</span> 要复制的数组元素的数量)  复制数组
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>StringBuilder:
</span></span><span style=display:flex><span>    在String类中<span style=color:#960050;background-color:#1e0010>，</span>字符串是常量<span style=color:#960050;background-color:#1e0010>，</span>底层是被final修饰的数组<span style=color:#960050;background-color:#1e0010>。</span>字符串相加时<span style=color:#960050;background-color:#1e0010>，</span>占用内存多<span style=color:#960050;background-color:#1e0010>，</span>效率低下<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    StringBuilder类是字符串缓冲区<span style=color:#960050;background-color:#1e0010>，</span>可以提高字符串的操作效率<span style=color:#960050;background-color:#1e0010>（</span>看成是一个长度可以变化的字符串<span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span>        底层也是一个数组<span style=color:#960050;background-color:#1e0010>，</span>但是没有被final修饰<span style=color:#960050;background-color:#1e0010>，</span>可以改变长度<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        在内存中始终是一个数组<span style=color:#960050;background-color:#1e0010>，</span>初始容量为16个字节<span style=color:#960050;background-color:#1e0010>，</span>超出会自动扩容<span style=color:#960050;background-color:#1e0010>，</span>占用空间少<span style=color:#960050;background-color:#1e0010>，</span>效率高<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    构造函数<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>        StringBuilder()  无参构造<span style=color:#960050;background-color:#1e0010>，</span>空字符串<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        StringBuilder(<span style=color:#e6db74>&#34;abc&#34;</span>)  有参构造<span style=color:#960050;background-color:#1e0010>，</span>即参数的字符串<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    成员函数<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>        append(任意类型)   添加到字符串<span style=color:#960050;background-color:#1e0010>，</span>并返回自身<span style=color:#960050;background-color:#1e0010>。</span>所以无需接收<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        toString()   将StringBuilder对象<span style=color:#960050;background-color:#1e0010>，</span>转换为String对象<span style=color:#960050;background-color:#1e0010>。</span>       通过StringBuilder的构造方法可以将String转换为StringBuilder.
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>reverser</span>()   翻转
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>File:    文件类<span style=color:#960050;background-color:#1e0010>，</span>主要用于文件和目录的创建<span style=color:#960050;background-color:#1e0010>，</span>查找和删除等操作     File类已被Path取代
</span></span><span style=display:flex><span>    静态方法:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> String	pathSeparator    路径分隔符    windows ; 分号      linux  : 冒号
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> String	separator        文件名称分隔符   Windows <span style=color:#960050;background-color:#1e0010>\</span> 反斜杠   Linux  <span style=color:#f92672>/</span> 正斜杠
</span></span><span style=display:flex><span>    构造方法:
</span></span><span style=display:flex><span>        File(String pathname)    路径名 <span style=color:#f92672>==&gt;</span> 文件<span style=color:#f92672>/</span>文件夹  相对<span style=color:#f92672>/</span>绝对  存在<span style=color:#f92672>/</span>不存在
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>File</span>(String parent, String child)  父路径<span style=color:#960050;background-color:#1e0010>，</span>子路径
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>File</span>(File parent, String child)  父路径<span style=color:#960050;background-color:#1e0010>，</span>子路径<span style=color:#960050;background-color:#1e0010>。</span>父路径是File型<span style=color:#960050;background-color:#1e0010>，</span>故可以使用其方法做调整
</span></span><span style=display:flex><span>    常用方法:
</span></span><span style=display:flex><span>        获取方法:
</span></span><span style=display:flex><span>            String <span style=color:#a6e22e>getAbsolutePath</span>()  返回绝对路径名
</span></span><span style=display:flex><span>            String <span style=color:#a6e22e>getPath</span>()          返回路径名
</span></span><span style=display:flex><span>            String <span style=color:#a6e22e>getName</span>()          返回末尾文件<span style=color:#f92672>/</span>文件夹 名字
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>length</span>()             返回文件大小<span style=color:#960050;background-color:#1e0010>（</span>以字节为单位<span style=color:#960050;background-color:#1e0010>）</span> 不能是文件夹<span style=color:#960050;background-color:#1e0010>，</span>若路径不存在<span style=color:#960050;background-color:#1e0010>，</span>返回0
</span></span><span style=display:flex><span>        判断方法:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>exists</span>()          文件或文件夹是否真实存在
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isDirectory</span>()     路径是否以文件夹结尾   前提<span style=color:#960050;background-color:#1e0010>：</span>真实存在
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isFile</span>()          路径是否以文件结尾     前提<span style=color:#960050;background-color:#1e0010>：</span>真实存在
</span></span><span style=display:flex><span>        创建删除:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>creatNewFile</span>()    不存在时创建文件     不能创建文件夹<span style=color:#960050;background-color:#1e0010>，</span>路径必须存在
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>delete</span>()          删除文件<span style=color:#f92672>/</span>文件夹
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>mkdir</span>()           创建单级空文件夹
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>mkdirs</span>()          创建单级<span style=color:#f92672>/</span>多级空文件夹     多级文件夹<span style=color:#960050;background-color:#1e0010>：</span>父文件夹中包含子文件夹
</span></span><span style=display:flex><span>        遍历文件夹:
</span></span><span style=display:flex><span>            String<span style=color:#f92672>[]</span> <span style=color:#a6e22e>list</span>()           返回由所有文件或子目录组成的字符串数组
</span></span><span style=display:flex><span>            File<span style=color:#f92672>[]</span> <span style=color:#a6e22e>listFiles</span>()        返回由所有文件或子目录封装而成的文件数组
</span></span><span style=display:flex><span>    过滤器:
</span></span><span style=display:flex><span>        File<span style=color:#f92672>[]</span> files <span style=color:#f92672>=</span> dir.<span style=color:#a6e22e>listFiles</span>(<span style=color:#66d9ef>new</span> FileFilter(){重写accept()方法<span style=color:#960050;background-color:#1e0010>，</span>该方法中写入过滤规则<span style=color:#960050;background-color:#1e0010>，</span>留下的返回ture<span style=color:#960050;background-color:#1e0010>，</span>不要的返回false})
</span></span><span style=display:flex><span>            可以写为Lambda表达式<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>读取文件的方法<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>        Scanner in <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Scanner(Paths.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;C:\\Users\\Lenovo\\Desktop\\1.txt&#34;</span>), StandardCharsets.<span style=color:#a6e22e>UTF_8</span>);
</span></span><span style=display:flex><span>        String num <span style=color:#f92672>=</span> in.<span style=color:#a6e22e>nextLine</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        BufferedReader reader <span style=color:#f92672>=</span> Files.<span style=color:#a6e22e>newBufferedReader</span>(Paths.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;C:\\Users\\Lenovo\\Desktop\\1.txt&#34;</span>), StandardCharsets.<span style=color:#a6e22e>UTF_8</span>);
</span></span><span style=display:flex><span>        String str <span style=color:#f92672>=</span> reader.<span style=color:#a6e22e>readLine</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>（</span>不好用<span style=color:#960050;background-color:#1e0010>）</span>BufferedReader bufferedReader <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> BufferedReader(<span style=color:#66d9ef>new</span> FileReader(<span style=color:#e6db74>&#34;C:\\Users\\Lenovo\\Desktop\\1.txt&#34;</span>));
</span></span><span style=display:flex><span>        String s <span style=color:#f92672>=</span> bufferedReader.<span style=color:#a6e22e>readLine</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Properties:  用来加载配置文件,  示例如下<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>            Properties properties <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Properties();
</span></span><span style=display:flex><span>            <span style=color:#75715e>//  ClassLoader classLoader = Person.class.getClassLoader();  注释掉的两句作用与下一句一样</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//  InputStream is = classLoader.getResourceAsStream(&#34;jdbc.properties&#34;);  //  路径相对于src</span>
</span></span><span style=display:flex><span>            FileInputStream fis <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FileInputStream(<span style=color:#e6db74>&#34;src\\jdbc.properties&#34;</span>);  <span style=color:#75715e>// 路径相对于Module而不是src</span>
</span></span><span style=display:flex><span>            properties.<span style=color:#a6e22e>load</span>(fis);
</span></span><span style=display:flex><span>            String user <span style=color:#f92672>=</span> properties.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;user&#34;</span>);
</span></span><span style=display:flex><span>            String passwd <span style=color:#f92672>=</span> properties.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;passwd&#34;</span>);
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(user <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> passwd);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>IO流:    <span style=color:#960050;background-color:#1e0010>（</span>默认相对路径在Module下<span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span>    基本流:
</span></span><span style=display:flex><span>        OutputStream: 字节输出流  (一切都以字节为单位) (一次读写一个字节)  接口
</span></span><span style=display:flex><span>            共有方法: write(<span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> bytes)    写入多个字节
</span></span><span style=display:flex><span>                     <span style=color:#a6e22e>close</span>()
</span></span><span style=display:flex><span>            FileOutputStream: 文件字节输出流
</span></span><span style=display:flex><span>                构造方法: FileOutputStream(String name<span style=color:#f92672>[</span>, <span style=color:#66d9ef>boolean</span> append <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>]</span>)
</span></span><span style=display:flex><span>                            参数为路径<span style=color:#960050;background-color:#1e0010>，</span>即写入的目标文件路径<span style=color:#960050;background-color:#1e0010>，</span>如果没有该文件<span style=color:#960050;background-color:#1e0010>，</span>会先创建该文件<span style=color:#960050;background-color:#1e0010>。</span>若append为ture<span style=color:#960050;background-color:#1e0010>，</span>则为追加写<span style=color:#960050;background-color:#1e0010>，</span>否则会覆盖原文件
</span></span><span style=display:flex><span>                         <span style=color:#a6e22e>FileOutputStream</span>(File file<span style=color:#f92672>[</span>, <span style=color:#66d9ef>boolean</span> append <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>]</span>)    参数为文件<span style=color:#960050;background-color:#1e0010>，</span>即写入的目标文件<span style=color:#960050;background-color:#1e0010>，</span>append同上<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        InputStream: 字节输入流  接口
</span></span><span style=display:flex><span>            共有方法: read()   读取一个字节,返回读到的内容<span style=color:#960050;background-color:#1e0010>，</span>读到文件末尾返回<span style=color:#f92672>-</span>1
</span></span><span style=display:flex><span>                     <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>read</span>(<span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> bytes)   读取多个字节<span style=color:#960050;background-color:#1e0010>，</span>将读取到的内容存入字节数组中<span style=color:#960050;background-color:#1e0010>，</span>并返回读取的有效字节个数<span style=color:#960050;background-color:#1e0010>，</span>读到文件末尾返回<span style=color:#f92672>-</span>1
</span></span><span style=display:flex><span>                     <span style=color:#a6e22e>close</span>()
</span></span><span style=display:flex><span>            FileInputStream: 文件字节输入流
</span></span><span style=display:flex><span>                构造方法: FileInputStream(String name)
</span></span><span style=display:flex><span>                         FileInputStream(File file)
</span></span><span style=display:flex><span>        Reader: 字符输入流  抽象
</span></span><span style=display:flex><span>            共有方法: read()    read(<span style=color:#66d9ef>char</span><span style=color:#f92672>[]</span> c)   close()   作用和上述相同,包括返回<span style=color:#f92672>-</span>1等等都相同<span style=color:#960050;background-color:#1e0010>，</span>只是读取单位变为字符<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>            FileReader: 文件字符输入流  <span style=color:#f92672>---&gt;</span>   只能读取IDEA默认编码格式文件(即UTF<span style=color:#f92672>-</span>8)
</span></span><span style=display:flex><span>                构造方法: FileReader(String filename)     FileReader(File file)
</span></span><span style=display:flex><span>        Writer: 字符输出流  抽象
</span></span><span style=display:flex><span>            共有方法: write()  参数可以为单个字符<span style=color:#960050;background-color:#1e0010>，</span>字符数组或字符串   <span style=color:#a6e22e>close</span>()
</span></span><span style=display:flex><span>            FileWriter: 文件字符输出流
</span></span><span style=display:flex><span>                构造方法: FileWriter(String filename<span style=color:#f92672>[</span>, <span style=color:#66d9ef>boolean</span> append <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>]</span>)     FileWriter(File file<span style=color:#f92672>[</span>, <span style=color:#66d9ef>boolean</span> append <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>]</span>)
</span></span><span style=display:flex><span>                注意: 这里的write方法是将数据写入内存缓冲区(字符转为字节)<span style=color:#960050;background-color:#1e0010>，</span>flash方法或close方法会数据刷新到文件<span style=color:#960050;background-color:#1e0010>。</span>因此必须调用close()方法<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        Properties集合: 实现了Map<span style=color:#f92672>&lt;</span>K, V<span style=color:#f92672>&gt;</span>   唯一和IO流结合的集合
</span></span><span style=display:flex><span>            该集合的默认键和值都是字符串类型<span style=color:#960050;background-color:#1e0010>。</span>store方法能把集合中的数据存入硬盘<span style=color:#960050;background-color:#1e0010>，</span>load方法会加载到该集合中<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    缓冲流:  创建一个缓冲区<span style=color:#960050;background-color:#1e0010>，</span>减少系统IO次数<span style=color:#960050;background-color:#1e0010>，</span>提高读写效率<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        BufferedInputStream:  字节缓冲输入流 <span style=color:#66d9ef>extends</span> InputStream        用read写入<span style=color:#960050;background-color:#1e0010>，</span>close关闭<span style=color:#960050;background-color:#1e0010>。</span>只需要关闭缓冲流<span style=color:#960050;background-color:#1e0010>，</span>基本流会随之关闭<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>            构造方法: BufferedInputStream(InputStream in<span style=color:#f92672>[</span>, <span style=color:#66d9ef>int</span> size<span style=color:#f92672>]</span>)       read和write方法与基本流完全相同<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        BufferedOutputStream: 字节缓冲输出流 <span style=color:#66d9ef>extends</span> OutputStream       用write写入<span style=color:#960050;background-color:#1e0010>，</span>close关闭
</span></span><span style=display:flex><span>            构造方法: BufferedOutputStream(OutputStream out<span style=color:#f92672>[</span>, <span style=color:#66d9ef>int</span> size<span style=color:#f92672>]</span>)
</span></span><span style=display:flex><span>                参数可以传递FileOutputStream对象<span style=color:#960050;background-color:#1e0010>，</span>可选参数size用于指定缓冲区大小
</span></span><span style=display:flex><span>        BufferedWriter:  字符缓冲输出流 <span style=color:#66d9ef>extends</span> Writer
</span></span><span style=display:flex><span>            构造方法: BufferedWriter(Writer out<span style=color:#f92672>[</span>, <span style=color:#66d9ef>int</span> size<span style=color:#f92672>]</span>)  可传入FileWriter
</span></span><span style=display:flex><span>            特有方法: <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>newLine</span>()   无视系统差异<span style=color:#960050;background-color:#1e0010>，</span>换行
</span></span><span style=display:flex><span>        BufferedReader:  字符缓冲输入流 <span style=color:#66d9ef>extends</span> Reader
</span></span><span style=display:flex><span>            构造方法: BufferedReader(Reader in<span style=color:#f92672>[</span>, <span style=color:#66d9ef>int</span> size<span style=color:#f92672>]</span>)  可传入FileReader
</span></span><span style=display:flex><span>            特有方法: String <span style=color:#a6e22e>readLine</span>()   读取一行数据<span style=color:#960050;background-color:#1e0010>，</span>但不读取行末换行符<span style=color:#960050;background-color:#1e0010>。</span>读到文件末尾返回null
</span></span><span style=display:flex><span>    转换流:  可以指定编码<span style=color:#f92672>/</span>解码的码表
</span></span><span style=display:flex><span>        OutputStreamWriter <span style=color:#66d9ef>extends</span> Writer:  步骤: 1<span style=color:#960050;background-color:#1e0010>、</span>new对象 2<span style=color:#960050;background-color:#1e0010>、</span>write()  3<span style=color:#960050;background-color:#1e0010>、</span>close()
</span></span><span style=display:flex><span>            构造方法: OutputStreamWriter(OutputStream out<span style=color:#f92672>[</span>, String charsetName<span style=color:#f92672>]</span>)
</span></span><span style=display:flex><span>                参数一般传递为FileOutputStream<span style=color:#960050;background-color:#1e0010>。</span>可选字段为编码表名称<span style=color:#960050;background-color:#1e0010>，</span>不区分大小写<span style=color:#960050;background-color:#1e0010>，</span>默认为UTF<span style=color:#f92672>-</span>8
</span></span><span style=display:flex><span>        InputStreamReader <span style=color:#66d9ef>extends</span> Reader:  步骤: 1<span style=color:#960050;background-color:#1e0010>、</span>new对象 2<span style=color:#960050;background-color:#1e0010>、</span>read()  3<span style=color:#960050;background-color:#1e0010>、</span>close()
</span></span><span style=display:flex><span>            构造方法: OutputStreamWriter(InputStream in<span style=color:#f92672>[</span>, String charsetName<span style=color:#f92672>]</span>)
</span></span><span style=display:flex><span>    (反)序列化流: 把对象以流的方式写入<span style=color:#f92672>/</span>读出到文件中     使用字节流
</span></span><span style=display:flex><span>        ObjectOutputStream: <span style=color:#66d9ef>extends</span> OutputStream  对象的序列化流    把对象以流的方式写入到文件中保存<span style=color:#960050;background-color:#1e0010>，</span>叫写对象<span style=color:#960050;background-color:#1e0010>，</span>也叫对象的序列化<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>            构造方法: ObjectOutputStream(OutputStream out)   参数一般传递为FileOutputStream<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>            特有方法: <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>writeObject</span>(Object obj)   此处参数也可以是由obj组成的集合<span style=color:#960050;background-color:#1e0010>，</span>如ArrayList<span style=color:#f92672>&lt;</span>Person<span style=color:#f92672>&gt;</span> list
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>被序列化的对象</span>(即参数obj)必须实现Serializable接口<span style=color:#960050;background-color:#1e0010>，</span>以激活(反)序列化功能<span style=color:#960050;background-color:#1e0010>。</span>其为标记型接口<span style=color:#960050;background-color:#1e0010>，</span>内部没有任何抽象方法<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        ObjectInputStream: <span style=color:#66d9ef>extends</span> InputStream   对象的反序列化流    把文件中保存的对象以流的方式读出来<span style=color:#960050;background-color:#1e0010>，</span>叫读对象<span style=color:#960050;background-color:#1e0010>，</span>也叫对象的反序列化<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>            构造方法: ObjectInputStream(InputStream in)       参数一般传递为FileInputStream<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>            特有方法: Object <span style=color:#a6e22e>readObject</span>()
</span></span><span style=display:flex><span>        transient关键字: 瞬态关键字<span style=color:#960050;background-color:#1e0010>，</span>被其修饰的成员变量不能被序列化<span style=color:#960050;background-color:#1e0010>，</span>没有替他功能<span style=color:#960050;background-color:#1e0010>。</span>static关键字也有这个功能<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        注意<span style=color:#960050;background-color:#1e0010>：</span>为了避免InvalidClassException,在每个被序列化的对象中都显示声明一个序列号<span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>long</span> serialVersionUID <span style=color:#f92672>=</span> 42L
</span></span><span style=display:flex><span>    打印流:  PrintStream                          System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> :    枚举类   类的对象只有确定的有限个<span style=color:#960050;background-color:#1e0010>，</span>我们称之为枚举类   当需要定义一组常量时<span style=color:#960050;background-color:#1e0010>，</span>强烈建议使用枚举类    默认继承java.<span style=color:#a6e22e>lang</span>.<span style=color:#a6e22e>Enum</span>
</span></span><span style=display:flex><span>    定义<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>        类似于接口的定义<span style=color:#960050;background-color:#1e0010>，</span>创建Class包时<span style=color:#960050;background-color:#1e0010>，</span>选项中就有Enum的选项<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>enum</span> Season {
</span></span><span style=display:flex><span>            SPRING(<span style=color:#e6db74>&#34;春天&#34;</span>, <span style=color:#e6db74>&#34;warm&#34;</span>),                               默认由public <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> 修饰
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>SUMMER</span>(<span style=color:#e6db74>&#34;夏天&#34;</span>, <span style=color:#e6db74>&#34;sun&#34;</span>),                                实例写在类的最前面
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>AUTUMN</span>(<span style=color:#e6db74>&#34;秋天&#34;</span>, <span style=color:#e6db74>&#34;cool&#34;</span>),                               实例之间用逗号分隔<span style=color:#960050;background-color:#1e0010>，</span>最后一个结尾为分号
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>WINTER</span>(<span style=color:#e6db74>&#34;冬天&#34;</span>, <span style=color:#e6db74>&#34;cold&#34;</span>);                               为什么不需要显示声明成员变量(由局部变量代替)<span style=color:#960050;background-color:#1e0010>，</span>暂时不清楚
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Season</span>(String seasonName, String seasonDec){}  }      构造函数默认由private修饰<span style=color:#960050;background-color:#1e0010>，</span>可省略不写<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    静态方法<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>        values()                   返回枚举类型的对象数组<span style=color:#960050;background-color:#1e0010>，</span>方便用于遍历枚举值
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>valueOf</span>(String objName)    返回枚举类中对象名为objName的对象   如: Season winter <span style=color:#f92672>=</span> Season.<span style=color:#a6e22e>valueOf</span>(<span style=color:#e6db74>&#34;WINTER&#34;</span>);
</span></span><span style=display:flex><span>        toString()                 返回当前枚举类对象常量的名字
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>反射:    java.<span style=color:#a6e22e>lang</span>.<span style=color:#a6e22e>Class</span>
</span></span><span style=display:flex><span>            程序由javac.<span style=color:#a6e22e>exe编译后</span><span style=color:#960050;background-color:#1e0010>，</span>会生成一个或多个字节码文件(.<span style=color:#a6e22e>class结尾</span>)<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>            接着使用java.<span style=color:#a6e22e>exe对某个字节码文件解释运行</span><span style=color:#960050;background-color:#1e0010>，</span>就相当于将某个字节码文件加载到内存中<span style=color:#960050;background-color:#1e0010>，</span>这个过程就叫类的加载<span style=color:#960050;background-color:#1e0010>，</span>
</span></span><span style=display:flex><span>            加载到内存中的类就叫运行时类<span style=color:#960050;background-color:#1e0010>，</span>这个运行时类就是Class的一个实例<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>            加载到内存中的运行时类会缓存一段时间<span style=color:#960050;background-color:#1e0010>，</span>在此时间内以不同方式获取到的该运行时类的Class实例都是同一个<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        获取Class实例的方法<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>            1<span style=color:#960050;background-color:#1e0010>、</span> Class clazz <span style=color:#f92672>=</span> Person.<span style=color:#a6e22e>class</span>;
</span></span><span style=display:flex><span>            2<span style=color:#960050;background-color:#1e0010>、</span> Person person <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person();     Class clazz <span style=color:#f92672>=</span> person.<span style=color:#a6e22e>getClass</span>();
</span></span><span style=display:flex><span>            3<span style=color:#960050;background-color:#1e0010>、</span> Class clazz <span style=color:#f92672>=</span> Class.<span style=color:#a6e22e>forName</span>(类相对于src的全路径);   <span style=color:#75715e>// 用的较多</span>
</span></span><span style=display:flex><span>        ClassLoader<span style=color:#960050;background-color:#1e0010>：</span>引导类加载器<span style=color:#f92672>--</span><span style=color:#960050;background-color:#1e0010>》</span>加载java核心类库   引导类加载器无法获取到
</span></span><span style=display:flex><span>                     扩展类加载器<span style=color:#f92672>--</span><span style=color:#960050;background-color:#1e0010>》</span>加载jar包      通过Class实例.<span style=color:#a6e22e>getClassLoader</span>()即可获得类加载器<span style=color:#960050;background-color:#1e0010>，</span>如
</span></span><span style=display:flex><span>                     系统类加载器<span style=color:#f92672>--</span><span style=color:#960050;background-color:#1e0010>》</span>加载自定义类    Person.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getClassLoader</span>()获取的即为系统类加载器
</span></span><span style=display:flex><span>        无法创建实例的类型用  Class c <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>.<span style=color:#a6e22e>class</span>;   <span style=color:#66d9ef>double</span>.<span style=color:#a6e22e>class</span>;    Math.<span style=color:#a6e22e>class</span>; 等
</span></span><span style=display:flex><span>        ArrayList<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> list <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        Class l1 <span style=color:#f92672>=</span> list.<span style=color:#a6e22e>getClass</span>();           得到ArrayList<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span>类的Class实例
</span></span><span style=display:flex><span>        l1.<span style=color:#a6e22e>getDeclaredConstructors</span>();         获取所有构造函数<span style=color:#960050;background-color:#1e0010>，</span>去掉Declared为只获取public的构造函数
</span></span><span style=display:flex><span>        l1.<span style=color:#a6e22e>getDeclaredMethods</span>();              获取所有函数<span style=color:#960050;background-color:#1e0010>，</span>去掉Declared为只获取public的函数
</span></span><span style=display:flex><span>        l1.<span style=color:#a6e22e>getDeclaredFields</span>();               获取所有属性<span style=color:#960050;background-color:#1e0010>，</span>去掉Declared为只获取public的属性
</span></span><span style=display:flex><span>        l1.<span style=color:#a6e22e>getSuperclass</span>();                   获取父类
</span></span><span style=display:flex><span>        l1.<span style=color:#a6e22e>getGenericSuperclass</span>();            获取带泛型的父类
</span></span><span style=display:flex><span>        li.<span style=color:#a6e22e>getInterfaces</span>();                   获取接口
</span></span><span style=display:flex><span>        li.<span style=color:#a6e22e>getPackage</span>();                      获取包
</span></span><span style=display:flex><span>        li.<span style=color:#a6e22e>getAnnotations</span>();                  获取注解
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>for</span> (Method method: l1.<span style=color:#a6e22e>getDeclaredMethods</span>()) {
</span></span><span style=display:flex><span>           System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Modifier.<span style=color:#a6e22e>toString</span>(method.<span style=color:#a6e22e>getModifiers</span>()) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> method.<span style=color:#a6e22e>getReturnType</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;  &#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                   method.<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;(&#34;</span> <span style=color:#f92672>+</span> Arrays.<span style=color:#a6e22e>toString</span>(method.<span style=color:#a6e22e>getParameterTypes</span>()) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;);&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        Field f <span style=color:#f92672>=</span> l1.<span style=color:#a6e22e>getDeclaredField</span>(<span style=color:#e6db74>&#34;size&#34;</span>);  根据属性名称获取特定的Field对象<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>        f.<span style=color:#a6e22e>setAccessible</span>(<span style=color:#66d9ef>true</span>);                  使其变为可访问的
</span></span><span style=display:flex><span>        Object v <span style=color:#f92672>=</span> f.<span style=color:#a6e22e>get</span>(list);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Person person <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person(<span style=color:#e6db74>&#34;alice&#34;</span>, 21);    方法对象调用invoke方法来执行方法<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    Class p <span style=color:#f92672>=</span> person.<span style=color:#a6e22e>getClass</span>();                <span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>invoke</span>(Object obj, Object... args)
</span></span><span style=display:flex><span>    Method m <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>getMethod</span>(<span style=color:#e6db74>&#34;getName&#34;</span>);          第一个参数为对象名<span style=color:#960050;background-color:#1e0010>，</span>之后的参数为方法的参数<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    String s <span style=color:#f92672>=</span> (String) m.<span style=color:#a6e22e>invoke</span>(person);       调用的是静态方法时<span style=color:#960050;background-color:#1e0010>，</span>第一个参数为null<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    代理的作用就是在不修改源码的情况下<span style=color:#960050;background-color:#1e0010>，</span>对目标对象的方法增强<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>    静态代理<span style=color:#960050;background-color:#1e0010>：</span>接口 <span style=color:#f92672>+</span> 代理类 <span style=color:#f92672>+</span> 被代理类   <span style=color:#f92672>--</span><span style=color:#960050;background-color:#1e0010>》</span>  一个代理类只能对应一个被代理类         代理类与被代理类实现同样的接口
</span></span><span style=display:flex><span>    动态代理<span style=color:#960050;background-color:#1e0010>：</span>接口 <span style=color:#f92672>+</span> 代理类 <span style=color:#f92672>+</span> 多个被代理类   <span style=color:#f92672>--</span><span style=color:#960050;background-color:#1e0010>》</span>  一个代理类可以对应多个被代理类     代理类与被代理类实现同样的接口
</span></span><span style=display:flex><span>        结合src<span style=color:#f92672>/</span>proxy<span style=color:#f92672>/</span>annotationProxy包下的例子理解
</span></span><span style=display:flex><span>        1<span style=color:#960050;background-color:#1e0010>、</span>根据自己需求创建一个被代理类对象<span style=color:#960050;background-color:#1e0010>（</span>想象在项目中<span style=color:#960050;background-color:#1e0010>，</span>要增强功能时<span style=color:#960050;background-color:#1e0010>，</span>一定在之前已经使用过这个对象<span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span>        2<span style=color:#960050;background-color:#1e0010>、</span>根据这个被代理类对象<span style=color:#960050;background-color:#1e0010>，</span>动态获取一个代理类对象<span style=color:#960050;background-color:#1e0010>（</span>因此<span style=color:#960050;background-color:#1e0010>，</span>没有显示的代理类<span style=color:#960050;background-color:#1e0010>，</span>是被动态获取到的<span style=color:#960050;background-color:#1e0010>）</span>
</span></span><span style=display:flex><span>        3<span style=color:#960050;background-color:#1e0010>、</span>使用代理类对象调用被代理类的方法<span style=color:#960050;background-color:#1e0010>。（</span>具体原理看包中例子的注释<span style=color:#960050;background-color:#1e0010>）</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E7%AC%94%E8%AE%B0/><span class=title>« Prev</span><br><span>MySQL概述</span>
</a><a class=next href=https://ethereal-lu.github.io/posts/java/annotation%E7%AC%94%E8%AE%B0/><span class=title>Next »</span><br><span>Annotation学习笔记</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>