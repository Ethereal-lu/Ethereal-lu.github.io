<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JUC 并发编程 | lu</title>
<meta name=keywords content><meta name=description content="线程基础知识
概述
每个线程拥有一个自己独立的栈，但是共享进程的堆空间。
Thread 中的 run 方法是一个回调函数，与普通函数没什么区别，所以以如下方式调用run时，就是一个普通的方法执行。而 start 方法会在本地创建一个线程，然后在本地代码中通过 jvm 回调 run 方法来执行任务。
Thread thread = new Thread(() -> {...});
thread.run();
线程实现方法
Thread类是描述线程的类，要实现多线程，必须继承Thread类
方法一、创建Thread类的子类
1、创建Thread类的子类，并重写run方法，其中设置线程的任务
2、创建子类对象，并执行start方法
​	（执行start方法会创建一个新的栈空间，并在该栈空间中执行run方法。每执行一次步骤2，就开启一个新的线程）
方法二、实现Runnable接口
推荐使用这种   &mdash;>  使用该方法时，Thread 类是咱们自定义类的静态代理类
1、创建一个Runnable接口的实现类，并重写run方法，其中设置线程的任务
2、创建对象，并将其作为参数传递给Thread类的构造方法，再调用start方法。
​     new Thread(new MyRunnable()).start();
​     匿名内部类实现： new Thread(new Runnable(){重写run方法}).start();
方法三、实现Callable接口
Callable接口类似于Runnable，但Runnable不会返回结果，也不会抛出检查异常，Callable可以，Runnable 效率比 Callable 低。
1、创建一个Callable接口的实现类，并重写call方法，其中设置线程的任务
2、在使用的地方创建该类对象 obj 。
3、ExecutorService executorService = Executors.newFixedThreadPool(5);  // 创建执行服务
4、Future future = executorService.submit(obj);                                       // 提交执行
5、V result = future.get();                                                                                 // 获取结果
6、executorService.shutdownNow();                                                               // 关闭服务"><meta name=author content="lu"><link rel=canonical href=http://localhost:1313/posts/java/juc%E7%AC%94%E8%AE%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity="sha256-1yREUm1+y9sAFUOKf6iQVKZYv3WdBULi5d+BzpS0k+4=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/java/juc%E7%AC%94%E8%AE%B0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/java/juc%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="lu"><meta property="og:title" content="JUC 并发编程"><meta property="og:description" content="线程基础知识 概述 每个线程拥有一个自己独立的栈，但是共享进程的堆空间。
Thread 中的 run 方法是一个回调函数，与普通函数没什么区别，所以以如下方式调用run时，就是一个普通的方法执行。而 start 方法会在本地创建一个线程，然后在本地代码中通过 jvm 回调 run 方法来执行任务。
Thread thread = new Thread(() -> {...}); thread.run(); 线程实现方法 Thread类是描述线程的类，要实现多线程，必须继承Thread类
方法一、创建Thread类的子类 1、创建Thread类的子类，并重写run方法，其中设置线程的任务
2、创建子类对象，并执行start方法
​	（执行start方法会创建一个新的栈空间，并在该栈空间中执行run方法。每执行一次步骤2，就开启一个新的线程）
方法二、实现Runnable接口 推荐使用这种 —> 使用该方法时，Thread 类是咱们自定义类的静态代理类
1、创建一个Runnable接口的实现类，并重写run方法，其中设置线程的任务
2、创建对象，并将其作为参数传递给Thread类的构造方法，再调用start方法。
​ new Thread(new MyRunnable()).start(); ​ 匿名内部类实现： new Thread(new Runnable(){重写run方法}).start();
方法三、实现Callable接口 Callable接口类似于Runnable，但Runnable不会返回结果，也不会抛出检查异常，Callable可以，Runnable 效率比 Callable 低。
1、创建一个Callable接口的实现类，并重写call方法，其中设置线程的任务 2、在使用的地方创建该类对象 obj 。 3、ExecutorService executorService = Executors.newFixedThreadPool(5); // 创建执行服务 4、Future future = executorService.submit(obj); // 提交执行 5、V result = future.get(); // 获取结果 6、executorService.shutdownNow(); // 关闭服务"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-16T17:12:41+00:00"><meta property="article:modified_time" content="2021-08-16T17:12:41+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="JUC 并发编程"><meta name=twitter:description content="线程基础知识
概述
每个线程拥有一个自己独立的栈，但是共享进程的堆空间。
Thread 中的 run 方法是一个回调函数，与普通函数没什么区别，所以以如下方式调用run时，就是一个普通的方法执行。而 start 方法会在本地创建一个线程，然后在本地代码中通过 jvm 回调 run 方法来执行任务。
Thread thread = new Thread(() -> {...});
thread.run();
线程实现方法
Thread类是描述线程的类，要实现多线程，必须继承Thread类
方法一、创建Thread类的子类
1、创建Thread类的子类，并重写run方法，其中设置线程的任务
2、创建子类对象，并执行start方法
​	（执行start方法会创建一个新的栈空间，并在该栈空间中执行run方法。每执行一次步骤2，就开启一个新的线程）
方法二、实现Runnable接口
推荐使用这种   &mdash;>  使用该方法时，Thread 类是咱们自定义类的静态代理类
1、创建一个Runnable接口的实现类，并重写run方法，其中设置线程的任务
2、创建对象，并将其作为参数传递给Thread类的构造方法，再调用start方法。
​     new Thread(new MyRunnable()).start();
​     匿名内部类实现： new Thread(new Runnable(){重写run方法}).start();
方法三、实现Callable接口
Callable接口类似于Runnable，但Runnable不会返回结果，也不会抛出检查异常，Callable可以，Runnable 效率比 Callable 低。
1、创建一个Callable接口的实现类，并重写call方法，其中设置线程的任务
2、在使用的地方创建该类对象 obj 。
3、ExecutorService executorService = Executors.newFixedThreadPool(5);  // 创建执行服务
4、Future future = executorService.submit(obj);                                       // 提交执行
5、V result = future.get();                                                                                 // 获取结果
6、executorService.shutdownNow();                                                               // 关闭服务"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"JUC 并发编程","item":"http://localhost:1313/posts/java/juc%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JUC 并发编程","name":"JUC 并发编程","description":"线程基础知识 概述 每个线程拥有一个自己独立的栈，但是共享进程的堆空间。\nThread 中的 run 方法是一个回调函数，与普通函数没什么区别，所以以如下方式调用run时，就是一个普通的方法执行。而 start 方法会在本地创建一个线程，然后在本地代码中通过 jvm 回调 run 方法来执行任务。\nThread thread = new Thread(() -\u0026gt; {...}); thread.run(); 线程实现方法 Thread类是描述线程的类，要实现多线程，必须继承Thread类\n方法一、创建Thread类的子类 1、创建Thread类的子类，并重写run方法，其中设置线程的任务\n2、创建子类对象，并执行start方法\n​\t（执行start方法会创建一个新的栈空间，并在该栈空间中执行run方法。每执行一次步骤2，就开启一个新的线程）\n方法二、实现Runnable接口 推荐使用这种 \u0026mdash;\u0026gt; 使用该方法时，Thread 类是咱们自定义类的静态代理类\n1、创建一个Runnable接口的实现类，并重写run方法，其中设置线程的任务\n2、创建对象，并将其作为参数传递给Thread类的构造方法，再调用start方法。\n​ new Thread(new MyRunnable()).start(); ​ 匿名内部类实现： new Thread(new Runnable(){重写run方法}).start();\n方法三、实现Callable接口 Callable接口类似于Runnable，但Runnable不会返回结果，也不会抛出检查异常，Callable可以，Runnable 效率比 Callable 低。\n1、创建一个Callable接口的实现类，并重写call方法，其中设置线程的任务 2、在使用的地方创建该类对象 obj 。 3、ExecutorService executorService = Executors.newFixedThreadPool(5); // 创建执行服务 4、Future future = executorService.submit(obj); // 提交执行 5、V result = future.get(); // 获取结果 6、executorService.shutdownNow(); // 关闭服务\n","keywords":[],"articleBody":"线程基础知识 概述 每个线程拥有一个自己独立的栈，但是共享进程的堆空间。\nThread 中的 run 方法是一个回调函数，与普通函数没什么区别，所以以如下方式调用run时，就是一个普通的方法执行。而 start 方法会在本地创建一个线程，然后在本地代码中通过 jvm 回调 run 方法来执行任务。\nThread thread = new Thread(() -\u003e {...}); thread.run(); 线程实现方法 Thread类是描述线程的类，要实现多线程，必须继承Thread类\n方法一、创建Thread类的子类 1、创建Thread类的子类，并重写run方法，其中设置线程的任务\n2、创建子类对象，并执行start方法\n​\t（执行start方法会创建一个新的栈空间，并在该栈空间中执行run方法。每执行一次步骤2，就开启一个新的线程）\n方法二、实现Runnable接口 推荐使用这种 —\u003e 使用该方法时，Thread 类是咱们自定义类的静态代理类\n1、创建一个Runnable接口的实现类，并重写run方法，其中设置线程的任务\n2、创建对象，并将其作为参数传递给Thread类的构造方法，再调用start方法。\n​ new Thread(new MyRunnable()).start(); ​ 匿名内部类实现： new Thread(new Runnable(){重写run方法}).start();\n方法三、实现Callable接口 Callable接口类似于Runnable，但Runnable不会返回结果，也不会抛出检查异常，Callable可以，Runnable 效率比 Callable 低。\n1、创建一个Callable接口的实现类，并重写call方法，其中设置线程的任务 2、在使用的地方创建该类对象 obj 。 3、ExecutorService executorService = Executors.newFixedThreadPool(5); // 创建执行服务 4、Future future = executorService.submit(obj); // 提交执行 5、V result = future.get(); // 获取结果 6、executorService.shutdownNow(); // 关闭服务\n同步实现方法 多个对象访问同一个资源，可以并发读取，但当其中某一个对象要修改时，就必须实现同步\n锁对象选取总结为一句话就是 在同步代码中要改变谁就锁谁。\n方法一： 同步代码块 synchronized (锁对象) {访问共享数据的代码} 线程不仅要抢夺CUP，还要占用锁对象。同时拥有才能执行代码 锁对象可以是任意对象，但必须是同一个对象，推荐将共享资源作为锁对象。线程占用锁对象后直到执行完毕才释放。\n方法二： 同步方法 修饰符 synchronized 返回值类型 方法名 (参数列表) {访问共享数据的代码} // 该方法即为同步方法 首先将 访问共享数据的代码块 抽取出来，作为上述方法。 同步方法的锁对象默认为 this ，即调用该同步方法的对象；创建该类的对象后，该对象调用同步方法时就会锁住对象自己。 当同步方法同时也是静态方法时，锁对象为同步方法所在类的 Class 对象。\n因此普通同步方法，每个对象都有一把锁；静态同步方法，所有对象共用一把锁。对同一个对象而言，这是两把不同的锁，一个锁是自己、一个锁是 Class 类模板。\n方法三： Lock锁 Lock是一个接口，有两个方法 void lock() 获取锁 和 void unlock() 释放锁 它有一个实现类ReentrantLock（可重入锁）， 先实例化一个ReentrantLock对象。 在出现安全问题代码之前用该对象调用 lock() 方法。在出现安全问题代码之后用该对象调用 unlock() 方法。 lock() 和 unlock() 方法建议放在 try — finally 代码块中\nsynchronized 底层原理 使用时需要关联一个对象，而这个对象就是 monitor object。\n管程（monitor）机制中，monitor object 充当着维护 mutex 以及定义 wait/signal API 来管理线程的阻塞和唤醒的角色。\nJava 语言中的 java.lang.Object 类，便是满足这个要求的对象，任何一个 Java 对象都可以作为 monitor 机制的 monitor object。\njava 对象的内存布局中，每个对象的对象头都保存了锁标识。\n要进入一个 synchronized 方法修饰的方法或者代码块，会先获取与 synchronized 关键字绑定在一起的 Object 的对象锁，这个锁也限定了其它线程无法进入与这个锁相关的其它 synchronized 代码区域。\n当一个线程需要获取与 synchronized 关联的 Object 的锁时，会被放入 EntrySet 中进行等待，如果该线程获取到了锁，就成为当前锁的 owner，此时 monitor + 1，当前线程可以使用该临界资源，而在该线程持有锁的期间，该线程还可以再次进入临界区，此时 monitor 再次加 1 （这就是可重入锁），同样、线程每次退出临界区 monitor 都会减 1，当 monitor 减为 0 时，代表当前线程放弃对对象锁的拥有权。如果获取到锁的线程不是因使用完放弃，而是由于缺少外部条件时就会调用 wait 方法将锁释放，进入 wait set 中阻塞进行等待。\n底层使用指令码方式来控制锁的，映射成字节码指令就是两个指令：monitorenter和monitorexit。当线程执行遇到monitorenter指令时会尝试获取内置锁，如果获取锁则锁计数器+1，如果没有获取锁则阻塞；当遇到monitorexit指令时锁计数器-1，如果计数器为0则释放锁。\nJVM 在执行方法之前，如果发现该方法前面有 synchronized 关键字，就先在该对象的 ID 上加锁，当其他线程执行到这个方法时，会检测该对象ID上是否加锁，如果加锁时就等待锁释放。\n如果一个对象中有两个方法同时被 synchronized 修饰，则同一个对象，调用这两个方法时，只能同时执行一个。\n线程状态 创建、就绪、运行、阻塞、死亡。\njava线程状态 NEW：创建线程实例，但还没有用 start()方法启动 RUNNABLE：线程启动之后，就绪和运行状态都属于RUNNABLE状态 BLOCKED：竞争synchronize 锁失败，java中只有这一种进入BLOCKED的方式，Lock进入的是WAITING状态 WAITING：通过join、wait、lock等方法进入次状态 TIMED_WAITING：通过sleep、wait(time)等方法进入此状态 TERMINATED：结束退出 线程停止 不推荐使用 Thread 类提供的 stop() 等方法。推荐自己设置一个标志位，通过调用自己实现的 stop 方法来停止线程。如下：\npublic class MyRunnable implements Runnable { private boolean flag = true; @Override public void run() { while (flag) { TODO... } } public void stop() { flag = false; } } 下方所有方法都是 Thread 类中的方法！\n线程休眠 Thread.sleep(毫秒)\nsleep 不会释放锁、 wait 会释放锁。两者都释放 CPU\nJUC 编程中常使用 TimeUnit.SECONDS.sleep(2); 进行休眠\n线程礼让 Thread.yield();\n使当前线程从运行状态变为就绪状态，让 cpu 从所有就绪的线程中挑一个运行。 礼让有可能不成功，因为 cpu 可能再挑选一次还是让当前线程继续执行。\n线程强制执行 join()\n相当于插队，停止现在执行的线程，立刻执行自己的线程，且本线程执行结束才能执行其他线程\n在下方举例代码中，主线程执行到200之前，主线程和Runnable线程交替执行，当主线程执行到200次时，Runnable 线程插队接着执行，之后Runnable线程全部执行完毕后才由主线程继续执行。\npublic class MyRunnable implements Runnable { @Override public void run() { for (int i = 0; i \u003c 1000; i++) { System.out.println(\"Runnable \" + i); } } public static void main(String[] args) throws InterruptedException { MyRunnable myRunnable = new MyRunnable(); Thread thread = new Thread(myRunnable); thread.start(); for (int i = 0; i \u003c 500; i++) { if (i == 200) { thread.join(); } System.out.println(\"主线程\" + i); } } } 查看线程状态 Thread.State state = thread.getState();\nThread.State 是一个枚举类型，枚举类中包含的就是上方java的6个状态\n线程优先级 1 最小；10 最大；默认为5。优先级越高在就绪状态很大可能越早执行，但也不是一定。\n守护（daemon）线程 线程分为用户线程和守护线程。 虚拟机必须保证用户线程执行完毕，但不用等待守护线程执行完毕。 守护线程有：后台记录日志、监控内存、垃圾回收等\nprivate boolean daemon = false; // 该句为 Thread 类的源码，默认 daemon 属性是关闭的，即默认为用户线程 thread.setDaemon(true); // 可通过这样将线程设置为 守护线程。 将线程设置为守护线程之后，虚拟机将不再保证该线程是否执行结束， 即只要当用户线程执行结束后就将整个程序关闭，而不考虑守护线程此时是否已经执行完毕。\n线程池 底层原理 线程池就是一个容纳多个线程的容器，可由集合实现\n使用步骤 1、使用线程池工厂类Executors里面的静态方法newFixedThreadPool生产一个指定线程数量的线程池，由ExecutorService接口接收。 2、创建Runnable接口的实现类，重写run方法，设置线程任务。 3、调用ExecutorService中的execute方法，传递线程任务，开启线程，执行run方法。\n举例：\nExecutorService executorService = Executors.newFixedThreadPool(5); // 创建服务 Runnable runnable = new Runnable() { //此处虽然new 的是Runnable接口，但是立即重写了run方法，故相当于其实现类。 @Override public void run() { //线程任务 } }; executorService.execute(runnable); // 执行服务 executorService.shutdownNow(); // 关闭服务 submit()方法和 execute()方法 ExecutorService 中的 submit()方法和 execute()方法作用相同，只是适用于不同场景 void execute(Runnable command) // 执行任务，没有返回值，一般用于执行 Runnable \u003cT\u003e Future\u003cT\u003e submit(Callable\u003cT\u003e task); // 执行任务，有返回值，一般用于执行 Callable JUC 并发编程 1、什么是 JUC JUC 即与并发相关的三个包：java.util.concurrent、 java.util.concurrent.atomic 、 java.util.concurrent.locks。\n2、线程与进程 一个 java 进程默认包含 2 个线程：main 线程与 GC 线程。\njava 本身并不能开启线程，是通过调用本地方法（C++）实现的。\n// 获取本机 CPU 的核数，其实是逻辑处理器的个数 System.out.println(Runtime.getRuntime().availableProcessors()); 并行编程：利用线程池\n并发编程的本质：充分利用 CPU 的资源。\n并发：多个线程操作同一个资源类\n3、虚假唤醒问题 在如下代码中，当条件不满足时，进入等待；当其他线程执行 notifyAll() 时，该线程被唤醒去执行业务逻辑。\n但是有可能该线程被唤醒后仍然不满足条件，却没有加以判断就直接执行后续代码，这就是虚假唤醒。\npublic synchronized void func() { if ( \"条件不满足\" ) { this.wait(); } // 业务逻辑 } 为了避免虚假唤醒问题，所有的 wait() 都应该出现在 while 循环中，原因如下：\n用 if 判断流水线状态为空时，线程被阻塞，这时 if 判断就完成了，线程被唤醒后直接执行线程剩余操作；\n用 while 判断流水线状态为空时，线程被阻塞，这时 while 判断没有完成，线程被唤醒后需先进行 while 判断。\n4、Lock 锁（重点） 并发工具（锁）：深入Lock+Condition - 知乎 (zhihu.com)\nLock 和 synchronized都是基于管程模型设计的。\n4.1、Synchronized 与 Lock 的区别 存在层次上： synchronized 是 Java 的关键字，在jvm层面上； Lock: 是一个接口\n锁的释放： synchronized: 自动释放； Lock: 在finally中必须释放锁，不然容易造成线程死锁\n锁的获取： synchronized: 假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待\n​\tLock: 分情况而定，Lock有多个锁获取的方式，可以通过 tryLock() 尝试获得锁，线程可以不用一直等待\n锁的状态： synchronized: 无法判断 ； Lock: 可以判断\n锁的类型： synchronized: 可重入 不可中断 非公平； Lock: 可重入 可中断 可公平（两者皆可）\n性能： synchronized: 少量同步； Lock: 大量同步\n调度： synchronized: 使用Object对象本身的wait 、notify、notifyAll调度机制； Lock: 可以使用Condition进行线程之间的调度\n排队队列：synchronized 不论是竞争锁失败还是条件不满足都只有一个排队队列。Lock 可以和 Condition 搭配根据不同条件创建不同排队队列。\n公平：synchronized 为非公平锁。Lock 可以自己设置公平或非公平。\n4.2、JUC 代替传统线程通信 阻塞 通知 Synchronized wait notify Lock await signal Condition 介绍\nLock替换synchronized方法和语句的使用， Condition取代了对象监视器方法的使用。 Condition接口为一个线程暂停执行（“等待”）提供了一种方法，直到另一个线程通知某些状态现在可能为真。 一个Condition实例本质上绑定到一个锁。 await() ：阻塞自己、signal() ：唤醒自己、signalAll()：唤醒所有线程 替换\n将 synchronized变为被lock.lock() 和 lock.unlock()包围； this.wait() –\u003e condition.await()； this.notify() –\u003e condition.signal()。 // Javadoc 示例 class BoundedBuffer { final Lock lock = new ReentrantLock(); // 新建 Lock final Condition notFull = lock.newCondition(); // 通过 Lock 生成 Condition final Condition notEmpty = lock.newCondition(); // 一个 Condition 对应一个阻塞队列 final Object[] items = new Object[100]; int putptr, takeptr, count; // put 和 take 方法使用的同一把锁，同时只能进入一个方法 public void put(Object x) throws InterruptedException { lock.lock(); try { while (count == items.length) // 当消费者线程1执行到这条语句时，就会将消费者线程1移到 notFull 条件的阻塞队列等待 notFull.await(); items[putptr] = x; if (++putptr == items.length) putptr = 0; ++count; // 唤醒 notEmpty 条件的阻塞队列中的第一个线程 notEmpty.signal(); } finally { lock.unlock(); } } public Object take() throws InterruptedException { lock.lock(); try { while (count == 0) notEmpty.await(); // 将当前线程阻塞到 notEmpty 条件的阻塞队列 Object x = items[takeptr]; if (++takeptr == items.length) takeptr = 0; --count; notFull.signal(); // 唤醒 notFull 条件的阻塞队列中的第一个线程 return x; } finally { lock.unlock(); } } } Condition 可以精准唤醒指定的线程\n由于每个 Condition 对应一个阻塞队列，可以为每个线程增加一个判断条件，即每个线程都只能固定阻塞在某个条件的阻塞队列中，这样就可以根据条件精准地唤醒对应线程了。\n5、8 锁问题 同步方法的锁对象默认为 this ，即调用该同步方法的对象；创建该类的对象后，该对象调用同步方法时就会锁住对象自己。 当同步方法同时也是静态方法时，锁对象为同步方法所在类的 Class 对象。\n因此普通同步方法，每个对象都有一把锁；静态同步方法，所有对象共用一把锁。对同一个对象而言，这是两把不同的锁，一个锁是自己、一个锁是 Class 类模板。\n6、集合类不安全【面试高频】 6.1、List 不安全 平时使用的如下代码，都是单线程，是绝对安全的。\nList\u003cString\u003e list = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c 10; i++) { list.add(UUID.randomUUID().toString().substring(0, 5)); } 但当涉及多线程时就会出现问题\nList\u003cString\u003e list = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c 100; i++) { new Thread( () -\u003e { list.add(UUID.randomUUID().toString().substring(0, 5)); System.out.println(list); // list.toString() 方法使用的迭代器，触发了快速失败，因此报错。 }, String.valueOf(i)).start(); } // 报错 java.util.ConcurrentModificationException --》 并发修改异常 解决方案\n1、使用 Vector\u003c\u003e() 。【不推荐】看源码可知 Vector 的涉及并发的所有方法都被 synchronized 修饰。但其效率太低，已被淘汰。 此处有疑问：synchronized 在 jdk1.6 优化之后，Vector 为什么还不能使用？\n2、List list = Collections.synchronizedList(new ArrayList\u003c\u003e()); 使用Collections将其转换为安全 List 。\n3、List list = new CopyOnWriteArrayList\u003c\u003e(); 使用 JUC 提供的安全 List 。【推荐】\nCopyOnWrite 为 “写入时复制”，是计算机程序设计领域的一种优化策略。 在写之前复制一份，在复制的 list 上写，写完再将其赋值给原来的list。 CopyOnWriteArrayList 比 Vector 高效。 高效吗？高效在哪里？ 6.2、Set 不安全 Set 与 List 遇到的不安全问题完全相同。\n解决方案\n1、Set set = Collections.synchronizedSet(new HashSet\u003c\u003e()); 使用Collections将其转换为安全 Set 。\n2、Set set = new CopyOnWriteArraySet\u003c\u003e(); 使用 JUC 提供的安全 Set 。【推荐】\n6.3、Map 不安全 Map 与 Set 、List 遇到的不安全问题完全相同。\n1、Map map = Collections.synchronizedMap(new HashMap\u003c\u003e());\n2、Map map = new ConcurrentHashMap\u003c\u003e(); 使用 JUC 提供的安全 Map 。【推荐】\n有时间看 ConcurrentHashMap 的原理 7、Callable 普通线程实现方法 —》 通过 Runnable 的实现类 FutureTask 作为桥梁，将 Callable 提交给 Thread 执行。\n同一个 FutureTask 任务只能执行一次 （无论将其交由几个线程执行）。因为其内部有一个 state ，只有 state 为 NEW 时才能开始执行，任意一个线程开始执行之后，state 就会被改变。 public class CallableTest { public static void main(String[] args) throws ExecutionException, InterruptedException { MyThread myThread = new MyThread(); FutureTask\u003cInteger\u003e task = new FutureTask\u003c\u003e(myThread); // 适配类，Runnable 的实现类 new Thread(task, \"name\").start(); // 执行 Integer ans = task.get(); // 获取结果，计算完成之前，get 方法会被阻塞 System.out.println(ans); } } class MyThread implements Callable\u003cInteger\u003e { @Override public Integer call() { return 1024; } } 线程池实现方法。搭配线程基础知识的线程实现方法的方法三看。\npublic class CallableTest { public static void main(String[] args) throws ExecutionException, InterruptedException { MyThread myThread = new MyThread(); ExecutorService executorService = Executors.newFixedThreadPool(5); Future\u003cInteger\u003e future = executorService.submit(myThread); Integer ans = future.get(); // 执行计算较耗时，应放在最后或者通过异步方式处理。 executorService.shutdownNow(); System.out.println(ans); } } class MyThread implements Callable\u003cInteger\u003e { @Override public Integer call() { return 1024; } } 8、常用辅助类【必会】 8.1、CountDownLatch 减法计数器\n// 计数器 public class CountDownLatchDemo { public static void main(String[] args) throws InterruptedException { // 计数器总数是6 CountDownLatch latch = new CountDownLatch(6); for (int i = 0; i \u003c 6; i++) { new Thread( () -\u003e { System.out.println(Thread.currentThread().getName() + \" done!\"); latch.countDown(); // 计数器减一 }, String.valueOf(i)).start(); } latch.await(); // 在计数器减为 0 之前，将所有的线程阻塞在此处 System.out.println(\"to do next step!\"); // 计数器为 0 ，所有线程执行后续操作。 } } 8.2、CyclicBarrier 循环阻塞，相当于加法计数器\nCyclicBarrier 构造时会指定参与的线程数量，通过barrier.await();生成屏障点，将线程阻塞在该屏障点，直到所有参与的线程都到达这个屏障点，然后统一释放。释放之后，该 CyclicBarrier 对象还可以继续使用，即再次从 0 开始计数直到足够数量的线程到达屏障点，再释放…\npublic class CyclicBarrierDemo { public static void main(String[] args) { // 指定共有 7 个参与方（线程），以及触发屏障之后的操作，该操作由进入屏障的最后一个线程执行。 CyclicBarrier barrier = new CyclicBarrier(7, () -\u003e System.out.println(\"召唤神龙成功！\")); for (int i = 0; i \u003c 7; i++) { int finalI = i; new Thread( () -\u003e { // lambda 表达式中使用的变量应该是 final 或有效 final System.out.println(Thread.currentThread().getName() + \"收集了第\" + finalI + \"颗龙珠\"); try { barrier.await(); // 屏障点。阻塞当前线程，直到所有的参与方都到达这个屏障点 } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } }).start(); } } } 8.3、Semaphore 信号量，和操作系统信号量一样，P 一下减 1，V 一下加 1。会限制最大并发数量。\n变为方法调用，即 P –\u003e acquire()， V –\u003e release() 。\n作用：\n多个线程互斥共享有限资源 限流，限制最大并发数量。 public class SemaphoreDemo { public static void main(String[] args) { // 最多同时执行的线程数量，其实应该是资源数量 Semaphore semaphore = new Semaphore(3); for (int i = 0; i \u003c 6; i++) { new Thread( () -\u003e { try { semaphore.acquire(); System.out.println(Thread.currentThread().getName() + \"抢到车位\"); TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } finally { semaphore.release(); System.out.println(Thread.currentThread().getName() + \"离开车位\"); } }).start(); } } } 9、读写锁（ReadWriteLock） 解决读者写者问题。\n写锁（独占锁、排他锁） 一次只能被一个线程占有\n读锁（共享锁） 多个线程可以同时占有\n读-读 可以共存 读-写 不能共存 写-写 不能共存 用法和 Lock 完全一样，在写的地方用写锁，读的地方用读锁。\n// 该代码示例很不恰当，会出现先读后写的问题。只用来展示 ReadWriteLock 怎么使用。 public class ReadWriteLockDemo { public static void main(String[] args) { MyCache myCache = new MyCache(); for (int i = 0; i \u003c 5; i++) { int finalI = i; new Thread( () -\u003e myCache.put(finalI + \"\", finalI + \"\")).start(); } for (int i = 0; i \u003c 5; i++) { int finalI = i; new Thread( () -\u003e myCache.get(finalI + \"\")).start(); } } } class MyCache { private volatile Map\u003cString, Object\u003e map = new HashMap\u003c\u003e(); // 读写锁 private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); public void put(String key, Object value) { readWriteLock.writeLock().lock(); try { System.out.println(Thread.currentThread().getName() + \" write \" + key); map.put(key, value); System.out.println(Thread.currentThread().getName() + \" write done\"); } catch (Exception e) { e.printStackTrace(); } finally { readWriteLock.writeLock().unlock(); } } public void get(String key) { readWriteLock.readLock().lock(); try { System.out.println(Thread.currentThread().getName() + \" read \" + key); Object value = map.get(key); System.out.println(Thread.currentThread().getName() + \" result \" + value); } catch (Exception e) { e.printStackTrace(); } finally { readWriteLock.readLock().unlock(); } } } 10、阻塞队列（BlockingQueue） BlockingQueue extends Queue Queue extends Collection\n使用场景： 多线程并发处理、线程池\n四组 API\n失败抛异常 失败返回特殊值 持续阻塞 限时阻塞 添加 add(e) offer(e) put(e) offer(e, time, unit) 移除 remove() poll() take() poll(time, unit) 查看首元素 element() peek() 无 无 SynchronousQueue 同步队列 SynchronousQueue implements BlockingQueue 当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。\n*当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒。*\nput(e) take()\n11、线程池【重点】 作用：线程复用、控制最大并发数、线程管理\n内容：三大方法、七大参数、四种拒绝策略\n11.1、三大方法 Executors.newSingleThreadExecutor(); // 单个线程的线程池 Executors.newFixedThreadPool(5); // 固定个数线程的线程池 Executors.newCachedThreadPool(); // 可伸缩大小的线程池 示例：\npublic static void main(String[] args) { ExecutorService threadPool = Executors.newFixedThreadPool(5);// 固定个数线程的线程池 try { for (int i = 0; i \u003c 10; i++) { // Runnable 接口的 lambda 表达式 threadPool.execute( () -\u003e System.out.println(Thread.currentThread().getName() + \"is executing now.\")); } } finally { threadPool.shutdown(); // 关闭线程池 } } 11.2、七大参数 阿里开发手册规定，不得使用 Executors 创建线程池，应该使用 ThreadPoolExecutor。\n进入上节三大方法内部，发现都是调用 ThreadPoolExecutor方法生成的线程池。该方法调用的构造方法有 7 个参数。\npublic ThreadPoolExecutor (int corePoolSize, // 核心线程池大小，即该线程池中不论任何时候都最少存在的线程数量 int maximumPoolSize, // 最大线程池大小 long keepAliveTime, // 线程超时未调用会被释放。用于大于核心大小，小于最大大小的线程 TimeUnit unit, // 超时的单位 BlockingQueue\u003cRunnable\u003e workQueue, // 阻塞队列，类似于银行等候的待客区，等待线程空闲 ThreadFactory threadFactory, // 线程工厂，不用改变 RejectedExecutionHandler handler) // 拒绝策略 11.3、四种拒绝策略 最初只有 corePoolSize个线程处理请求，当请求数量大于corePoolSize时，多出的请求进入阻塞队列。\n假设用 BlockingQueueSize表示阻塞队列的容量，当请求总数大于 (corePoolSize+BlockingQueueSize)时，就用线程工厂新建 (请求总数 - (corePoolSize+BlockingQueueSize)) 个线程，即总是优先阻塞请求。\n当最大线程数量都被分配完毕，且阻塞队列也满了的时候，需要拒绝策略来拒绝新的请求。\n四种拒绝策略即RejectedExecutionHandler接口的四个实现类。\n这四个实现类都是 ThreadPoolExecutor的静态内部类。\n策略 作用 AbortPolicy (默认) 抛出异常 CallerRunsPolicy 哪条线程送你来的线程池，就送回去让那条线程执行，不抛出异常 DiscardPolicy 丢弃请求，不抛出异常 DiscardOldestPolicy 丢弃最早进入阻塞队列的请求，并对新请求再次执行execute。 对正在执行的请求没有任何影响。不抛出异常 11.4、线程池的线程数 1、 CPU 密集型任务：最优线程数应为核心数 + 1。由于CPU一直处于运行状态，如果设置的线程数过多会导致频繁的上下文切换。在理论上，最优线程数应该是核心数，但是在实际运行中，可能某个线程会因为缺页或其他异常而暂停，此时由额外线程补上，从而让CPU一直运行。\nRuntime.getRuntime().availableProcessors() // 将其作为最大线程容量传入即可 2、IO 密集型任务：最优线程数应为核心数 * 2。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程。\n《Java并发编程实战》对于计算最优线程数有一个公式：最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）* CPU数目\n11.5、线程池状态 线程池有个变量为：控制状态 ctl，其高三位表示下方的5中状态，低29位表示线程池中有效的线程个数。\n1、RUNNING\n(1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。 (2) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0\n2、 SHUTDOWN\n(1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。 (2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -\u003e SHUTDOWN。\n3、STOP\n(1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。 (2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -\u003e STOP。\n4、TIDYING\n(1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。 (2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -\u003e TIDYING。 当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -\u003e TIDYING。\n5、 TERMINATED\n(1) 状态说明：线程池彻底终止，就变成TERMINATED状态。 (2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -\u003e TERMINATED。\n12、四大函数式接口【必须掌握】 虽然看着没什么用，但是 JDK 大量源码都将这些接口作为参数使用，因此必须会。\nFunction\u003cString, Integer\u003e function = String::length; // 函数式接口可以直接由 lambda 表达式构造 接口 抽象方法 描述 Function R apply(T t); 作为一个方法，只能接受一个参数并返回结果 Predicate boolean test(T t); 同上方，只是返回结果为布尔值 Consumer void accept(T t); 消费型接口，接受一个参数，不返回结果 Supplier T get(); 供给型接口，不输入只返回 上述四大接口还衍生出来许多其他类似接口，例如BiConsumer，它同样是消费型接口，接受两个参数但没有返回值，更多类似用到时心里有数就行。\n13、Stream 流式计算 大数据 = 存储 + 计算\n存储 ： 集合、容器、数据库\n计算 ： 流\nStream 的方法中大量使用了上章四大函数式接口。\n性能优化程度： Stream \u003e ForkJoin \u003e 普通计算\n14、ForkJoin ForkJoin 出现于 JDK 1.7。适用于大数据量（至少 1e8）并行执行任务，提高效率。\n将一个大任务拆分成多个小任务（Fork），让多条线程并行执行完毕后，再将各自的结果合并（Join），得出最终结论。\n工作窃取：将最终拆分好的小任务用多个双端队列存储，每个线程负责一个双端队列并从头部开始执行，当执行速度快的线程将自己负责的队列中的所有任务执行完后，就会从执行速度慢的还没有执行完的队列底部窃取任务，帮助其执行。\n使用：\n1、ForkJoinTask抽象类，主要有两个子类，一个为RecursiveAction没有返回值；一个为RecursiveTask有返回值，返回类型即为 V。在自己的计算类中根据是否需要返回值继承其中一个子类并重写compute方法。\nclass Fibonacci extends RecursiveTask\u003cInteger\u003e { final int n; Fibonacci(int n) { this.n = n; } protected Integer compute() { if (n \u003c= 1) return n; Fibonacci f1 = new Fibonacci(n - 1); f1.fork(); Fibonacci f2 = new Fibonacci(n - 2); return f2.compute() + f1.join(); } } 2、实例化 ForkJoinPool；实例化自己的计算类，根据是否需要返回值调用submit或execute方法。\nForkJoinPool forkJoinPool = new ForkJoinPool(); Fibonacci fibonacci = new Fibonacci(1000000000); ForkJoinTask\u003cInteger\u003e submit = forkJoinPool.submit(fibonacci); Integer result = submit.get(); 15、异步回调 可以将异步回调理解为 Ajax 的调用过程：即当我们发起一个请求后，该请求可能会被阻塞或等待一段时间才能拿到结果，这时我们无需傻傻等待；将请求发起后就无需理会，可以直接去执行其他操作，待其执行完毕返回结果后再去接收处理。\n三部曲：异步执行、成功回调、失败回调\nFuture 是对未来的某个事件的结果进行建模，异步回调使用CompletableFuture,它是Future 的子类且对Future增强。\n// 没有返回值的异步回调 public static void main(String[] args) throws ExecutionException, InterruptedException { Future\u003cVoid\u003e future = CompletableFuture.runAsync( () -\u003e { /* TODO */ System.out.println(\"runAsync\"); }); // 到这里只是构造好了 future future.get(); // 取得结果，可能发生阻塞 System.out.println(\"main\"); } // --------------------------------------------------------- // 有返回值的异步回调 public static void main(String[] args) throws ExecutionException, InterruptedException { CompletableFuture\u003cInteger\u003e completableFuture = CompletableFuture.supplyAsync( () -\u003e 1024); // 无论是否正确执行都会调用 whenComplete 方法，第一个参数为正确结果，第二个参数为异常信息 // 当执行完成后会自动调用该方法，内部传参，我们只需对这些参数操作即可。 completableFuture.whenComplete((result, error) -\u003e System.out.println(\"result=\u003e\" + result + \" --- error=\u003e\" + error)) .exceptionally( (e) -\u003e { // 发生异常时既会调用 whenComplete 方法，又会调用 exceptionally 方法 e.printStackTrace(); return 1; }).get(); } 16、JMM JMM是面试高频，这里还是不够详细，其他知识如主线嗅探、缓存一致性、监听管道等等在面试前搞懂、理顺。\n16.1、主内存与工作内存 主内存与工作内存都是 JMM 中的抽象定义，主内存是共享的，工作内存是私有的。主内存包括本地方法区和堆；工作内存包括线程私有的栈和cup缓存区。\n所有的变量都存储在主内存中(虚拟机内存的一部分)，对于所有线程都是共享的。 每条线程都有自己的工作内存，工作内存中保存的是主存中某些变量的拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。 线程之间无法直接访问对方的工作内存中的变量，线程间变量的传递均需要通过主内存来完成。 JMM定义了lock(锁定)、read(读取)、load(加载)、use(使用)、assign(赋值)、store(存储)、write(写入)、unlock(解锁)八个步骤来实现主内存与工作内存之间的 具体交互。\n16.2、as-if-serial 和 happens-before Java内存模型是为了解决在并发环境下由于 CPU缓存、编译器和处理器的指令重排序导致的可见性、有序性问题。其包括两个规则，分别是as-if-serial规则和happens-before规则。\nas-if-serial规则即不管怎么重排序，程序的执行结果不能被改变。\n对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。 对于不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求（JMM允许这种重排序）。 为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序。\nhappens-before 规则所表述的是前一个操作的结果对后续操作是可见的，解决的就是内存可见性问题。重点记前4个。\n程序顺序规则： 同一线程内，程序按代码顺序执行（同一个线程中前面的所有写操作对后面的操作可见） 锁规则：如果线程1解锁了monitor a，接着线程2锁定了a，那么，线程1解锁a之前的写操作都对线程2可见 volatile变量规则：线程1写入了volatile变量v，接着线程2读取了v，那么线程1写入v及之前的写操作都对线程2可见 传递性：如果操作A happen—before操作B，操作B happen—before操作C，那么可以得出A happen—before操作C。 线程启动规则：线程A通过执行ThreadB.start()来启动线程B，那么线程A对共享变量的修改在接下来线程B开始执行前对线程B可见。注意：线程B启动之后，线程A在对变量修改线程B未必可见。 线程终止规则：线程t1写入的所有变量，在任意其它线程t2调用t1.join()，或者t1.isAlive() 成功返回后，都对t2可见。 线程中断规则：线程t1写入的所有变量，t1调用Thread.interrupt()打断t2，t2中断后可以看到t1的全部操作 对象终结规则：对象调用finalize()方法时，对象初始化完成的任意操作，同步到全部主存 happen—before的关键就是对一个共享变量读之前，对这个变量的写操作要从工作内存刷新到主存。\n17、volatile volatile 的引出：当多个线程都使用了主存中的一个值，其中当一个线程对该值作出修改并刷新到主存时，其他线程并不知道该值已经被修改，继续使用旧值操作从而产生逻辑问题。为了解决该问题，出现了volatile。\nvolatile 是 java 虚拟机提供比 sychronized 关键字更轻量级的同步机制，访问 volitile 变量时，不会执行加锁操作。\n特性：\n1、保证可见性 ：当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。\n2、不保证原子性 ：java 中自增包括取数、加一、保存三个过程的操作，假如 volitile 修饰的值执行自增，则在自增的任意一个阶段都可能被其他操作打断。\n3、禁止指令重排 ：编译器、CPU 都有可能通过指令重排来优化我们的代码，指令重排即对我们的源代码重新排序。 volitile 会在写操作的前和后都设置一道内存屏障来保证程序局部的有序性。\nvolatile 如何保证可见性 volatile 通过缓存一致性协议和总线嗅探机制来保证可见性。\ncpu1 的 线程1 与 cpu2 的 线程2 同时将主内存中的被 volatile 修饰的变量 v 加载的自己的工作内存（栈和L3缓存）。当 cpu1 的 线程1 对变量 v 修改后，总线就会发起通知， cpu2 嗅探到总线通知发现有其他线程对变量 v 产生了修改，就会将自己的 L3 缓存中的变量 v 的副本所在的缓存行置为无效状态，当线程 2 访问 v 时发现 v 所在缓存行失效就会丢弃该数据并去主内存中读取 v。\n单核 CPU 不存在可见性问题！\n18、单例模式 18.1、DCL 懒汉式（Double Check Lock 双重检测锁定） 第一重判断 if (lazyMan == null) 无需解释，第二重判断原因：当 a 和 b 两线程都进入第一重判断之后，a 获得锁执行完毕后释放锁，此时 b 线程获取锁又执行一次实例化操作，从而出现问题。\n实例加 volatile 的原因：lazyMan = new LazyMan(); 构造并不是原子操作，分为三部：\n1、分配内存空间\n2、在该内存空间初始化实例\n3、将该内存空间地址赋值给 lazyMan ；\n指令优化重新排序后可能按 1 3 2 的顺序执行，当 a 线程执行完 3 还没执行 2 时，lazyMan 已经不为 null ，此时线程 b 在第一重判断后直接返回 lazyMan ，但是 lazyMan 指向的空间还未初始化从而出现问题。volatile 通过限制指令重排使 CPU 只能按 1 2 3 的顺序执行从而解决问题。\n// DCL 懒汉式 public class LazyMan { private volatile static LazyMan lazyMan; private LazyMan() {} public static LazyMan getInstance() { if (lazyMan == null) { synchronized (LazyMan.class) { if (lazyMan == null) lazyMan = new LazyMan(); } } return lazyMan; } } 18.2、springboot 单例原理 springboot是通过单例注册表的方式实现单例模式的，即用一个 ConcurrentHashMap 作为单例注册表存储类名到单例的映射，每次获取单例实例时，先到注册表中查找是否已经有该实例，若有直接返回，否则新建一个实例返回并添加到单例注册表中。\n19、深入理解 CAS 19.1、CAS 是什么 CAS是英文单词CompareAndSwap的缩写，中文意思是：比较并替换。CAS 是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了CAS技术。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。\nCAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。\n原子操作在执行过程中，CPU会将内存的总线锁定（目前已优化为禁止访问缓存行），使其他处理器暂时无法通过总线访问内存，从而保证了读-改-写的原子性。\n具体可以参考这篇文章 面试必问的CAS，你懂了吗？ - 知乎 (zhihu.com)\n19.2、Unsafe 类 Unsafe类 主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。\n19.3、使用示例 普通数字 i 或由 volatile 修饰的数字执行自增操作时需要三步：取值、加一、写值。在这三步执行的任何时间都可以被打断插队执行，因此会引发并发问题：如10个线程同时各自执行1000次自增操作，则实际结果会小于10000。而 AtomicInteger 可以解决这个问题，它的计算是原子操作。\n19.4、CAS 中存在的 ABA 问题 CAS 的使用流程通常如下：1）某一时刻从地址 V 读取值 A；2）以原子方式在当前时刻比较A与地址 V 的值，若一致则替换。\nCAS 的原子性是指步骤2是原子操作，会通过禁止访问缓存行实现不被打断。但步骤1和步骤2之间会有一个时间差，可能会引发 ABA 问题。\n如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。\n20、原子引用 原子引用是带版本号的原子操作，相当于 MySQL的乐观锁。\n在下方程序执行后，b 线程的 CAS 操作会失败，因为版本号已改变。\npublic class CASDemo { public static void main(String[] args) { AtomicStampedReference\u003cInteger\u003e atomicReference = new AtomicStampedReference\u003c\u003e(1, 1); int stamp = atomicReference.getStamp(); // 获取版本号 new Thread( () -\u003e { // 该线程模拟 ABA 问题，将当前值由 1 改为 2，再改回 1。 atomicReference.compareAndSet(1, 2, atomicReference.getStamp(), atomicReference.getStamp() + 1); atomicReference.compareAndSet(2, 1, atomicReference.getStamp(), atomicReference.getStamp() + 1); }, \"a\").start(); new Thread( () -\u003e { // 睡两秒，确保线程 a 先执行。 try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } boolean result = atomicReference.compareAndSet(1, 2, stamp, stamp + 1); System.out.println(result); }, \"b\").start(); } } 相关知识点：Integer 缓存机制\nInteger 缓存机制只适用于自动装配，等同于 Integer.valueOf(i);。\n在 Integer 类第一次被使用的时候，会将 -128 ~ 127 的 Integer 对象直接组成数组保存在内存中并一直存在，以后当遇到在这个范围内的值需要自动装配时就会直接使用这个数组中的对象，只有当需要自动装配的值不在这个范围时才会重新在其他地址生成对象。\n因此在上方的代码中，当构造 AtomicStampedReference时若初始值在 -128 ~ 127 的范围时程序成功执行，但当初始值不在该范围时 CAS 操作就会执行失败，因为 CAS 是直接通过 == 判断当前值与期望值是否相等，而超出范围的值都是重新分配地址，自然就会判断失败。但实际使用中通常使用字符串，字符串常量池不存在该问题。\n21、锁 21.1、公平锁、非公平锁 公平锁：不允许插队，所有线程必须先来先执行。\n非公平锁：允许插队，默认都是非公平的、如 synchronzied 和 lock锁。\npublic ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } 21.2、可重入锁 可重入 就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。\n// ReentrantLock 类的源码 final boolean nonfairTryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { if (compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } // 若占用锁的线程就是当前线程，则 state + 1，继续使用。即为可重入锁 else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc \u003c 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; } return false; } 21.3、自旋锁 对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，“自旋\"一词就是因此而得名。\n21.4、死锁 如何排查：\n1、在命令行使用 jps -l来定位所有存活的 java 进程的进程号。\n2、在命令行使用 jstack 进程号查看进程信息。若存在死锁这些信息会反应出来。\n21.5、Synchronized 锁升级 锁升级过程为：无锁状态、偏向锁、轻量级锁状态、重量级锁状态\n无锁状态：没有线程来获取锁时就是无锁状态。\n偏向锁：第一个线程获取锁就会从无锁变为偏向锁，并将对象头中的偏向线程id设置为该线程，线程再次获取锁时会比较当前的threadID与对象头中的threadID是否一致，如果一致则不需要通过CAS来加锁、解锁；如果不一致并且持有锁的线程还需要持续持有锁，则暂停当前线程撤销偏向锁，升级为轻量级锁。如果不再需要持续持有锁则锁对象头设为无锁状态，重新设置偏向锁。\n轻量级锁：如果只有一个线程获取锁就是偏向锁，偏向锁使用过程中又有其他线程竞争锁就会变为轻量级锁。在轻量级锁状态下，线程通过CAS方式来竞争锁。注意：只CAS一次，失败就升级为重量级锁。轻量级锁用于多个线程在不同的时间段获取锁，这时CAS成功，避免阻塞带来的开销。\n重量级锁：进入重量级锁后，在真正阻塞之前，默认进行10次自旋，若自旋获取锁就无需阻塞。目的还是尽量不要陷入阻塞。\n","wordCount":"2357","inLanguage":"en","datePublished":"2021-08-16T17:12:41Z","dateModified":"2021-08-16T17:12:41Z","author":{"@type":"Person","name":"lu"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/java/juc%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"lu","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/categories/ title=categories><span>categories</span></a></li><li><a href=http://localhost:1313/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">JUC 并发编程</h1><div class=post-meta><span title='2021-08-16 17:12:41 +0000 UTC'>2021-08-16</span>&nbsp;·&nbsp;2357 words&nbsp;·&nbsp;lu</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#线程基础知识>线程基础知识</a><ul><li><a href=#概述>概述</a></li><li><a href=#线程实现方法>线程实现方法</a></li><li><a href=#同步实现方法>同步实现方法</a></li><li><a href=#线程状态>线程状态</a></li><li><a href=#线程池>线程池</a></li></ul></li><li><a href=#juc-并发编程>JUC 并发编程</a><ul><li><a href=#1什么是-juc>1、什么是 JUC</a></li><li><a href=#2线程与进程>2、线程与进程</a></li><li><a href=#3虚假唤醒问题>3、虚假唤醒问题</a></li><li><a href=#4lock-锁重点>4、Lock 锁（重点）</a></li><li><a href=#58-锁问题>5、8 锁问题</a></li><li><a href=#6集合类不安全面试高频>6、集合类不安全【面试高频】</a></li><li><a href=#7callable>7、Callable</a></li><li><a href=#8常用辅助类必会>8、常用辅助类【必会】</a></li><li><a href=#9读写锁readwritelock>9、读写锁（ReadWriteLock）</a></li><li><a href=#10阻塞队列blockingqueue>10、阻塞队列（BlockingQueue）</a></li><li><a href=#11线程池重点>11、线程池【重点】</a></li><li><a href=#12四大函数式接口必须掌握>12、四大函数式接口【必须掌握】</a></li><li><a href=#13stream-流式计算>13、Stream 流式计算</a></li><li><a href=#14forkjoin>14、ForkJoin</a></li><li><a href=#15异步回调>15、异步回调</a></li><li><a href=#16jmm>16、JMM</a></li><li><a href=#17volatile>17、volatile</a></li><li><a href=#18单例模式>18、单例模式</a></li><li><a href=#19深入理解-cas>19、深入理解 CAS</a></li><li><a href=#20原子引用>20、原子引用</a></li><li><a href=#21锁>21、锁</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=线程基础知识>线程基础知识<a hidden class=anchor aria-hidden=true href=#线程基础知识>#</a></h2><h3 id=概述>概述<a hidden class=anchor aria-hidden=true href=#概述>#</a></h3><p>每个线程拥有一个自己独立的栈，但是共享进程的堆空间。</p><p>Thread 中的 run 方法是一个回调函数，与普通函数没什么区别，所以以如下方式调用run时，就是一个普通的方法执行。而 start 方法会在本地创建一个线程，然后在本地代码中通过 jvm 回调 run 方法来执行任务。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Thread thread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {...});
</span></span><span style=display:flex><span>thread.<span style=color:#a6e22e>run</span>();
</span></span></code></pre></div><h3 id=线程实现方法>线程实现方法<a hidden class=anchor aria-hidden=true href=#线程实现方法>#</a></h3><p>Thread类是描述线程的类，要实现多线程，必须继承Thread类</p><h5 id=方法一创建thread类的子类>方法一、创建Thread类的子类<a hidden class=anchor aria-hidden=true href=#方法一创建thread类的子类>#</a></h5><p>1、创建Thread类的子类，并重写run方法，其中设置线程的任务</p><p>2、创建子类对象，并执行start方法</p><p>​ （执行start方法会创建一个新的栈空间，并在该栈空间中执行run方法。每执行一次步骤2，就开启一个新的线程）</p><h5 id=方法二实现runnable接口>方法二、实现Runnable接口<a hidden class=anchor aria-hidden=true href=#方法二实现runnable接口>#</a></h5><p><strong>推荐使用这种</strong> &mdash;> 使用该方法时，Thread 类是咱们自定义类的静态代理类</p><p>1、创建一个Runnable接口的实现类，并重写run方法，其中设置线程的任务</p><p>2、创建对象，并将其作为参数传递给Thread类的构造方法，再调用start方法。</p><p>​ new Thread(new MyRunnable()).start();
​ 匿名内部类实现： new Thread(new Runnable(){重写run方法}).start();</p><h5 id=方法三实现callablev接口>方法三、实现Callable<v>接口<a hidden class=anchor aria-hidden=true href=#方法三实现callablev接口>#</a></h5><p><strong>Callable接口类似于Runnable，但Runnable不会返回结果，也不会抛出检查异常，Callable可以</strong>，Runnable 效率比 Callable 低。</p><p>1、创建一个Callable<v>接口的实现类，并重写call方法，其中设置线程的任务
2、在使用的地方创建该类对象 obj 。
3、ExecutorService executorService = Executors.newFixedThreadPool(5); // 创建执行服务
4、Future<v> future = executorService.submit(obj); // 提交执行
5、V result = future.get(); // 获取结果
6、executorService.shutdownNow(); // 关闭服务</p><hr><h3 id=同步实现方法>同步实现方法<a hidden class=anchor aria-hidden=true href=#同步实现方法>#</a></h3><p>多个对象访问同一个资源，可以并发读取，但当其中某一个对象要修改时，就必须实现同步</p><p>锁对象选取总结为一句话就是 在同步代码中要改变谁就锁谁。</p><h5 id=方法一-同步代码块>方法一： 同步代码块<a hidden class=anchor aria-hidden=true href=#方法一-同步代码块>#</a></h5><p>synchronized (锁对象) {访问共享数据的代码} 线程不仅要抢夺CUP，还要占用锁对象。同时拥有才能执行代码
锁对象可以是任意对象，但必须是同一个对象，推荐将共享资源作为锁对象。线程占用锁对象后直到执行完毕才释放。</p><h5 id=方法二-同步方法>方法二： 同步方法<a hidden class=anchor aria-hidden=true href=#方法二-同步方法>#</a></h5><p>修饰符 synchronized 返回值类型 方法名 (参数列表) {访问共享数据的代码} // 该方法即为同步方法
首先将 访问共享数据的代码块 抽取出来，作为上述方法。
同步方法的锁对象默认为 this ，即调用该同步方法的对象；创建该类的对象后，该对象调用同步方法时就会锁住对象自己。
当同步方法同时也是静态方法时，锁对象为同步方法所在类的 Class 对象。</p><p>因此普通同步方法，每个对象都有一把锁；静态同步方法，所有对象共用一把锁。对同一个对象而言，这是两把不同的锁，一个锁是自己、一个锁是 Class 类模板。</p><h5 id=方法三-lock锁>方法三： Lock锁<a hidden class=anchor aria-hidden=true href=#方法三-lock锁>#</a></h5><p>Lock是一个接口，有两个方法 void lock() 获取锁 和 void unlock() 释放锁
它有一个实现类ReentrantLock（可重入锁）， 先实例化一个ReentrantLock对象。
在出现安全问题代码之前用该对象调用 lock() 方法。在出现安全问题代码之后用该对象调用 unlock() 方法。
lock() 和 unlock() 方法建议放在 try &mdash; finally 代码块中</p><h5 id=synchronized-底层原理>synchronized 底层原理<a hidden class=anchor aria-hidden=true href=#synchronized-底层原理>#</a></h5><p>使用时需要关联一个对象，而这个对象就是 monitor object。</p><p>管程（monitor）机制中，monitor object 充当着维护 mutex 以及定义 wait/signal API 来管理线程的阻塞和唤醒的角色。</p><p>Java 语言中的 java.lang.Object 类，便是满足这个要求的对象，任何一个 Java 对象都可以作为 monitor 机制的 monitor object。</p><p>java 对象的内存布局中，每个对象的对象头都保存了锁标识。</p><p>要进入一个 synchronized 方法修饰的方法或者代码块，会先获取与 synchronized 关键字绑定在一起的 Object 的对象锁，这个锁也限定了其它线程无法进入与这个锁相关的其它 synchronized 代码区域。</p><p>当一个线程需要获取与 synchronized 关联的 Object 的锁时，会被放入 EntrySet 中进行等待，如果该线程获取到了锁，就成为当前锁的 owner，此时 monitor + 1，当前线程可以使用该临界资源，而在该线程持有锁的期间，该线程还可以再次进入临界区，此时 monitor 再次加 1 （这就是可重入锁），同样、线程每次退出临界区 monitor 都会减 1，当 monitor 减为 0 时，代表当前线程放弃对对象锁的拥有权。如果获取到锁的线程不是因使用完放弃，而是由于缺少外部条件时就会调用 wait 方法将锁释放，进入 wait set 中阻塞进行等待。</p><p>底层使用指令码方式来控制锁的，映射成字节码指令就是两个指令：monitorenter和monitorexit。当线程执行遇到monitorenter指令时会尝试获取内置锁，如果获取锁则锁计数器+1，如果没有获取锁则阻塞；当遇到monitorexit指令时锁计数器-1，如果计数器为0则释放锁。</p><p>JVM 在执行方法之前，如果发现该方法前面有 synchronized 关键字，就先在该对象的 ID 上加锁，当其他线程执行到这个方法时，会检测该对象ID上是否加锁，如果加锁时就等待锁释放。</p><p>如果一个对象中有两个方法同时被 synchronized 修饰，则同一个对象，调用这两个方法时，只能同时执行一个。</p><hr><h3 id=线程状态>线程状态<a hidden class=anchor aria-hidden=true href=#线程状态>#</a></h3><p>创建、就绪、运行、阻塞、死亡。</p><h5 id=java线程状态>java线程状态<a hidden class=anchor aria-hidden=true href=#java线程状态>#</a></h5><ul><li><strong>NEW</strong>：创建线程实例，但还没有用 start()方法启动</li><li><strong>RUNNABLE</strong>：线程启动之后，就绪和运行状态都属于<code>RUNNABLE</code>状态</li><li><strong>BLOCKED</strong>：竞争<code>synchronize</code> 锁失败，java中只有这一种进入<code>BLOCKED</code>的方式，<code>Lock</code>进入的是<code>WAITING</code>状态</li><li><strong>WAITING</strong>：通过<code>join</code>、<code>wait</code>、<code>lock</code>等方法进入次状态</li><li><strong>TIMED_WAITING</strong>：通过<code>sleep</code>、<code>wait(time)</code>等方法进入此状态</li><li><strong>TERMINATED</strong>：结束退出</li></ul><h5 id=线程停止>线程停止<a hidden class=anchor aria-hidden=true href=#线程停止>#</a></h5><p>不推荐使用 Thread 类提供的 stop() 等方法。推荐自己设置一个标志位，通过调用自己实现的 stop 方法来停止线程。如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyRunnable</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> flag <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (flag) {
</span></span><span style=display:flex><span>            TODO...
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>stop</span>() { flag <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>; }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>下方所有方法都是 Thread 类中的方法！</p><h5 id=线程休眠>线程休眠<a hidden class=anchor aria-hidden=true href=#线程休眠>#</a></h5><p>Thread.sleep(毫秒)</p><p>sleep 不会释放锁、 wait 会释放锁。两者都释放 CPU</p><p>JUC 编程中常使用 <code>TimeUnit.SECONDS.sleep(2);</code> 进行休眠</p><h5 id=线程礼让>线程礼让<a hidden class=anchor aria-hidden=true href=#线程礼让>#</a></h5><p>Thread.yield();</p><p>使当前线程从运行状态变为就绪状态，让 cpu 从所有就绪的线程中挑一个运行。
礼让有可能不成功，因为 cpu 可能再挑选一次还是让当前线程继续执行。</p><h5 id=线程强制执行>线程强制执行<a hidden class=anchor aria-hidden=true href=#线程强制执行>#</a></h5><p>join()</p><p>相当于插队，停止现在执行的线程，立刻执行自己的线程，且本线程执行结束才能执行其他线程</p><p>在下方举例代码中，主线程执行到200之前，主线程和Runnable线程交替执行，当主线程执行到200次时，Runnable 线程插队接着执行，之后Runnable线程全部执行完毕后才由主线程继续执行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyRunnable</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 1000; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Runnable &#34;</span> <span style=color:#f92672>+</span> i);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        MyRunnable myRunnable <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyRunnable();
</span></span><span style=display:flex><span>        Thread thread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(myRunnable);
</span></span><span style=display:flex><span>        thread.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 500; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>==</span> 200) {
</span></span><span style=display:flex><span>                thread.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;主线程&#34;</span> <span style=color:#f92672>+</span> i);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=查看线程状态>查看线程状态<a hidden class=anchor aria-hidden=true href=#查看线程状态>#</a></h5><p>Thread.State state = thread.getState();</p><p>Thread.State 是一个枚举类型，枚举类中包含的就是上方java的6个状态</p><h5 id=线程优先级>线程优先级<a hidden class=anchor aria-hidden=true href=#线程优先级>#</a></h5><p>1 最小；10 最大；默认为5。优先级越高在就绪状态很大可能越早执行，但也不是一定。</p><h5 id=守护daemon线程>守护（daemon）线程<a hidden class=anchor aria-hidden=true href=#守护daemon线程>#</a></h5><p>线程分为用户线程和守护线程。
虚拟机必须保证用户线程执行完毕，但不用等待守护线程执行完毕。
守护线程有：后台记录日志、监控内存、垃圾回收等</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> daemon <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;    <span style=color:#75715e>// 该句为 Thread 类的源码，默认 daemon 属性是关闭的，即默认为用户线程</span>
</span></span><span style=display:flex><span>thread.<span style=color:#a6e22e>setDaemon</span>(<span style=color:#66d9ef>true</span>);            <span style=color:#75715e>// 可通过这样将线程设置为 守护线程。</span>
</span></span></code></pre></div><p>将线程设置为守护线程之后，虚拟机将不再保证该线程是否执行结束，
即只要当用户线程执行结束后就将整个程序关闭，而不考虑守护线程此时是否已经执行完毕。</p><hr><h3 id=线程池>线程池<a hidden class=anchor aria-hidden=true href=#线程池>#</a></h3><h5 id=底层原理>底层原理<a hidden class=anchor aria-hidden=true href=#底层原理>#</a></h5><p>线程池就是一个容纳多个线程的容器，可由集合实现</p><h5 id=使用步骤>使用步骤<a hidden class=anchor aria-hidden=true href=#使用步骤>#</a></h5><p>1、使用线程池工厂类Executors里面的静态方法newFixedThreadPool生产一个指定线程数量的线程池，由ExecutorService接口接收。
2、创建Runnable接口的实现类，重写run方法，设置线程任务。
3、调用ExecutorService中的execute方法，传递线程任务，开启线程，执行run方法。</p><p>举例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ExecutorService executorService <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newFixedThreadPool</span>(5);  <span style=color:#75715e>// 创建服务</span>
</span></span><span style=display:flex><span>Runnable runnable <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Runnable() {  <span style=color:#75715e>//此处虽然new 的是Runnable接口，但是立即重写了run方法，故相当于其实现类。</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//线程任务</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>executorService.<span style=color:#a6e22e>execute</span>(runnable);                                  <span style=color:#75715e>// 执行服务</span>
</span></span><span style=display:flex><span>executorService.<span style=color:#a6e22e>shutdownNow</span>();                                      <span style=color:#75715e>// 关闭服务</span>
</span></span></code></pre></div><h5 id=submit方法和-execute方法>submit()方法和 execute()方法<a hidden class=anchor aria-hidden=true href=#submit方法和-execute方法>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ExecutorService 中的 <span style=color:#a6e22e>submit</span>()方法和 <span style=color:#a6e22e>execute</span>()方法作用相同<span style=color:#960050;background-color:#1e0010>，</span>只是适用于不同场景
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>execute</span>(Runnable command)           <span style=color:#75715e>// 执行任务，没有返回值，一般用于执行 Runnable</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Future<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>submit</span>(Callable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> task);  <span style=color:#75715e>// 执行任务，有返回值，一般用于执行 Callable</span>
</span></span></code></pre></div><hr><hr><hr><h2 id=juc-并发编程>JUC 并发编程<a hidden class=anchor aria-hidden=true href=#juc-并发编程>#</a></h2><h3 id=1什么是-juc>1、什么是 JUC<a hidden class=anchor aria-hidden=true href=#1什么是-juc>#</a></h3><p>JUC 即与并发相关的三个包：<code>java.util.concurrent</code>、 <code>java.util.concurrent.atomic</code> 、 <code>java.util.concurrent.locks</code>。</p><hr><h3 id=2线程与进程>2、线程与进程<a hidden class=anchor aria-hidden=true href=#2线程与进程>#</a></h3><p>一个 java 进程默认包含 2 个线程：main 线程与 GC 线程。</p><p>java 本身并不能开启线程，是通过调用本地方法（C++）实现的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 获取本机 CPU 的核数，其实是逻辑处理器的个数</span>
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Runtime.<span style=color:#a6e22e>getRuntime</span>().<span style=color:#a6e22e>availableProcessors</span>());
</span></span></code></pre></div><p>并行编程：利用线程池</p><p>并发编程的本质：充分利用 CPU 的资源。</p><p>并发：多个线程操作同一个资源类</p><hr><h3 id=3虚假唤醒问题>3、虚假唤醒问题<a hidden class=anchor aria-hidden=true href=#3虚假唤醒问题>#</a></h3><p>在如下代码中，当条件不满足时，进入等待；当其他线程执行 notifyAll() 时，该线程被唤醒去执行业务逻辑。</p><p>但是有可能该线程被唤醒后仍然不满足条件，却没有加以判断就直接执行后续代码，这就是虚假唤醒。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ( <span style=color:#e6db74>&#34;条件不满足&#34;</span> ) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>wait</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 业务逻辑</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>为了避免虚假唤醒问题，所有的 wait() 都应该出现在 while 循环中，原因如下：</p><p>用 if 判断流水线状态为空时，线程被阻塞，这时 if 判断就完成了，线程被唤醒后直接执行线程剩余操作；</p><p>用 while 判断流水线状态为空时，线程被阻塞，这时 while 判断没有完成，线程被唤醒后需先进行 while 判断。</p><hr><h3 id=4lock-锁重点>4、Lock 锁（重点）<a hidden class=anchor aria-hidden=true href=#4lock-锁重点>#</a></h3><p><a href=https://zhuanlan.zhihu.com/p/333969353>并发工具（锁）：深入Lock+Condition - 知乎 (zhihu.com)</a></p><p><code>Lock</code> 和 <code>synchronized</code>都是基于管程模型设计的。</p><h4 id=41synchronized-与-lock-的区别>4.1、Synchronized 与 Lock 的区别<a hidden class=anchor aria-hidden=true href=#41synchronized-与-lock-的区别>#</a></h4><p>存在层次上： synchronized 是 Java 的关键字，在jvm层面上； Lock: 是一个接口</p><p>锁的释放： synchronized: 自动释放； Lock: 在finally中必须释放锁，不然容易造成线程死锁</p><p>锁的获取： synchronized: 假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待</p><p>​ Lock: 分情况而定，Lock有多个锁获取的方式，可以通过 tryLock() 尝试获得锁，线程可以不用一直等待</p><p>锁的状态： synchronized: 无法判断 ； Lock: 可以判断</p><p>锁的类型： synchronized: 可重入 不可中断 非公平； Lock: 可重入 可中断 可公平（两者皆可）</p><p>性能： synchronized: 少量同步； Lock: 大量同步</p><p>调度： synchronized: 使用Object对象本身的wait 、notify、notifyAll调度机制； Lock: 可以使用Condition进行线程之间的调度</p><p>排队队列：synchronized 不论是竞争锁失败还是条件不满足都只有一个排队队列。Lock 可以和 Condition 搭配根据不同条件创建不同排队队列。</p><p>公平：synchronized 为非公平锁。Lock 可以自己设置公平或非公平。</p><h4 id=42juc-代替传统线程通信>4.2、JUC 代替传统线程通信<a hidden class=anchor aria-hidden=true href=#42juc-代替传统线程通信>#</a></h4><table><thead><tr><th style=text-align:center></th><th style=text-align:center>阻塞</th><th style=text-align:center>通知</th></tr></thead><tbody><tr><td style=text-align:center>Synchronized</td><td style=text-align:center>wait</td><td style=text-align:center>notify</td></tr><tr><td style=text-align:center>Lock</td><td style=text-align:center>await</td><td style=text-align:center>signal</td></tr></tbody></table><p><strong>Condition 介绍</strong></p><ul><li><code>Lock</code>替换<code>synchronized</code>方法和语句的使用， <code>Condition</code>取代了对象监视器方法的使用。</li><li><code>Condition</code>接口为一个线程暂停执行（“等待”）提供了一种方法，直到另一个线程通知某些状态现在可能为真。</li><li>一个<code>Condition</code>实例本质上绑定到一个锁。</li><li><code>await()</code> ：阻塞自己、<code>signal()</code> ：唤醒自己、<code>signalAll()</code>：唤醒所有线程</li></ul><p><strong>替换</strong></p><ul><li>将 <code>synchronized</code>变为被<code>lock.lock()</code> 和 <code>lock.unlock()</code>包围；</li><li><code>this.wait()</code> &ndash;> <code>condition.await()</code>；</li><li><code>this.notify()</code> &ndash;> <code>condition.signal()</code>。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Javadoc 示例</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BoundedBuffer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> Lock lock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReentrantLock();              <span style=color:#75715e>// 新建 Lock</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> Condition notFull  <span style=color:#f92672>=</span> lock.<span style=color:#a6e22e>newCondition</span>();     <span style=color:#75715e>// 通过 Lock 生成 Condition</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> Condition notEmpty <span style=color:#f92672>=</span> lock.<span style=color:#a6e22e>newCondition</span>();     <span style=color:#75715e>// 一个 Condition 对应一个阻塞队列</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> Object<span style=color:#f92672>[]</span> items <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[</span>100<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> putptr, takeptr, count;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// put 和 take 方法使用的同一把锁，同时只能进入一个方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>put</span>(Object x) <span style=color:#66d9ef>throws</span> InterruptedException {    
</span></span><span style=display:flex><span>        lock.<span style=color:#a6e22e>lock</span>(); 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (count <span style=color:#f92672>==</span> items.<span style=color:#a6e22e>length</span>)
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 当消费者线程1执行到这条语句时，就会将消费者线程1移到 notFull 条件的阻塞队列等待</span>
</span></span><span style=display:flex><span>                notFull.<span style=color:#a6e22e>await</span>();     
</span></span><span style=display:flex><span>            items<span style=color:#f92672>[</span>putptr<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>++</span>putptr <span style=color:#f92672>==</span> items.<span style=color:#a6e22e>length</span>) putptr <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>            <span style=color:#f92672>++</span>count;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 唤醒 notEmpty 条件的阻塞队列中的第一个线程</span>
</span></span><span style=display:flex><span>            notEmpty.<span style=color:#a6e22e>signal</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> { lock.<span style=color:#a6e22e>unlock</span>(); }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>take</span>() <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        lock.<span style=color:#a6e22e>lock</span>(); 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (count <span style=color:#f92672>==</span> 0)
</span></span><span style=display:flex><span>                notEmpty.<span style=color:#a6e22e>await</span>();     <span style=color:#75715e>// 将当前线程阻塞到 notEmpty 条件的阻塞队列</span>
</span></span><span style=display:flex><span>            Object x <span style=color:#f92672>=</span> items<span style=color:#f92672>[</span>takeptr<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>++</span>takeptr <span style=color:#f92672>==</span> items.<span style=color:#a6e22e>length</span>) takeptr <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>            <span style=color:#f92672>--</span>count;
</span></span><span style=display:flex><span>            notFull.<span style=color:#a6e22e>signal</span>();         <span style=color:#75715e>// 唤醒 notFull 条件的阻塞队列中的第一个线程</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> x;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> { lock.<span style=color:#a6e22e>unlock</span>(); }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Condition 可以精准唤醒指定的线程</strong></p><p>由于每个 Condition 对应一个阻塞队列，可以为每个线程增加一个判断条件，即每个线程都只能固定阻塞在某个条件的阻塞队列中，这样就可以根据条件精准地唤醒对应线程了。</p><hr><h3 id=58-锁问题>5、8 锁问题<a hidden class=anchor aria-hidden=true href=#58-锁问题>#</a></h3><p>同步方法的锁对象默认为 this ，即调用该同步方法的对象；创建该类的对象后，该对象调用同步方法时就会锁住对象自己。
当同步方法同时也是静态方法时，锁对象为同步方法所在类的 Class 对象。</p><p>因此普通同步方法，每个对象都有一把锁；静态同步方法，所有对象共用一把锁。对同一个对象而言，这是两把不同的锁，一个锁是自己、一个锁是 Class 类模板。</p><hr><h3 id=6集合类不安全面试高频>6、集合类不安全【面试高频】<a hidden class=anchor aria-hidden=true href=#6集合类不安全面试高频>#</a></h3><h4 id=61list-不安全>6.1、List 不安全<a hidden class=anchor aria-hidden=true href=#61list-不安全>#</a></h4><p>平时使用的如下代码，都是单线程，是绝对安全的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> list <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 10; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    list.<span style=color:#a6e22e>add</span>(UUID.<span style=color:#a6e22e>randomUUID</span>().<span style=color:#a6e22e>toString</span>().<span style=color:#a6e22e>substring</span>(0, 5));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>但当涉及多线程时就会出现问题</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> list <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 100; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> Thread( () <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>        list.<span style=color:#a6e22e>add</span>(UUID.<span style=color:#a6e22e>randomUUID</span>().<span style=color:#a6e22e>toString</span>().<span style=color:#a6e22e>substring</span>(0, 5));
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(list);  <span style=color:#75715e>// list.toString() 方法使用的迭代器，触发了快速失败，因此报错。</span>
</span></span><span style=display:flex><span>    }, String.<span style=color:#a6e22e>valueOf</span>(i)).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 报错 java.util.ConcurrentModificationException  --》 并发修改异常</span>
</span></span></code></pre></div><p><strong>解决方案</strong></p><p>1、使用 Vector&lt;>() 。【不推荐】看源码可知 Vector 的涉及并发的所有方法都被 synchronized 修饰。但其效率太低，已被淘汰。 <strong>此处有疑问：synchronized 在 jdk1.6 优化之后，Vector 为什么还不能使用？</strong></p><p>2、<code>List&lt;String> list = Collections.synchronizedList(new ArrayList&lt;>());</code> 使用<code>Collections</code>将其转换为安全 List 。</p><p>3、<code>List&lt;String> list = new CopyOnWriteArrayList&lt;>();</code> 使用 JUC 提供的安全 List 。【推荐】</p><ul><li><code>CopyOnWrite</code> 为 “写入时复制”，是计算机程序设计领域的一种优化策略。</li><li>在写之前复制一份，在复制的 list 上写，写完再将其赋值给原来的list。</li><li><code>CopyOnWriteArrayList</code> 比 <code>Vector</code> 高效。 <strong>高效吗？高效在哪里？</strong></li></ul><h4 id=62set-不安全>6.2、Set 不安全<a hidden class=anchor aria-hidden=true href=#62set-不安全>#</a></h4><p>Set 与 List 遇到的不安全问题完全相同。</p><p><strong>解决方案</strong></p><p>1、<code>Set&lt;String> set = Collections.synchronizedSet(new HashSet&lt;>());</code> 使用<code>Collections</code>将其转换为安全 Set 。</p><p>2、<code>Set&lt;String> set = new CopyOnWriteArraySet&lt;>();</code> 使用 JUC 提供的安全 Set 。【推荐】</p><h4 id=63map-不安全>6.3、Map 不安全<a hidden class=anchor aria-hidden=true href=#63map-不安全>#</a></h4><p>Map 与 Set 、List 遇到的不安全问题完全相同。</p><p>1、<code>Map&lt;Integer, String> map = Collections.synchronizedMap(new HashMap&lt;>());</code></p><p>2、<code>Map&lt;Integer, String> map = new ConcurrentHashMap&lt;>();</code> 使用 JUC 提供的安全 Map 。【推荐】</p><ul><li>有时间看 ConcurrentHashMap 的原理</li></ul><hr><h3 id=7callable>7、Callable<a hidden class=anchor aria-hidden=true href=#7callable>#</a></h3><p><strong>普通线程实现方法</strong> &mdash;》 通过 Runnable 的实现类 FutureTask 作为桥梁，将 Callable 提交给 Thread 执行。</p><ul><li>同一个 FutureTask 任务只能执行一次 （无论将其交由几个线程执行）。因为其内部有一个 state ，只有 state 为 NEW 时才能开始执行，任意一个线程开始执行之后，state 就会被改变。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CallableTest</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> ExecutionException, InterruptedException {
</span></span><span style=display:flex><span>        MyThread myThread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyThread();
</span></span><span style=display:flex><span>        FutureTask<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> task <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FutureTask<span style=color:#f92672>&lt;&gt;</span>(myThread);  <span style=color:#75715e>// 适配类，Runnable 的实现类</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(task, <span style=color:#e6db74>&#34;name&#34;</span>).<span style=color:#a6e22e>start</span>();                       <span style=color:#75715e>// 执行</span>
</span></span><span style=display:flex><span>        Integer ans <span style=color:#f92672>=</span> task.<span style=color:#a6e22e>get</span>();        <span style=color:#75715e>// 获取结果，计算完成之前，get 方法会被阻塞</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(ans);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyThread</span> <span style=color:#66d9ef>implements</span> Callable<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Integer <span style=color:#a6e22e>call</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> 1024;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>线程池实现方法</strong>。搭配线程基础知识的线程实现方法的方法三看。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CallableTest</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> ExecutionException, InterruptedException {
</span></span><span style=display:flex><span>        MyThread myThread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyThread();
</span></span><span style=display:flex><span>        ExecutorService executorService <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newFixedThreadPool</span>(5);
</span></span><span style=display:flex><span>        Future<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> future <span style=color:#f92672>=</span> executorService.<span style=color:#a6e22e>submit</span>(myThread);
</span></span><span style=display:flex><span>        Integer ans <span style=color:#f92672>=</span> future.<span style=color:#a6e22e>get</span>();   <span style=color:#75715e>// 执行计算较耗时，应放在最后或者通过异步方式处理。</span>
</span></span><span style=display:flex><span>        executorService.<span style=color:#a6e22e>shutdownNow</span>();
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(ans);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyThread</span> <span style=color:#66d9ef>implements</span> Callable<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Integer <span style=color:#a6e22e>call</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> 1024;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=8常用辅助类必会>8、常用辅助类【必会】<a hidden class=anchor aria-hidden=true href=#8常用辅助类必会>#</a></h3><h4 id=81countdownlatch>8.1、CountDownLatch<a hidden class=anchor aria-hidden=true href=#81countdownlatch>#</a></h4><p>减法计数器</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 计数器</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CountDownLatchDemo</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 计数器总数是6</span>
</span></span><span style=display:flex><span>        CountDownLatch latch <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CountDownLatch(6);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 6; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Thread( () <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; done!&#34;</span>);
</span></span><span style=display:flex><span>                latch.<span style=color:#a6e22e>countDown</span>();    <span style=color:#75715e>// 计数器减一</span>
</span></span><span style=display:flex><span>            }, String.<span style=color:#a6e22e>valueOf</span>(i)).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        latch.<span style=color:#a6e22e>await</span>();                <span style=color:#75715e>// 在计数器减为 0 之前，将所有的线程阻塞在此处</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;to do next step!&#34;</span>);  <span style=color:#75715e>// 计数器为 0 ，所有线程执行后续操作。</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=82cyclicbarrier>8.2、CyclicBarrier<a hidden class=anchor aria-hidden=true href=#82cyclicbarrier>#</a></h4><p>循环阻塞，相当于加法计数器</p><p>CyclicBarrier 构造时会指定参与的线程数量，通过<code>barrier.await();</code>生成屏障点，将线程阻塞在该屏障点，直到所有参与的线程都到达这个屏障点，然后统一释放。释放之后，该 CyclicBarrier 对象还可以继续使用，即再次从 0 开始计数直到足够数量的线程到达屏障点，再释放&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CyclicBarrierDemo</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 指定共有 7 个参与方（线程），以及触发屏障之后的操作，该操作由进入屏障的最后一个线程执行。</span>
</span></span><span style=display:flex><span>        CyclicBarrier barrier <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CyclicBarrier(7, () <span style=color:#f92672>-&gt;</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;召唤神龙成功！&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 7; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> finalI <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Thread( () <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// lambda 表达式中使用的变量应该是 final 或有效 final</span>
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;收集了第&#34;</span> <span style=color:#f92672>+</span> finalI <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;颗龙珠&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    barrier.<span style=color:#a6e22e>await</span>();   <span style=color:#75715e>// 屏障点。阻塞当前线程，直到所有的参与方都到达这个屏障点</span>
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (InterruptedException <span style=color:#f92672>|</span> BrokenBarrierException e) {
</span></span><span style=display:flex><span>                    e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=83semaphore>8.3、Semaphore<a hidden class=anchor aria-hidden=true href=#83semaphore>#</a></h4><p>信号量，和操作系统信号量一样，P 一下减 1，V 一下加 1。会限制最大并发数量。</p><p>变为方法调用，即 P &ndash;> acquire()， V &ndash;> release() 。</p><p>作用：</p><ul><li>多个线程互斥共享有限资源</li><li>限流，限制最大并发数量。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SemaphoreDemo</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 最多同时执行的线程数量，其实应该是资源数量</span>
</span></span><span style=display:flex><span>        Semaphore semaphore <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Semaphore(3);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 6; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Thread( () <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    semaphore.<span style=color:#a6e22e>acquire</span>();
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;抢到车位&#34;</span>);
</span></span><span style=display:flex><span>                    TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(2);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                    e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                    semaphore.<span style=color:#a6e22e>release</span>();
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;离开车位&#34;</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=9读写锁readwritelock>9、读写锁（ReadWriteLock）<a hidden class=anchor aria-hidden=true href=#9读写锁readwritelock>#</a></h3><p>解决读者写者问题。</p><p>写锁（独占锁、排他锁） 一次只能被一个线程占有</p><p>读锁（共享锁） 多个线程可以同时占有</p><ul><li>读-读 可以共存</li><li>读-写 不能共存</li><li>写-写 不能共存</li></ul><p>用法和 Lock 完全一样，在写的地方用写锁，读的地方用读锁。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 该代码示例很不恰当，会出现先读后写的问题。只用来展示 ReadWriteLock 怎么使用。</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ReadWriteLockDemo</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        MyCache myCache <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyCache();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 5; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> finalI <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Thread( () <span style=color:#f92672>-&gt;</span> myCache.<span style=color:#a6e22e>put</span>(finalI <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;&#34;</span>, finalI <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;&#34;</span>)).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 5; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> finalI <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> Thread( () <span style=color:#f92672>-&gt;</span> myCache.<span style=color:#a6e22e>get</span>(finalI <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;&#34;</span>)).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyCache</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> Map<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span> map <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 读写锁</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> ReadWriteLock readWriteLock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReentrantReadWriteLock();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>put</span>(String key, Object value) {
</span></span><span style=display:flex><span>        readWriteLock.<span style=color:#a6e22e>writeLock</span>().<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; write &#34;</span> <span style=color:#f92672>+</span> key);
</span></span><span style=display:flex><span>            map.<span style=color:#a6e22e>put</span>(key, value);
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; write done&#34;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>            readWriteLock.<span style=color:#a6e22e>writeLock</span>().<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>get</span>(String key) {
</span></span><span style=display:flex><span>        readWriteLock.<span style=color:#a6e22e>readLock</span>().<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; read &#34;</span> <span style=color:#f92672>+</span> key);
</span></span><span style=display:flex><span>            Object value <span style=color:#f92672>=</span> map.<span style=color:#a6e22e>get</span>(key);
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; result &#34;</span> <span style=color:#f92672>+</span> value);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>            readWriteLock.<span style=color:#a6e22e>readLock</span>().<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=10阻塞队列blockingqueue>10、阻塞队列（BlockingQueue）<a hidden class=anchor aria-hidden=true href=#10阻塞队列blockingqueue>#</a></h3><p><code>BlockingQueue&lt;E> extends Queue&lt;E></code> <code>Queue&lt;E> extends Collection&lt;E></code></p><p>使用场景： 多线程并发处理、线程池</p><p><strong>四组 API</strong></p><table><thead><tr><th></th><th>失败抛异常</th><th>失败返回特殊值</th><th><strong>持续阻塞</strong></th><th><strong>限时阻塞</strong></th></tr></thead><tbody><tr><td><strong>添加</strong></td><td><a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#add-E-><code>add(e)</code></a></td><td><a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#offer-E-><code>offer(e)</code></a></td><td><a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#put-E-><code>put(e)</code></a></td><td><a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#offer-E-long-java.util.concurrent.TimeUnit-><code>offer(e, time, unit)</code></a></td></tr><tr><td><strong>移除</strong></td><td><a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#remove-java.lang.Object-><code>remove()</code></a></td><td><a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#poll-long-java.util.concurrent.TimeUnit-><code>poll()</code></a></td><td><a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#take--><code>take()</code></a></td><td><a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#poll-long-java.util.concurrent.TimeUnit-><code>poll(time, unit)</code></a></td></tr><tr><td><strong>查看首元素</strong></td><td><a href=https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html#element--><code>element()</code></a></td><td><a href=https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html#peek--><code>peek()</code></a></td><td>无</td><td>无</td></tr></tbody></table><p><strong>SynchronousQueue</strong> 同步队列 <code>SynchronousQueue&lt;E> implements BlockingQueue&lt;E></code></p><p>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。</p><p>*<em><strong>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒。*</strong></em></p><p>put(e) take()</p><hr><h3 id=11线程池重点>11、线程池【重点】<a hidden class=anchor aria-hidden=true href=#11线程池重点>#</a></h3><p><strong>作用</strong>：线程复用、控制最大并发数、线程管理</p><p><strong>内容</strong>：三大方法、七大参数、四种拒绝策略</p><h4 id=111三大方法>11.1、三大方法<a hidden class=anchor aria-hidden=true href=#111三大方法>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Executors.<span style=color:#a6e22e>newSingleThreadExecutor</span>();          <span style=color:#75715e>//  单个线程的线程池</span>
</span></span><span style=display:flex><span>Executors.<span style=color:#a6e22e>newFixedThreadPool</span>(5);              <span style=color:#75715e>//  固定个数线程的线程池</span>
</span></span><span style=display:flex><span>Executors.<span style=color:#a6e22e>newCachedThreadPool</span>();              <span style=color:#75715e>//  可伸缩大小的线程池</span>
</span></span></code></pre></div><p>示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>    ExecutorService threadPool <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newFixedThreadPool</span>(5);<span style=color:#75715e>//  固定个数线程的线程池</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 10; i<span style=color:#f92672>++</span>) {   <span style=color:#75715e>// Runnable 接口的 lambda 表达式</span>
</span></span><span style=display:flex><span>            threadPool.<span style=color:#a6e22e>execute</span>( () <span style=color:#f92672>-&gt;</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;is executing now.&#34;</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        threadPool.<span style=color:#a6e22e>shutdown</span>();           <span style=color:#75715e>// 关闭线程池</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=112七大参数>11.2、七大参数<a hidden class=anchor aria-hidden=true href=#112七大参数>#</a></h4><p>阿里开发手册规定，不得使用 <code>Executors</code> 创建线程池，应该使用 <code>ThreadPoolExecutor</code>。</p><p>进入上节三大方法内部，发现都是调用 <code>ThreadPoolExecutor</code>方法生成的线程池。该方法调用的构造方法有 7 个参数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>ThreadPoolExecutor</span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>int</span> corePoolSize,           <span style=color:#75715e>// 核心线程池大小，即该线程池中不论任何时候都最少存在的线程数量</span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>int</span> maximumPoolSize,        <span style=color:#75715e>// 最大线程池大小</span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>long</span> keepAliveTime,         <span style=color:#75715e>// 线程超时未调用会被释放。用于大于核心大小，小于最大大小的线程</span>
</span></span><span style=display:flex><span>     TimeUnit unit,                       <span style=color:#75715e>// 超时的单位</span>
</span></span><span style=display:flex><span>     BlockingQueue<span style=color:#f92672>&lt;</span>Runnable<span style=color:#f92672>&gt;</span> workQueue,   <span style=color:#75715e>// 阻塞队列，类似于银行等候的待客区，等待线程空闲</span>
</span></span><span style=display:flex><span>     ThreadFactory threadFactory,         <span style=color:#75715e>// 线程工厂，不用改变</span>
</span></span><span style=display:flex><span>     RejectedExecutionHandler handler)    <span style=color:#75715e>// 拒绝策略</span>
</span></span></code></pre></div><h4 id=113四种拒绝策略>11.3、四种拒绝策略<a hidden class=anchor aria-hidden=true href=#113四种拒绝策略>#</a></h4><p>最初只有 <code>corePoolSize</code>个线程处理请求，当请求数量大于<code>corePoolSize</code>时，多出的请求进入阻塞队列。</p><p>假设用 <code>BlockingQueueSize</code>表示阻塞队列的容量，当请求总数大于 (<code>corePoolSize</code>+<code>BlockingQueueSize</code>)时，就用线程工厂新建 (请求总数 - (<code>corePoolSize</code>+<code>BlockingQueueSize</code>)) 个线程，即总是优先阻塞请求。</p><p>当最大线程数量都被分配完毕，且阻塞队列也满了的时候，需要拒绝策略来拒绝新的请求。</p><p><strong>四种拒绝策略</strong>即<code>RejectedExecutionHandler</code>接口的四个实现类。</p><p>这四个实现类都是 <code>ThreadPoolExecutor</code>的静态内部类。</p><table><thead><tr><th>策略</th><th>作用</th></tr></thead><tbody><tr><td><code>AbortPolicy</code> (默认)</td><td>抛出异常</td></tr><tr><td><code>CallerRunsPolicy</code></td><td>哪条线程送你来的线程池，就送回去让那条线程执行，不抛出异常</td></tr><tr><td><code>DiscardPolicy</code></td><td>丢弃请求，不抛出异常</td></tr><tr><td><code>DiscardOldestPolicy</code></td><td>丢弃最早进入阻塞队列的请求，并对新请求再次执行<code>execute</code>。 对正在执行的请求没有任何影响。不抛出异常</td></tr></tbody></table><h4 id=114线程池的线程数>11.4、线程池的线程数<a hidden class=anchor aria-hidden=true href=#114线程池的线程数>#</a></h4><p>1、 CPU 密集型任务：最优线程数应为核心数 + 1。由于CPU一直处于运行状态，如果设置的线程数过多会导致频繁的上下文切换。在理论上，最优线程数应该是核心数，但是在实际运行中，可能某个线程会因为缺页或其他异常而暂停，此时由额外线程补上，从而让CPU一直运行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Runtime.<span style=color:#a6e22e>getRuntime</span>().<span style=color:#a6e22e>availableProcessors</span>()   <span style=color:#75715e>// 将其作为最大线程容量传入即可</span>
</span></span></code></pre></div><p>2、IO 密集型任务：最优线程数应为核心数 * 2。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程。</p><p>《Java并发编程实战》对于计算最优线程数有一个公式：<code>最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）* CPU数目</code></p><h4 id=115线程池状态>11.5、线程池状态<a hidden class=anchor aria-hidden=true href=#115线程池状态>#</a></h4><p>线程池有个变量为：控制状态 ctl，其高三位表示下方的5中状态，低29位表示线程池中有效的线程个数。</p><p><img alt=线程池状态 loading=lazy src=/posts/java/juc%E7%AC%94%E8%AE%B0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.jpg></p><p>1、RUNNING</p><p>(1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。
(2) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0</p><p>2、 SHUTDOWN</p><p>(1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。
(2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -> SHUTDOWN。</p><p>3、STOP</p><p>(1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。
(2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -> STOP。</p><p>4、TIDYING</p><p>(1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。
(2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -> TIDYING。
当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -> TIDYING。</p><p>5、 TERMINATED</p><p>(1) 状态说明：线程池彻底终止，就变成TERMINATED状态。
(2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -> TERMINATED。</p><hr><h3 id=12四大函数式接口必须掌握>12、四大函数式接口【必须掌握】<a hidden class=anchor aria-hidden=true href=#12四大函数式接口必须掌握>#</a></h3><p>虽然看着没什么用，但是 JDK 大量源码都将这些接口作为参数使用，因此必须会。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Function<span style=color:#f92672>&lt;</span>String, Integer<span style=color:#f92672>&gt;</span> function <span style=color:#f92672>=</span> String::length;  <span style=color:#75715e>// 函数式接口可以直接由 lambda 表达式构造</span>
</span></span></code></pre></div><table><thead><tr><th>接口</th><th>抽象方法</th><th>描述</th></tr></thead><tbody><tr><td><code>Function&lt;T, R></code></td><td><code>R apply(T t);</code></td><td>作为一个方法，只能接受一个参数并返回结果</td></tr><tr><td><code>Predicate&lt;T></code></td><td><code>boolean test(T t);</code></td><td>同上方，只是返回结果为布尔值</td></tr><tr><td><code>Consumer&lt;T></code></td><td><code>void accept(T t);</code></td><td>消费型接口，接受一个参数，不返回结果</td></tr><tr><td><code>Supplier&lt;T></code></td><td><code>T get();</code></td><td>供给型接口，不输入只返回</td></tr></tbody></table><p>上述四大接口还衍生出来许多其他类似接口，例如<code>BiConsumer&lt;T, U></code>，它同样是消费型接口，接受两个参数但没有返回值，更多类似用到时心里有数就行。</p><hr><h3 id=13stream-流式计算>13、Stream 流式计算<a hidden class=anchor aria-hidden=true href=#13stream-流式计算>#</a></h3><p>大数据 = 存储 + 计算</p><p>存储 ： 集合、容器、数据库</p><p>计算 ： 流</p><p>Stream 的方法中大量使用了上章四大函数式接口。</p><p><strong>性能优化程度： Stream > ForkJoin > 普通计算</strong></p><hr><h3 id=14forkjoin>14、ForkJoin<a hidden class=anchor aria-hidden=true href=#14forkjoin>#</a></h3><p>ForkJoin 出现于 JDK 1.7。适用于大数据量（至少 1e8）并行执行任务，提高效率。</p><p>将一个大任务拆分成多个小任务（Fork），让多条线程并行执行完毕后，再将各自的结果合并（Join），得出最终结论。</p><p><strong>工作窃取</strong>：将最终拆分好的小任务用多个双端队列存储，每个线程负责一个双端队列并从头部开始执行，当执行速度快的线程将自己负责的队列中的所有任务执行完后，就会从执行速度慢的还没有执行完的队列底部窃取任务，帮助其执行。</p><p><strong>使用：</strong></p><p>1、<code>ForkJoinTask&lt;V></code>抽象类，主要有两个子类，一个为<code>RecursiveAction</code>没有返回值；一个为<code>RecursiveTask&lt;V></code>有返回值，返回类型即为 V。在自己的计算类中根据是否需要返回值继承其中一个子类并重写<code>compute</code>方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Fibonacci</span> <span style=color:#66d9ef>extends</span> RecursiveTask<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>    Fibonacci(<span style=color:#66d9ef>int</span> n) { <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>n</span> <span style=color:#f92672>=</span> n; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> Integer <span style=color:#a6e22e>compute</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&lt;=</span> 1)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> n;
</span></span><span style=display:flex><span>        Fibonacci f1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Fibonacci(n <span style=color:#f92672>-</span> 1);
</span></span><span style=display:flex><span>        f1.<span style=color:#a6e22e>fork</span>();
</span></span><span style=display:flex><span>        Fibonacci f2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Fibonacci(n <span style=color:#f92672>-</span> 2);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> f2.<span style=color:#a6e22e>compute</span>() <span style=color:#f92672>+</span> f1.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>2、实例化 <code>ForkJoinPool</code>；实例化自己的计算类，根据是否需要返回值调用<code>submit</code>或<code>execute</code>方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ForkJoinPool forkJoinPool <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ForkJoinPool();
</span></span><span style=display:flex><span>Fibonacci fibonacci <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Fibonacci(1000000000);
</span></span><span style=display:flex><span>ForkJoinTask<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> submit <span style=color:#f92672>=</span> forkJoinPool.<span style=color:#a6e22e>submit</span>(fibonacci);
</span></span><span style=display:flex><span>Integer result <span style=color:#f92672>=</span> submit.<span style=color:#a6e22e>get</span>();
</span></span></code></pre></div><hr><h3 id=15异步回调>15、异步回调<a hidden class=anchor aria-hidden=true href=#15异步回调>#</a></h3><p>可以将异步回调理解为 Ajax 的调用过程：即当我们发起一个请求后，该请求可能会被阻塞或等待一段时间才能拿到结果，这时我们无需傻傻等待；将请求发起后就无需理会，可以直接去执行其他操作，待其执行完毕返回结果后再去接收处理。</p><p>三部曲：异步执行、成功回调、失败回调</p><p>Future 是对未来的某个事件的结果进行建模，异步回调使用<code>CompletableFuture</code>,它是Future 的子类且对Future增强。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 没有返回值的异步回调</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> ExecutionException, InterruptedException {
</span></span><span style=display:flex><span>    Future<span style=color:#f92672>&lt;</span>Void<span style=color:#f92672>&gt;</span> future <span style=color:#f92672>=</span> CompletableFuture.<span style=color:#a6e22e>runAsync</span>( () <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* TODO */</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;runAsync&#34;</span>);
</span></span><span style=display:flex><span>    });            <span style=color:#75715e>// 到这里只是构造好了 future</span>
</span></span><span style=display:flex><span>    future.<span style=color:#a6e22e>get</span>();  <span style=color:#75715e>// 取得结果，可能发生阻塞</span>
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;main&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// ---------------------------------------------------------</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 有返回值的异步回调</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> ExecutionException, InterruptedException {
</span></span><span style=display:flex><span>    CompletableFuture<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> completableFuture <span style=color:#f92672>=</span> CompletableFuture.<span style=color:#a6e22e>supplyAsync</span>( () <span style=color:#f92672>-&gt;</span> 1024);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 无论是否正确执行都会调用 whenComplete 方法，第一个参数为正确结果，第二个参数为异常信息</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 当执行完成后会自动调用该方法，内部传参，我们只需对这些参数操作即可。</span>
</span></span><span style=display:flex><span>    completableFuture.<span style=color:#a6e22e>whenComplete</span>((result, error) <span style=color:#f92672>-&gt;</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;result=&gt;&#34;</span> <span style=color:#f92672>+</span> result <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;  ---  error=&gt;&#34;</span> <span style=color:#f92672>+</span> error))
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>exceptionally</span>( (e) <span style=color:#f92672>-&gt;</span> {   <span style=color:#75715e>// 发生异常时既会调用 whenComplete 方法，又会调用 exceptionally 方法</span>
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> 1;
</span></span><span style=display:flex><span>        }).<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=16jmm>16、JMM<a hidden class=anchor aria-hidden=true href=#16jmm>#</a></h3><p>JMM是<strong>面试高频</strong>，这里还是不够详细，其他知识如主线嗅探、缓存一致性、监听管道等等在面试前搞懂、理顺。</p><h4 id=161主内存与工作内存>16.1、主内存与工作内存<a hidden class=anchor aria-hidden=true href=#161主内存与工作内存>#</a></h4><p>主内存与工作内存都是 JMM 中的抽象定义，主内存是共享的，工作内存是私有的。主内存包括本地方法区和堆；工作内存包括线程私有的栈和cup缓存区。</p><ol><li>所有的变量都存储在主内存中(虚拟机内存的一部分)，对于所有线程都是共享的。</li><li>每条线程都有自己的工作内存，工作内存中保存的是主存中某些变量的拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。</li><li>线程之间无法直接访问对方的工作内存中的变量，线程间变量的传递均需要通过主内存来完成。</li></ol><p>JMM定义了<code>lock(锁定)</code>、<code>read(读取)</code>、<code>load(加载)</code>、<code>use(使用)</code>、<code>assign(赋值)</code>、<code>store(存储)</code>、<code>write(写入)</code>、<code>unlock(解锁)</code>八个步骤来实现主内存与工作内存之间的 具体交互。</p><h4 id=162as-if-serial-和-happens-before>16.2、as-if-serial 和 happens-before<a hidden class=anchor aria-hidden=true href=#162as-if-serial-和-happens-before>#</a></h4><p>Java内存模型是为了解决在并发环境下由于 CPU缓存、编译器和处理器的指令重排序导致的可见性、有序性问题。其包括两个规则，分别是<code>as-if-serial规则</code>和<code>happens-before规则</code>。</p><p><strong>as-if-serial规则</strong>即不管怎么重排序，程序的执行结果不能被改变。</p><ol><li>对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。</li><li>对于不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求（JMM允许这种重排序）。</li></ol><p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序。</p><p><strong>happens-before 规则</strong>所表述的是前一个操作的结果对后续操作是可见的，解决的就是内存可见性问题。重点记前4个。</p><ul><li>程序顺序规则： 同一线程内，程序按代码顺序执行（同一个线程中前面的所有写操作对后面的操作可见）</li><li>锁规则：如果线程1解锁了monitor a，接着线程2锁定了a，那么，线程1解锁a之前的写操作都对线程2可见</li><li>volatile变量规则：线程1写入了volatile变量v，接着线程2读取了v，那么线程1写入v及之前的写操作都对线程2可见</li><li>传递性：如果操作A happen—before操作B，操作B happen—before操作C，那么可以得出A happen—before操作C。</li><li>线程启动规则：线程A通过执行ThreadB.start()来启动线程B，那么线程A对共享变量的修改在接下来线程B开始执行前对线程B可见。注意：线程B启动之后，线程A在对变量修改线程B未必可见。</li><li>线程终止规则：线程t1写入的所有变量，在任意其它线程t2调用t1.join()，或者t1.isAlive() 成功返回后，都对t2可见。</li><li>线程中断规则：线程t1写入的所有变量，t1调用Thread.interrupt()打断t2，t2中断后可以看到t1的全部操作</li><li>对象终结规则：对象调用finalize()方法时，对象初始化完成的任意操作，同步到全部主存</li></ul><p>happen—before的关键就是对一个共享变量读之前，对这个变量的写操作要从工作内存刷新到主存。</p><hr><h3 id=17volatile>17、volatile<a hidden class=anchor aria-hidden=true href=#17volatile>#</a></h3><p><strong>volatile 的引出</strong>：当多个线程都使用了主存中的一个值，其中当一个线程对该值作出修改并刷新到主存时，其他线程并不知道该值已经被修改，继续使用旧值操作从而产生逻辑问题。为了解决该问题，出现了volatile。</p><p>volatile 是 java 虚拟机提供比 <code>sychronized</code> 关键字更<strong>轻量级的同步机制</strong>，访问 <code>volitile</code> 变量时，不会执行加锁操作。</p><p>特性：</p><p>1、保证可见性 ：当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p><p>2、不保证原子性 ：java 中自增包括取数、加一、保存三个过程的操作，假如 <code>volitile</code> 修饰的值执行自增，则在自增的任意一个阶段都可能被其他操作打断。</p><p>3、禁止指令重排 ：编译器、CPU 都有可能通过指令重排来优化我们的代码，指令重排即对我们的源代码重新排序。 <code>volitile</code> 会在写操作的前和后都设置一道内存屏障来保证程序局部的有序性。</p><h4 id=volatile-如何保证可见性>volatile 如何保证可见性<a hidden class=anchor aria-hidden=true href=#volatile-如何保证可见性>#</a></h4><p>volatile 通过缓存一致性协议和总线嗅探机制来保证可见性。</p><p>cpu1 的 线程1 与 cpu2 的 线程2 同时将主内存中的被 volatile 修饰的变量 v 加载的自己的工作内存（栈和L3缓存）。当 cpu1 的 线程1 对变量 v 修改后，总线就会发起通知， cpu2 嗅探到总线通知发现有其他线程对变量 v 产生了修改，就会将自己的 L3 缓存中的变量 v 的副本所在的缓存行置为无效状态，当线程 2 访问 v 时发现 v 所在缓存行失效就会丢弃该数据并去主内存中读取 v。</p><p>单核 CPU 不存在可见性问题！</p><hr><h3 id=18单例模式>18、单例模式<a hidden class=anchor aria-hidden=true href=#18单例模式>#</a></h3><h4 id=181dcl-懒汉式double-check-lock-双重检测锁定>18.1、DCL 懒汉式（Double Check Lock 双重检测锁定）<a hidden class=anchor aria-hidden=true href=#181dcl-懒汉式double-check-lock-双重检测锁定>#</a></h4><p>第一重判断 if (lazyMan == null) 无需解释，第二重判断原因：当 a 和 b 两线程都进入第一重判断之后，a 获得锁执行完毕后释放锁，此时 b 线程获取锁又执行一次实例化操作，从而出现问题。</p><p>实例加 volatile 的原因：lazyMan = new LazyMan(); 构造并不是原子操作，分为三部：</p><p>1、分配内存空间</p><p>2、在该内存空间初始化实例</p><p>3、将该内存空间地址赋值给 lazyMan ；</p><p>指令优化重新排序后可能按 1 3 2 的顺序执行，当 a 线程执行完 3 还没执行 2 时，lazyMan 已经不为 null ，此时线程 b 在第一重判断后直接返回 lazyMan ，但是 lazyMan 指向的空间还未初始化从而出现问题。volatile 通过限制指令重排使 CPU 只能按 1 2 3 的顺序执行从而解决问题。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// DCL 懒汉式</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LazyMan</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>static</span> LazyMan lazyMan;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>LazyMan</span>() {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> LazyMan <span style=color:#a6e22e>getInstance</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (lazyMan <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>synchronized</span> (LazyMan.<span style=color:#a6e22e>class</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (lazyMan <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                    lazyMan <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LazyMan();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> lazyMan;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=182springboot-单例原理>18.2、springboot 单例原理<a hidden class=anchor aria-hidden=true href=#182springboot-单例原理>#</a></h4><p><code>springboot</code>是通过单例注册表的方式实现单例模式的，即用一个 <code>ConcurrentHashMap </code>作为单例注册表存储类名到单例的映射，每次获取单例实例时，先到注册表中查找是否已经有该实例，若有直接返回，否则新建一个实例返回并添加到单例注册表中。</p><hr><h3 id=19深入理解-cas>19、深入理解 CAS<a hidden class=anchor aria-hidden=true href=#19深入理解-cas>#</a></h3><h4 id=191cas-是什么>19.1、CAS 是什么<a hidden class=anchor aria-hidden=true href=#191cas-是什么>#</a></h4><p>CAS是英文单词<strong>CompareAndSwap</strong>的缩写，中文意思是：比较并替换。CAS 是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了CAS技术。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。</p><p>CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。</p><p>原子操作在执行过程中，CPU会将内存的总线锁定（目前已优化为禁止访问缓存行），使其他处理器暂时无法通过总线访问内存，从而保证了读-改-写的原子性。</p><p>具体可以参考这篇文章 <a href="https://zhuanlan.zhihu.com/p/34556594#:~:text=CAS%EF%BC%88Compare-and-Swap%EF%BC%89%EF%BC%8C%E5%8D%B3%E6%AF%94%E8%BE%83%E5%B9%B6%E6%9B%BF%E6%8D%A2%EF%BC%8C%E6%98%AF%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E7%AE%97%E6%B3%95%E6%97%B6%E5%B8%B8%E7%94%A8%E5%88%B0%E7%9A%84%E6%8A%80%E6%9C%AF%EF%BC%8CJava%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%AD%E7%9A%84%E5%BE%88%E5%A4%9A%E7%B1%BB%E9%83%BD%E4%BD%BF%E7%94%A8%E4%BA%86CAS%E6%8A%80%E6%9C%AF%E3%80%82.,CAS%E4%B9%9F%E6%98%AF%E7%8E%B0%E5%9C%A8%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%B8%B8%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E6%9C%AC%E6%96%87%E5%B0%86%E6%B7%B1%E5%85%A5%E7%9A%84%E4%BB%8B%E7%BB%8DCAS%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%82.">面试必问的CAS，你懂了吗？ - 知乎 (zhihu.com)</a></p><h4 id=192unsafe-类>19.2、Unsafe 类<a hidden class=anchor aria-hidden=true href=#192unsafe-类>#</a></h4><p>Unsafe类 主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。</p><p><img alt=Unsafe loading=lazy src=/posts/java/juc%E7%AC%94%E8%AE%B0/Unsafe.png></p><h4 id=193使用示例>19.3、使用示例<a hidden class=anchor aria-hidden=true href=#193使用示例>#</a></h4><p>普通数字 i 或由 volatile 修饰的数字执行自增操作时需要三步：取值、加一、写值。在这三步执行的任何时间都可以被打断插队执行，因此会引发并发问题：如10个线程同时各自执行1000次自增操作，则实际结果会小于10000。而 AtomicInteger 可以解决这个问题，它的计算是原子操作。</p><h4 id=194cas-中存在的-aba-问题>19.4、CAS 中存在的 ABA 问题<a hidden class=anchor aria-hidden=true href=#194cas-中存在的-aba-问题>#</a></h4><p>CAS 的使用流程通常如下：1）某一时刻从地址 V 读取值 A；2）以原子方式在当前时刻比较A与地址 V 的值，若一致则替换。</p><p>CAS 的原子性是指步骤2是原子操作，会通过禁止访问缓存行实现不被打断。但步骤1和步骤2之间会有一个时间差，可能会引发 ABA 问题。</p><p>如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p><hr><h3 id=20原子引用>20、原子引用<a hidden class=anchor aria-hidden=true href=#20原子引用>#</a></h3><p>原子引用是带版本号的原子操作，相当于 MySQL的乐观锁。</p><p>在下方程序执行后，b 线程的 CAS 操作会失败，因为版本号已改变。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CASDemo</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        AtomicStampedReference<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> atomicReference <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AtomicStampedReference<span style=color:#f92672>&lt;&gt;</span>(1, 1);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> stamp <span style=color:#f92672>=</span> atomicReference.<span style=color:#a6e22e>getStamp</span>();     <span style=color:#75715e>// 获取版本号</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread( () <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 该线程模拟 ABA 问题，将当前值由 1 改为 2，再改回 1。</span>
</span></span><span style=display:flex><span>            atomicReference.<span style=color:#a6e22e>compareAndSet</span>(1, 2,
</span></span><span style=display:flex><span>                    atomicReference.<span style=color:#a6e22e>getStamp</span>(), atomicReference.<span style=color:#a6e22e>getStamp</span>() <span style=color:#f92672>+</span> 1);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            atomicReference.<span style=color:#a6e22e>compareAndSet</span>(2, 1,
</span></span><span style=display:flex><span>                    atomicReference.<span style=color:#a6e22e>getStamp</span>(), atomicReference.<span style=color:#a6e22e>getStamp</span>() <span style=color:#f92672>+</span> 1);
</span></span><span style=display:flex><span>        }, <span style=color:#e6db74>&#34;a&#34;</span>).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread( () <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 睡两秒，确保线程 a 先执行。</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(2);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>boolean</span> result <span style=color:#f92672>=</span> atomicReference.<span style=color:#a6e22e>compareAndSet</span>(1, 2,
</span></span><span style=display:flex><span>                    stamp, stamp <span style=color:#f92672>+</span> 1);
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(result);
</span></span><span style=display:flex><span>        }, <span style=color:#e6db74>&#34;b&#34;</span>).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>相关知识点：<strong>Integer 缓存机制</strong></p><p>Integer 缓存机制只适用于自动装配，等同于 <code>Integer.valueOf(i);</code>。</p><p>在 Integer 类第一次被使用的时候，会将 -128 ~ 127 的 Integer 对象直接组成数组保存在内存中并一直存在，以后当遇到在这个范围内的值需要自动装配时就会直接使用这个数组中的对象，只有当需要自动装配的值不在这个范围时才会重新在其他地址生成对象。</p><p>因此在上方的代码中，当构造 <code>AtomicStampedReference</code>时若初始值在 -128 ~ 127 的范围时程序成功执行，但当初始值不在该范围时 CAS 操作就会执行失败，因为 CAS 是直接通过 == 判断当前值与期望值是否相等，而超出范围的值都是重新分配地址，自然就会判断失败。但实际使用中通常使用字符串，字符串常量池不存在该问题。</p><hr><h3 id=21锁>21、锁<a hidden class=anchor aria-hidden=true href=#21锁>#</a></h3><h4 id=211公平锁非公平锁>21.1、公平锁、非公平锁<a hidden class=anchor aria-hidden=true href=#211公平锁非公平锁>#</a></h4><p>公平锁：不允许插队，所有线程必须先来先执行。</p><p>非公平锁：允许插队，默认都是非公平的、如 <code>synchronzied </code>和 lock锁。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>ReentrantLock</span>(<span style=color:#66d9ef>boolean</span> fair) {
</span></span><span style=display:flex><span>        sync <span style=color:#f92672>=</span> fair <span style=color:#f92672>?</span> <span style=color:#66d9ef>new</span> FairSync() : <span style=color:#66d9ef>new</span> NonfairSync();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=212可重入锁>21.2、可重入锁<a hidden class=anchor aria-hidden=true href=#212可重入锁>#</a></h4><p>可重入 就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// ReentrantLock 类的源码</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>nonfairTryAcquire</span>(<span style=color:#66d9ef>int</span> acquires) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> Thread current <span style=color:#f92672>=</span> Thread.<span style=color:#a6e22e>currentThread</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> getState();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (c <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (compareAndSetState(0, acquires)) {
</span></span><span style=display:flex><span>            setExclusiveOwnerThread(current);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 若占用锁的线程就是当前线程，则 state + 1，继续使用。即为可重入锁</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (current <span style=color:#f92672>==</span> getExclusiveOwnerThread()) { 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> nextc <span style=color:#f92672>=</span> c <span style=color:#f92672>+</span> acquires;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (nextc <span style=color:#f92672>&lt;</span> 0) <span style=color:#75715e>// overflow</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#34;Maximum lock count exceeded&#34;</span>);
</span></span><span style=display:flex><span>        setState(nextc);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=213自旋锁>21.3、自旋锁<a hidden class=anchor aria-hidden=true href=#213自旋锁>#</a></h4><p>对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，&ldquo;自旋"一词就是因此而得名。</p><h4 id=214死锁>21.4、死锁<a hidden class=anchor aria-hidden=true href=#214死锁>#</a></h4><p>如何排查：</p><p>1、在命令行使用 <code>jps -l</code>来定位所有存活的 java 进程的进程号。</p><p>2、在命令行使用 <code>jstack 进程号</code>查看进程信息。若存在死锁这些信息会反应出来。</p><h4 id=215synchronized-锁升级>21.5、Synchronized 锁升级<a hidden class=anchor aria-hidden=true href=#215synchronized-锁升级>#</a></h4><p>锁升级过程为：无锁状态、偏向锁、轻量级锁状态、重量级锁状态</p><p><strong>无锁状态</strong>：没有线程来获取锁时就是无锁状态。</p><p><strong>偏向锁</strong>：第一个线程获取锁就会从无锁变为偏向锁，并将对象头中的偏向线程id设置为该线程，线程再次获取锁时会比较当前的threadID与对象头中的threadID是否一致，如果一致则不需要通过CAS来加锁、解锁；如果不一致并且持有锁的线程还需要持续持有锁，则暂停当前线程撤销偏向锁，升级为轻量级锁。如果不再需要持续持有锁则锁对象头设为无锁状态，重新设置偏向锁。</p><p><strong>轻量级锁</strong>：如果只有一个线程获取锁就是偏向锁，偏向锁使用过程中又有其他线程竞争锁就会变为轻量级锁。在轻量级锁状态下，线程通过CAS方式来竞争锁。注意：只CAS一次，失败就升级为重量级锁。轻量级锁用于多个线程在不同的时间段获取锁，这时CAS成功，避免阻塞带来的开销。</p><p><strong>重量级锁</strong>：进入重量级锁后，在真正阻塞之前，默认进行10次自旋，若自旋获取锁就无需阻塞。目的还是尽量不要陷入阻塞。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E6%96%87%E4%BB%B6md5/><span class=title>« Prev</span><br><span>文件的 MD5 值</span>
</a><a class=next href=http://localhost:1313/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/enum%E8%B5%8B%E5%80%BC/><span class=title>Next »</span><br><span>Enum 向注解赋值问题</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>