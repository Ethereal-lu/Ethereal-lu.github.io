<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Netty | lu</title>
<meta name=keywords content><meta name=description content='1 NIO基础
non-blocking io 非阻塞IO
1.1 三大组件
1.1.1 Channel & Buffer
Buffer是内存中的数据缓冲区，Channel 是内存与磁盘之间的数据通道。不同于InputStream、OutputStream等BIO中的流都是单向数据通道，Channel 是双向数据通道，可以从 Channel 将数据读入 Buffer，也可以将Buffer 中的数据写入Channel 。
常见的 Channel 有：

FileChannel ：文件通道
DatagramChannel ：udp
SocketChannel ：tcp；客户端服务端都可以
ServerSocketChannel ：tcp；专用于服务端

Buffer 使用最多的就是 ByteBuffer，其他的也是每种基础数据类型有一个对应的Buffer，但用的不多。
1.1.2 Selector
在使用传统BIO开发时，要么对每个连接都新建一个线程处理（线程太多撑爆内存、线程切换成本高），要么使用线程池（阻塞IO，同时只能处理一个连接，线程利用率不高）&mdash;> 正因为此，原始的HTTP1.0才使用短连接，一个请求处理完立刻释放连接，让线程可以处理其他请求。
Selector 的作用就是配合一个线程来管理多个Channel ，获取这些Channel 上发生的事件，将有事件发生的Channel 交给线程处理。适合连接数多但流量低的场景，流量大意味着一个Channel 要处理大量数据，会使其他Channel 饥饿。

1.2 ByteBuffer
1.2.1 基本使用
public class TestByteBuffer {
    public static void main(String[] args) {
        // 获取 FileChannel
        try (FileChannel channel = new FileInputStream("data.txt").getChannel()) {
            // 申请 10 个字节的缓冲区
            ByteBuffer buffer = ByteBuffer.allocate(10);
            // 读取channel中的数据到buffer。read 方法返回读取到的字节数，-1表示读完了
            while (channel.read(buffer) != -1) {
                buffer.flip();  // 切换为读模式
                while (buffer.hasRemaining()) {
                    System.out.println(buffer.get());  // get 每次读一个字节
                }
                buffer.clear();  // 切换为写模式
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
1.2.2 内部结构
ByteBuffer有以下几个重要属性'><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/posts/java/netty/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity="sha256-1yREUm1+y9sAFUOKf6iQVKZYv3WdBULi5d+BzpS0k+4=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/posts/java/netty/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/posts/java/netty/"><meta property="og:site_name" content="lu"><meta property="og:title" content="Netty"><meta property="og:description" content='1 NIO基础 non-blocking io 非阻塞IO
1.1 三大组件 1.1.1 Channel & Buffer Buffer是内存中的数据缓冲区，Channel 是内存与磁盘之间的数据通道。不同于InputStream、OutputStream等BIO中的流都是单向数据通道，Channel 是双向数据通道，可以从 Channel 将数据读入 Buffer，也可以将Buffer 中的数据写入Channel 。
常见的 Channel 有：
FileChannel ：文件通道 DatagramChannel ：udp SocketChannel ：tcp；客户端服务端都可以 ServerSocketChannel ：tcp；专用于服务端 Buffer 使用最多的就是 ByteBuffer，其他的也是每种基础数据类型有一个对应的Buffer，但用的不多。
1.1.2 Selector 在使用传统BIO开发时，要么对每个连接都新建一个线程处理（线程太多撑爆内存、线程切换成本高），要么使用线程池（阻塞IO，同时只能处理一个连接，线程利用率不高）—> 正因为此，原始的HTTP1.0才使用短连接，一个请求处理完立刻释放连接，让线程可以处理其他请求。
Selector 的作用就是配合一个线程来管理多个Channel ，获取这些Channel 上发生的事件，将有事件发生的Channel 交给线程处理。适合连接数多但流量低的场景，流量大意味着一个Channel 要处理大量数据，会使其他Channel 饥饿。
1.2 ByteBuffer 1.2.1 基本使用 public class TestByteBuffer { public static void main(String[] args) { // 获取 FileChannel try (FileChannel channel = new FileInputStream("data.txt").getChannel()) { // 申请 10 个字节的缓冲区 ByteBuffer buffer = ByteBuffer.allocate(10); // 读取channel中的数据到buffer。read 方法返回读取到的字节数，-1表示读完了 while (channel.read(buffer) != -1) { buffer.flip(); // 切换为读模式 while (buffer.hasRemaining()) { System.out.println(buffer.get()); // get 每次读一个字节 } buffer.clear(); // 切换为写模式 } } catch (IOException e) { e.printStackTrace(); } } } 1.2.2 内部结构 ByteBuffer有以下几个重要属性'><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-09T19:12:41+00:00"><meta property="article:modified_time" content="2022-07-09T19:12:41+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Netty"><meta name=twitter:description content='1 NIO基础
non-blocking io 非阻塞IO
1.1 三大组件
1.1.1 Channel & Buffer
Buffer是内存中的数据缓冲区，Channel 是内存与磁盘之间的数据通道。不同于InputStream、OutputStream等BIO中的流都是单向数据通道，Channel 是双向数据通道，可以从 Channel 将数据读入 Buffer，也可以将Buffer 中的数据写入Channel 。
常见的 Channel 有：

FileChannel ：文件通道
DatagramChannel ：udp
SocketChannel ：tcp；客户端服务端都可以
ServerSocketChannel ：tcp；专用于服务端

Buffer 使用最多的就是 ByteBuffer，其他的也是每种基础数据类型有一个对应的Buffer，但用的不多。
1.1.2 Selector
在使用传统BIO开发时，要么对每个连接都新建一个线程处理（线程太多撑爆内存、线程切换成本高），要么使用线程池（阻塞IO，同时只能处理一个连接，线程利用率不高）&mdash;> 正因为此，原始的HTTP1.0才使用短连接，一个请求处理完立刻释放连接，让线程可以处理其他请求。
Selector 的作用就是配合一个线程来管理多个Channel ，获取这些Channel 上发生的事件，将有事件发生的Channel 交给线程处理。适合连接数多但流量低的场景，流量大意味着一个Channel 要处理大量数据，会使其他Channel 饥饿。

1.2 ByteBuffer
1.2.1 基本使用
public class TestByteBuffer {
    public static void main(String[] args) {
        // 获取 FileChannel
        try (FileChannel channel = new FileInputStream("data.txt").getChannel()) {
            // 申请 10 个字节的缓冲区
            ByteBuffer buffer = ByteBuffer.allocate(10);
            // 读取channel中的数据到buffer。read 方法返回读取到的字节数，-1表示读完了
            while (channel.read(buffer) != -1) {
                buffer.flip();  // 切换为读模式
                while (buffer.hasRemaining()) {
                    System.out.println(buffer.get());  // get 每次读一个字节
                }
                buffer.clear();  // 切换为写模式
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
1.2.2 内部结构
ByteBuffer有以下几个重要属性'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ethereal-lu.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Netty","item":"https://ethereal-lu.github.io/posts/java/netty/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Netty","name":"Netty","description":"1 NIO基础 non-blocking io 非阻塞IO\n1.1 三大组件 1.1.1 Channel \u0026amp; Buffer Buffer是内存中的数据缓冲区，Channel 是内存与磁盘之间的数据通道。不同于InputStream、OutputStream等BIO中的流都是单向数据通道，Channel 是双向数据通道，可以从 Channel 将数据读入 Buffer，也可以将Buffer 中的数据写入Channel 。\n常见的 Channel 有：\nFileChannel ：文件通道 DatagramChannel ：udp SocketChannel ：tcp；客户端服务端都可以 ServerSocketChannel ：tcp；专用于服务端 Buffer 使用最多的就是 ByteBuffer，其他的也是每种基础数据类型有一个对应的Buffer，但用的不多。\n1.1.2 Selector 在使用传统BIO开发时，要么对每个连接都新建一个线程处理（线程太多撑爆内存、线程切换成本高），要么使用线程池（阻塞IO，同时只能处理一个连接，线程利用率不高）\u0026mdash;\u0026gt; 正因为此，原始的HTTP1.0才使用短连接，一个请求处理完立刻释放连接，让线程可以处理其他请求。\nSelector 的作用就是配合一个线程来管理多个Channel ，获取这些Channel 上发生的事件，将有事件发生的Channel 交给线程处理。适合连接数多但流量低的场景，流量大意味着一个Channel 要处理大量数据，会使其他Channel 饥饿。\n1.2 ByteBuffer 1.2.1 基本使用 public class TestByteBuffer { public static void main(String[] args) { // 获取 FileChannel try (FileChannel channel = new FileInputStream(\u0026#34;data.txt\u0026#34;).getChannel()) { // 申请 10 个字节的缓冲区 ByteBuffer buffer = ByteBuffer.allocate(10); // 读取channel中的数据到buffer。read 方法返回读取到的字节数，-1表示读完了 while (channel.read(buffer) != -1) { buffer.flip(); // 切换为读模式 while (buffer.hasRemaining()) { System.out.println(buffer.get()); // get 每次读一个字节 } buffer.clear(); // 切换为写模式 } } catch (IOException e) { e.printStackTrace(); } } } 1.2.2 内部结构 ByteBuffer有以下几个重要属性\n","keywords":[],"articleBody":"1 NIO基础 non-blocking io 非阻塞IO\n1.1 三大组件 1.1.1 Channel \u0026 Buffer Buffer是内存中的数据缓冲区，Channel 是内存与磁盘之间的数据通道。不同于InputStream、OutputStream等BIO中的流都是单向数据通道，Channel 是双向数据通道，可以从 Channel 将数据读入 Buffer，也可以将Buffer 中的数据写入Channel 。\n常见的 Channel 有：\nFileChannel ：文件通道 DatagramChannel ：udp SocketChannel ：tcp；客户端服务端都可以 ServerSocketChannel ：tcp；专用于服务端 Buffer 使用最多的就是 ByteBuffer，其他的也是每种基础数据类型有一个对应的Buffer，但用的不多。\n1.1.2 Selector 在使用传统BIO开发时，要么对每个连接都新建一个线程处理（线程太多撑爆内存、线程切换成本高），要么使用线程池（阻塞IO，同时只能处理一个连接，线程利用率不高）—\u003e 正因为此，原始的HTTP1.0才使用短连接，一个请求处理完立刻释放连接，让线程可以处理其他请求。\nSelector 的作用就是配合一个线程来管理多个Channel ，获取这些Channel 上发生的事件，将有事件发生的Channel 交给线程处理。适合连接数多但流量低的场景，流量大意味着一个Channel 要处理大量数据，会使其他Channel 饥饿。\n1.2 ByteBuffer 1.2.1 基本使用 public class TestByteBuffer { public static void main(String[] args) { // 获取 FileChannel try (FileChannel channel = new FileInputStream(\"data.txt\").getChannel()) { // 申请 10 个字节的缓冲区 ByteBuffer buffer = ByteBuffer.allocate(10); // 读取channel中的数据到buffer。read 方法返回读取到的字节数，-1表示读完了 while (channel.read(buffer) != -1) { buffer.flip(); // 切换为读模式 while (buffer.hasRemaining()) { System.out.println(buffer.get()); // get 每次读一个字节 } buffer.clear(); // 切换为写模式 } } catch (IOException e) { e.printStackTrace(); } } } 1.2.2 内部结构 ByteBuffer有以下几个重要属性\ncapacity：容量 —–\u003e 在任何时候都指向ByteBuffer的末尾 position：读或者写的当前位置 limit：读或者写的限制处 在写模式下limit指向ByteBuffer末尾，position指向当前写入的位置。在读模式下，limit指向写入的最后一个位置，position指向当前读取的位置。\nflip()方法从写模式切换为读模式，即limit指向写入的最后一个位置，position置为 0，从头读。\nclear()方法从读模式切换为写模式，即limit指向ByteBuffer末尾，position置为 0，从头写。\ncompact()方法从读模式切换为写模式，但是它会将之前没有读取到的数据移动到ByteBuffer的开头，然后从下一个位置开始写。\n1.2.3 方法 分配空间\nByteBuffer.allocate(10)：HeapByteBuffer，申请的是堆内存，读写效率低，会受到GC影响而在新生代中复制 ByteBuffer.allocateDirect(10)：DirectByteBuffer，申请的是直接内存，读写效率高（零拷贝），不受GC影响，但分配内存需要由操作系统分配，故分配时效率较低。 向 buffer 写数据\nchannel.read(buffer) buffer.put((byte)127) 从buffer读数据\nchannel.write(buffer) buffer.get()。get 方法会让 position 指针向后走，如果想重复读取，有以下两种方法 调用 rewind 方法将 position 重置为 0 调用 get(int i)获取索引为 i 处的内容，指针不移动 mark \u0026 reset\nmark：做一个标记，记录 position 位置 reset：将 position 重新设置为 mark 处，两者一般配合使用。这两个是对 rewind 的增强。 字符串存入缓冲区\nByteBuffer buffer = ByteBuffer.wrap(\"hello\".getBytes()); // 还有其他方式，需要再看吧 批量读取写入：其实就是在channel 的read 和 write 方法中可以传入一个 byteBuffer 数组。\n1.3 FileChannel FileInputStream、FileOutputStream、RandomAccessFile都可以创建FileChannel ，前两种只能是单向通道，后一种可以指定为“rw”作为双向通道。 两个FileChannel 之间可以通过transferTo()方法传输数据。效率高，底层用操作系统零拷贝实现，最大2G，超过2G的文件需要循环传输 推荐使用JDK1.7的path和files类操作文件与路径 Files.walkFileTree()可以遍历目录下的所有目录和文件，在遍历过程中可以执行一些自定义操作。 1.4 网络编程 1.4.1 BIO 线程与客户端连接之前会阻塞，建立连接后只能服务一个客户端，直到服务结束，线程池也是同样的道理。\npublic static void main(String[] args) throws IOException { ServerSocketChannel ssc = ServerSocketChannel.open(); ssc.bind(new InetSocketAddress(8080)); ByteBuffer buffer = ByteBuffer.allocate(16); while (true) { // accept() 会阻塞当前线程，直到有客户端连接它 SocketChannel sc = ssc.accept(); sc.read(buffer); // read 会阻塞当前线程，直到客户端将数据发送过来 buffer.flip(); while (buffer.hasRemaining()) buffer.get(); buffer.clear(); } } 1.4.2 NIO NIO可以解决BIO中单线程只能服务一个客户端的弊端，但是它需要不停地轮询，绝大多数时候都是在空转，浪费资源。\npublic static void main(String[] args) throws IOException { ServerSocketChannel ssc = ServerSocketChannel.open(); ssc.configureBlocking(false); // 非阻塞模式，这里影响的是下方的 accept 方法。 ssc.bind(new InetSocketAddress(8080)); ByteBuffer buffer = ByteBuffer.allocate(16); List\u003cSocketChannel\u003e channels = new ArrayList\u003c\u003e(); while (true) { SocketChannel sc = ssc.accept(); // 非阻塞，如果没有建立连接，返回的 sc 为null if (sc != null) { sc.configureBlocking(false); // 非阻塞模式，这里影响的是下方的 read 方法 // 非阻塞模式下可以与多个客户端同时连接，此处将所有客户端存储起来，方便后续轮询 channels.add(sc); } for (SocketChannel channel : channels) { int read = channel.read(buffer); // 非阻塞，如果客户端没有发送数据，返回的读取数为 0 if (read \u003e 0) { buffer.flip(); while (buffer.hasRemaining()) buffer.get(); buffer.clear(); } } } } 1.4.3 IO多路复用-Selector 多路复用只能用于网络编程，普通文件读写没法使用。\n事件类型有以下四种：\naccept：当客户端发起连接请求时，在服务端产生事件 connect：连接建立成功后，在客户端触发 — 一般用不到 read：可读事件 write：可写事件 public static void main(String[] args) throws IOException { // 相当于使用 epoll_create 创建一个 epoll 实例 Selector selector = Selector.open(); ServerSocketChannel ssc = ServerSocketChannel.open(); ssc.configureBlocking(false); // 将通道注册到 selector，并关注 accept 事件；相当于把 ssc 这个 channel 的 fd 通过 epoll_ctl 注册到红黑树 ssc.register(selector, SelectionKey.OP_ACCEPT); ssc.bind(new InetSocketAddress(8081)); while (true) { // 此处相当于调用 epoll_wait，没有事件发生则线程阻塞，有事件才会唤醒。 // 这里使用水平触发，如果事件未处理就类似于NIO，会一直循环直到你处理了。cancel()方法会从红黑树和链表都删除fd selector.select(); // 取出链表中的事件遍历处理 Iterator\u003cSelectionKey\u003e iter = selector.selectedKeys().iterator(); while (iter.hasNext()){ SelectionKey key = iter.next(); // 重点：每发生一个事件，都会将该事件的 fd 从红黑树复制到链表中，但是事件处理完成后不会自动从链表删除。 // 这就意味着下次遍历链表时还会遍历到它，但是它已经被处理过了，也就是此时它没有事件发生，就会造成异常。 // 比如此时 accept 没有事件但是会进入它的分支，导致返回的 sc 为null，再执行后续操作会爆空指针异常。 // 因此，每次处理完成一个事件后必须手动删除它。 iter.remove(); if (key.isAcceptable()) { // 因为关注 accept 事件的只有 ssc，故此处 key.channel() 获取到的就是上方的 ssc // 可以直接使用 ssc 替换下方两句 ServerSocketChannel channel = (ServerSocketChannel) key.channel(); SocketChannel sc = channel.accept(); sc.configureBlocking(false); // 非阻塞模式才能配合 Selector 使用 sc.register(selector, SelectionKey.OP_READ); // 注册并关注读事件 } else if (key.isReadable()) { // 不论客户端是正常退出还是异常退出，都会触发一个读事件 try { SocketChannel channel = (SocketChannel) key.channel(); // 此处在这里新建 buffer 而不是在 accept 事件中注册时添加附件，是因为下方服务器响应时会覆盖附件 // 而 accept 事件只有连接时触发一次，这样的话之后的读操作就获取不到 buffer 了 ByteBuffer buffer = ByteBuffer.allocate(1024); // 如果客户端异常退出，触发读事件进行到这里时，read 操作会抛出 IOException，所以需要捕获处理 int read = channel.read(buffer); // 如果 buffer 较小一次没读完，会触发多次读事件 // 如果客户端正常退出，只有客户端调用 close 方法才是正常退出，即数据流读到了末尾 // 这时 read 方法的返回值为 0 或 -1。cancel()方法会从红黑树中删除 fd。 // 注意：如果是正常有数据过来触发的读事件，能读出的数据一定大于 0 if (read \u003c= 0) { System.out.println(\"stream end\"); key.cancel(); // 既然客户端已经断开连接，那红黑树中的 fd 就没必要监听了 } else { buffer.flip(); System.out.println(\"服务端处理消息\" + Charset.defaultCharset().decode(buffer)); // 此处服务端读取完客户端信息后开始响应消息 key.interestOps(key.interestOps() | SelectionKey.OP_WRITE); // 添加监听写事件 key.attach(ByteBuffer.wrap(\"服务端响应的消息\".getBytes())); } } catch (IOException e) { e.printStackTrace(); key.cancel(); } } else if (key.isWritable()) { SocketChannel channel = (SocketChannel) key.channel(); ByteBuffer buffer = (ByteBuffer) key.attachment(); channel.write(buffer); // channel 容量有限，如果一次写不完就需要触发多次写事件 if (!buffer.hasRemaining()) { key.attach(null); // 将附件扔掉，以免浪费空间 key.interestOps(key.interestOps() ^ SelectionKey.OP_WRITE); // 写完了就取消监听写事件 } } } } } 上方代码中没有考虑消息边界的处理，即如果 ByteBuffer设置的太小，则会产生半包，如用 4 字节的 ByteBuffer接收两个汉字（UTF-8），则第一个汉字正常处理，第二个汉字会拆成两半无法正常解码。一种解决方法是初始申请较小空间，如果空间不足则扩容，这种方法需要指定消息边界，如使用 \\n作为一条消息的结尾，则逐一遍历消息中的每个 byte，若 ByteBuffer遍历完依然没有找到\\n就要扩容。\n如果初始申请的 ByteBuffer就很大，则服务器连接几个客户端就把内存占满了，不划算。\n1.4.4 多线程优化 单线程配合 Selector 已经可以实现多路复用，但是无法充分利用多核CPU，且如果一个事件需要耗费很长时间，就会使其他事件等待。\n初始版本：由于 register和 select造成死锁，无法将通道注册到 Selector，所以不能用。\npublic class MultiThreadServer { public static void main(String[] args) throws IOException { // master 只负责接受连接，具体的读写交给 Worker Selector master = Selector.open(); ServerSocketChannel ssc = ServerSocketChannel.open(); ssc.configureBlocking(false); ssc.register(master, SelectionKey.OP_ACCEPT); ssc.bind(new InetSocketAddress(8081)); // 创建固定大小的 worker，一般取核心数个 Worker worker = new Worker(\"worker-0\"); while (true) { master.select(); Iterator\u003cSelectionKey\u003e iter = master.selectedKeys().iterator(); while (iter.hasNext()) { SelectionKey key = iter.next(); iter.remove(); if (key.isAcceptable()) { SocketChannel sc = ssc.accept(); sc.configureBlocking(false); // 将客户通道注册到 worker 的 selector // 观察源码可知，该方法最终会调用 selector 的注册方法，且这个方法会和 selector.select() 竞争锁 // 由于 selector.select() 先执行已经获取了锁，此方法就被阻塞，而 select 方法没有事件又持续阻塞 // 所以造成死锁。（由此可见，select 方法阻塞也不会释放锁。） sc.register(worker.selector, SelectionKey.OP_READ); } } } } static class Worker implements Runnable { private String name; private Selector selector; private Thread thread; public Worker(String name) throws IOException { this.name = name; this.selector = Selector.open(); this.thread = new Thread(this, name); thread.start(); } @SneakyThrows @Override public void run() { while (true) { selector.select(); Iterator\u003cSelectionKey\u003e iter = selector.selectedKeys().iterator(); while (iter.hasNext()) { SelectionKey key = iter.next(); iter.remove(); if (key.isReadable()) { ByteBuffer buffer = ByteBuffer.allocate(1024); SocketChannel sc = (SocketChannel) key.channel(); sc.read(buffer); buffer.flip(); System.out.println(\"thread: \" + thread.getName() + \"--\u003e charge for: \" + Charset.defaultCharset().decode(buffer)); } } } } } } 优化：将注册的事交给子线程去执行。最关键的点还是 selector.wakeup();，netty 就是通过消息队列实现的工作传递\n注意：wakeup 和 select 的关系与 unpark 和 park 相似。\npublic class MultiThreadServer { public static void main(String[] args) throws IOException { Selector master = Selector.open(); ServerSocketChannel ssc = ServerSocketChannel.open(); ssc.configureBlocking(false); ssc.register(master, SelectionKey.OP_ACCEPT); ssc.bind(new InetSocketAddress(8081)); // Runtime.getRuntime().availableProcessors() 获取的是物理机的核心数 // 对于 docker 类容器就会有问题，因为实际不可能把所有核心分配给 docker Worker[] workers = new Worker[Runtime.getRuntime().availableProcessors()]; for (int i = 0; i \u003c workers.length; i++) { workers[i] = new Worker(\"worker-\" + i); } AtomicInteger index = new AtomicInteger(); while (true) { master.select(); Iterator\u003cSelectionKey\u003e iter = master.selectedKeys().iterator(); while (iter.hasNext()) { SelectionKey key = iter.next(); iter.remove(); if (key.isAcceptable()) { SocketChannel sc = ssc.accept(); sc.configureBlocking(false); // 将注册这个工作放到消息队列，同时唤醒子线程。负载均衡 workers[index.incrementAndGet() % workers.length].register(sc); } } } } static class Worker implements Runnable { private String name; private Selector selector; private Thread thread; private ConcurrentLinkedQueue\u003cRunnable\u003e queue; public Worker(String name) throws IOException { this.name = name; this.selector = Selector.open(); this.queue = new ConcurrentLinkedQueue\u003c\u003e(); this.thread = new Thread(this, name); thread.start(); } public void register(SocketChannel sc) { queue.add(() -\u003e { try { sc.register(selector, SelectionKey.OP_READ); } catch (ClosedChannelException e) { e.printStackTrace(); } }); selector.wakeup(); } @SneakyThrows @Override public void run() { while (true) { selector.select(); Runnable task = queue.poll(); if (task != null) task.run(); // 这里才将通道注册到子线程的 selector Iterator\u003cSelectionKey\u003e iter = selector.selectedKeys().iterator(); while (iter.hasNext()) { SelectionKey key = iter.next(); iter.remove(); if (key.isReadable()) { ByteBuffer buffer = ByteBuffer.allocate(1024); SocketChannel sc = (SocketChannel) key.channel(); sc.read(buffer); buffer.flip(); System.out.println(\"thread: \" + thread.getName() + \"--\u003e charge for: \" + Charset.defaultCharset().decode(buffer)); } } } } } } 1.5 零拷贝 1.5.1 传统 IO 问题 传统的 IO 将一个文件通过 socket 写出\nFile f = new File(\"helloword/data.txt\"); RandomAccessFile file = new RandomAccessFile(file, \"r\"); byte[] buf = new byte[(int)f.length()]; file.read(buf); Socket socket = ...; socket.getOutputStream().write(buf); 内部工作流程是这样的：\n读数据过程：\n应用程序要读取磁盘数据，调用read()函数从而实现用户态切换内核态，这是第1次状态切换； DMA控制器将数据从磁盘拷贝到内核缓冲区，这是第1次DMA拷贝； CPU将数据从内核缓冲区复制到用户缓冲区，这是第1次CPU拷贝； CPU完成拷贝之后，read()函数返回实现内核态切换用户态，这是第2次状态切换； 写数据过程：\n应用程序要向网卡写数据，调用write()函数实现用户态切换内核态，这是第1次切换； CPU将用户缓冲区数据拷贝到内核缓冲区，这是第1次CPU拷贝； DMA控制器将数据从内核缓冲区复制到socket缓冲区，这是第1次DMA拷贝； 完成拷贝之后，write()函数返回实现内核态切换用户态，这是第2次切换； 综上所述：\n读过程涉及2次空间切换、1次DMA拷贝、1次CPU拷贝； 写过程涉及2次空间切换、1次DMA拷贝、1次CPU拷贝； 可见传统模式下，涉及多次空间切换和数据冗余拷贝，效率并不高，接下来就该零拷贝技术出场了。\n1.5.2 NIO 优化 通过 DirectByteBuf ，即 mmap\nByteBuffer.allocate(10) HeapByteBuffer 使用的还是 java 内存 ByteBuffer.allocateDirect(10) DirectByteBuffer 使用的是操作系统内存 大部分步骤与优化前相同，不再赘述。唯有一点：java 可以使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用\n这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写 java 中的 DirectByteBuf 对象仅维护了此内存的虚引用 Cleaner，内存回收分成两步 DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列 通过专门的回收线程访问引用队列，根据虚引用释放堆外内存 减少了一次数据拷贝，用户态与内核态的切换次数没有减少。 2dma + 1cpu 以下两种方式，由于数据不经过用户缓冲区，因此无法修改。\n进一步优化（底层采用了 linux 2.1 后提供的 sendFile 方法），java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据\njava 调用 transferTo 方法后，要从 java 程序的用户态切换至内核态，使用 DMA将数据读入内核缓冲区，不会使用 cpu 数据从内核缓冲区传输到 socket 缓冲区，cpu 会参与拷贝 最后使用 DMA 将 socket 缓冲区的数据写入网卡，不会使用 cpu，方法结束后切换回用户态 可以看到\n只发生了2次用户态与内核态的切换 数据拷贝了 3 次 。2dma + 1cpu 进一步优化（linux 2.4）\njava 调用 transferTo 方法后，要从 java 程序的用户态切换至内核态，使用 DMA将数据读入内核缓冲区，不会使用 cpu 只会将一些 offset 和 length 信息拷入 socket 缓冲区，几乎无消耗 使用 DMA 将 内核缓冲区的数据写入网卡，不会使用 cpu，方法结束后切换回用户态 整个过程仅只发生了2次用户态与内核态的切换，数据拷贝了 2 次。所谓的【零拷贝】，并不是真正无拷贝，而是在不会在内核态和用户态之间拷贝数据，零拷贝的优点有\n更少的用户态与内核态的切换 不利用 cpu 计算，减少 cpu 缓存伪共享 零拷贝适合小文件传输 1.6 AIO netty 不支持 AIO，因为 linux 不支持AIO（现在貌似支持了）\n2 Netty 基础 Netty 的网络模型依然是多路复用\n一开始需要树立正确的观念\n把 channel 理解为数据的通道 把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf 把 handler 理解为数据的处理工序 工序有多道，合在一起就是 pipeline，pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法） handler 分 Inbound 和 Outbound 两类，分别对入站和出站的数据处理 把 eventLoop 理解为处理数据的工人 工人可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定）（避免多个线程对同一个channel操作引发并发问题） 工人既可以执行 io 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务 工人按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每道工序指定不同的工人 2.1 初体验 注意：下方代码都是固定格式，不同场景只需要更换不同处理器即可，格式不变\n服务端：\npublic class HelloServer { public static void main(String[] args) { // 服务器端启动器，负责组装 netty 组件，启动服务器 new ServerBootstrap() // EventLoop 即事件循环，其中包含(selector,thread)，作用和之前手写的 master、worker一样 // 每个 EventLoop 负责监听一部分事件，group 即有多个 EventLoop // 这其中会有一个 master 负责 accept 建立连接 .group(new NioEventLoopGroup()) // 选择服务器的 ServerSocketChannel .channel(NioServerSocketChannel.class) // 此处 child 即之前的 worker，负责处理读写，这里编写 child 需要处理的逻辑 // 此处只是添加了处理器，需要等到 accept 建立连接之后才会真正执行处理器的逻辑 .childHandler( // 泛型表示这是为 NioSocketChannel 进行初始化，初始化即为这个泛型中通道配置一些 Handler // NioSocketChannel 即与客户端进行数据读写的通道。 new ChannelInitializer\u003cNioSocketChannel\u003e() { @Override // 在连接建立之后被调用 protected void initChannel(NioSocketChannel ch) { // 添加具体的处理器 // 注意：这里也只是将一个个处理器添加到通道中，真正执行是在数据经过通道时 // 不论是收还是发数据都会经过所有的处理器，只是如下方的channelRead它只在读数据时起作用 // 客户端的一个个处理器与这里一样，也是收发数据时才真正执行 ch.pipeline().addLast(new StringDecoder()); // 将 ByteBuf 转化为字符串 ch.pipeline().addLast(new ChannelInboundHandlerAdapter() { // 自定义 handler @Override // 处理读事件 public void channelRead(ChannelHandlerContext ctx, Object msg) { System.out.println(msg); } }); } }) .bind(8080); } } 客户端：\npublic class HelloClient { public static void main(String[] args) throws InterruptedException { // 客户端启动类 new Bootstrap() // EventLoop 对于客户端没啥用，但是 netty 中统一格式 .group(new NioEventLoopGroup()) // 选择 channel .channel(NioSocketChannel.class) // 添加处理器 .handler(new ChannelInitializer\u003cNioSocketChannel\u003e() { @Override // 在连接建立之后被调用 protected void initChannel(NioSocketChannel ch) throws Exception { // 将字符串编码为 ByteBuf ch.pipeline().addLast(new StringEncoder()); } }) // 连接到服务器 .connect(new InetSocketAddress(\"localhost\", 8080)) // sync 是阻塞方法，等到连接建立之后才允许继续执行下方代码 .sync() // channel 即客户端与服务端之间的数据通道 .channel() // 向服务器发送数据 .writeAndFlush(\"hello netty!\"); } } 2.2 组件 2.2.1 EventLoop EventLoop 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 io 事件。继承了 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法\nEventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）\n// EventLoopGroup 基础使用 public class EventLoopTest { public static void main(String[] args) { // 参数为 EventLoop 的数量，默认为 核心数 * 2 EventLoopGroup group = new NioEventLoopGroup(3); // IO事件，普通任务，定时任务 // DefaultEventLoop 不能执行 IO 事件，其他和 NioEventLoopGroup 一样 // 获取下一个 EventLoop System.out.println(group.next()); // 执行普通任务 group.next().submit(() -\u003e System.out.println(\"子线程\")); // 执行定时任务 （0秒后开始，每 1 秒执行一次） group.next().scheduleAtFixedRate(() -\u003e System.out.println(\"ok\"), 0, 1, TimeUnit.SECONDS); } } 优雅关闭\n优雅关闭 shutdownGracefully 方法。该方法会首先切换 EventLoopGroup 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的\n","wordCount":"1470","inLanguage":"en","datePublished":"2022-07-09T19:12:41Z","dateModified":"2022-07-09T19:12:41Z","author":{"@type":"Person","name":"lu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ethereal-lu.github.io/posts/java/netty/"},"publisher":{"@type":"Organization","name":"lu","logo":{"@type":"ImageObject","url":"https://ethereal-lu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://ethereal-lu.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethereal-lu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ethereal-lu.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Netty</h1><div class=post-meta><span title='2022-07-09 19:12:41 +0000 UTC'>2022-07-09</span>&nbsp;·&nbsp;1470 words&nbsp;·&nbsp;lu</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1-nio基础>1 NIO基础</a><ul><li><a href=#11-三大组件>1.1 三大组件</a></li><li><a href=#12-bytebuffer>1.2 ByteBuffer</a></li><li><a href=#13-filechannel>1.3 FileChannel</a></li><li><a href=#14-网络编程>1.4 网络编程</a></li><li><a href=#15-零拷贝>1.5 零拷贝</a></li><li><a href=#16-aio>1.6 AIO</a></li></ul></li><li><a href=#2-netty-基础>2 Netty 基础</a><ul><li><a href=#21-初体验>2.1 初体验</a></li><li><a href=#22-组件>2.2 组件</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=1-nio基础>1 NIO基础<a hidden class=anchor aria-hidden=true href=#1-nio基础>#</a></h2><p>non-blocking io 非阻塞IO</p><h3 id=11-三大组件>1.1 三大组件<a hidden class=anchor aria-hidden=true href=#11-三大组件>#</a></h3><h4 id=111-channel--buffer>1.1.1 Channel & Buffer<a hidden class=anchor aria-hidden=true href=#111-channel--buffer>#</a></h4><p>Buffer是内存中的数据缓冲区，Channel 是内存与磁盘之间的数据通道。不同于InputStream、OutputStream等BIO中的流都是单向数据通道，Channel 是双向数据通道，可以从 Channel 将数据读入 Buffer，也可以将Buffer 中的数据写入Channel 。</p><p>常见的 Channel 有：</p><ul><li>FileChannel ：文件通道</li><li>DatagramChannel ：udp</li><li>SocketChannel ：tcp；客户端服务端都可以</li><li>ServerSocketChannel ：tcp；专用于服务端</li></ul><p>Buffer 使用最多的就是 ByteBuffer，其他的也是每种基础数据类型有一个对应的Buffer，但用的不多。</p><h4 id=112-selector>1.1.2 Selector<a hidden class=anchor aria-hidden=true href=#112-selector>#</a></h4><p>在使用传统BIO开发时，要么对每个连接都新建一个线程处理（线程太多撑爆内存、线程切换成本高），要么使用线程池（阻塞IO，同时只能处理一个连接，线程利用率不高）&mdash;> 正因为此，原始的HTTP1.0才使用短连接，一个请求处理完立刻释放连接，让线程可以处理其他请求。</p><p>Selector 的作用就是配合一个线程来管理多个Channel ，获取这些Channel 上发生的事件，将有事件发生的Channel 交给线程处理。适合连接数多但流量低的场景，流量大意味着一个Channel 要处理大量数据，会使其他Channel 饥饿。</p><p><img alt=selector loading=lazy src=/posts/java/netty/selector.png></p><h3 id=12-bytebuffer>1.2 ByteBuffer<a hidden class=anchor aria-hidden=true href=#12-bytebuffer>#</a></h3><h4 id=121-基本使用>1.2.1 基本使用<a hidden class=anchor aria-hidden=true href=#121-基本使用>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestByteBuffer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取 FileChannel</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> (FileChannel channel <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FileInputStream(<span style=color:#e6db74>&#34;data.txt&#34;</span>).<span style=color:#a6e22e>getChannel</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 申请 10 个字节的缓冲区</span>
</span></span><span style=display:flex><span>            ByteBuffer buffer <span style=color:#f92672>=</span> ByteBuffer.<span style=color:#a6e22e>allocate</span>(10);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 读取channel中的数据到buffer。read 方法返回读取到的字节数，-1表示读完了</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (channel.<span style=color:#a6e22e>read</span>(buffer) <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span>1) {
</span></span><span style=display:flex><span>                buffer.<span style=color:#a6e22e>flip</span>();  <span style=color:#75715e>// 切换为读模式</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (buffer.<span style=color:#a6e22e>hasRemaining</span>()) {
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(buffer.<span style=color:#a6e22e>get</span>());  <span style=color:#75715e>// get 每次读一个字节</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                buffer.<span style=color:#a6e22e>clear</span>();  <span style=color:#75715e>// 切换为写模式</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (IOException e) {
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=122-内部结构>1.2.2 内部结构<a hidden class=anchor aria-hidden=true href=#122-内部结构>#</a></h4><p>ByteBuffer有以下几个重要属性</p><ul><li>capacity：容量 &mdash;&ndash;> 在任何时候都指向ByteBuffer的末尾</li><li>position：读或者写的当前位置</li><li>limit：读或者写的限制处</li></ul><p>在写模式下limit指向ByteBuffer末尾，position指向当前写入的位置。在读模式下，limit指向写入的最后一个位置，position指向当前读取的位置。</p><p>flip()方法从写模式切换为读模式，即limit指向写入的最后一个位置，position置为 0，从头读。</p><p>clear()方法从读模式切换为写模式，即limit指向ByteBuffer末尾，position置为 0，从头写。</p><p>compact()方法从读模式切换为写模式，但是它会将之前没有读取到的数据移动到ByteBuffer的开头，然后从下一个位置开始写。</p><h4 id=123-方法>1.2.3 方法<a hidden class=anchor aria-hidden=true href=#123-方法>#</a></h4><p>分配空间</p><ul><li><code>ByteBuffer.allocate(10)</code>：<code>HeapByteBuffer</code>，申请的是堆内存，读写效率低，会受到GC影响而在新生代中复制</li><li><code>ByteBuffer.allocateDirect(10)</code>：<code>DirectByteBuffer</code>，申请的是直接内存，读写效率高（零拷贝），不受GC影响，但分配内存需要由操作系统分配，故分配时效率较低。</li></ul><p>向 buffer 写数据</p><ul><li><code>channel.read(buffer)</code></li><li><code>buffer.put((byte)127)</code></li></ul><p>从buffer读数据</p><ul><li><code>channel.write(buffer)</code></li><li><code>buffer.get()</code>。get 方法会让 position 指针向后走，如果想重复读取，有以下两种方法<ul><li>调用 rewind 方法将 position 重置为 0</li><li>调用 get(int i)获取索引为 i 处的内容，指针不移动</li></ul></li></ul><p>mark & reset</p><ul><li>mark：做一个标记，记录 position 位置</li><li>reset：将 position 重新设置为 mark 处，两者一般配合使用。这两个是对 rewind 的增强。</li></ul><p>字符串存入缓冲区</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ByteBuffer buffer <span style=color:#f92672>=</span> ByteBuffer.<span style=color:#a6e22e>wrap</span>(<span style=color:#e6db74>&#34;hello&#34;</span>.<span style=color:#a6e22e>getBytes</span>());  <span style=color:#75715e>// 还有其他方式，需要再看吧</span>
</span></span></code></pre></div><p>批量读取写入：其实就是在channel 的read 和 write 方法中可以传入一个 byteBuffer 数组。</p><h3 id=13-filechannel>1.3 FileChannel<a hidden class=anchor aria-hidden=true href=#13-filechannel>#</a></h3><ul><li><code>FileInputStream</code>、<code>FileOutputStream</code>、<code>RandomAccessFile</code>都可以创建<code>FileChannel</code> ，前两种只能是单向通道，后一种可以指定为“rw”作为双向通道。</li><li>两个<code>FileChannel </code>之间可以通过<code>transferTo()</code>方法传输数据。效率高，底层用操作系统零拷贝实现，最大2G，超过2G的文件需要循环传输</li><li>推荐使用JDK1.7的path和files类操作文件与路径</li><li><code>Files.walkFileTree()</code>可以遍历目录下的所有目录和文件，在遍历过程中可以执行一些自定义操作。</li></ul><h3 id=14-网络编程>1.4 网络编程<a hidden class=anchor aria-hidden=true href=#14-网络编程>#</a></h3><h4 id=141-bio>1.4.1 BIO<a hidden class=anchor aria-hidden=true href=#141-bio>#</a></h4><p>线程与客户端连接之前会阻塞，建立连接后只能服务一个客户端，直到服务结束，线程池也是同样的道理。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>    ServerSocketChannel ssc <span style=color:#f92672>=</span> ServerSocketChannel.<span style=color:#a6e22e>open</span>();
</span></span><span style=display:flex><span>    ssc.<span style=color:#a6e22e>bind</span>(<span style=color:#66d9ef>new</span> InetSocketAddress(8080));
</span></span><span style=display:flex><span>    ByteBuffer buffer <span style=color:#f92672>=</span> ByteBuffer.<span style=color:#a6e22e>allocate</span>(16);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// accept() 会阻塞当前线程，直到有客户端连接它</span>
</span></span><span style=display:flex><span>        SocketChannel sc <span style=color:#f92672>=</span> ssc.<span style=color:#a6e22e>accept</span>();
</span></span><span style=display:flex><span>        sc.<span style=color:#a6e22e>read</span>(buffer);   <span style=color:#75715e>// read 会阻塞当前线程，直到客户端将数据发送过来</span>
</span></span><span style=display:flex><span>        buffer.<span style=color:#a6e22e>flip</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (buffer.<span style=color:#a6e22e>hasRemaining</span>())
</span></span><span style=display:flex><span>            buffer.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>        buffer.<span style=color:#a6e22e>clear</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=142-nio>1.4.2 NIO<a hidden class=anchor aria-hidden=true href=#142-nio>#</a></h4><p>NIO可以解决BIO中单线程只能服务一个客户端的弊端，但是它需要不停地轮询，绝大多数时候都是在空转，浪费资源。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>    ServerSocketChannel ssc <span style=color:#f92672>=</span> ServerSocketChannel.<span style=color:#a6e22e>open</span>();
</span></span><span style=display:flex><span>    ssc.<span style=color:#a6e22e>configureBlocking</span>(<span style=color:#66d9ef>false</span>);          <span style=color:#75715e>// 非阻塞模式，这里影响的是下方的 accept 方法。</span>
</span></span><span style=display:flex><span>    ssc.<span style=color:#a6e22e>bind</span>(<span style=color:#66d9ef>new</span> InetSocketAddress(8080));
</span></span><span style=display:flex><span>    ByteBuffer buffer <span style=color:#f92672>=</span> ByteBuffer.<span style=color:#a6e22e>allocate</span>(16);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>SocketChannel<span style=color:#f92672>&gt;</span> channels <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>        SocketChannel sc <span style=color:#f92672>=</span> ssc.<span style=color:#a6e22e>accept</span>();   <span style=color:#75715e>// 非阻塞，如果没有建立连接，返回的 sc 为null</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (sc <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            sc.<span style=color:#a6e22e>configureBlocking</span>(<span style=color:#66d9ef>false</span>);   <span style=color:#75715e>// 非阻塞模式，这里影响的是下方的 read 方法</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 非阻塞模式下可以与多个客户端同时连接，此处将所有客户端存储起来，方便后续轮询</span>
</span></span><span style=display:flex><span>            channels.<span style=color:#a6e22e>add</span>(sc);              
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (SocketChannel channel : channels) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> read <span style=color:#f92672>=</span> channel.<span style=color:#a6e22e>read</span>(buffer);    <span style=color:#75715e>// 非阻塞，如果客户端没有发送数据，返回的读取数为 0</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (read <span style=color:#f92672>&gt;</span> 0) {
</span></span><span style=display:flex><span>                buffer.<span style=color:#a6e22e>flip</span>();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (buffer.<span style=color:#a6e22e>hasRemaining</span>())
</span></span><span style=display:flex><span>                    buffer.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>                buffer.<span style=color:#a6e22e>clear</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=143-io多路复用-selector>1.4.3 IO多路复用-Selector<a hidden class=anchor aria-hidden=true href=#143-io多路复用-selector>#</a></h4><p>多路复用只能用于网络编程，普通文件读写没法使用。</p><p>事件类型有以下四种：</p><ul><li>accept：当客户端发起连接请求时，在服务端产生事件</li><li>connect：连接建立成功后，在客户端触发 &mdash; 一般用不到</li><li>read：可读事件</li><li>write：可写事件</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 相当于使用 epoll_create 创建一个 epoll 实例</span>
</span></span><span style=display:flex><span>    Selector selector <span style=color:#f92672>=</span> Selector.<span style=color:#a6e22e>open</span>();
</span></span><span style=display:flex><span>    ServerSocketChannel ssc <span style=color:#f92672>=</span> ServerSocketChannel.<span style=color:#a6e22e>open</span>();
</span></span><span style=display:flex><span>    ssc.<span style=color:#a6e22e>configureBlocking</span>(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将通道注册到 selector，并关注 accept 事件；相当于把 ssc 这个 channel 的 fd 通过 epoll_ctl 注册到红黑树</span>
</span></span><span style=display:flex><span>    ssc.<span style=color:#a6e22e>register</span>(selector, SelectionKey.<span style=color:#a6e22e>OP_ACCEPT</span>);
</span></span><span style=display:flex><span>    ssc.<span style=color:#a6e22e>bind</span>(<span style=color:#66d9ef>new</span> InetSocketAddress(8081));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 此处相当于调用 epoll_wait，没有事件发生则线程阻塞，有事件才会唤醒。</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 这里使用水平触发，如果事件未处理就类似于NIO，会一直循环直到你处理了。cancel()方法会从红黑树和链表都删除fd</span>
</span></span><span style=display:flex><span>        selector.<span style=color:#a6e22e>select</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 取出链表中的事件遍历处理</span>
</span></span><span style=display:flex><span>        Iterator<span style=color:#f92672>&lt;</span>SelectionKey<span style=color:#f92672>&gt;</span> iter <span style=color:#f92672>=</span> selector.<span style=color:#a6e22e>selectedKeys</span>().<span style=color:#a6e22e>iterator</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (iter.<span style=color:#a6e22e>hasNext</span>()){
</span></span><span style=display:flex><span>            SelectionKey key <span style=color:#f92672>=</span> iter.<span style=color:#a6e22e>next</span>();
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 重点：每发生一个事件，都会将该事件的 fd 从红黑树复制到链表中，但是事件处理完成后不会自动从链表删除。</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 这就意味着下次遍历链表时还会遍历到它，但是它已经被处理过了，也就是此时它没有事件发生，就会造成异常。</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 比如此时 accept 没有事件但是会进入它的分支，导致返回的 sc 为null，再执行后续操作会爆空指针异常。</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 因此，每次处理完成一个事件后必须手动删除它。</span>
</span></span><span style=display:flex><span>            iter.<span style=color:#a6e22e>remove</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (key.<span style=color:#a6e22e>isAcceptable</span>()) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 因为关注 accept 事件的只有 ssc，故此处 key.channel() 获取到的就是上方的 ssc</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 可以直接使用 ssc 替换下方两句</span>
</span></span><span style=display:flex><span>                ServerSocketChannel channel <span style=color:#f92672>=</span> (ServerSocketChannel) key.<span style=color:#a6e22e>channel</span>();
</span></span><span style=display:flex><span>                SocketChannel sc <span style=color:#f92672>=</span> channel.<span style=color:#a6e22e>accept</span>();
</span></span><span style=display:flex><span>                sc.<span style=color:#a6e22e>configureBlocking</span>(<span style=color:#66d9ef>false</span>);   <span style=color:#75715e>// 非阻塞模式才能配合 Selector 使用</span>
</span></span><span style=display:flex><span>                sc.<span style=color:#a6e22e>register</span>(selector, SelectionKey.<span style=color:#a6e22e>OP_READ</span>);  <span style=color:#75715e>// 注册并关注读事件</span>
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (key.<span style=color:#a6e22e>isReadable</span>()) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 不论客户端是正常退出还是异常退出，都会触发一个读事件</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    SocketChannel channel <span style=color:#f92672>=</span> (SocketChannel) key.<span style=color:#a6e22e>channel</span>();
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 此处在这里新建 buffer 而不是在 accept 事件中注册时添加附件，是因为下方服务器响应时会覆盖附件</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 而 accept 事件只有连接时触发一次，这样的话之后的读操作就获取不到 buffer 了</span>
</span></span><span style=display:flex><span>                    ByteBuffer buffer <span style=color:#f92672>=</span> ByteBuffer.<span style=color:#a6e22e>allocate</span>(1024);
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 如果客户端异常退出，触发读事件进行到这里时，read 操作会抛出 IOException，所以需要捕获处理</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>int</span> read <span style=color:#f92672>=</span> channel.<span style=color:#a6e22e>read</span>(buffer);   <span style=color:#75715e>// 如果 buffer 较小一次没读完，会触发多次读事件</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 如果客户端正常退出，只有客户端调用 close 方法才是正常退出，即数据流读到了末尾</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 这时 read 方法的返回值为 0 或 -1。cancel()方法会从红黑树中删除 fd。</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 注意：如果是正常有数据过来触发的读事件，能读出的数据一定大于 0</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (read <span style=color:#f92672>&lt;=</span> 0) {
</span></span><span style=display:flex><span>                        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;stream end&#34;</span>);
</span></span><span style=display:flex><span>                        key.<span style=color:#a6e22e>cancel</span>();   <span style=color:#75715e>// 既然客户端已经断开连接，那红黑树中的 fd 就没必要监听了</span>
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        buffer.<span style=color:#a6e22e>flip</span>();
</span></span><span style=display:flex><span>                        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;服务端处理消息&#34;</span> <span style=color:#f92672>+</span> Charset.<span style=color:#a6e22e>defaultCharset</span>().<span style=color:#a6e22e>decode</span>(buffer));
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// 此处服务端读取完客户端信息后开始响应消息</span>
</span></span><span style=display:flex><span>                        key.<span style=color:#a6e22e>interestOps</span>(key.<span style=color:#a6e22e>interestOps</span>() <span style=color:#f92672>|</span> SelectionKey.<span style=color:#a6e22e>OP_WRITE</span>);  <span style=color:#75715e>// 添加监听写事件</span>
</span></span><span style=display:flex><span>                        key.<span style=color:#a6e22e>attach</span>(ByteBuffer.<span style=color:#a6e22e>wrap</span>(<span style=color:#e6db74>&#34;服务端响应的消息&#34;</span>.<span style=color:#a6e22e>getBytes</span>()));
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (IOException e) {
</span></span><span style=display:flex><span>                    e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>                    key.<span style=color:#a6e22e>cancel</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (key.<span style=color:#a6e22e>isWritable</span>()) {
</span></span><span style=display:flex><span>                SocketChannel channel <span style=color:#f92672>=</span> (SocketChannel) key.<span style=color:#a6e22e>channel</span>();
</span></span><span style=display:flex><span>                ByteBuffer buffer <span style=color:#f92672>=</span> (ByteBuffer) key.<span style=color:#a6e22e>attachment</span>();
</span></span><span style=display:flex><span>                channel.<span style=color:#a6e22e>write</span>(buffer);    <span style=color:#75715e>// channel 容量有限，如果一次写不完就需要触发多次写事件</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>buffer.<span style=color:#a6e22e>hasRemaining</span>()) {
</span></span><span style=display:flex><span>                    key.<span style=color:#a6e22e>attach</span>(<span style=color:#66d9ef>null</span>);   <span style=color:#75715e>// 将附件扔掉，以免浪费空间</span>
</span></span><span style=display:flex><span>                    key.<span style=color:#a6e22e>interestOps</span>(key.<span style=color:#a6e22e>interestOps</span>() <span style=color:#f92672>^</span> SelectionKey.<span style=color:#a6e22e>OP_WRITE</span>); <span style=color:#75715e>// 写完了就取消监听写事件</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上方代码中没有考虑消息边界的处理，即如果 <code>ByteBuffer</code>设置的太小，则会产生半包，如用 4 字节的 <code>ByteBuffer</code>接收两个汉字（UTF-8），则第一个汉字正常处理，第二个汉字会拆成两半无法正常解码。一种解决方法是初始申请较小空间，如果空间不足则扩容，这种方法需要指定消息边界，如使用 <code>\n</code>作为一条消息的结尾，则逐一遍历消息中的每个 <code>byte</code>，若 <code>ByteBuffer</code>遍历完依然没有找到<code>\n</code>就要扩容。</p><p>如果初始申请的 <code>ByteBuffer</code>就很大，则服务器连接几个客户端就把内存占满了，不划算。</p><h4 id=144-多线程优化>1.4.4 多线程优化<a hidden class=anchor aria-hidden=true href=#144-多线程优化>#</a></h4><p>单线程配合 Selector 已经可以实现多路复用，但是无法充分利用多核CPU，且如果一个事件需要耗费很长时间，就会使其他事件等待。</p><p><strong>初始版本</strong>：由于 <code>register</code>和 <code>select</code>造成死锁，无法将通道注册到 <code>Selector</code>，所以不能用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MultiThreadServer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// master 只负责接受连接，具体的读写交给 Worker</span>
</span></span><span style=display:flex><span>        Selector master <span style=color:#f92672>=</span> Selector.<span style=color:#a6e22e>open</span>();
</span></span><span style=display:flex><span>        ServerSocketChannel ssc <span style=color:#f92672>=</span> ServerSocketChannel.<span style=color:#a6e22e>open</span>();
</span></span><span style=display:flex><span>        ssc.<span style=color:#a6e22e>configureBlocking</span>(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>        ssc.<span style=color:#a6e22e>register</span>(master, SelectionKey.<span style=color:#a6e22e>OP_ACCEPT</span>);
</span></span><span style=display:flex><span>        ssc.<span style=color:#a6e22e>bind</span>(<span style=color:#66d9ef>new</span> InetSocketAddress(8081));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建固定大小的 worker，一般取核心数个</span>
</span></span><span style=display:flex><span>        Worker worker <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Worker(<span style=color:#e6db74>&#34;worker-0&#34;</span>); 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>            master.<span style=color:#a6e22e>select</span>();
</span></span><span style=display:flex><span>            Iterator<span style=color:#f92672>&lt;</span>SelectionKey<span style=color:#f92672>&gt;</span> iter <span style=color:#f92672>=</span> master.<span style=color:#a6e22e>selectedKeys</span>().<span style=color:#a6e22e>iterator</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (iter.<span style=color:#a6e22e>hasNext</span>()) {
</span></span><span style=display:flex><span>                SelectionKey key <span style=color:#f92672>=</span> iter.<span style=color:#a6e22e>next</span>();
</span></span><span style=display:flex><span>                iter.<span style=color:#a6e22e>remove</span>();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (key.<span style=color:#a6e22e>isAcceptable</span>()) {
</span></span><span style=display:flex><span>                    SocketChannel sc <span style=color:#f92672>=</span> ssc.<span style=color:#a6e22e>accept</span>();
</span></span><span style=display:flex><span>                    sc.<span style=color:#a6e22e>configureBlocking</span>(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 将客户通道注册到 worker 的 selector</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 观察源码可知，该方法最终会调用 selector 的注册方法，且这个方法会和 selector.select() 竞争锁</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 由于 selector.select() 先执行已经获取了锁，此方法就被阻塞，而 select 方法没有事件又持续阻塞</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 所以造成死锁。（由此可见，select 方法阻塞也不会释放锁。）</span>
</span></span><span style=display:flex><span>                    sc.<span style=color:#a6e22e>register</span>(worker.<span style=color:#a6e22e>selector</span>, SelectionKey.<span style=color:#a6e22e>OP_READ</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Worker</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Selector selector;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Thread thread;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Worker</span>(String name) <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>selector</span> <span style=color:#f92672>=</span> Selector.<span style=color:#a6e22e>open</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>thread</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(<span style=color:#66d9ef>this</span>, name);
</span></span><span style=display:flex><span>            thread.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>                selector.<span style=color:#a6e22e>select</span>();
</span></span><span style=display:flex><span>                Iterator<span style=color:#f92672>&lt;</span>SelectionKey<span style=color:#f92672>&gt;</span> iter <span style=color:#f92672>=</span> selector.<span style=color:#a6e22e>selectedKeys</span>().<span style=color:#a6e22e>iterator</span>();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (iter.<span style=color:#a6e22e>hasNext</span>()) {
</span></span><span style=display:flex><span>                    SelectionKey key <span style=color:#f92672>=</span> iter.<span style=color:#a6e22e>next</span>();
</span></span><span style=display:flex><span>                    iter.<span style=color:#a6e22e>remove</span>();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (key.<span style=color:#a6e22e>isReadable</span>()) {
</span></span><span style=display:flex><span>                        ByteBuffer buffer <span style=color:#f92672>=</span> ByteBuffer.<span style=color:#a6e22e>allocate</span>(1024);
</span></span><span style=display:flex><span>                        SocketChannel sc <span style=color:#f92672>=</span> (SocketChannel) key.<span style=color:#a6e22e>channel</span>();
</span></span><span style=display:flex><span>                        sc.<span style=color:#a6e22e>read</span>(buffer);
</span></span><span style=display:flex><span>                        buffer.<span style=color:#a6e22e>flip</span>();
</span></span><span style=display:flex><span>                        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;thread: &#34;</span> <span style=color:#f92672>+</span> thread.<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;--&gt; charge for: &#34;</span>
</span></span><span style=display:flex><span>                                <span style=color:#f92672>+</span> Charset.<span style=color:#a6e22e>defaultCharset</span>().<span style=color:#a6e22e>decode</span>(buffer));
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>优化</strong>：将注册的事交给子线程去执行。最关键的点还是 <code>selector.wakeup();</code>，netty 就是通过消息队列实现的工作传递</p><p>注意：wakeup 和 select 的关系与 unpark 和 park 相似。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MultiThreadServer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>        Selector master <span style=color:#f92672>=</span> Selector.<span style=color:#a6e22e>open</span>();
</span></span><span style=display:flex><span>        ServerSocketChannel ssc <span style=color:#f92672>=</span> ServerSocketChannel.<span style=color:#a6e22e>open</span>();
</span></span><span style=display:flex><span>        ssc.<span style=color:#a6e22e>configureBlocking</span>(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>        ssc.<span style=color:#a6e22e>register</span>(master, SelectionKey.<span style=color:#a6e22e>OP_ACCEPT</span>);
</span></span><span style=display:flex><span>        ssc.<span style=color:#a6e22e>bind</span>(<span style=color:#66d9ef>new</span> InetSocketAddress(8081));
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Runtime.getRuntime().availableProcessors() 获取的是物理机的核心数</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 对于 docker 类容器就会有问题，因为实际不可能把所有核心分配给 docker</span>
</span></span><span style=display:flex><span>        Worker<span style=color:#f92672>[]</span> workers <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Worker<span style=color:#f92672>[</span>Runtime.<span style=color:#a6e22e>getRuntime</span>().<span style=color:#a6e22e>availableProcessors</span>()<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> workers.<span style=color:#a6e22e>length</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            workers<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Worker(<span style=color:#e6db74>&#34;worker-&#34;</span> <span style=color:#f92672>+</span> i);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        AtomicInteger index <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AtomicInteger();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>            master.<span style=color:#a6e22e>select</span>();
</span></span><span style=display:flex><span>            Iterator<span style=color:#f92672>&lt;</span>SelectionKey<span style=color:#f92672>&gt;</span> iter <span style=color:#f92672>=</span> master.<span style=color:#a6e22e>selectedKeys</span>().<span style=color:#a6e22e>iterator</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (iter.<span style=color:#a6e22e>hasNext</span>()) {
</span></span><span style=display:flex><span>                SelectionKey key <span style=color:#f92672>=</span> iter.<span style=color:#a6e22e>next</span>();
</span></span><span style=display:flex><span>                iter.<span style=color:#a6e22e>remove</span>();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (key.<span style=color:#a6e22e>isAcceptable</span>()) {
</span></span><span style=display:flex><span>                    SocketChannel sc <span style=color:#f92672>=</span> ssc.<span style=color:#a6e22e>accept</span>();
</span></span><span style=display:flex><span>                    sc.<span style=color:#a6e22e>configureBlocking</span>(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 将注册这个工作放到消息队列，同时唤醒子线程。负载均衡</span>
</span></span><span style=display:flex><span>                    workers<span style=color:#f92672>[</span>index.<span style=color:#a6e22e>incrementAndGet</span>() <span style=color:#f92672>%</span> workers.<span style=color:#a6e22e>length</span><span style=color:#f92672>]</span>.<span style=color:#a6e22e>register</span>(sc);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Worker</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Selector selector;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Thread thread;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ConcurrentLinkedQueue<span style=color:#f92672>&lt;</span>Runnable<span style=color:#f92672>&gt;</span> queue;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Worker</span>(String name) <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>selector</span> <span style=color:#f92672>=</span> Selector.<span style=color:#a6e22e>open</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>queue</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConcurrentLinkedQueue<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>thread</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(<span style=color:#66d9ef>this</span>, name);
</span></span><span style=display:flex><span>            thread.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>register</span>(SocketChannel sc) {
</span></span><span style=display:flex><span>            queue.<span style=color:#a6e22e>add</span>(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    sc.<span style=color:#a6e22e>register</span>(selector, SelectionKey.<span style=color:#a6e22e>OP_READ</span>);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (ClosedChannelException e) {
</span></span><span style=display:flex><span>                    e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>            selector.<span style=color:#a6e22e>wakeup</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>                selector.<span style=color:#a6e22e>select</span>();
</span></span><span style=display:flex><span>                Runnable task <span style=color:#f92672>=</span> queue.<span style=color:#a6e22e>poll</span>();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (task <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                    task.<span style=color:#a6e22e>run</span>();   <span style=color:#75715e>// 这里才将通道注册到子线程的 selector</span>
</span></span><span style=display:flex><span>                Iterator<span style=color:#f92672>&lt;</span>SelectionKey<span style=color:#f92672>&gt;</span> iter <span style=color:#f92672>=</span> selector.<span style=color:#a6e22e>selectedKeys</span>().<span style=color:#a6e22e>iterator</span>();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (iter.<span style=color:#a6e22e>hasNext</span>()) {
</span></span><span style=display:flex><span>                    SelectionKey key <span style=color:#f92672>=</span> iter.<span style=color:#a6e22e>next</span>();
</span></span><span style=display:flex><span>                    iter.<span style=color:#a6e22e>remove</span>();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (key.<span style=color:#a6e22e>isReadable</span>()) {
</span></span><span style=display:flex><span>                        ByteBuffer buffer <span style=color:#f92672>=</span> ByteBuffer.<span style=color:#a6e22e>allocate</span>(1024);
</span></span><span style=display:flex><span>                        SocketChannel sc <span style=color:#f92672>=</span> (SocketChannel) key.<span style=color:#a6e22e>channel</span>();
</span></span><span style=display:flex><span>                        sc.<span style=color:#a6e22e>read</span>(buffer);
</span></span><span style=display:flex><span>                        buffer.<span style=color:#a6e22e>flip</span>();
</span></span><span style=display:flex><span>                        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;thread: &#34;</span> <span style=color:#f92672>+</span> thread.<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;--&gt; charge for: &#34;</span>
</span></span><span style=display:flex><span>                                <span style=color:#f92672>+</span> Charset.<span style=color:#a6e22e>defaultCharset</span>().<span style=color:#a6e22e>decode</span>(buffer));
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=15-零拷贝>1.5 零拷贝<a hidden class=anchor aria-hidden=true href=#15-零拷贝>#</a></h3><h4 id=151-传统-io-问题>1.5.1 传统 IO 问题<a hidden class=anchor aria-hidden=true href=#151-传统-io-问题>#</a></h4><p>传统的 IO 将一个文件通过 socket 写出</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>File f <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> File(<span style=color:#e6db74>&#34;helloword/data.txt&#34;</span>);
</span></span><span style=display:flex><span>RandomAccessFile file <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> RandomAccessFile(file, <span style=color:#e6db74>&#34;r&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> buf <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[</span>(<span style=color:#66d9ef>int</span>)f.<span style=color:#a6e22e>length</span>()<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>file.<span style=color:#a6e22e>read</span>(buf);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Socket socket <span style=color:#f92672>=</span> ...;
</span></span><span style=display:flex><span>socket.<span style=color:#a6e22e>getOutputStream</span>().<span style=color:#a6e22e>write</span>(buf);
</span></span></code></pre></div><p>内部工作流程是这样的：</p><p><img alt=传统IO loading=lazy src=/posts/java/netty/%E4%BC%A0%E7%BB%9FIO.jpg></p><ol><li><p>读数据过程：</p><ul><li>应用程序要读取磁盘数据，调用read()函数从而实现用户态切换内核态，这是第1次状态切换；</li><li>DMA控制器将数据从磁盘拷贝到内核缓冲区，这是第1次DMA拷贝；</li><li>CPU将数据从内核缓冲区复制到用户缓冲区，这是第1次CPU拷贝；</li><li>CPU完成拷贝之后，read()函数返回实现内核态切换用户态，这是第2次状态切换；</li></ul></li><li><p>写数据过程：</p><ul><li>应用程序要向网卡写数据，调用write()函数实现用户态切换内核态，这是第1次切换；</li><li>CPU将用户缓冲区数据拷贝到内核缓冲区，这是第1次CPU拷贝；</li><li>DMA控制器将数据从内核缓冲区复制到socket缓冲区，这是第1次DMA拷贝；</li><li>完成拷贝之后，write()函数返回实现内核态切换用户态，这是第2次切换；</li></ul></li></ol><p>综上所述：</p><ul><li>读过程涉及2次空间切换、1次DMA拷贝、1次CPU拷贝；</li><li>写过程涉及2次空间切换、1次DMA拷贝、1次CPU拷贝；</li></ul><p>可见传统模式下，涉及多次空间切换和数据冗余拷贝，效率并不高，接下来就该零拷贝技术出场了。</p><h4 id=152-nio-优化>1.5.2 NIO 优化<a hidden class=anchor aria-hidden=true href=#152-nio-优化>#</a></h4><p>通过 DirectByteBuf ，即 mmap</p><ul><li>ByteBuffer.allocate(10) HeapByteBuffer 使用的还是 java 内存</li><li>ByteBuffer.allocateDirect(10) DirectByteBuffer 使用的是操作系统内存</li></ul><p><img alt=mmap loading=lazy src=/posts/java/netty/mmap.jpg></p><p>大部分步骤与优化前相同，不再赘述。唯有一点：java 可以使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用</p><ul><li>这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li><li>java 中的 DirectByteBuf 对象仅维护了此内存的虚引用 Cleaner，内存回收分成两步<ul><li>DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列</li><li>通过专门的回收线程访问引用队列，根据虚引用释放堆外内存</li></ul></li><li>减少了一次数据拷贝，用户态与内核态的切换次数没有减少。 2dma + 1cpu</li></ul><p>以下两种方式，由于数据不经过用户缓冲区，因此无法修改。</p><p>进一步优化（底层采用了 linux 2.1 后提供的 sendFile 方法），java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据</p><p><img alt=sendfile loading=lazy src=/posts/java/netty/sendfile.jpg></p><ol><li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li><li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</li><li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu，方法结束后切换回用户态</li></ol><p>可以看到</p><ul><li>只发生了2次用户态与内核态的切换</li><li>数据拷贝了 3 次 。2dma + 1cpu</li></ul><p>进一步优化（linux 2.4）</p><p><img alt=sendfile+dma loading=lazy src=/posts/java/netty/sendfile+dma.jpg></p><ol><li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li><li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li><li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 cpu，方法结束后切换回用户态</li></ol><p>整个过程仅只发生了2次用户态与内核态的切换，数据拷贝了 2 次。所谓的【零拷贝】，并不是真正无拷贝，而是在不会在内核态和用户态之间拷贝数据，零拷贝的优点有</p><ul><li>更少的用户态与内核态的切换</li><li>不利用 cpu 计算，减少 cpu 缓存伪共享</li><li>零拷贝适合小文件传输</li></ul><h3 id=16-aio>1.6 AIO<a hidden class=anchor aria-hidden=true href=#16-aio>#</a></h3><p>netty 不支持 AIO，因为 linux 不支持AIO（现在貌似支持了）</p><h2 id=2-netty-基础>2 Netty 基础<a hidden class=anchor aria-hidden=true href=#2-netty-基础>#</a></h2><p>Netty 的网络模型依然是多路复用</p><p>一开始需要树立正确的观念</p><ul><li>把 channel 理解为数据的通道</li><li>把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf</li><li>把 handler 理解为数据的处理工序<ul><li>工序有多道，合在一起就是 pipeline，pipeline 负责发布事件（读、读取完成&mldr;）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</li><li>handler 分 Inbound 和 Outbound 两类，分别对入站和出站的数据处理</li></ul></li><li>把 eventLoop 理解为处理数据的工人<ul><li>工人可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定）（避免多个线程对同一个channel操作引发并发问题）</li><li>工人既可以执行 io 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li><li>工人按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每道工序指定不同的工人</li></ul></li></ul><h3 id=21-初体验>2.1 初体验<a hidden class=anchor aria-hidden=true href=#21-初体验>#</a></h3><p>注意：下方代码都是固定格式，不同场景只需要更换不同处理器即可，格式不变</p><p>服务端：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HelloServer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 服务器端启动器，负责组装 netty 组件，启动服务器</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> ServerBootstrap()
</span></span><span style=display:flex><span>                <span style=color:#75715e>// EventLoop 即事件循环，其中包含(selector,thread)，作用和之前手写的 master、worker一样</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 每个 EventLoop 负责监听一部分事件，group 即有多个 EventLoop</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 这其中会有一个 master 负责 accept 建立连接</span>
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>group</span>(<span style=color:#66d9ef>new</span> NioEventLoopGroup())
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 选择服务器的 ServerSocketChannel</span>
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>channel</span>(NioServerSocketChannel.<span style=color:#a6e22e>class</span>)
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 此处 child 即之前的 worker，负责处理读写，这里编写 child 需要处理的逻辑</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 此处只是添加了处理器，需要等到 accept 建立连接之后才会真正执行处理器的逻辑</span>
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>childHandler</span>(
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// 泛型表示这是为 NioSocketChannel 进行初始化，初始化即为这个泛型中通道配置一些 Handler</span>
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// NioSocketChannel 即与客户端进行数据读写的通道。</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>new</span> ChannelInitializer<span style=color:#f92672>&lt;</span>NioSocketChannel<span style=color:#f92672>&gt;</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>@Override</span>  <span style=color:#75715e>// 在连接建立之后被调用</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initChannel</span>(NioSocketChannel ch) {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// 添加具体的处理器</span>
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// 注意：这里也只是将一个个处理器添加到通道中，真正执行是在数据经过通道时</span>
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// 不论是收还是发数据都会经过所有的处理器，只是如下方的channelRead它只在读数据时起作用</span>
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// 客户端的一个个处理器与这里一样，也是收发数据时才真正执行</span>
</span></span><span style=display:flex><span>                        ch.<span style=color:#a6e22e>pipeline</span>().<span style=color:#a6e22e>addLast</span>(<span style=color:#66d9ef>new</span> StringDecoder());   <span style=color:#75715e>// 将 ByteBuf 转化为字符串</span>
</span></span><span style=display:flex><span>                        ch.<span style=color:#a6e22e>pipeline</span>().<span style=color:#a6e22e>addLast</span>(<span style=color:#66d9ef>new</span> ChannelInboundHandlerAdapter() { <span style=color:#75715e>// 自定义 handler</span>
</span></span><span style=display:flex><span>                            <span style=color:#a6e22e>@Override</span>     <span style=color:#75715e>// 处理读事件</span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>channelRead</span>(ChannelHandlerContext ctx, Object msg) {
</span></span><span style=display:flex><span>                                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(msg);
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        });
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                })
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>bind</span>(8080);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>客户端：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HelloClient</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 客户端启动类</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Bootstrap()
</span></span><span style=display:flex><span>                <span style=color:#75715e>// EventLoop 对于客户端没啥用，但是 netty 中统一格式</span>
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>group</span>(<span style=color:#66d9ef>new</span> NioEventLoopGroup())
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 选择 channel</span>
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>channel</span>(NioSocketChannel.<span style=color:#a6e22e>class</span>)
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 添加处理器</span>
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>handler</span>(<span style=color:#66d9ef>new</span> ChannelInitializer<span style=color:#f92672>&lt;</span>NioSocketChannel<span style=color:#f92672>&gt;</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>@Override</span>   <span style=color:#75715e>// 在连接建立之后被调用</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initChannel</span>(NioSocketChannel ch) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// 将字符串编码为 ByteBuf</span>
</span></span><span style=display:flex><span>                        ch.<span style=color:#a6e22e>pipeline</span>().<span style=color:#a6e22e>addLast</span>(<span style=color:#66d9ef>new</span> StringEncoder());
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                })
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 连接到服务器</span>
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>connect</span>(<span style=color:#66d9ef>new</span> InetSocketAddress(<span style=color:#e6db74>&#34;localhost&#34;</span>, 8080))
</span></span><span style=display:flex><span>                <span style=color:#75715e>// sync 是阻塞方法，等到连接建立之后才允许继续执行下方代码</span>
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>sync</span>()
</span></span><span style=display:flex><span>                <span style=color:#75715e>// channel 即客户端与服务端之间的数据通道</span>
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>channel</span>()
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 向服务器发送数据</span>
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>writeAndFlush</span>(<span style=color:#e6db74>&#34;hello netty!&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=22-组件>2.2 组件<a hidden class=anchor aria-hidden=true href=#22-组件>#</a></h3><h4 id=221-eventloop>2.2.1 EventLoop<a hidden class=anchor aria-hidden=true href=#221-eventloop>#</a></h4><p>EventLoop 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 io 事件。继承了 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</p><p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// EventLoopGroup 基础使用</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EventLoopTest</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 参数为 EventLoop 的数量，默认为 核心数 * 2</span>
</span></span><span style=display:flex><span>        EventLoopGroup group <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> NioEventLoopGroup(3);   <span style=color:#75715e>// IO事件，普通任务，定时任务</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// DefaultEventLoop 不能执行 IO 事件，其他和 NioEventLoopGroup 一样</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取下一个 EventLoop</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(group.<span style=color:#a6e22e>next</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 执行普通任务</span>
</span></span><span style=display:flex><span>        group.<span style=color:#a6e22e>next</span>().<span style=color:#a6e22e>submit</span>(() <span style=color:#f92672>-&gt;</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;子线程&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 执行定时任务 （0秒后开始，每 1 秒执行一次）</span>
</span></span><span style=display:flex><span>        group.<span style=color:#a6e22e>next</span>().<span style=color:#a6e22e>scheduleAtFixedRate</span>(() <span style=color:#f92672>-&gt;</span> System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;ok&#34;</span>), 0, 1, TimeUnit.<span style=color:#a6e22e>SECONDS</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>优雅关闭</strong></p><p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethereal-lu.github.io/posts/%E9%9D%A2%E7%BB%8F/%E5%B1%B1%E8%A5%BF%E5%BB%BA%E8%A1%8C%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/><span class=title>« Prev</span><br><span>山西建行暑期实习面经</span>
</a><a class=next href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8/kuberbetes/kuberbetes%E5%9F%BA%E7%A1%80/><span class=title>Next »</span><br><span>Kuberbetes基础</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>