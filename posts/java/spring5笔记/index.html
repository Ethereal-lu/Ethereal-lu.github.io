<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Spring5学习笔记 | lu</title>
<meta name=keywords content><meta name=description content='IOC： 控制反转，把创建对象的过程交给Spring进行管理   
Aop： 面向切片，不修改源代码进行功能增强
Spring5入门案例基本步骤：   
1、创建项目   
2、在项目中创建一个lib文件夹，把需要的jar包复制进来   
3、点击  file -> project structure -> modules -> dependencies -> 左下角的 + 号 -> jars or directories -> 选中刚复制过来的jar包，将导入的jar包全选，点击ok   
4、创建普通类User   
5、创建Spring配置文件，在配置文件配置创建的对象在src中创建xml格式的Spring配置文件， 在<beans>的内部末尾添加   
<!&ndash;配置User对象创建&ndash;>  <bean id=&ldquo;user&rdquo; class=&ldquo;com.ethereal.spring5.User&rdquo;></bean> 两行
6、进行测试代码编写
        public class TestSpring5 {      
            @Test      
            public void testAdd() {      
                // 加载spring配置文件      
                ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml");      
                // 获取配置创建的对象      
                User user = context.getBean("user", User.class);      
      
                System.out.println(user);      
                user.add();      
            }      
        }

IOC容器： (Inversion of Control) 控制反转，把创建对象和对象之间调用的过程交给Spring进行管理   
1、IOC底层原理     xml解析 + 反射 + 工厂模式      （降低耦合度）'><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/posts/java/spring5%E7%AC%94%E8%AE%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity="sha256-1yREUm1+y9sAFUOKf6iQVKZYv3WdBULi5d+BzpS0k+4=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/posts/java/spring5%E7%AC%94%E8%AE%B0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/posts/java/spring5%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="lu"><meta property="og:title" content="Spring5学习笔记"><meta property="og:description" content='IOC： 控制反转，把创建对象的过程交给Spring进行管理 Aop： 面向切片，不修改源代码进行功能增强
Spring5入门案例基本步骤： 1、创建项目 2、在项目中创建一个lib文件夹，把需要的jar包复制进来 3、点击 file -> project structure -> modules -> dependencies -> 左下角的 + 号 -> jars or directories -> 选中刚复制过来的jar包，将导入的jar包全选，点击ok 4、创建普通类User 5、创建Spring配置文件，在配置文件配置创建的对象在src中创建xml格式的Spring配置文件， 在<beans>的内部末尾添加 <!–配置User对象创建–> <bean id=“user” class=“com.ethereal.spring5.User”></bean> 两行
6、进行测试代码编写
public class TestSpring5 { @Test public void testAdd() { // 加载spring配置文件 ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml"); // 获取配置创建的对象 User user = context.getBean("user", User.class); System.out.println(user); user.add(); } } IOC容器： (Inversion of Control) 控制反转，把创建对象和对象之间调用的过程交给Spring进行管理 1、IOC底层原理 xml解析 + 反射 + 工厂模式 （降低耦合度）'><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-20T15:39:41+00:00"><meta property="article:modified_time" content="2021-04-20T15:39:41+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Spring5学习笔记"><meta name=twitter:description content='IOC： 控制反转，把创建对象的过程交给Spring进行管理   
Aop： 面向切片，不修改源代码进行功能增强
Spring5入门案例基本步骤：   
1、创建项目   
2、在项目中创建一个lib文件夹，把需要的jar包复制进来   
3、点击  file -> project structure -> modules -> dependencies -> 左下角的 + 号 -> jars or directories -> 选中刚复制过来的jar包，将导入的jar包全选，点击ok   
4、创建普通类User   
5、创建Spring配置文件，在配置文件配置创建的对象在src中创建xml格式的Spring配置文件， 在<beans>的内部末尾添加   
<!&ndash;配置User对象创建&ndash;>  <bean id=&ldquo;user&rdquo; class=&ldquo;com.ethereal.spring5.User&rdquo;></bean> 两行
6、进行测试代码编写
        public class TestSpring5 {      
            @Test      
            public void testAdd() {      
                // 加载spring配置文件      
                ApplicationContext context = new ClassPathXmlApplicationContext("bean1.xml");      
                // 获取配置创建的对象      
                User user = context.getBean("user", User.class);      
      
                System.out.println(user);      
                user.add();      
            }      
        }

IOC容器： (Inversion of Control) 控制反转，把创建对象和对象之间调用的过程交给Spring进行管理   
1、IOC底层原理     xml解析 + 反射 + 工厂模式      （降低耦合度）'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ethereal-lu.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Spring5学习笔记","item":"https://ethereal-lu.github.io/posts/java/spring5%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Spring5学习笔记","name":"Spring5学习笔记","description":"IOC： 控制反转，把创建对象的过程交给Spring进行管理 Aop： 面向切片，不修改源代码进行功能增强\nSpring5入门案例基本步骤： 1、创建项目 2、在项目中创建一个lib文件夹，把需要的jar包复制进来 3、点击 file -\u0026gt; project structure -\u0026gt; modules -\u0026gt; dependencies -\u0026gt; 左下角的 + 号 -\u0026gt; jars or directories -\u0026gt; 选中刚复制过来的jar包，将导入的jar包全选，点击ok 4、创建普通类User 5、创建Spring配置文件，在配置文件配置创建的对象在src中创建xml格式的Spring配置文件， 在\u0026lt;beans\u0026gt;的内部末尾添加 \u0026lt;!\u0026ndash;配置User对象创建\u0026ndash;\u0026gt; \u0026lt;bean id=\u0026ldquo;user\u0026rdquo; class=\u0026ldquo;com.ethereal.spring5.User\u0026rdquo;\u0026gt;\u0026lt;/bean\u0026gt; 两行\n6、进行测试代码编写\npublic class TestSpring5 { @Test public void testAdd() { // 加载spring配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;bean1.xml\u0026#34;); // 获取配置创建的对象 User user = context.getBean(\u0026#34;user\u0026#34;, User.class); System.out.println(user); user.add(); } } IOC容器： (Inversion of Control) 控制反转，把创建对象和对象之间调用的过程交给Spring进行管理 1、IOC底层原理 xml解析 + 反射 + 工厂模式 （降低耦合度）\n","keywords":[],"articleBody":"IOC： 控制反转，把创建对象的过程交给Spring进行管理 Aop： 面向切片，不修改源代码进行功能增强\nSpring5入门案例基本步骤： 1、创建项目 2、在项目中创建一个lib文件夹，把需要的jar包复制进来 3、点击 file -\u003e project structure -\u003e modules -\u003e dependencies -\u003e 左下角的 + 号 -\u003e jars or directories -\u003e 选中刚复制过来的jar包，将导入的jar包全选，点击ok 4、创建普通类User 5、创建Spring配置文件，在配置文件配置创建的对象在src中创建xml格式的Spring配置文件， 在的内部末尾添加 \u003c!–配置User对象创建–\u003e 两行\n6、进行测试代码编写\npublic class TestSpring5 { @Test public void testAdd() { // 加载spring配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(\"bean1.xml\"); // 获取配置创建的对象 User user = context.getBean(\"user\", User.class); System.out.println(user); user.add(); } } IOC容器： (Inversion of Control) 控制反转，把创建对象和对象之间调用的过程交给Spring进行管理 1、IOC底层原理 xml解析 + 反射 + 工厂模式 （降低耦合度）\npublic class UserFactory { //工厂类 public static User getUser() throws Exception { //静态工厂方法 String classValue = class属性值; //解析出xml配置文件中的创建对象的class的值 Class clazz = Class.forName(classValue); //反射 创建Class对象 return (User) clazz.getDeclaredConstructor().newInstance(); //利用反射生成类的对象 } } 2、IOC接口 1、IOC思想基于IOC容器完成，IOC容器底层就是对象工厂 2、Spring提供IOC容器实现两种方式：（两个接口） 1）BeanFactory： 是Spring内部使用的接口，不提供给开发人员使用。但非要用也可以用。（懒加载）加载配置文件时不创建对象，使用时才创建 2）ApplicationContext： 是BeanFactory接口的子接口，功能更强大，一般就用这个。 加载配置文件时就创建对象。 3、ApplicationContext接口两个主要实现类： ClassPathXmlApplicationContext： 传入参数为以【src】为根路径的相对路径 （参数即为xml配置文件的路径） FileSystemXmlApplicationContext： 传入参数为绝对路径 （参数即为xml配置文件的路径） 3、IOC操作Bean管理 1、Bean管理概念： Bean管理指两个操作 1）Spring创建对象 2）Spring注入属性 - 工厂bean： 1）Spring中有两种类型的bean，一种是普通bean（即用户自己定义的bean）还有一种工厂bean（FactoryBean） 2）两种类型的区别：普通bean生成的对象一定对应于其class值的类，而工厂bean生成的对象不一定对应于其class值类 3）工厂bean实现： 1、创建一个类使其实现接口FactoryBean（这个类称为工厂类） 2、实现接口中的方法public Object getObject()时，将Object替换为具体的想要生成的类，并用上方IOC底层原理方法返回对象。 3、在xml配置文件中，只需创建工厂类的bean就可以了 【一个工厂bean只能实现一个单类】 - bean的作用域： 1）在Spring中，可以设置创建bean实例是单实例还是多实例（单实例即无论创建多少次（个）实例，都是同一个实例。多实例即每次创建新的不同的实例） 2）在Spring中，默认情况下，bean实例是单实例对象 3）设置bean实例为单实例或多实例。bean标签内的属性scope用于设置，其有两个主要的值：singleton（默认）单实例；prototype（多实例） 例如： 即表示多实例 4）当scope的值为singleton时，在加载spring配置文件的时候就会创建单实例对象 当scope的值为prototype时，在调用getBean方法的时候创建多实例对象 - bean生命周期：【此为面试重点问题】 （在第3步的前后都可以将bean实例传递给bean前置（后置）处理器）（此时变为7步） 1）通过构造器创建bean实例（调用构造方法）； 2）为bean的属性设置值（调用set方法） 3）调用bean的初始化方法（需要配置初始化方法） 4）使用bean， 5）容器关闭时，调用销毁方法（需要配置销毁方法） 2、基于xml实现： 1）基于xml创建对象 （1）在Spring配置文件中，使用bean标签，标签中添加对应属性实现对象创建。 （2）属性含义：id：不是对象名，而是bean的唯一标识 name属性与id作用相同，现在不用了，被id代替了。 class：类的全路径（包 + 类）必须是可实例化的类。 （3）创建对象时默认使用无参构造函数 2）基于xml注入属性 DI与IOC的关系：DI是IOC的一种具体实现，他表示依赖注入，即注入属性，需要在创建对象的基础之上完成。 两种注入方式： 1）set方法注入 p名称空间注入（了解） 底层使用set方法注入 （1) 类中创建属性并生成set方法,注意set方法必须是public修饰的 （2）在Spring配置文件中配置对象创建，配置属性注入。 使用方法同上方入门案例中的6，在创建对象的过程中就完成了属性的注入 创建对象 注入属性，想注入几个属性就注入几个 2）有参构造函数注入 （1）类中创建属性并生成有参构造方法 【注意】在配置文件中可以同时存在这两种注入方法，但是必须保证两个创建对象的bean的id值不同。 因为xml根据id唯一标识一个bean，一个bean代表一个对象。 3）基于xml注入其他类型属性 1、字面量：固定值，如创建属性时直接赋值，或xml注入属性时所注入的属性值都是字面量 （1）向属性注入空值 （2）属性值包含特殊符号 1 转义（不好用） 2 把特殊符号写入CDATA（CDATA是xml配置文件的优秀功能，而非Spring的功能） \u003c![CDATA[\u003c\u003c北京\u003e\u003e]]\u003e 其中\u003c\u003c北京\u003e\u003e为注入的值 2、注入属性： （1）外部bean 在xml配置文件中，一个类调用另外一个类的方法 举例： UserService类想要调用UserDaoImpl类中的方法，先在UserService类中创建UserDaoImpl的属性以及set方法。 （2）内部bean 与数据库中表与表之间的关系（一对多、多对一、多对多）有关 举例： 一对多关系： 部门与员工 分别用两个类表示 外部bean同样能达到目的，且无好坏之分，看个人习惯 1） 用对象类型属性表示员工属于某个部门 2） xml配置 在一个bean的内部定义另一个bean 由于只能用这一次，故无需设置id (感觉有点像匿名内部类） （3）级联赋值 第一种写法： 写法和外部bean完全一样，自动在ref引用外部bean的同时将外部bean中已经赋好的属性的值再赋给引用的bean。 第二种写法： 在Emp类中生成Dept属性的get方法，然后在xml中写 （4）注入属性集合 - 注入数组、List、Map、Set类型属性，集合中为基本类型 具体写法见bean5.xml文件 - 注入数组、List、Map、Set类型属性，集合中为对象类型 详见bean5.xml写法 - 把集合注入部分从单个bean中提取出来，使所有bean都可以使用 - 先在xml配置文件中引入一个名称空间util 具体写法见bean6.xml文件 - 使用util标签完成List集合注入提取 具体写法见bean6.xml文件 4）基于xml的自动装配（几乎不用） 1、自动装配：这种属于手动装配；自动装配详见bean7.xml 5）引入外部属性文件(使用阿里的druid数据库连接池，先将druid的jar导入项目中) 1、创建外部属性文件，properties格式文件，写数据库信息 详见jdbc.properties文件 2、在xml配置文件中引入context名称空间 详见bean8.xml文件 3、配置连接池 详见bean8.xml文件 3、基于注解实现：（注解只是让代码更简洁、优雅，但是底层仍然是用xml实现的） 1）注解方法实现对象创建 - 以下4个注解的功能是一样的，都可以用来创建bean。只是约定俗成用在不同的层。 @Component @Service @Controller @Repository （1）引入aop依赖，即spring中的aop的jar包 （2）开启组件扫描 在xml配置文件中添加context名称空间，再进行配置，其中base-package属性的值为扫描的包的路径 如果扫描多个包，则这些包之间用逗号隔开；或者直接扫描这些包的上层目录 组件扫描的细节配置：详见bean9.xml文件 （对扫描的文件进行过滤） （3）创建类，在类上面添加创建对象注解（上面四个中的任意一个） 举例：// 注解里的value属性值可以不写，默认为类名的首字母小写,这对于四个注解都适用 @Component(value = \"userService\") // 这句同作用一样 public class UserService { 属性... 方法...} 2）注解方法实现属性注入 - 注解： 前三个注解都是针对对象类型的注入 @Autowired 根据属性类型注入 @Qualifier 根据属性名称注入（该注解要与@Autowired一起使用） @Resource 既可以根据类型注入，也可以根据名称注入 @Value 注入普通类型属性 （1）对象类型的注入： 1、在注入与被注入的类的前面都加上创建对象的注解 2、在UserService中注入UserDao对象，在UserService类中添加UserDao类型的属性，并在属性前面添加注解（不需要添加set方法） @Autowired：上方两步中直接添加注解即可 @Qualifier：若一个接口有多个实现类，想要注入一个接口类型的属性时，仅使用@Autowired就无法确定使用接口的哪个实现类了， 因此应该配合@Qualifier一起使用：在属性前面@Autowired下方添加@Qualifier(value=\"具体类的bean的id值\") 具体类的bean的id值即为类前注解的value值，不写默认为类名的首字母小写 @Resource：若在属性前直接写@Resource，效果等同于@Autowired 若在属性前写@Resource(name = \"具体类的bean的id值\")，效果等同于@Qualifier （注意）@Resource并非Spring的注解，故Spring官方不建议使用它。import javax.annotation.Resource; 而且JDK11开始不再支持@Resource注解。 （2）普通类型的注入： @Value(value = \"abc\") private String name; 在创建对象时就会将\"abc\"赋值给name 上方这种硬注入很少使用，在SpringBoot和SpringCloud使用注解可以配合${}动态获取配置文件的值，比如数据库，端口号 3）完全注解开发：（不需要xml配置文件）（这种方式在SpringBoot中使用） （1）创建配置类，替代xml配置文件 举例：@Configuration //作为配置类，代替xml配置文件 // 下方注解效果等同于 @ComponentScan(basePackages = \"com.annotation.spring5\") public class SpringConfig {} （2）其余操作和上方完全一样，只是在创建对象之前，将加载配置文件换为加载配置类，如下： ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); AOP: 面向切面编程，不修改源代码进行功能增强 1、底层原理（使用动态代理） 1）有两种情况的动态代理 （1）有接口：使用JDK动态代理 --》 创建接口实现类的代理对象，增强类的方法 （2）无接口：使用CGLIB动态代理 --》 创建当前类子类的代理对象，增强类的方法 2、术语 1）连接点：方法执行前、执行后、返回前、抛异常后等可以被增强的地方叫连接点 2）切入点：实际被增强的方法就叫切入点 3）通知（增强）：增强的逻辑部分 前置通知：前执行； 后置通知：后执行； 环绕通知：前后都执行； 异常通知：发生异常时执行； 最终通知：类似于finally 4）切面：把通知添加到切入点的过程 3、AspectJ 1、AspectJ不是Spring的组成部分，是一个独立的AOP框架，一般把AspectJ和Spring框架一起使用，进行AOP操作。 2、在项目中引入AOP相关依赖 3、切入点表达式 1）作用：知道对哪个类的哪个方法增强 2）语法结构：execution([权限修饰符][返回类型][类全路径][方法名称]([参数列表])) 举例：假设对com/ethereal/spring5/dao/UserDaoImpl中的update方法增强。 execution(\\* com.ethereal.spring5.dao.UserDaoImpl.update(..)) 其中权限修饰符可以不写，通配符*代替任意返回类型 通配符也可以使用在路径中，如将类名，包名替换为*，表示将类中所有方法、包中所有类的所有方法进行增强。参数列表用两个点表示 4、配置不同类型的通知：在增强类里的通知方法上面添加通知类型注解，使用切入点表达式配置。详见part/aop/annotation/UserProxy.java 5、基于AspectJ实现AOP操作： 1）基于xml配置文件 创建被增强类与增强类，并在配置文件中生成对象，然后配置切入点（配置文件详见bean11.xml） 2）基于注解 （具体过程见part/aop/annotation包下的文件，以及bean10.xml） （1）创建类，写方法。创建增强类，写增强方法。（关于5中不同的通知，详见part/aop/annotation/UserProxy.java） （2）配置通知，在配置文件中开启注解扫描 详见bean10.xml文件 （3）使用注解创建对象，在增强类上面添加注解@Aspect （4）在配置文件中开启生成代理对象 细节问题： 1、相同切入点抽取 （意思是每个通知前的切入点表达式都一样，把它提取出来，不用每个通知前都写一遍） @Pointcut(value = \"execution(* part.aop.annotation.User.add(..))\") public void pointCut() {} // 创建一个空方法，上面用@Pointcut注解，之后每个通知的注解的value值赋值为pointCut()即可 不过，将其设为字符串常量也可以，private static final String value = 切入点表达式 （这种更简洁） 2、若多个增强类对同一个方法增强，设置增强类的优先级，规定让哪个增强类先执行 在类前加一个@Order(数字) 注解， 括号内的数字值越小优先级越高。 完全注解开发： （1）创建配置类，不需要xml配置文件 @Configuration // 作为配置类，代替xml配置文件 @ComponentScan(basePackages = {\"part.aop.annotation\"}) // 开启注解扫描 @EnableAspectJAutoProxy(proxyTargetClass = true) // 开启AspectJ，生成代理对象 public class ConfigAop {} JDBCTemplate： 1、概念：Spring框架对JDBC进行封装，使用JDBCTemplate方便实现对数据库的操作。 2、准备工作：1）引入依赖； 2）在spring配置文件中配置数据库连接池（详见bean8.xml文件）； 3）配置JDBCTemplate对象，并注入DataSource（详见bean8.xml文件） 3、使用：在part/JDBCTemplate包下，创建services类和dao类，在services中注入dao，在dao类中注入JDBCTemplate对象 1）对应数据库创建实体类 2）在dao中进行数据库添加操作（调用JDBCTemplate对象中的update方法实现添加操作，第一个参数为create等语句，第二个参数为添加的对应属性的值） JDBCTemplate对象中的其他方法： 1、`queryForObject(String var1, Class var2)` 参数：sql语句； 返回类型的class，如Integer.class, String.class等 1、`queryForObject(String var1, RowMapper var2, @Nullable Object... var3)` 该方法根据给定字段返回一个对象，var1为sql语句，var2如下方固定写法，其中User为想要返回的类型，var3为sql语句的参数。下方为一个示例。 `jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper(User.class), id);` 2、`query(String var1, RowMapper var2, @Nullable Object... var3)` 返回表中所有对象组成List集合，用法与上方一样。 3、`batchUpdate(String sql, List batchArgs)` 批量操作 事务： 1、概念：事务是数据库操作最基本的单元，逻辑上一组操作，要么都成功，如果有一个失败所有操作都失败。 2、四个特性： 1）原子性：原子操作不可分割 2）一致性：操作前后的总量不变（类似能量守恒） 3）隔离性：多个事务操作之间互不影响 4）持久性：提交后数据库中数据发生永久性变化 3、事务操作（在part/tx包下的例子中，由少钱和多钱两个动作组成转账事务） 1）步骤： 开启事务； 进行业务操作； 如果没有发生异常，则提交事务； 如果发生了异常，则事务回滚。 2）事务一般添加到Service层（javaEE三层结构为View层，Service层和Dao层） 3）Spring进行事务管理有两种方式：编程式事务管理（即写代码的方式，一般不使用）和声明式事务管理（即配置的方式，使用） 4）Spring事务管理API： PlatformTransactionManager接口代表事务管理器，这个接口针对不同的框架提供不同的实现类 5）声明式事务管理：（底层使用AOP原理） （1）基于xml配置文件 配置事务管理器、通知、切入点、切面 （2）基于注解 1、在Spring配置文件中配置事务管理器，并开启事务注解（详见bean8.xml） 2、在service类（或service类的方法）上面添加事务注解@Transactional （若添加到类上，则类中所有方法都添加事务，方法上则只作用于该方法） @Transactional中的参数： - propagation：事务传播行为 -》 如何管理多事务方法之间的调用 （例如insert方法调用update方法） 事务方法：能使数据库表中数据发生改变的方法，如insert，update等，select不是事务方法。 REQUIRED：如果insert方法本身有事务，则update就用这个事务，如果insert方法本身没有事务，则创建新事务让update用（默认） REQUIRED_NEW：无论insert方法本身有没有事务，都要创建新事务。 - isolation：事务隔离级别 -》 为了解决脏读，不可重复读，虚读的问题 mysql默认为REPEATABLE READ：可解决脏读和不可重复读，不能解决虚读 （解决能力越好，效率越低） - timeout：超时时间 -》 在一定时间内必须提交，否则就会回滚，默认为-1，即不限制，自己可以设置，单位为秒 - readonly：是否只读 -》 默认为false，即各种操作都可以，若为true，则只能查询 - rollbackFor：回滚 -》 设置出现哪些异常就发生回滚 - noRollbackFor：不回滚 -》 设置出现哪些异常不发生回滚 （3）完全注解开发： 见part/tx/FullyAnnotated.java ","wordCount":"578","inLanguage":"en","datePublished":"2021-04-20T15:39:41Z","dateModified":"2021-04-20T15:39:41Z","author":{"@type":"Person","name":"lu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ethereal-lu.github.io/posts/java/spring5%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"lu","logo":{"@type":"ImageObject","url":"https://ethereal-lu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="lu (Alt + H)">lu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethereal-lu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ethereal-lu.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Spring5学习笔记</h1><div class=post-meta><span title='2021-04-20 15:39:41 +0000 UTC'>2021-04-20</span>&nbsp;·&nbsp;578 words&nbsp;·&nbsp;lu</div></header><div class=post-content><p>IOC： 控制反转，把创建对象的过程交给Spring进行管理<br>Aop： 面向切片，不修改源代码进行功能增强</p><p>Spring5入门案例基本步骤：<br>1、创建项目<br>2、在项目中创建一个lib文件夹，把需要的jar包复制进来<br>3、点击 file -> project structure -> modules -> dependencies -> 左下角的 + 号 -> jars or directories -> 选中刚复制过来的jar包，将导入的jar包全选，点击ok<br>4、创建普通类User<br>5、创建Spring配置文件，在配置文件配置创建的对象在src中创建xml格式的Spring配置文件， 在&lt;beans>的内部末尾添加<br>&lt;!&ndash;配置User对象创建&ndash;> &lt;bean id=&ldquo;user&rdquo; class=&ldquo;com.ethereal.spring5.User&rdquo;>&lt;/bean> 两行<br>6、进行测试代码编写</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestSpring5</span> {      
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@Test</span>      
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testAdd</span>() {      
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 加载spring配置文件      </span>
</span></span><span style=display:flex><span>                ApplicationContext context <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ClassPathXmlApplicationContext(<span style=color:#e6db74>&#34;bean1.xml&#34;</span>);      
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 获取配置创建的对象      </span>
</span></span><span style=display:flex><span>                User user <span style=color:#f92672>=</span> context.<span style=color:#a6e22e>getBean</span>(<span style=color:#e6db74>&#34;user&#34;</span>, User.<span style=color:#a6e22e>class</span>);      
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(user);      
</span></span><span style=display:flex><span>                user.<span style=color:#a6e22e>add</span>();      
</span></span><span style=display:flex><span>            }      
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><hr><p>IOC容器： (Inversion of Control) 控制反转，把创建对象和对象之间调用的过程交给Spring进行管理<br>1、IOC底层原理 xml解析 + 反射 + 工厂模式 （降低耦合度）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserFactory</span> {                             <span style=color:#75715e>//工厂类      </span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> User <span style=color:#a6e22e>getUser</span>() <span style=color:#66d9ef>throws</span> Exception {    <span style=color:#75715e>//静态工厂方法      </span>
</span></span><span style=display:flex><span>                String classValue <span style=color:#f92672>=</span> class属性值;                <span style=color:#75715e>//解析出xml配置文件中的创建对象的class的值      </span>
</span></span><span style=display:flex><span>                Class clazz <span style=color:#f92672>=</span> Class.<span style=color:#a6e22e>forName</span>(classValue);       <span style=color:#75715e>//反射 创建Class对象      </span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> (User) clazz.<span style=color:#a6e22e>getDeclaredConstructor</span>().<span style=color:#a6e22e>newInstance</span>();    <span style=color:#75715e>//利用反射生成类的对象      </span>
</span></span><span style=display:flex><span>            }      
</span></span><span style=display:flex><span>        }    
</span></span></code></pre></div><pre tabindex=0><code>    2、IOC接口      
        1、IOC思想基于IOC容器完成，IOC容器底层就是对象工厂      
        2、Spring提供IOC容器实现两种方式：（两个接口）      
            1）BeanFactory： 是Spring内部使用的接口，不提供给开发人员使用。但非要用也可以用。（懒加载）加载配置文件时不创建对象，使用时才创建      
            2）ApplicationContext： 是BeanFactory接口的子接口，功能更强大，一般就用这个。         加载配置文件时就创建对象。      
        3、ApplicationContext接口两个主要实现类：      
            ClassPathXmlApplicationContext：  传入参数为以【src】为根路径的相对路径 （参数即为xml配置文件的路径）      
            FileSystemXmlApplicationContext： 传入参数为绝对路径              （参数即为xml配置文件的路径）      
    3、IOC操作Bean管理      
        1、Bean管理概念： Bean管理指两个操作 1）Spring创建对象  2）Spring注入属性      
            - 工厂bean：      
                1）Spring中有两种类型的bean，一种是普通bean（即用户自己定义的bean）还有一种工厂bean（FactoryBean）      
                2）两种类型的区别：普通bean生成的对象一定对应于其class值的类，而工厂bean生成的对象不一定对应于其class值类      
                3）工厂bean实现： 1、创建一个类使其实现接口FactoryBean（这个类称为工厂类）      
                                2、实现接口中的方法public Object getObject()时，将Object替换为具体的想要生成的类，并用上方IOC底层原理方法返回对象。      
                                3、在xml配置文件中，只需创建工厂类的bean就可以了        【一个工厂bean只能实现一个单类】      
            - bean的作用域：      
                1）在Spring中，可以设置创建bean实例是单实例还是多实例（单实例即无论创建多少次（个）实例，都是同一个实例。多实例即每次创建新的不同的实例）      
                2）在Spring中，默认情况下，bean实例是单实例对象      
                3）设置bean实例为单实例或多实例。bean标签内的属性scope用于设置，其有两个主要的值：singleton（默认）单实例；prototype（多实例）      
                            例如：&lt;bean id=&#34;book&#34; class=&#34;Book&#34; scope=&#34;prototype&#34;/&gt; 即表示多实例      
                4）当scope的值为singleton时，在加载spring配置文件的时候就会创建单实例对象      
                   当scope的值为prototype时，在调用getBean方法的时候创建多实例对象      
            - bean生命周期：【此为面试重点问题】          （在第3步的前后都可以将bean实例传递给bean前置（后置）处理器）（此时变为7步）      
                1）通过构造器创建bean实例（调用构造方法）；  2）为bean的属性设置值（调用set方法）   3）调用bean的初始化方法（需要配置初始化方法）      
                4）使用bean，                          5）容器关闭时，调用销毁方法（需要配置销毁方法）      
        2、基于xml实现：      
            1）基于xml创建对象   &lt;bean id=&#34;user&#34; class=&#34;com.ethereal.spring5.User&#34;&gt;&lt;/bean&gt;      
                （1）在Spring配置文件中，使用bean标签，标签中添加对应属性实现对象创建。      
                （2）属性含义：id：不是对象名，而是bean的唯一标识    name属性与id作用相同，现在不用了，被id代替了。      
                        class：类的全路径（包 + 类）必须是可实例化的类。      
                （3）创建对象时默认使用无参构造函数      
            2）基于xml注入属性      
                DI与IOC的关系：DI是IOC的一种具体实现，他表示依赖注入，即注入属性，需要在创建对象的基础之上完成。      
                两种注入方式： 1）set方法注入         p名称空间注入（了解） 底层使用set方法注入      
                                （1) 类中创建属性并生成set方法,注意set方法必须是public修饰的      
                                （2）在Spring配置文件中配置对象创建，配置属性注入。  使用方法同上方入门案例中的6，在创建对象的过程中就完成了属性的注入      
                                    &lt;!--2、set方法注入属性--&gt;      
                                    &lt;bean id=&#34;user&#34; class=&#34;com.ethereal.spring5.User&#34;&gt;   创建对象      
                                        &lt;!--使用property标签完成属性注入--&gt;  &lt;!--name属性表示类中属性的名称   value属性表示向属性中注入的值--&gt;      
                                        &lt;property name=&#34;userName&#34; value=&#34;九阴真经&#34;&gt;&lt;/property&gt;   注入属性，想注入几个属性就注入几个      
                                    &lt;/bean&gt;      
                            2）有参构造函数注入      
                                （1）类中创建属性并生成有参构造方法      
                                &lt;!--3、有参构造方法注入属性--&gt;      
                                    &lt;bean id=&#34;user&#34; class=&#34;com.ethereal.spring5.User&#34;&gt;      
                                        &lt;constructor-arg name=&#34;userName&#34; value=&#34;李沁&#34;&gt;&lt;/constructor-arg&gt;      
                                        &lt;constructor-arg name=&#34;agent&#34; value=&#34;female&#34;&gt;&lt;/constructor-arg&gt;      
                                    &lt;/bean&gt;      
                            【注意】在配置文件中可以同时存在这两种注入方法，但是必须保证两个创建对象的bean的id值不同。      
                                            因为xml根据id唯一标识一个bean，一个bean代表一个对象。      
            3）基于xml注入其他类型属性      
                1、字面量：固定值，如创建属性时直接赋值，或xml注入属性时所注入的属性值都是字面量      
                    （1）向属性注入空值  &lt;property name=&#34;userName&#34;&gt; &lt;null/&gt; &lt;/property&gt;      
                    （2）属性值包含特殊符号  1 转义（不好用）   2 把特殊符号写入CDATA（CDATA是xml配置文件的优秀功能，而非Spring的功能）      
                            &lt;property name=&#34;userName&#34;&gt; &lt;value&gt;&lt;![CDATA[&lt;&lt;北京&gt;&gt;]]&gt;&lt;/value&gt; &lt;/property&gt; 其中&lt;&lt;北京&gt;&gt;为注入的值      
                2、注入属性：      
                    （1）外部bean   在xml配置文件中，一个类调用另外一个类的方法      
                        举例：   UserService类想要调用UserDaoImpl类中的方法，先在UserService类中创建UserDaoImpl的属性以及set方法。      
                                &lt;bean id=&#34;userService&#34; class=&#34;com.ethereal.spring5.services.UserService&#34;&gt;      
                                    &lt;!--注入UserDao对象   name：属性值   ref：注入的对象的bean标识符，即对象对应bean标签的id值--&gt;      
                                    &lt;property name=&#34;userDao&#34; ref=&#34;userDao&#34;/&gt;      
                                &lt;/bean&gt;      
                                &lt;bean id=&#34;userDao&#34; class=&#34;com.ethereal.spring5.dao.UserDaoImpl&#34;/&gt;      
                    （2）内部bean    与数据库中表与表之间的关系（一对多、多对一、多对多）有关      
                        举例： 一对多关系： 部门与员工  分别用两个类表示          外部bean同样能达到目的，且无好坏之分，看个人习惯      
                            1） 用对象类型属性表示员工属于某个部门      
                            2） xml配置    &lt;bean id=&#34;emp&#34; class=&#34;com.ethereal.spring5.bean.Emp&#34;&gt;      
                                             &lt;property name=&#34;ename&#34; value=&#34;alice&#34;/&gt;      
                                             &lt;property name=&#34;gender&#34; value=&#34;female&#34;/&gt;      
                                             &lt;property name=&#34;dept&#34;&gt;         在一个bean的内部定义另一个bean      
                                                 &lt;bean class=&#34;com.ethereal.spring5.bean.Dept&#34;&gt;   由于只能用这一次，故无需设置id      
                                                     &lt;property name=&#34;dname&#34; value=&#34;保安部&#34;/&gt;       (感觉有点像匿名内部类）      
                                                 &lt;/bean&gt;      
                                             &lt;/property&gt;      
                                          &lt;/bean&gt;      
                    （3）级联赋值      
                        第一种写法： 写法和外部bean完全一样，自动在ref引用外部bean的同时将外部bean中已经赋好的属性的值再赋给引用的bean。      
                        第二种写法： 在Emp类中生成Dept属性的get方法，然后在xml中写&lt;property name=&#34;dept.dname&#34; value=&#34;公关部&#34;/&gt;      
                    （4）注入属性集合      
                        - 注入数组、List、Map、Set类型属性，集合中为基本类型       具体写法见bean5.xml文件      
                        - 注入数组、List、Map、Set类型属性，集合中为对象类型       详见bean5.xml写法      
                        - 把集合注入部分从单个bean中提取出来，使所有bean都可以使用      
                            - 先在xml配置文件中引入一个名称空间util              具体写法见bean6.xml文件      
                            - 使用util标签完成List集合注入提取                  具体写法见bean6.xml文件      
            4）基于xml的自动装配（几乎不用）      
                1、自动装配：&lt;property name=&#34;userDao&#34; ref=&#34;userDao&#34;/&gt;这种属于手动装配；自动装配详见bean7.xml      
            5）引入外部属性文件(使用阿里的druid数据库连接池，先将druid的jar导入项目中)      
                1、创建外部属性文件，properties格式文件，写数据库信息  详见jdbc.properties文件      
                2、在xml配置文件中引入context名称空间               详见bean8.xml文件      
                3、配置连接池                                    详见bean8.xml文件      
        3、基于注解实现：（注解只是让代码更简洁、优雅，但是底层仍然是用xml实现的）      
            1）注解方法实现对象创建      
                - 以下4个注解的功能是一样的，都可以用来创建bean。只是约定俗成用在不同的层。      
                @Component    @Service    @Controller   @Repository      
                （1）引入aop依赖，即spring中的aop的jar包      
                （2）开启组件扫描   在xml配置文件中添加context名称空间，再进行配置，其中base-package属性的值为扫描的包的路径      
                                 &lt;context:component-scan base-package=&#34;com.annotation.spring5&#34;/&gt;      
                                 如果扫描多个包，则这些包之间用逗号隔开；或者直接扫描这些包的上层目录      
                    组件扫描的细节配置：详见bean9.xml文件 （对扫描的文件进行过滤）      
                （3）创建类，在类上面添加创建对象注解（上面四个中的任意一个）      
                    举例：// 注解里的value属性值可以不写，默认为类名的首字母小写,这对于四个注解都适用      
                         @Component(value = &#34;userService&#34;)  // 这句同&lt;bean id=&#34;userService&#34; class=&#34;类路径&#34;/&gt;作用一样      
                         public class UserService { 属性...   方法...}      
            2）注解方法实现属性注入      
                - 注解： 前三个注解都是针对对象类型的注入      
                        @Autowired 根据属性类型注入      
                        @Qualifier 根据属性名称注入（该注解要与@Autowired一起使用）      
                        @Resource  既可以根据类型注入，也可以根据名称注入      
                        @Value     注入普通类型属性      
                （1）对象类型的注入：      
                    1、在注入与被注入的类的前面都加上创建对象的注解      
                    2、在UserService中注入UserDao对象，在UserService类中添加UserDao类型的属性，并在属性前面添加注解（不需要添加set方法）      
                    @Autowired：上方两步中直接添加注解即可      
                    @Qualifier：若一个接口有多个实现类，想要注入一个接口类型的属性时，仅使用@Autowired就无法确定使用接口的哪个实现类了，      
                                因此应该配合@Qualifier一起使用：在属性前面@Autowired下方添加@Qualifier(value=&#34;具体类的bean的id值&#34;)      
                                具体类的bean的id值即为类前注解的value值，不写默认为类名的首字母小写      
                    @Resource：若在属性前直接写@Resource，效果等同于@Autowired      
                               若在属性前写@Resource(name = &#34;具体类的bean的id值&#34;)，效果等同于@Qualifier      
                               （注意）@Resource并非Spring的注解，故Spring官方不建议使用它。import javax.annotation.Resource;      
                                     而且JDK11开始不再支持@Resource注解。      
                （2）普通类型的注入：      
                    @Value(value = &#34;abc&#34;)      
                    private String name;  在创建对象时就会将&#34;abc&#34;赋值给name      
                    上方这种硬注入很少使用，在SpringBoot和SpringCloud使用注解可以配合${}动态获取配置文件的值，比如数据库，端口号      
            3）完全注解开发：（不需要xml配置文件）（这种方式在SpringBoot中使用）      
                （1）创建配置类，替代xml配置文件      
                    举例：@Configuration  //作为配置类，代替xml配置文件      
                         // 下方注解效果等同于&lt;context:component-scan base-package=&#34;com.annotation.spring5&#34;/&gt;      
                         @ComponentScan(basePackages = &#34;com.annotation.spring5&#34;)      
                         public class SpringConfig {}      
                （2）其余操作和上方完全一样，只是在创建对象之前，将加载配置文件换为加载配置类，如下：      
                        ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);      
</code></pre><hr><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>AOP: 面向切面编程<span style=color:#960050;background-color:#1e0010>，</span>不修改源代码进行功能增强      
</span></span><span style=display:flex><span>    1<span style=color:#960050;background-color:#1e0010>、</span>底层原理<span style=color:#960050;background-color:#1e0010>（</span>使用动态代理<span style=color:#960050;background-color:#1e0010>）</span>      
</span></span><span style=display:flex><span>        1<span style=color:#960050;background-color:#1e0010>）</span>有两种情况的动态代理      
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>（</span>1<span style=color:#960050;background-color:#1e0010>）</span>有接口<span style=color:#960050;background-color:#1e0010>：</span>使用JDK动态代理 <span style=color:#f92672>--</span><span style=color:#960050;background-color:#1e0010>》</span> 创建接口实现类的代理对象<span style=color:#960050;background-color:#1e0010>，</span>增强类的方法      
</span></span><span style=display:flex><span>            <span style=color:#960050;background-color:#1e0010>（</span>2<span style=color:#960050;background-color:#1e0010>）</span>无接口<span style=color:#960050;background-color:#1e0010>：</span>使用CGLIB动态代理  <span style=color:#f92672>--</span><span style=color:#960050;background-color:#1e0010>》</span> 创建当前类子类的代理对象<span style=color:#960050;background-color:#1e0010>，</span>增强类的方法      
</span></span><span style=display:flex><span>    2<span style=color:#960050;background-color:#1e0010>、</span>术语      
</span></span><span style=display:flex><span>        1<span style=color:#960050;background-color:#1e0010>）</span>连接点<span style=color:#960050;background-color:#1e0010>：</span>方法执行前<span style=color:#960050;background-color:#1e0010>、</span>执行后<span style=color:#960050;background-color:#1e0010>、</span>返回前<span style=color:#960050;background-color:#1e0010>、</span>抛异常后等可以被增强的地方叫连接点
</span></span><span style=display:flex><span>        2<span style=color:#960050;background-color:#1e0010>）</span>切入点<span style=color:#960050;background-color:#1e0010>：</span>实际被增强的方法就叫切入点      
</span></span><span style=display:flex><span>        3<span style=color:#960050;background-color:#1e0010>）</span>通知<span style=color:#960050;background-color:#1e0010>（</span>增强<span style=color:#960050;background-color:#1e0010>）：</span>增强的逻辑部分  前置通知<span style=color:#960050;background-color:#1e0010>：</span>前执行<span style=color:#960050;background-color:#1e0010>；</span> 后置通知<span style=color:#960050;background-color:#1e0010>：</span>后执行<span style=color:#960050;background-color:#1e0010>；</span> 环绕通知<span style=color:#960050;background-color:#1e0010>：</span>前后都执行<span style=color:#960050;background-color:#1e0010>；</span> 异常通知<span style=color:#960050;background-color:#1e0010>：</span>发生异常时执行<span style=color:#960050;background-color:#1e0010>；</span> 最终通知<span style=color:#960050;background-color:#1e0010>：</span>类似于finally      
</span></span><span style=display:flex><span>        4<span style=color:#960050;background-color:#1e0010>）</span>切面<span style=color:#960050;background-color:#1e0010>：</span>把通知添加到切入点的过程      
</span></span><span style=display:flex><span>    3<span style=color:#960050;background-color:#1e0010>、</span>AspectJ      
</span></span><span style=display:flex><span>        1<span style=color:#960050;background-color:#1e0010>、</span>AspectJ不是Spring的组成部分<span style=color:#960050;background-color:#1e0010>，</span>是一个独立的AOP框架<span style=color:#960050;background-color:#1e0010>，</span>一般把AspectJ和Spring框架一起使用<span style=color:#960050;background-color:#1e0010>，</span>进行AOP操作<span style=color:#960050;background-color:#1e0010>。</span>      
</span></span><span style=display:flex><span>        2<span style=color:#960050;background-color:#1e0010>、</span>在项目中引入AOP相关依赖      
</span></span><span style=display:flex><span>        3<span style=color:#960050;background-color:#1e0010>、</span>切入点表达式      
</span></span><span style=display:flex><span>            1<span style=color:#960050;background-color:#1e0010>）</span>作用<span style=color:#960050;background-color:#1e0010>：</span>知道对哪个类的哪个方法增强      
</span></span><span style=display:flex><span>            2<span style=color:#960050;background-color:#1e0010>）</span>语法结构<span style=color:#960050;background-color:#1e0010>：</span>execution(<span style=color:#f92672>[</span>权限修饰符<span style=color:#f92672>][</span>返回类型<span style=color:#f92672>][</span>类全路径<span style=color:#f92672>][</span>方法名称<span style=color:#f92672>]</span>(<span style=color:#f92672>[</span>参数列表<span style=color:#f92672>]</span>))      
</span></span><span style=display:flex><span>                举例<span style=color:#960050;background-color:#1e0010>：</span>假设对com<span style=color:#f92672>/</span>ethereal<span style=color:#f92672>/</span>spring5<span style=color:#f92672>/</span>dao<span style=color:#f92672>/</span>UserDaoImpl中的update方法增强<span style=color:#960050;background-color:#1e0010>。</span>      
</span></span><span style=display:flex><span>                    execution(<span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>*</span> com.<span style=color:#a6e22e>ethereal</span>.<span style=color:#a6e22e>spring5</span>.<span style=color:#a6e22e>dao</span>.<span style=color:#a6e22e>UserDaoImpl</span>.<span style=color:#a6e22e>update</span>(..)) 其中权限修饰符可以不写<span style=color:#960050;background-color:#1e0010>，</span>通配符<span style=color:#f92672>*</span>代替任意返回类型      
</span></span><span style=display:flex><span>                    通配符也可以使用在路径中<span style=color:#960050;background-color:#1e0010>，</span>如将类名<span style=color:#960050;background-color:#1e0010>，</span>包名替换为<span style=color:#f92672>*</span><span style=color:#960050;background-color:#1e0010>，</span>表示将类中所有方法<span style=color:#960050;background-color:#1e0010>、</span>包中所有类的所有方法进行增强<span style=color:#960050;background-color:#1e0010>。</span>参数列表用两个点表示      
</span></span><span style=display:flex><span>        4<span style=color:#960050;background-color:#1e0010>、</span>配置不同类型的通知<span style=color:#960050;background-color:#1e0010>：</span>在增强类里的通知方法上面添加通知类型注解<span style=color:#960050;background-color:#1e0010>，</span>使用切入点表达式配置<span style=color:#960050;background-color:#1e0010>。</span>详见part<span style=color:#f92672>/</span>aop<span style=color:#f92672>/</span>annotation<span style=color:#f92672>/</span>UserProxy.<span style=color:#a6e22e>java</span>      
</span></span><span style=display:flex><span>        5<span style=color:#960050;background-color:#1e0010>、</span>基于AspectJ实现AOP操作<span style=color:#960050;background-color:#1e0010>：</span>      
</span></span><span style=display:flex><span>            1<span style=color:#960050;background-color:#1e0010>）</span>基于xml配置文件      
</span></span><span style=display:flex><span>                创建被增强类与增强类<span style=color:#960050;background-color:#1e0010>，</span>并在配置文件中生成对象<span style=color:#960050;background-color:#1e0010>，</span>然后配置切入点<span style=color:#960050;background-color:#1e0010>（</span>配置文件详见bean11.<span style=color:#a6e22e>xml</span><span style=color:#960050;background-color:#1e0010>）</span>      
</span></span><span style=display:flex><span>            2<span style=color:#960050;background-color:#1e0010>）</span>基于注解  <span style=color:#960050;background-color:#1e0010>（</span>具体过程见part<span style=color:#f92672>/</span>aop<span style=color:#f92672>/</span>annotation包下的文件<span style=color:#960050;background-color:#1e0010>，</span>以及bean10.<span style=color:#a6e22e>xml</span><span style=color:#960050;background-color:#1e0010>）</span>      
</span></span><span style=display:flex><span>                <span style=color:#960050;background-color:#1e0010>（</span>1<span style=color:#960050;background-color:#1e0010>）</span>创建类<span style=color:#960050;background-color:#1e0010>，</span>写方法<span style=color:#960050;background-color:#1e0010>。</span>创建增强类<span style=color:#960050;background-color:#1e0010>，</span>写增强方法<span style=color:#960050;background-color:#1e0010>。（</span>关于5中不同的通知<span style=color:#960050;background-color:#1e0010>，</span>详见part<span style=color:#f92672>/</span>aop<span style=color:#f92672>/</span>annotation<span style=color:#f92672>/</span>UserProxy.<span style=color:#a6e22e>java</span><span style=color:#960050;background-color:#1e0010>）</span>      
</span></span><span style=display:flex><span>                <span style=color:#960050;background-color:#1e0010>（</span>2<span style=color:#960050;background-color:#1e0010>）</span>配置通知<span style=color:#960050;background-color:#1e0010>，</span>在配置文件中开启注解扫描    详见bean10.<span style=color:#a6e22e>xml文件</span>      
</span></span><span style=display:flex><span>                <span style=color:#960050;background-color:#1e0010>（</span>3<span style=color:#960050;background-color:#1e0010>）</span>使用注解创建对象<span style=color:#960050;background-color:#1e0010>，</span>在增强类上面添加注解<span style=color:#a6e22e>@Aspect</span>      
</span></span><span style=display:flex><span>                <span style=color:#960050;background-color:#1e0010>（</span>4<span style=color:#960050;background-color:#1e0010>）</span>在配置文件中开启生成代理对象      
</span></span><span style=display:flex><span>                细节问题<span style=color:#960050;background-color:#1e0010>：</span>      
</span></span><span style=display:flex><span>                    1<span style=color:#960050;background-color:#1e0010>、</span>相同切入点抽取 <span style=color:#960050;background-color:#1e0010>（</span>意思是每个通知前的切入点表达式都一样<span style=color:#960050;background-color:#1e0010>，</span>把它提取出来<span style=color:#960050;background-color:#1e0010>，</span>不用每个通知前都写一遍<span style=color:#960050;background-color:#1e0010>）</span>      
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>@Pointcut</span>(value <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;execution(* part.aop.annotation.User.add(..))&#34;</span>)      
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pointCut</span>() {}  <span style=color:#75715e>// 创建一个空方法，上面用@Pointcut注解，之后每个通知的注解的value值赋值为pointCut()即可      </span>
</span></span><span style=display:flex><span>                            不过<span style=color:#960050;background-color:#1e0010>，</span>将其设为字符串常量也可以<span style=color:#960050;background-color:#1e0010>，</span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String value <span style=color:#f92672>=</span> 切入点表达式  <span style=color:#960050;background-color:#1e0010>（</span>这种更简洁<span style=color:#960050;background-color:#1e0010>）</span>      
</span></span><span style=display:flex><span>                    2<span style=color:#960050;background-color:#1e0010>、</span>若多个增强类对同一个方法增强<span style=color:#960050;background-color:#1e0010>，</span>设置增强类的优先级<span style=color:#960050;background-color:#1e0010>，</span>规定让哪个增强类先执行      
</span></span><span style=display:flex><span>                        在类前加一个<span style=color:#a6e22e>@Order</span>(数字) 注解<span style=color:#960050;background-color:#1e0010>，</span> 括号内的数字值越小优先级越高<span style=color:#960050;background-color:#1e0010>。</span>      
</span></span><span style=display:flex><span>                完全注解开发<span style=color:#960050;background-color:#1e0010>：</span>      
</span></span><span style=display:flex><span>                    <span style=color:#960050;background-color:#1e0010>（</span>1<span style=color:#960050;background-color:#1e0010>）</span>创建配置类<span style=color:#960050;background-color:#1e0010>，</span>不需要xml配置文件      
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>@Configuration</span>      <span style=color:#75715e>// 作为配置类，代替xml配置文件      </span>
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>@ComponentScan</span>(basePackages <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#34;part.aop.annotation&#34;</span>})      <span style=color:#75715e>// 开启注解扫描      </span>
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>@EnableAspectJAutoProxy</span>(proxyTargetClass <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>)         <span style=color:#75715e>// 开启AspectJ，生成代理对象      </span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ConfigAop</span> {}      
</span></span></code></pre></div><hr><pre tabindex=0><code>JDBCTemplate：      
    1、概念：Spring框架对JDBC进行封装，使用JDBCTemplate方便实现对数据库的操作。      
    2、准备工作：1）引入依赖； 2）在spring配置文件中配置数据库连接池（详见bean8.xml文件）； 3）配置JDBCTemplate对象，并注入DataSource（详见bean8.xml文件）      
    3、使用：在part/JDBCTemplate包下，创建services类和dao类，在services中注入dao，在dao类中注入JDBCTemplate对象      
        1）对应数据库创建实体类      
        2）在dao中进行数据库添加操作（调用JDBCTemplate对象中的update方法实现添加操作，第一个参数为create等语句，第二个参数为添加的对应属性的值）      
            JDBCTemplate对象中的其他方法：      
                1、`queryForObject(String var1, Class&lt;T&gt; var2)`    参数：sql语句； 返回类型的class，如Integer.class, String.class等      
                1、`queryForObject(String var1, RowMapper&lt;T&gt; var2, @Nullable Object... var3)`    
                    该方法根据给定字段返回一个对象，var1为sql语句，var2如下方固定写法，其中User为想要返回的类型，var3为sql语句的参数。下方为一个示例。      
                    `jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), id);`      
                2、`query(String var1, RowMapper&lt;T&gt; var2, @Nullable Object... var3)` 返回表中所有对象组成List集合，用法与上方一样。      
                3、`batchUpdate(String sql, List&lt;Object[]&gt; batchArgs)`  批量操作    
</code></pre><hr><pre tabindex=0><code>事务：      
    1、概念：事务是数据库操作最基本的单元，逻辑上一组操作，要么都成功，如果有一个失败所有操作都失败。      
    2、四个特性：      
        1）原子性：原子操作不可分割      
        2）一致性：操作前后的总量不变（类似能量守恒）      
        3）隔离性：多个事务操作之间互不影响      
        4）持久性：提交后数据库中数据发生永久性变化      
    3、事务操作（在part/tx包下的例子中，由少钱和多钱两个动作组成转账事务）      
        1）步骤：   开启事务；   进行业务操作；     如果没有发生异常，则提交事务；     如果发生了异常，则事务回滚。      
        2）事务一般添加到Service层（javaEE三层结构为View层，Service层和Dao层）      
        3）Spring进行事务管理有两种方式：编程式事务管理（即写代码的方式，一般不使用）和声明式事务管理（即配置的方式，使用）      
        4）Spring事务管理API：    PlatformTransactionManager接口代表事务管理器，这个接口针对不同的框架提供不同的实现类      
        5）声明式事务管理：（底层使用AOP原理）      
            （1）基于xml配置文件    配置事务管理器、通知、切入点、切面      
            （2）基于注解      
                1、在Spring配置文件中配置事务管理器，并开启事务注解（详见bean8.xml）      
                2、在service类（或service类的方法）上面添加事务注解@Transactional （若添加到类上，则类中所有方法都添加事务，方法上则只作用于该方法）      
                @Transactional中的参数：      
                    - propagation：事务传播行为 -》 如何管理多事务方法之间的调用 （例如insert方法调用update方法）      
                        事务方法：能使数据库表中数据发生改变的方法，如insert，update等，select不是事务方法。      
                        REQUIRED：如果insert方法本身有事务，则update就用这个事务，如果insert方法本身没有事务，则创建新事务让update用（默认）      
                        REQUIRED_NEW：无论insert方法本身有没有事务，都要创建新事务。      
                    - isolation：事务隔离级别  -》 为了解决脏读，不可重复读，虚读的问题      
                        mysql默认为REPEATABLE READ：可解决脏读和不可重复读，不能解决虚读  （解决能力越好，效率越低）      
                    - timeout：超时时间        -》 在一定时间内必须提交，否则就会回滚，默认为-1，即不限制，自己可以设置，单位为秒      
                    - readonly：是否只读       -》 默认为false，即各种操作都可以，若为true，则只能查询      
                    - rollbackFor：回滚       -》 设置出现哪些异常就发生回滚      
                    - noRollbackFor：不回滚   -》 设置出现哪些异常不发生回滚      
            （3）完全注解开发：  见part/tx/FullyAnnotated.java      
</code></pre></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/tomcat/><span class=title>« Prev</span><br><span>Tomcat启动一闪而过以及报java.lang.IllegalStateException: 无输出目录以及乱码</span>
</a><a class=next href=https://ethereal-lu.github.io/posts/go/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><span class=title>Next »</span><br><span>Go 基础</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>