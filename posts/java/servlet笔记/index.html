<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Servlet学习笔记 | lu</title>
<meta name=keywords content><meta name=description content='Servlet定义
Servlet是一个Java应用程序，运行在服务器端，用来处理客户端请求并作出响应的程序。

实现Servlet的主要方式


程序实现Servlet接口（很少使用）

编写类实现Servlet接口
根据业务重写service方法
到web.xml中配置Servlet程序的访问地址（基于注解时不需要）



程序继承HttpServlet类（一般使用这种）

编写类继承HttpServlet类
根据业务需要重写doGet或doPost方法
到web.xml中配置Servlet程序的访问地址（基于注解时不需要）



在IDEA中直接创建Servlet程序
实质上还是第二种方法，只是IDEA帮你做了一些通用的工作


Servlet的生命周期

执行Servlet构造器方法，该方法在初次访问时调用一次。由Servlet容器（Tomcat）创建。这说明 Servlet 是单实例的!
执行init初始化方法，该方法在初次访问时调用一次。
执行service方法，该方法在每次访问时都会调用一次。
执行destory方法，该方法在web工程停止时调用一次。  用于释放当前 Servlet 所占用的资源。


Servlet接口的架构


Servlet的域对象

概念：可以在不同Servlet之间传递数据的对象，就是域对象。通俗的讲就是这个对象本身可以存储一定范围内的所有数据，通过它就能获取和存储数据。
域对象共有的方法：

getAttribute(String name) 获取对应的数据
getAttributeNames() 获取所有的key
removeAttribute(String name) 移除对应的数据
setAttribute(String name, Object object) 设置数据


Servlet的三大域对象分别为ServletRequest域、HttpSession域、ServletContext域
ServletRequest：

生命周期：请求开始到请求结束
作用域：整个请求链（包括请求转发）


HttpSession：

生命周期：会话开始到会话结束，服务器会为每个浏览器创建一个供其独享的Session对象，当一段时间内，session没有被使用（默认是30分钟），服务器会销毁该session。
作用域：一次会话


ServletContext：

生命周期：服务器开启到服务器关闭
作用域：整个web应用




ServletConfig类

ServletConfig类是Servlet程序的配置信息类，里面封装了一些初始化配置的信息
Servlet程序和ServletConfig对象都是由Tomcat负责创建，供我们使用。
每创建一次Servlet程序时，就创建一个ServletConfig对象。
每个ServletConfig对象都只能获取自己的Servlet的信息，不能跨域获取
重写init方法时要带上父类的init方法，如果不带上，则在使用ServletConfig相关方法时就会引发NullPointerException，这是因为父类GenericServlet的init方法中保存了ServletConfig对象，如果重写了init方法，该对象就会丢失，故而引发NullPointerException。
作用：

获取Servlet程序的别名，即servlet-name的值servletConfig.getServletName()
获取初始化参数init-paramservletConfig.getInitParameter()
获取ServletContext对象servletConfig.getServletContext()




ServletContext类

ServletContext是接口，表示Servlet上下文对象
一个web工程只有一个ServletContext对象实例，在web工程启动时创建，停止时销毁
ServletContext对象是一个域对象

域对象是可以像map一样存取数据的对象，域指的是存取数据的操作范围



                        存数据                  取数据                     删除数据  
        Map             put()                   get()                     remove()  
        域对象      serAttribute()          getAttribute()             removeAttribute()

作用：

获取web.xml中配置的上下文参数context-param: servletContext.getInitParameter()
获取当前的工程路径，格式：/工程路径: servletContext.getContextPath()
获取工程部署后在服务器硬盘上的绝对路径: servletContext.getRealPath("/")其中/在服务器解析时，表示地址为：http://ip:port/工程路径映射到IDEA为web目录
像map一样存储数据




HttpServletRequest类

作用：每次只要有请求进入Tomcat服务器，Tomcat服务器就会把请求过来的HTTP协议信息解析好封装到Request对象中，然后传递到service方法（doGet和DoPost中给我们使用，我们可以通过HttpServletRequest对象，获取到所有请求的信息。（每次请求创建一个，请求完成即销毁）
常见API：

request.getRequestURI() ：获取请求的资源路径
request.getRequestURL() ：获取请求的url
request.getRemoteHost() ：获取客户端ip地址
request.getHeader(String key) ：获取请求头中对应键的值
request.getMethod() ：获取请求方式
request.getParameter(String key) ：获取请求参数
request.getParameterValues(String key): 获取请求参数，用于参数值有多个时


通常在doPost方法的第一行写request.setCharacterEncoding("UTF-8");用来解决post请求的中文乱码问题
HttpServletRequest对象也是域对象。每个请求对应着唯一一个HttpServletRequest对象，而且在请求结束之前会一直存在，故在处理请求过程中可以使用request.setAttribute(String name, Object o)方法对该对象添加属性，用request.getAttribute(String name)获取该对象的属性，从而执行一些操作。
请求转发：服务器收到请求后，从一个资源转到另一个资源的操作

特点：1、浏览器地址栏没有改变。2、属于一次请求：由多个servlet资源共同完成的同一个请求，故HttpServletRequest对象的作用域涵盖请求转发过程，从而这些servlet资源可以共享该对象中的数据。3、能访问WEB-INF中的资源。4、不可以访问当前工程以外的资源。
RequestDispatcher requestDispatcher = request.getRequestDispatcher("/目的资源名称");请求转发必须以斜杠/开头，/表示http://ip:port/工程路径映射到IDEA为web目录
base标签的作用：所有的相对路径都是以base标签中的地址为参照。在没有base标签时，所有路径都以当前地址栏中的地址为参照，这在某些情况下会出错（如请求转发时，地址栏中的地址不变，但页面改变，若此页面中有相对路径，则参考基准不再是当前页面，而是地址栏的地址，从而出错）。若在页面中引入base标签，则相对路径参考基准成为base标签的路径。base标签在HTML文档的head标签内，如<base herf="http://localhost:8080/project/a/b.html>。




HttpServletResponse类

作用：HttpServletResponse类和HttpServletRequest类一样，每次请求进来，Tomcat服务器都会创建一个Response对象传递给Servlet程序去使用。HttpServletRequest表示请求过来的信息，HttpServletResponse表示所有响应的信息，如果需要设置返回给客户端的信息，都可以通过HttpServletResponse对象进行设置。
输出流：HttpServletResponse类通过流将响应传递给客户端。

字节流 getOutputStream();  常用于下载（传递）二进制数据
字符流 getWriter();    常用于回传字符串（常用）


两个流只能互斥使用


中文乱码：HttpServletResponse响应的默认字符集为ISO-8859-1，所以会中文乱码，可以通过response.setContentType("text/html; charset=UTF-8");将服务器和浏览器的字符集以及响应头都设置为UTF-8，就能解决中文乱码问题。此方法必须在获取流对象之前调用才有效
请求重定向：

第一种方法：在下图的response1中写response.setStatus(302) 来设置响应状态码，response.setHeader("Location", "http://ip:port/工程路径/response2 来设置响应头，告知新地址。
第二种方法（推荐使用）：在下图的response1中写response.sendRedirect(http://ip:port/工程路径/response2即可。
请求重定向是两次独立的请求，只是第二次有浏览器代劳，不需要手动发起请求而已。
特点：1、浏览器地址栏发生变化。2、属于两次请求。3、前后两个servlet资源不共享request域中的数据。4、不能访问WEB-INF中的资源。5、可以访问当前工程以外的资源。





web中 / 的不同含义

在web中 / 斜杠是一种绝对路径
/ 斜杠如果被浏览器解析，得到地址为：http://ip:port/，如html中的<a href="/">斜杠</a>
/ 斜杠如果被服务器解析，得到地址为：http://ip:port/工程路径，如  <url-pattern>/hello</url-pattern> 、
servletContext.getRealPath("/") 、 request.getRequestDispatcher("/")
特殊情况：response.sendRediect("/");重定向，会将 / 斜杠发送给浏览器解析，得到http://ip:port/


基于xml的方式
Servlet中web.xml的配置
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <!--servlet标签给Tomcat配置Servlet程序-->
    <servlet>
        <!--servlet-name标签：给Servlet程序起一个别名（一般是类名）-->
        <servlet-name>HiServlet</servlet-name>
        <!--servlet-class是Servlet程序的全类名-->
        <servlet-class>com.example.tomcat.HiServlet</servlet-class>
    </servlet>

    <!--servlet-mapping标签给Servlet程序配置访问地址-->
    <servlet-mapping>
        <!--servlet-name标签告诉服务器，我当前配置的地址给哪个Servlet程序使用-->
        <servlet-name>HiServlet</servlet-name>
        <!--url-pattern标签配置访问地址
            /   斜杠在服务器解析时，表示地址为：http://ip:port/工程路径   本工程即为http://localhost:8080/tomcat_war_exploded/
            /hello  表示：http://ip:port/工程路径/hello    即http://localhost:8080/tomcat_war_exploded/hello
        -->
        <url-pattern>/hello</url-pattern>
    </servlet-mapping>
</web-app>
从url定位到Servlet程序过程
对照上方的xml配置文件：当在地址栏输入http://localhost:8080/tomcat_war_exploded/hello时，由8080定位到Tomcat服务器，再由/tomcat_war_exploded定位到该工程，然后根据/hello定位到xml配置文件中<servlet-mapping>标签下的<url-pattern>标签，其对应的<servlet-name>标签值为HiServlet，再根据这个标识符找到相同名的<servlet>标签，根据其标签下<servlet-class>的值定位到类的位置，然后执行类中的service方法。'><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/posts/java/servlet%E7%AC%94%E8%AE%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/posts/java/servlet%E7%AC%94%E8%AE%B0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/posts/java/servlet%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="lu"><meta property="og:title" content="Servlet学习笔记"><meta property="og:description" content='Servlet定义 Servlet是一个Java应用程序，运行在服务器端，用来处理客户端请求并作出响应的程序。
实现Servlet的主要方式 程序实现Servlet接口（很少使用） 编写类实现Servlet接口 根据业务重写service方法 到web.xml中配置Servlet程序的访问地址（基于注解时不需要） 程序继承HttpServlet类（一般使用这种） 编写类继承HttpServlet类 根据业务需要重写doGet或doPost方法 到web.xml中配置Servlet程序的访问地址（基于注解时不需要） 在IDEA中直接创建Servlet程序 实质上还是第二种方法，只是IDEA帮你做了一些通用的工作 Servlet的生命周期 执行Servlet构造器方法，该方法在初次访问时调用一次。由Servlet容器（Tomcat）创建。这说明 Servlet 是单实例的! 执行init初始化方法，该方法在初次访问时调用一次。 执行service方法，该方法在每次访问时都会调用一次。 执行destory方法，该方法在web工程停止时调用一次。 用于释放当前 Servlet 所占用的资源。 Servlet接口的架构 Servlet的域对象 概念：可以在不同Servlet之间传递数据的对象，就是域对象。通俗的讲就是这个对象本身可以存储一定范围内的所有数据，通过它就能获取和存储数据。 域对象共有的方法： getAttribute(String name) 获取对应的数据 getAttributeNames() 获取所有的key removeAttribute(String name) 移除对应的数据 setAttribute(String name, Object object) 设置数据 Servlet的三大域对象分别为ServletRequest域、HttpSession域、ServletContext域 ServletRequest： 生命周期：请求开始到请求结束 作用域：整个请求链（包括请求转发） HttpSession： 生命周期：会话开始到会话结束，服务器会为每个浏览器创建一个供其独享的Session对象，当一段时间内，session没有被使用（默认是30分钟），服务器会销毁该session。 作用域：一次会话 ServletContext： 生命周期：服务器开启到服务器关闭 作用域：整个web应用 ServletConfig类 ServletConfig类是Servlet程序的配置信息类，里面封装了一些初始化配置的信息 Servlet程序和ServletConfig对象都是由Tomcat负责创建，供我们使用。 每创建一次Servlet程序时，就创建一个ServletConfig对象。 每个ServletConfig对象都只能获取自己的Servlet的信息，不能跨域获取 重写init方法时要带上父类的init方法，如果不带上，则在使用ServletConfig相关方法时就会引发NullPointerException，这是因为父类GenericServlet的init方法中保存了ServletConfig对象，如果重写了init方法，该对象就会丢失，故而引发NullPointerException。 作用： 获取Servlet程序的别名，即servlet-name的值servletConfig.getServletName() 获取初始化参数init-paramservletConfig.getInitParameter() 获取ServletContext对象servletConfig.getServletContext() ServletContext类 ServletContext是接口，表示Servlet上下文对象 一个web工程只有一个ServletContext对象实例，在web工程启动时创建，停止时销毁 ServletContext对象是一个域对象 域对象是可以像map一样存取数据的对象，域指的是存取数据的操作范围 存数据 取数据 删除数据 Map put() get() remove() 域对象 serAttribute() getAttribute() removeAttribute() 作用： 获取web.xml中配置的上下文参数context-param: servletContext.getInitParameter() 获取当前的工程路径，格式：/工程路径: servletContext.getContextPath() 获取工程部署后在服务器硬盘上的绝对路径: servletContext.getRealPath("/")其中/在服务器解析时，表示地址为：http://ip:port/工程路径映射到IDEA为web目录 像map一样存储数据 HttpServletRequest类 作用：每次只要有请求进入Tomcat服务器，Tomcat服务器就会把请求过来的HTTP协议信息解析好封装到Request对象中，然后传递到service方法（doGet和DoPost中给我们使用，我们可以通过HttpServletRequest对象，获取到所有请求的信息。（每次请求创建一个，请求完成即销毁） 常见API： request.getRequestURI() ：获取请求的资源路径 request.getRequestURL() ：获取请求的url request.getRemoteHost() ：获取客户端ip地址 request.getHeader(String key) ：获取请求头中对应键的值 request.getMethod() ：获取请求方式 request.getParameter(String key) ：获取请求参数 request.getParameterValues(String key): 获取请求参数，用于参数值有多个时 通常在doPost方法的第一行写request.setCharacterEncoding("UTF-8");用来解决post请求的中文乱码问题 HttpServletRequest对象也是域对象。每个请求对应着唯一一个HttpServletRequest对象，而且在请求结束之前会一直存在，故在处理请求过程中可以使用request.setAttribute(String name, Object o)方法对该对象添加属性，用request.getAttribute(String name)获取该对象的属性，从而执行一些操作。 请求转发：服务器收到请求后，从一个资源转到另一个资源的操作 特点：1、浏览器地址栏没有改变。2、属于一次请求：由多个servlet资源共同完成的同一个请求，故HttpServletRequest对象的作用域涵盖请求转发过程，从而这些servlet资源可以共享该对象中的数据。3、能访问WEB-INF中的资源。4、不可以访问当前工程以外的资源。 RequestDispatcher requestDispatcher = request.getRequestDispatcher("/目的资源名称");请求转发必须以斜杠/开头，/表示http://ip:port/工程路径映射到IDEA为web目录 base标签的作用：所有的相对路径都是以base标签中的地址为参照。在没有base标签时，所有路径都以当前地址栏中的地址为参照，这在某些情况下会出错（如请求转发时，地址栏中的地址不变，但页面改变，若此页面中有相对路径，则参考基准不再是当前页面，而是地址栏的地址，从而出错）。若在页面中引入base标签，则相对路径参考基准成为base标签的路径。base标签在HTML文档的head标签内，如<base herf="http://localhost:8080/project/a/b.html>。 HttpServletResponse类 作用：HttpServletResponse类和HttpServletRequest类一样，每次请求进来，Tomcat服务器都会创建一个Response对象传递给Servlet程序去使用。HttpServletRequest表示请求过来的信息，HttpServletResponse表示所有响应的信息，如果需要设置返回给客户端的信息，都可以通过HttpServletResponse对象进行设置。 输出流：HttpServletResponse类通过流将响应传递给客户端。 字节流 getOutputStream(); 常用于下载（传递）二进制数据 字符流 getWriter(); 常用于回传字符串（常用） 两个流只能互斥使用 中文乱码：HttpServletResponse响应的默认字符集为ISO-8859-1，所以会中文乱码，可以通过response.setContentType("text/html; charset=UTF-8");将服务器和浏览器的字符集以及响应头都设置为UTF-8，就能解决中文乱码问题。此方法必须在获取流对象之前调用才有效 请求重定向： 第一种方法：在下图的response1中写response.setStatus(302) 来设置响应状态码，response.setHeader("Location", "http://ip:port/工程路径/response2 来设置响应头，告知新地址。 第二种方法（推荐使用）：在下图的response1中写response.sendRedirect(http://ip:port/工程路径/response2即可。 请求重定向是两次独立的请求，只是第二次有浏览器代劳，不需要手动发起请求而已。 特点：1、浏览器地址栏发生变化。2、属于两次请求。3、前后两个servlet资源不共享request域中的数据。4、不能访问WEB-INF中的资源。5、可以访问当前工程以外的资源。
web中 / 的不同含义 在web中 / 斜杠是一种绝对路径 / 斜杠如果被浏览器解析，得到地址为：http://ip:port/，如html中的<a href="/">斜杠</a> / 斜杠如果被服务器解析，得到地址为：http://ip:port/工程路径，如 <url-pattern>/hello</url-pattern> 、 servletContext.getRealPath("/") 、 request.getRequestDispatcher("/") 特殊情况：response.sendRediect("/");重定向，会将 / 斜杠发送给浏览器解析，得到http://ip:port/ 基于xml的方式 Servlet中web.xml的配置 <?xml version="1.0" encoding="UTF-8"?> <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"> <!--servlet标签给Tomcat配置Servlet程序--> <servlet> <!--servlet-name标签：给Servlet程序起一个别名（一般是类名）--> <servlet-name>HiServlet</servlet-name> <!--servlet-class是Servlet程序的全类名--> <servlet-class>com.example.tomcat.HiServlet</servlet-class> </servlet> <!--servlet-mapping标签给Servlet程序配置访问地址--> <servlet-mapping> <!--servlet-name标签告诉服务器，我当前配置的地址给哪个Servlet程序使用--> <servlet-name>HiServlet</servlet-name> <!--url-pattern标签配置访问地址 / 斜杠在服务器解析时，表示地址为：http://ip:port/工程路径 本工程即为http://localhost:8080/tomcat_war_exploded/ /hello 表示：http://ip:port/工程路径/hello 即http://localhost:8080/tomcat_war_exploded/hello --> <url-pattern>/hello</url-pattern> </servlet-mapping> </web-app> 从url定位到Servlet程序过程 对照上方的xml配置文件：当在地址栏输入http://localhost:8080/tomcat_war_exploded/hello时，由8080定位到Tomcat服务器，再由/tomcat_war_exploded定位到该工程，然后根据/hello定位到xml配置文件中<servlet-mapping>标签下的<url-pattern>标签，其对应的<servlet-name>标签值为HiServlet，再根据这个标识符找到相同名的<servlet>标签，根据其标签下<servlet-class>的值定位到类的位置，然后执行类中的service方法。'><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-21T18:48:13+00:00"><meta property="article:modified_time" content="2021-04-21T18:48:13+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Servlet学习笔记"><meta name=twitter:description content='Servlet定义
Servlet是一个Java应用程序，运行在服务器端，用来处理客户端请求并作出响应的程序。

实现Servlet的主要方式


程序实现Servlet接口（很少使用）

编写类实现Servlet接口
根据业务重写service方法
到web.xml中配置Servlet程序的访问地址（基于注解时不需要）



程序继承HttpServlet类（一般使用这种）

编写类继承HttpServlet类
根据业务需要重写doGet或doPost方法
到web.xml中配置Servlet程序的访问地址（基于注解时不需要）



在IDEA中直接创建Servlet程序
实质上还是第二种方法，只是IDEA帮你做了一些通用的工作


Servlet的生命周期

执行Servlet构造器方法，该方法在初次访问时调用一次。由Servlet容器（Tomcat）创建。这说明 Servlet 是单实例的!
执行init初始化方法，该方法在初次访问时调用一次。
执行service方法，该方法在每次访问时都会调用一次。
执行destory方法，该方法在web工程停止时调用一次。  用于释放当前 Servlet 所占用的资源。


Servlet接口的架构


Servlet的域对象

概念：可以在不同Servlet之间传递数据的对象，就是域对象。通俗的讲就是这个对象本身可以存储一定范围内的所有数据，通过它就能获取和存储数据。
域对象共有的方法：

getAttribute(String name) 获取对应的数据
getAttributeNames() 获取所有的key
removeAttribute(String name) 移除对应的数据
setAttribute(String name, Object object) 设置数据


Servlet的三大域对象分别为ServletRequest域、HttpSession域、ServletContext域
ServletRequest：

生命周期：请求开始到请求结束
作用域：整个请求链（包括请求转发）


HttpSession：

生命周期：会话开始到会话结束，服务器会为每个浏览器创建一个供其独享的Session对象，当一段时间内，session没有被使用（默认是30分钟），服务器会销毁该session。
作用域：一次会话


ServletContext：

生命周期：服务器开启到服务器关闭
作用域：整个web应用




ServletConfig类

ServletConfig类是Servlet程序的配置信息类，里面封装了一些初始化配置的信息
Servlet程序和ServletConfig对象都是由Tomcat负责创建，供我们使用。
每创建一次Servlet程序时，就创建一个ServletConfig对象。
每个ServletConfig对象都只能获取自己的Servlet的信息，不能跨域获取
重写init方法时要带上父类的init方法，如果不带上，则在使用ServletConfig相关方法时就会引发NullPointerException，这是因为父类GenericServlet的init方法中保存了ServletConfig对象，如果重写了init方法，该对象就会丢失，故而引发NullPointerException。
作用：

获取Servlet程序的别名，即servlet-name的值servletConfig.getServletName()
获取初始化参数init-paramservletConfig.getInitParameter()
获取ServletContext对象servletConfig.getServletContext()




ServletContext类

ServletContext是接口，表示Servlet上下文对象
一个web工程只有一个ServletContext对象实例，在web工程启动时创建，停止时销毁
ServletContext对象是一个域对象

域对象是可以像map一样存取数据的对象，域指的是存取数据的操作范围



                        存数据                  取数据                     删除数据  
        Map             put()                   get()                     remove()  
        域对象      serAttribute()          getAttribute()             removeAttribute()

作用：

获取web.xml中配置的上下文参数context-param: servletContext.getInitParameter()
获取当前的工程路径，格式：/工程路径: servletContext.getContextPath()
获取工程部署后在服务器硬盘上的绝对路径: servletContext.getRealPath("/")其中/在服务器解析时，表示地址为：http://ip:port/工程路径映射到IDEA为web目录
像map一样存储数据




HttpServletRequest类

作用：每次只要有请求进入Tomcat服务器，Tomcat服务器就会把请求过来的HTTP协议信息解析好封装到Request对象中，然后传递到service方法（doGet和DoPost中给我们使用，我们可以通过HttpServletRequest对象，获取到所有请求的信息。（每次请求创建一个，请求完成即销毁）
常见API：

request.getRequestURI() ：获取请求的资源路径
request.getRequestURL() ：获取请求的url
request.getRemoteHost() ：获取客户端ip地址
request.getHeader(String key) ：获取请求头中对应键的值
request.getMethod() ：获取请求方式
request.getParameter(String key) ：获取请求参数
request.getParameterValues(String key): 获取请求参数，用于参数值有多个时


通常在doPost方法的第一行写request.setCharacterEncoding("UTF-8");用来解决post请求的中文乱码问题
HttpServletRequest对象也是域对象。每个请求对应着唯一一个HttpServletRequest对象，而且在请求结束之前会一直存在，故在处理请求过程中可以使用request.setAttribute(String name, Object o)方法对该对象添加属性，用request.getAttribute(String name)获取该对象的属性，从而执行一些操作。
请求转发：服务器收到请求后，从一个资源转到另一个资源的操作

特点：1、浏览器地址栏没有改变。2、属于一次请求：由多个servlet资源共同完成的同一个请求，故HttpServletRequest对象的作用域涵盖请求转发过程，从而这些servlet资源可以共享该对象中的数据。3、能访问WEB-INF中的资源。4、不可以访问当前工程以外的资源。
RequestDispatcher requestDispatcher = request.getRequestDispatcher("/目的资源名称");请求转发必须以斜杠/开头，/表示http://ip:port/工程路径映射到IDEA为web目录
base标签的作用：所有的相对路径都是以base标签中的地址为参照。在没有base标签时，所有路径都以当前地址栏中的地址为参照，这在某些情况下会出错（如请求转发时，地址栏中的地址不变，但页面改变，若此页面中有相对路径，则参考基准不再是当前页面，而是地址栏的地址，从而出错）。若在页面中引入base标签，则相对路径参考基准成为base标签的路径。base标签在HTML文档的head标签内，如<base herf="http://localhost:8080/project/a/b.html>。




HttpServletResponse类

作用：HttpServletResponse类和HttpServletRequest类一样，每次请求进来，Tomcat服务器都会创建一个Response对象传递给Servlet程序去使用。HttpServletRequest表示请求过来的信息，HttpServletResponse表示所有响应的信息，如果需要设置返回给客户端的信息，都可以通过HttpServletResponse对象进行设置。
输出流：HttpServletResponse类通过流将响应传递给客户端。

字节流 getOutputStream();  常用于下载（传递）二进制数据
字符流 getWriter();    常用于回传字符串（常用）


两个流只能互斥使用


中文乱码：HttpServletResponse响应的默认字符集为ISO-8859-1，所以会中文乱码，可以通过response.setContentType("text/html; charset=UTF-8");将服务器和浏览器的字符集以及响应头都设置为UTF-8，就能解决中文乱码问题。此方法必须在获取流对象之前调用才有效
请求重定向：

第一种方法：在下图的response1中写response.setStatus(302) 来设置响应状态码，response.setHeader("Location", "http://ip:port/工程路径/response2 来设置响应头，告知新地址。
第二种方法（推荐使用）：在下图的response1中写response.sendRedirect(http://ip:port/工程路径/response2即可。
请求重定向是两次独立的请求，只是第二次有浏览器代劳，不需要手动发起请求而已。
特点：1、浏览器地址栏发生变化。2、属于两次请求。3、前后两个servlet资源不共享request域中的数据。4、不能访问WEB-INF中的资源。5、可以访问当前工程以外的资源。





web中 / 的不同含义

在web中 / 斜杠是一种绝对路径
/ 斜杠如果被浏览器解析，得到地址为：http://ip:port/，如html中的<a href="/">斜杠</a>
/ 斜杠如果被服务器解析，得到地址为：http://ip:port/工程路径，如  <url-pattern>/hello</url-pattern> 、
servletContext.getRealPath("/") 、 request.getRequestDispatcher("/")
特殊情况：response.sendRediect("/");重定向，会将 / 斜杠发送给浏览器解析，得到http://ip:port/


基于xml的方式
Servlet中web.xml的配置
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <!--servlet标签给Tomcat配置Servlet程序-->
    <servlet>
        <!--servlet-name标签：给Servlet程序起一个别名（一般是类名）-->
        <servlet-name>HiServlet</servlet-name>
        <!--servlet-class是Servlet程序的全类名-->
        <servlet-class>com.example.tomcat.HiServlet</servlet-class>
    </servlet>

    <!--servlet-mapping标签给Servlet程序配置访问地址-->
    <servlet-mapping>
        <!--servlet-name标签告诉服务器，我当前配置的地址给哪个Servlet程序使用-->
        <servlet-name>HiServlet</servlet-name>
        <!--url-pattern标签配置访问地址
            /   斜杠在服务器解析时，表示地址为：http://ip:port/工程路径   本工程即为http://localhost:8080/tomcat_war_exploded/
            /hello  表示：http://ip:port/工程路径/hello    即http://localhost:8080/tomcat_war_exploded/hello
        -->
        <url-pattern>/hello</url-pattern>
    </servlet-mapping>
</web-app>
从url定位到Servlet程序过程
对照上方的xml配置文件：当在地址栏输入http://localhost:8080/tomcat_war_exploded/hello时，由8080定位到Tomcat服务器，再由/tomcat_war_exploded定位到该工程，然后根据/hello定位到xml配置文件中<servlet-mapping>标签下的<url-pattern>标签，其对应的<servlet-name>标签值为HiServlet，再根据这个标识符找到相同名的<servlet>标签，根据其标签下<servlet-class>的值定位到类的位置，然后执行类中的service方法。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ethereal-lu.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Servlet学习笔记","item":"https://ethereal-lu.github.io/posts/java/servlet%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Servlet学习笔记","name":"Servlet学习笔记","description":"Servlet定义 Servlet是一个Java应用程序，运行在服务器端，用来处理客户端请求并作出响应的程序。\n实现Servlet的主要方式 程序实现Servlet接口（很少使用） 编写类实现Servlet接口 根据业务重写service方法 到web.xml中配置Servlet程序的访问地址（基于注解时不需要） 程序继承HttpServlet类（一般使用这种） 编写类继承HttpServlet类 根据业务需要重写doGet或doPost方法 到web.xml中配置Servlet程序的访问地址（基于注解时不需要） 在IDEA中直接创建Servlet程序 实质上还是第二种方法，只是IDEA帮你做了一些通用的工作 Servlet的生命周期 执行Servlet构造器方法，该方法在初次访问时调用一次。由Servlet容器（Tomcat）创建。这说明 Servlet 是单实例的! 执行init初始化方法，该方法在初次访问时调用一次。 执行service方法，该方法在每次访问时都会调用一次。 执行destory方法，该方法在web工程停止时调用一次。 用于释放当前 Servlet 所占用的资源。 Servlet接口的架构 Servlet的域对象 概念：可以在不同Servlet之间传递数据的对象，就是域对象。通俗的讲就是这个对象本身可以存储一定范围内的所有数据，通过它就能获取和存储数据。 域对象共有的方法： getAttribute(String name) 获取对应的数据 getAttributeNames() 获取所有的key removeAttribute(String name) 移除对应的数据 setAttribute(String name, Object object) 设置数据 Servlet的三大域对象分别为ServletRequest域、HttpSession域、ServletContext域 ServletRequest： 生命周期：请求开始到请求结束 作用域：整个请求链（包括请求转发） HttpSession： 生命周期：会话开始到会话结束，服务器会为每个浏览器创建一个供其独享的Session对象，当一段时间内，session没有被使用（默认是30分钟），服务器会销毁该session。 作用域：一次会话 ServletContext： 生命周期：服务器开启到服务器关闭 作用域：整个web应用 ServletConfig类 ServletConfig类是Servlet程序的配置信息类，里面封装了一些初始化配置的信息 Servlet程序和ServletConfig对象都是由Tomcat负责创建，供我们使用。 每创建一次Servlet程序时，就创建一个ServletConfig对象。 每个ServletConfig对象都只能获取自己的Servlet的信息，不能跨域获取 重写init方法时要带上父类的init方法，如果不带上，则在使用ServletConfig相关方法时就会引发NullPointerException，这是因为父类GenericServlet的init方法中保存了ServletConfig对象，如果重写了init方法，该对象就会丢失，故而引发NullPointerException。 作用： 获取Servlet程序的别名，即servlet-name的值servletConfig.getServletName() 获取初始化参数init-paramservletConfig.getInitParameter() 获取ServletContext对象servletConfig.getServletContext() ServletContext类 ServletContext是接口，表示Servlet上下文对象 一个web工程只有一个ServletContext对象实例，在web工程启动时创建，停止时销毁 ServletContext对象是一个域对象 域对象是可以像map一样存取数据的对象，域指的是存取数据的操作范围 存数据 取数据 删除数据 Map put() get() remove() 域对象 serAttribute() getAttribute() removeAttribute() 作用： 获取web.xml中配置的上下文参数context-param: servletContext.getInitParameter() 获取当前的工程路径，格式：/工程路径: servletContext.getContextPath() 获取工程部署后在服务器硬盘上的绝对路径: servletContext.getRealPath(\u0026quot;/\u0026quot;)其中/在服务器解析时，表示地址为：http://ip:port/工程路径映射到IDEA为web目录 像map一样存储数据 HttpServletRequest类 作用：每次只要有请求进入Tomcat服务器，Tomcat服务器就会把请求过来的HTTP协议信息解析好封装到Request对象中，然后传递到service方法（doGet和DoPost中给我们使用，我们可以通过HttpServletRequest对象，获取到所有请求的信息。（每次请求创建一个，请求完成即销毁） 常见API： request.getRequestURI() ：获取请求的资源路径 request.getRequestURL() ：获取请求的url request.getRemoteHost() ：获取客户端ip地址 request.getHeader(String key) ：获取请求头中对应键的值 request.getMethod() ：获取请求方式 request.getParameter(String key) ：获取请求参数 request.getParameterValues(String key): 获取请求参数，用于参数值有多个时 通常在doPost方法的第一行写request.setCharacterEncoding(\u0026quot;UTF-8\u0026quot;);用来解决post请求的中文乱码问题 HttpServletRequest对象也是域对象。每个请求对应着唯一一个HttpServletRequest对象，而且在请求结束之前会一直存在，故在处理请求过程中可以使用request.setAttribute(String name, Object o)方法对该对象添加属性，用request.getAttribute(String name)获取该对象的属性，从而执行一些操作。 请求转发：服务器收到请求后，从一个资源转到另一个资源的操作 特点：1、浏览器地址栏没有改变。2、属于一次请求：由多个servlet资源共同完成的同一个请求，故HttpServletRequest对象的作用域涵盖请求转发过程，从而这些servlet资源可以共享该对象中的数据。3、能访问WEB-INF中的资源。4、不可以访问当前工程以外的资源。 RequestDispatcher requestDispatcher = request.getRequestDispatcher(\u0026quot;/目的资源名称\u0026quot;);请求转发必须以斜杠/开头，/表示http://ip:port/工程路径映射到IDEA为web目录 base标签的作用：所有的相对路径都是以base标签中的地址为参照。在没有base标签时，所有路径都以当前地址栏中的地址为参照，这在某些情况下会出错（如请求转发时，地址栏中的地址不变，但页面改变，若此页面中有相对路径，则参考基准不再是当前页面，而是地址栏的地址，从而出错）。若在页面中引入base标签，则相对路径参考基准成为base标签的路径。base标签在HTML文档的head标签内，如\u0026lt;base herf=\u0026quot;http://localhost:8080/project/a/b.html\u0026gt;。 HttpServletResponse类 作用：HttpServletResponse类和HttpServletRequest类一样，每次请求进来，Tomcat服务器都会创建一个Response对象传递给Servlet程序去使用。HttpServletRequest表示请求过来的信息，HttpServletResponse表示所有响应的信息，如果需要设置返回给客户端的信息，都可以通过HttpServletResponse对象进行设置。 输出流：HttpServletResponse类通过流将响应传递给客户端。 字节流 getOutputStream(); 常用于下载（传递）二进制数据 字符流 getWriter(); 常用于回传字符串（常用） 两个流只能互斥使用 中文乱码：HttpServletResponse响应的默认字符集为ISO-8859-1，所以会中文乱码，可以通过response.setContentType(\u0026quot;text/html; charset=UTF-8\u0026quot;);将服务器和浏览器的字符集以及响应头都设置为UTF-8，就能解决中文乱码问题。此方法必须在获取流对象之前调用才有效 请求重定向： 第一种方法：在下图的response1中写response.setStatus(302) 来设置响应状态码，response.setHeader(\u0026quot;Location\u0026quot;, \u0026quot;http://ip:port/工程路径/response2 来设置响应头，告知新地址。 第二种方法（推荐使用）：在下图的response1中写response.sendRedirect(http://ip:port/工程路径/response2即可。 请求重定向是两次独立的请求，只是第二次有浏览器代劳，不需要手动发起请求而已。 特点：1、浏览器地址栏发生变化。2、属于两次请求。3、前后两个servlet资源不共享request域中的数据。4、不能访问WEB-INF中的资源。5、可以访问当前工程以外的资源。\nweb中 / 的不同含义 在web中 / 斜杠是一种绝对路径 / 斜杠如果被浏览器解析，得到地址为：http://ip:port/，如html中的\u0026lt;a href=\u0026quot;/\u0026quot;\u0026gt;斜杠\u0026lt;/a\u0026gt; / 斜杠如果被服务器解析，得到地址为：http://ip:port/工程路径，如 \u0026lt;url-pattern\u0026gt;/hello\u0026lt;/url-pattern\u0026gt; 、 servletContext.getRealPath(\u0026quot;/\u0026quot;) 、 request.getRequestDispatcher(\u0026quot;/\u0026quot;) 特殊情况：response.sendRediect(\u0026quot;/\u0026quot;);重定向，会将 / 斜杠发送给浏览器解析，得到http://ip:port/ 基于xml的方式 Servlet中web.xml的配置 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;!--servlet标签给Tomcat配置Servlet程序--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;!--servlet-name标签：给Servlet程序起一个别名（一般是类名）--\u0026gt; \u0026lt;servlet-name\u0026gt;HiServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;!--servlet-class是Servlet程序的全类名--\u0026gt; \u0026lt;servlet-class\u0026gt;com.example.tomcat.HiServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;!--servlet-mapping标签给Servlet程序配置访问地址--\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;!--servlet-name标签告诉服务器，我当前配置的地址给哪个Servlet程序使用--\u0026gt; \u0026lt;servlet-name\u0026gt;HiServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;!--url-pattern标签配置访问地址 / 斜杠在服务器解析时，表示地址为：http://ip:port/工程路径 本工程即为http://localhost:8080/tomcat_war_exploded/ /hello 表示：http://ip:port/工程路径/hello 即http://localhost:8080/tomcat_war_exploded/hello --\u0026gt; \u0026lt;url-pattern\u0026gt;/hello\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 从url定位到Servlet程序过程 对照上方的xml配置文件：当在地址栏输入http://localhost:8080/tomcat_war_exploded/hello时，由8080定位到Tomcat服务器，再由/tomcat_war_exploded定位到该工程，然后根据/hello定位到xml配置文件中\u0026lt;servlet-mapping\u0026gt;标签下的\u0026lt;url-pattern\u0026gt;标签，其对应的\u0026lt;servlet-name\u0026gt;标签值为HiServlet，再根据这个标识符找到相同名的\u0026lt;servlet\u0026gt;标签，根据其标签下\u0026lt;servlet-class\u0026gt;的值定位到类的位置，然后执行类中的service方法。\n","keywords":[],"articleBody":"Servlet定义 Servlet是一个Java应用程序，运行在服务器端，用来处理客户端请求并作出响应的程序。\n实现Servlet的主要方式 程序实现Servlet接口（很少使用） 编写类实现Servlet接口 根据业务重写service方法 到web.xml中配置Servlet程序的访问地址（基于注解时不需要） 程序继承HttpServlet类（一般使用这种） 编写类继承HttpServlet类 根据业务需要重写doGet或doPost方法 到web.xml中配置Servlet程序的访问地址（基于注解时不需要） 在IDEA中直接创建Servlet程序 实质上还是第二种方法，只是IDEA帮你做了一些通用的工作 Servlet的生命周期 执行Servlet构造器方法，该方法在初次访问时调用一次。由Servlet容器（Tomcat）创建。这说明 Servlet 是单实例的! 执行init初始化方法，该方法在初次访问时调用一次。 执行service方法，该方法在每次访问时都会调用一次。 执行destory方法，该方法在web工程停止时调用一次。 用于释放当前 Servlet 所占用的资源。 Servlet接口的架构 Servlet的域对象 概念：可以在不同Servlet之间传递数据的对象，就是域对象。通俗的讲就是这个对象本身可以存储一定范围内的所有数据，通过它就能获取和存储数据。 域对象共有的方法： getAttribute(String name) 获取对应的数据 getAttributeNames() 获取所有的key removeAttribute(String name) 移除对应的数据 setAttribute(String name, Object object) 设置数据 Servlet的三大域对象分别为ServletRequest域、HttpSession域、ServletContext域 ServletRequest： 生命周期：请求开始到请求结束 作用域：整个请求链（包括请求转发） HttpSession： 生命周期：会话开始到会话结束，服务器会为每个浏览器创建一个供其独享的Session对象，当一段时间内，session没有被使用（默认是30分钟），服务器会销毁该session。 作用域：一次会话 ServletContext： 生命周期：服务器开启到服务器关闭 作用域：整个web应用 ServletConfig类 ServletConfig类是Servlet程序的配置信息类，里面封装了一些初始化配置的信息 Servlet程序和ServletConfig对象都是由Tomcat负责创建，供我们使用。 每创建一次Servlet程序时，就创建一个ServletConfig对象。 每个ServletConfig对象都只能获取自己的Servlet的信息，不能跨域获取 重写init方法时要带上父类的init方法，如果不带上，则在使用ServletConfig相关方法时就会引发NullPointerException，这是因为父类GenericServlet的init方法中保存了ServletConfig对象，如果重写了init方法，该对象就会丢失，故而引发NullPointerException。 作用： 获取Servlet程序的别名，即servlet-name的值servletConfig.getServletName() 获取初始化参数init-paramservletConfig.getInitParameter() 获取ServletContext对象servletConfig.getServletContext() ServletContext类 ServletContext是接口，表示Servlet上下文对象 一个web工程只有一个ServletContext对象实例，在web工程启动时创建，停止时销毁 ServletContext对象是一个域对象 域对象是可以像map一样存取数据的对象，域指的是存取数据的操作范围 存数据 取数据 删除数据 Map put() get() remove() 域对象 serAttribute() getAttribute() removeAttribute() 作用： 获取web.xml中配置的上下文参数context-param: servletContext.getInitParameter() 获取当前的工程路径，格式：/工程路径: servletContext.getContextPath() 获取工程部署后在服务器硬盘上的绝对路径: servletContext.getRealPath(\"/\")其中/在服务器解析时，表示地址为：http://ip:port/工程路径映射到IDEA为web目录 像map一样存储数据 HttpServletRequest类 作用：每次只要有请求进入Tomcat服务器，Tomcat服务器就会把请求过来的HTTP协议信息解析好封装到Request对象中，然后传递到service方法（doGet和DoPost中给我们使用，我们可以通过HttpServletRequest对象，获取到所有请求的信息。（每次请求创建一个，请求完成即销毁） 常见API： request.getRequestURI() ：获取请求的资源路径 request.getRequestURL() ：获取请求的url request.getRemoteHost() ：获取客户端ip地址 request.getHeader(String key) ：获取请求头中对应键的值 request.getMethod() ：获取请求方式 request.getParameter(String key) ：获取请求参数 request.getParameterValues(String key): 获取请求参数，用于参数值有多个时 通常在doPost方法的第一行写request.setCharacterEncoding(\"UTF-8\");用来解决post请求的中文乱码问题 HttpServletRequest对象也是域对象。每个请求对应着唯一一个HttpServletRequest对象，而且在请求结束之前会一直存在，故在处理请求过程中可以使用request.setAttribute(String name, Object o)方法对该对象添加属性，用request.getAttribute(String name)获取该对象的属性，从而执行一些操作。 请求转发：服务器收到请求后，从一个资源转到另一个资源的操作 特点：1、浏览器地址栏没有改变。2、属于一次请求：由多个servlet资源共同完成的同一个请求，故HttpServletRequest对象的作用域涵盖请求转发过程，从而这些servlet资源可以共享该对象中的数据。3、能访问WEB-INF中的资源。4、不可以访问当前工程以外的资源。 RequestDispatcher requestDispatcher = request.getRequestDispatcher(\"/目的资源名称\");请求转发必须以斜杠/开头，/表示http://ip:port/工程路径映射到IDEA为web目录 base标签的作用：所有的相对路径都是以base标签中的地址为参照。在没有base标签时，所有路径都以当前地址栏中的地址为参照，这在某些情况下会出错（如请求转发时，地址栏中的地址不变，但页面改变，若此页面中有相对路径，则参考基准不再是当前页面，而是地址栏的地址，从而出错）。若在页面中引入base标签，则相对路径参考基准成为base标签的路径。base标签在HTML文档的head标签内，如","wordCount":"243","inLanguage":"en","datePublished":"2021-04-21T18:48:13Z","dateModified":"2021-04-21T18:48:13Z","author":{"@type":"Person","name":"lu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ethereal-lu.github.io/posts/java/servlet%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"lu","logo":{"@type":"ImageObject","url":"https://ethereal-lu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="lu (Alt + H)">lu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethereal-lu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ethereal-lu.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Servlet学习笔记</h1><div class=post-meta><span title='2021-04-21 18:48:13 +0000 UTC'>2021-04-21</span>&nbsp;·&nbsp;243 words&nbsp;·&nbsp;lu</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#servlet定义>Servlet定义</a></li><li><a href=#实现servlet的主要方式>实现Servlet的主要方式</a></li><li><a href=#servlet的生命周期>Servlet的生命周期</a></li><li><a href=#servlet接口的架构>Servlet接口的架构</a></li><li><a href=#servlet的域对象>Servlet的域对象</a></li><li><a href=#servletconfig类>ServletConfig类</a></li><li><a href=#servletcontext类>ServletContext类</a></li><li><a href=#httpservletrequest类>HttpServletRequest类</a></li><li><a href=#httpservletresponse类>HttpServletResponse类</a></li><li><a href=#web中--的不同含义>web中 / 的不同含义</a></li><li><a href=#基于xml的方式>基于xml的方式</a></li><li><a href=#springboot-中的-servlet>Springboot 中的 Servlet</a></li><li><a href=#filter过滤器和spring-aop拦截器>Filter过滤器和Spring AOP拦截器</a></li><li><a href=#java回调机制callback>JAVA回调机制(CallBack)</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h3 id=servlet定义>Servlet定义<a hidden class=anchor aria-hidden=true href=#servlet定义>#</a></h3><p>Servlet是一个Java应用程序，运行在服务器端，用来处理客户端请求并作出响应的程序。</p><hr><h3 id=实现servlet的主要方式>实现Servlet的主要方式<a hidden class=anchor aria-hidden=true href=#实现servlet的主要方式>#</a></h3><ul><li><h4 id=程序实现servlet接口很少使用>程序实现Servlet接口（很少使用）<a hidden class=anchor aria-hidden=true href=#程序实现servlet接口很少使用>#</a></h4><ol><li>编写类实现Servlet接口</li><li>根据业务重写service方法</li><li>到web.xml中配置Servlet程序的访问地址（基于注解时不需要）</li></ol></li><li><h4 id=程序继承httpservlet类一般使用这种>程序继承HttpServlet类（一般使用这种）<a hidden class=anchor aria-hidden=true href=#程序继承httpservlet类一般使用这种>#</a></h4><ol><li>编写类继承HttpServlet类</li><li>根据业务需要重写doGet或doPost方法</li><li>到web.xml中配置Servlet程序的访问地址（基于注解时不需要）</li></ol></li><li><h4 id=在idea中直接创建servlet程序>在IDEA中直接创建Servlet程序<a hidden class=anchor aria-hidden=true href=#在idea中直接创建servlet程序>#</a></h4>实质上还是第二种方法，只是IDEA帮你做了一些通用的工作</li></ul><hr><h3 id=servlet的生命周期>Servlet的生命周期<a hidden class=anchor aria-hidden=true href=#servlet的生命周期>#</a></h3><ol><li>执行Servlet构造器方法，该方法在<u>初次访问</u>时调用一次。由Servlet容器（Tomcat）创建。<strong>这说明 Servlet 是单实例的!</strong></li><li>执行init初始化方法，该方法在<u>初次访问</u>时调用一次。</li><li>执行service方法，该方法在<u>每次访问</u>时都会调用一次。</li><li>执行destory方法，该方法在<u>web工程停止</u>时调用一次。 用于释放当前 Servlet 所占用的资源。</li></ol><hr><h3 id=servlet接口的架构>Servlet接口的架构<a hidden class=anchor aria-hidden=true href=#servlet接口的架构>#</a></h3><p><img alt=Servlet loading=lazy src=/posts/java/servlet%E7%AC%94%E8%AE%B0/Servlet.jpg></p><hr><h3 id=servlet的域对象>Servlet的域对象<a hidden class=anchor aria-hidden=true href=#servlet的域对象>#</a></h3><ul><li>概念：可以在不同Servlet之间传递数据的对象，就是域对象。通俗的讲就是这个对象本身可以存储一定范围内的所有数据，通过它就能获取和存储数据。</li><li>域对象共有的方法：<ul><li><code>getAttribute(String name)</code> 获取对应的数据</li><li><code>getAttributeNames()</code> 获取所有的key</li><li><code>removeAttribute(String name)</code> 移除对应的数据</li><li><code>setAttribute(String name, Object object)</code> 设置数据</li></ul></li><li>Servlet的三大域对象分别为<strong>ServletRequest域</strong>、<strong>HttpSession域</strong>、<strong>ServletContext域</strong></li><li>ServletRequest：<ul><li>生命周期：请求开始到请求结束</li><li>作用域：整个请求链（包括请求转发）</li></ul></li><li>HttpSession：<ul><li>生命周期：会话开始到会话结束，服务器会为每个浏览器创建一个供其独享的Session对象，当一段时间内，session没有被使用（默认是30分钟），服务器会销毁该session。</li><li>作用域：一次会话</li></ul></li><li>ServletContext：<ul><li>生命周期：服务器开启到服务器关闭</li><li>作用域：整个web应用</li></ul></li></ul><hr><h3 id=servletconfig类>ServletConfig类<a hidden class=anchor aria-hidden=true href=#servletconfig类>#</a></h3><ul><li>ServletConfig类是Servlet程序的配置信息类，里面封装了一些初始化配置的信息</li><li>Servlet程序和ServletConfig对象都是由Tomcat负责创建，供我们使用。</li><li>每创建一次Servlet程序时，就创建一个ServletConfig对象。</li><li>每个ServletConfig对象都只能获取自己的Servlet的信息，不能跨域获取</li><li>重写init方法时要带上父类的init方法，如果不带上，则在使用ServletConfig相关方法时就会引发NullPointerException，这是因为父类GenericServlet的init方法中保存了ServletConfig对象，如果重写了init方法，该对象就会丢失，故而引发NullPointerException。</li><li>作用：<ol><li>获取Servlet程序的别名，即servlet-name的值<code>servletConfig.getServletName()</code></li><li>获取初始化参数init-param<code>servletConfig.getInitParameter()</code></li><li>获取ServletContext对象<code>servletConfig.getServletContext()</code></li></ol></li></ul><hr><h3 id=servletcontext类>ServletContext类<a hidden class=anchor aria-hidden=true href=#servletcontext类>#</a></h3><ul><li>ServletContext是接口，表示Servlet上下文对象</li><li>一个web工程只有一个ServletContext对象实例，在web工程启动时创建，停止时销毁</li><li>ServletContext对象是一个域对象<ul><li>域对象是可以像map一样存取数据的对象，域指的是存取数据的操作范围</li></ul></li></ul><pre tabindex=0><code>                        存数据                  取数据                     删除数据  
        Map             put()                   get()                     remove()  
        域对象      serAttribute()          getAttribute()             removeAttribute()
</code></pre><ul><li>作用：<ol><li>获取web.xml中配置的上下文参数context-param: <code>servletContext.getInitParameter()</code></li><li>获取当前的工程路径，格式：/工程路径: <code>servletContext.getContextPath()</code></li><li>获取工程部署后在服务器硬盘上的绝对路径: <code>servletContext.getRealPath("/")</code>其中/在服务器解析时，表示地址为：<code>http://ip:port/工程路径</code>映射到IDEA为web目录</li><li>像map一样存储数据</li></ol></li></ul><hr><h3 id=httpservletrequest类>HttpServletRequest类<a hidden class=anchor aria-hidden=true href=#httpservletrequest类>#</a></h3><ul><li>作用：每次只要有请求进入Tomcat服务器，Tomcat服务器就会把请求过来的HTTP协议信息解析好封装到Request对象中，然后传递到service方法（doGet和DoPost中给我们使用，我们可以通过HttpServletRequest对象，获取到所有请求的信息。（每次请求创建一个，请求完成即销毁）</li><li>常见API：<ul><li><code>request.getRequestURI()</code> ：获取请求的资源路径</li><li><code>request.getRequestURL()</code> ：获取请求的url</li><li><code>request.getRemoteHost()</code> ：获取客户端ip地址</li><li><code>request.getHeader(String key)</code> ：获取请求头中对应键的值</li><li><code>request.getMethod()</code> ：获取请求方式</li><li><code>request.getParameter(String key)</code> ：获取请求参数</li><li><code>request.getParameterValues(String key)</code>: 获取请求参数，用于参数值有多个时</li></ul></li><li>通常在doPost方法的第一行写<code>request.setCharacterEncoding("UTF-8");</code>用来解决post请求的中文乱码问题</li><li>HttpServletRequest对象也是域对象。每个请求对应着唯一一个HttpServletRequest对象，而且在请求结束之前会一直存在，故在处理请求过程中可以使用<code>request.setAttribute(String name, Object o)</code>方法对该对象添加属性，用<code>request.getAttribute(String name)</code>获取该对象的属性，从而执行一些操作。</li><li>请求转发：服务器收到请求后，从一个资源转到另一个资源的操作<ul><li>特点：1、浏览器地址栏没有改变。2、属于一次请求：由多个servlet资源共同完成的同一个请求，故HttpServletRequest对象的作用域涵盖请求转发过程，从而这些servlet资源可以共享该对象中的数据。3、能访问WEB-INF中的资源。4、不可以访问当前工程以外的资源。</li><li><code>RequestDispatcher requestDispatcher = request.getRequestDispatcher("/目的资源名称");</code>请求转发必须以斜杠/开头，/表示<code>http://ip:port/工程路径</code>映射到IDEA为web目录</li><li>base标签的作用：所有的相对路径都是以base标签中的地址为参照。在没有base标签时，所有路径都以当前地址栏中的地址为参照，这在某些情况下会出错（如请求转发时，地址栏中的地址不变，但页面改变，若此页面中有相对路径，则参考基准不再是当前页面，而是地址栏的地址，从而出错）。若在页面中引入base标签，则相对路径参考基准成为base标签的路径。base标签在HTML文档的head标签内，如<code>&lt;base herf="http://localhost:8080/project/a/b.html></code>。</li></ul></li></ul><hr><h3 id=httpservletresponse类>HttpServletResponse类<a hidden class=anchor aria-hidden=true href=#httpservletresponse类>#</a></h3><ul><li>作用：HttpServletResponse类和HttpServletRequest类一样，每次请求进来，Tomcat服务器都会创建一个Response对象传递给Servlet程序去使用。HttpServletRequest表示请求过来的信息，HttpServletResponse表示所有响应的信息，如果需要设置返回给客户端的信息，都可以通过HttpServletResponse对象进行设置。</li><li>输出流：HttpServletResponse类通过流将响应传递给客户端。<ol><li>字节流 <code>getOutputStream();</code> 常用于下载（传递）二进制数据</li><li>字符流 <code>getWriter();</code> 常用于回传字符串（常用）</li></ol><ul><li>两个流只能互斥使用</li></ul></li><li>中文乱码：HttpServletResponse响应的默认字符集为ISO-8859-1，所以会中文乱码，可以通过<code>response.setContentType("text/html; charset=UTF-8");</code>将服务器和浏览器的字符集以及响应头都设置为UTF-8，就能解决中文乱码问题。<strong>此方法必须在获取流对象之前调用才有效</strong></li><li>请求重定向：<ul><li>第一种方法：在下图的response1中写<code>response.setStatus(302)</code> 来设置响应状态码，<code>response.setHeader("Location", "http://ip:port/工程路径/response2</code> 来设置响应头，告知新地址。</li><li>第二种方法（<strong>推荐使用</strong>）：在下图的response1中写<code>response.sendRedirect(http://ip:port/工程路径/response2</code>即可。</li><li>请求重定向是两次独立的请求，只是第二次有浏览器代劳，不需要手动发起请求而已。</li><li>特点：1、浏览器地址栏发生变化。2、属于两次请求。3、前后两个servlet资源不共享request域中的数据。4、不能访问WEB-INF中的资源。5、可以访问当前工程以外的资源。<br><img alt=请求重定向 loading=lazy src=/posts/java/servlet%E7%AC%94%E8%AE%B0/%E8%AF%B7%E6%B1%82%E9%87%8D%E5%AE%9A%E5%90%91.jpg></li></ul></li></ul><hr><h3 id=web中--的不同含义>web中 / 的不同含义<a hidden class=anchor aria-hidden=true href=#web中--的不同含义>#</a></h3><ul><li>在web中 / 斜杠是一种<strong>绝对路径</strong></li><li>/ 斜杠如果被浏览器解析，得到地址为：<code>http://ip:port/</code>，如html中的<code>&lt;a href="/">斜杠&lt;/a></code></li><li>/ 斜杠如果被服务器解析，得到地址为：<code>http://ip:port/工程路径</code>，如 <code>&lt;url-pattern>/hello&lt;/url-pattern></code> 、
<code>servletContext.getRealPath("/")</code> 、 <code>request.getRequestDispatcher("/")</code></li><li>特殊情况：<code>response.sendRediect("/");</code>重定向，会将 / 斜杠发送给浏览器解析，得到<code>http://ip:port/</code></li></ul><hr><h3 id=基于xml的方式>基于xml的方式<a hidden class=anchor aria-hidden=true href=#基于xml的方式>#</a></h3><h4 id=servlet中webxml的配置>Servlet中web.xml的配置<a hidden class=anchor aria-hidden=true href=#servlet中webxml的配置>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#75715e>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;web-app</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#34;http://xmlns.jcp.org/xml/ns/javaee&#34;</span>
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>xmlns:xsi=</span><span style=color:#e6db74>&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>xsi:schemaLocation=</span><span style=color:#e6db74>&#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&#34;</span>
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>version=</span><span style=color:#e6db74>&#34;4.0&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>&lt;!--servlet标签给Tomcat配置Servlet程序--&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;servlet&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>&lt;!--servlet-name标签：给Servlet程序起一个别名（一般是类名）--&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;servlet-name&gt;</span>HiServlet<span style=color:#f92672>&lt;/servlet-name&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>&lt;!--servlet-class是Servlet程序的全类名--&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;servlet-class&gt;</span>com.example.tomcat.HiServlet<span style=color:#f92672>&lt;/servlet-class&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/servlet&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>&lt;!--servlet-mapping标签给Servlet程序配置访问地址--&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;servlet-mapping&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>&lt;!--servlet-name标签告诉服务器，我当前配置的地址给哪个Servlet程序使用--&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;servlet-name&gt;</span>HiServlet<span style=color:#f92672>&lt;/servlet-name&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>&lt;!--url-pattern标签配置访问地址
</span></span></span><span style=display:flex><span><span style=color:#75715e>            /   斜杠在服务器解析时，表示地址为：http://ip:port/工程路径   本工程即为http://localhost:8080/tomcat_war_exploded/
</span></span></span><span style=display:flex><span><span style=color:#75715e>            /hello  表示：http://ip:port/工程路径/hello    即http://localhost:8080/tomcat_war_exploded/hello
</span></span></span><span style=display:flex><span><span style=color:#75715e>        --&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;url-pattern&gt;</span>/hello<span style=color:#f92672>&lt;/url-pattern&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;/servlet-mapping&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/web-app&gt;</span>
</span></span></code></pre></div><h4 id=从url定位到servlet程序过程>从url定位到Servlet程序过程<a hidden class=anchor aria-hidden=true href=#从url定位到servlet程序过程>#</a></h4><p>对照上方的xml配置文件：当在地址栏输入<code>http://localhost:8080/tomcat_war_exploded/hello</code>时，由8080定位到Tomcat服务器，再由/tomcat_war_exploded定位到该工程，然后根据/hello定位到xml配置文件中<code>&lt;servlet-mapping></code>标签下的<code>&lt;url-pattern></code>标签，其对应的<code>&lt;servlet-name></code>标签值为HiServlet，再根据这个标识符找到相同名的<code>&lt;servlet></code>标签，根据其标签下<code>&lt;servlet-class></code>的值定位到类的位置，然后执行类中的service方法。</p><hr><h3 id=springboot-中的-servlet>Springboot 中的 Servlet<a hidden class=anchor aria-hidden=true href=#springboot-中的-servlet>#</a></h3><p>Springboot 自带 tomcat 这一 web 容器，在 8080 端口监听连接请求。在 tomcat 中一个 context 容器就是一个 web 应用，一个web 应用可以有多个 servlet。</p><p>当 tomcat 接收到一个请求后，根据请求路径找到对应的 web application，然后进入该 web application 的 DispatcherServlet，之后就是 SpringMVC 流程。</p><p><strong>注意</strong>：HttpServletRequest和HttpServletResponse是在调用servlet之前由tomcat创建的，然后才将这两个对象作为参数调用servlet。</p><p>![DispatcherServlet 继承关系](DispatcherServlet 继承关系.png)</p><hr><h3 id=filter过滤器和spring-aop拦截器>Filter过滤器和Spring AOP拦截器<a hidden class=anchor aria-hidden=true href=#filter过滤器和spring-aop拦截器>#</a></h3><p>Spring的拦截器与Servlet的Filter有相似之处，比如二者都是AOP编程思想的体现，都能实现权限检查、日志记录等。</p><p>Filter是在Servlet规范中定义的，是Servlet容器支持的，而拦截器是在Spring容器内的，是Spring框架支持的。因此，Filter 的使用必须依赖于 Servlet容器，而拦截器不需要。而且拦截器是Spring中的组件，可以使用Spring中的所有资源，Filter 不能。</p><p>Filter在只在Servlet前后起作用。而拦截器能够深入到方法前后、异常抛出前后等，因此拦截器的使用粒度更细。所以在Spring构架的程序中，要优先使用拦截器。</p><p>Filter 通过Java的回调机制实现。 Interfactor是基于Java的反射机制实现。</p><p>执行顺序：过滤前-拦截前-Action处理-拦截后-过滤后。</p><p><img alt=过滤器于拦截器 loading=lazy src=/posts/java/servlet%E7%AC%94%E8%AE%B0/%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BA%8E%E6%8B%A6%E6%88%AA%E5%99%A8.png></p><h3 id=java回调机制callback>JAVA回调机制(CallBack)<a hidden class=anchor aria-hidden=true href=#java回调机制callback>#</a></h3><p>当要调用一个函数的时候，需要先给它传入一个函数，供其在合适的时候使用，这个被传入的函数就叫回调函数。如 Thread 的 run函数，以及Consumer、Predict函数等都是回调函数。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/markdown/><span class=title>« Prev</span><br><span>MarkDown无法显示本地图片</span>
</a><a class=next href=https://ethereal-lu.github.io/posts/java/tomcat%E7%AC%94%E8%AE%B0/><span class=title>Next »</span><br><span>tomcat笔记</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>