<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SpringBoot学习笔记 | lu</title>
<meta name=keywords content><meta name=description content="Spring Boot 是 Spring 的子项目，正如其名字，提供 Spring 的引导( Boot )的功能。
通过 Spring Boot ，开发者可以快速配置 Spring 项目，引入各种 Spring MVC、Spring Transaction、Spring AOP、等等框架，而无需不断重复编写繁重的 Spring 配置，降低了 Spring 的使用成本。
项目创建

新建 spring initializr 项目，在新建过程中引入 spring web 依赖
将所有的controller、pojo、dao等包创建在Application类的同名目录下（约定大于配置），创建在其他目录下会报错
在resources目录下创建banner.txt文件，可以在里面粘贴一些图片用于启动时展示


自动装配原理


父工程 spring-boot-dependencies 对springboot的所有依赖进行管理，其中就有依赖的版本控制，因此我们在pom.xml中引入依赖时，不需要指定版本


启动器：启动器都以spring-boot-starter打头，就是springboot的启动场景，如spring-boot-starter-web，就会帮我们自动导入web环境所有的依赖。springboot会将所有的功能场景变为一个个的启动器。我们要使用什么功能，只需要找到相对应的启动器并导入即可


主程序：
// @SpringBootApplication ：标注这个类是springboot的应用
@SpringBootApplication
public class Springboot01HelloworldApplication {
    public static void main(String[] args) {
        // 启动springboot
        SpringApplication.run(Springboot01HelloworldApplication.class, args);
    }
}
@SpringBootApplication 是复合注解，主要包括 **@ComponentScan, @EnableAutoConfiguration, @SpringBootConfiguration**三个注解。
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = {@Filter(
    type = FilterType.CUSTOM,
    classes = {TypeExcludeFilter.class}
), @Filter(
    type = FilterType.CUSTOM,
    classes = {AutoConfigurationExcludeFilter.class}
)}
)
public @interface SpringBootApplication

@ComponentScan 注解：组件扫描。 spring里有四大注解：@Service,@Repository,@Component,@Controller用来定义一个bean.@ComponentScan注解就是用来自动扫描被这些注解标识的类，最终生成ioc容器里的bean．
@SpringBootConfiguration 注解：@SpringBootConfiguration继承自@Configuration，二者功能也一致，标注当前类是配置类， 并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。
@EnableAutoConfiguration 注解：从 classpath 中搜索所有的 META-INF/spring.factories 配置文件，然后将其中key为org.springframework.boot.autoconfigure.EnableAutoConfiguration 的 value 加载到spring容器中。



注解："><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/posts/java/springboot%E7%AC%94%E8%AE%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity="sha256-1yREUm1+y9sAFUOKf6iQVKZYv3WdBULi5d+BzpS0k+4=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/posts/java/springboot%E7%AC%94%E8%AE%B0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/posts/java/springboot%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="lu"><meta property="og:title" content="SpringBoot学习笔记"><meta property="og:description" content="Spring Boot 是 Spring 的子项目，正如其名字，提供 Spring 的引导( Boot )的功能。
通过 Spring Boot ，开发者可以快速配置 Spring 项目，引入各种 Spring MVC、Spring Transaction、Spring AOP、等等框架，而无需不断重复编写繁重的 Spring 配置，降低了 Spring 的使用成本。
项目创建 新建 spring initializr 项目，在新建过程中引入 spring web 依赖 将所有的controller、pojo、dao等包创建在Application类的同名目录下（约定大于配置），创建在其他目录下会报错 在resources目录下创建banner.txt文件，可以在里面粘贴一些图片用于启动时展示 自动装配原理 父工程 spring-boot-dependencies 对springboot的所有依赖进行管理，其中就有依赖的版本控制，因此我们在pom.xml中引入依赖时，不需要指定版本
启动器：启动器都以spring-boot-starter打头，就是springboot的启动场景，如spring-boot-starter-web，就会帮我们自动导入web环境所有的依赖。springboot会将所有的功能场景变为一个个的启动器。我们要使用什么功能，只需要找到相对应的启动器并导入即可
主程序：
// @SpringBootApplication ：标注这个类是springboot的应用 @SpringBootApplication public class Springboot01HelloworldApplication { public static void main(String[] args) { // 启动springboot SpringApplication.run(Springboot01HelloworldApplication.class, args); } } @SpringBootApplication 是复合注解，主要包括 **@ComponentScan, @EnableAutoConfiguration, @SpringBootConfiguration**三个注解。
@SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) public @interface SpringBootApplication @ComponentScan 注解：组件扫描。 spring里有四大注解：@Service,@Repository,@Component,@Controller用来定义一个bean.@ComponentScan注解就是用来自动扫描被这些注解标识的类，最终生成ioc容器里的bean． @SpringBootConfiguration 注解：@SpringBootConfiguration继承自@Configuration，二者功能也一致，标注当前类是配置类， 并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。 @EnableAutoConfiguration 注解：从 classpath 中搜索所有的 META-INF/spring.factories 配置文件，然后将其中key为org.springframework.boot.autoconfigure.EnableAutoConfiguration 的 value 加载到spring容器中。 注解："><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-10T17:39:41+00:00"><meta property="article:modified_time" content="2021-05-10T17:39:41+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="SpringBoot学习笔记"><meta name=twitter:description content="Spring Boot 是 Spring 的子项目，正如其名字，提供 Spring 的引导( Boot )的功能。
通过 Spring Boot ，开发者可以快速配置 Spring 项目，引入各种 Spring MVC、Spring Transaction、Spring AOP、等等框架，而无需不断重复编写繁重的 Spring 配置，降低了 Spring 的使用成本。
项目创建

新建 spring initializr 项目，在新建过程中引入 spring web 依赖
将所有的controller、pojo、dao等包创建在Application类的同名目录下（约定大于配置），创建在其他目录下会报错
在resources目录下创建banner.txt文件，可以在里面粘贴一些图片用于启动时展示


自动装配原理


父工程 spring-boot-dependencies 对springboot的所有依赖进行管理，其中就有依赖的版本控制，因此我们在pom.xml中引入依赖时，不需要指定版本


启动器：启动器都以spring-boot-starter打头，就是springboot的启动场景，如spring-boot-starter-web，就会帮我们自动导入web环境所有的依赖。springboot会将所有的功能场景变为一个个的启动器。我们要使用什么功能，只需要找到相对应的启动器并导入即可


主程序：
// @SpringBootApplication ：标注这个类是springboot的应用
@SpringBootApplication
public class Springboot01HelloworldApplication {
    public static void main(String[] args) {
        // 启动springboot
        SpringApplication.run(Springboot01HelloworldApplication.class, args);
    }
}
@SpringBootApplication 是复合注解，主要包括 **@ComponentScan, @EnableAutoConfiguration, @SpringBootConfiguration**三个注解。
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = {@Filter(
    type = FilterType.CUSTOM,
    classes = {TypeExcludeFilter.class}
), @Filter(
    type = FilterType.CUSTOM,
    classes = {AutoConfigurationExcludeFilter.class}
)}
)
public @interface SpringBootApplication

@ComponentScan 注解：组件扫描。 spring里有四大注解：@Service,@Repository,@Component,@Controller用来定义一个bean.@ComponentScan注解就是用来自动扫描被这些注解标识的类，最终生成ioc容器里的bean．
@SpringBootConfiguration 注解：@SpringBootConfiguration继承自@Configuration，二者功能也一致，标注当前类是配置类， 并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。
@EnableAutoConfiguration 注解：从 classpath 中搜索所有的 META-INF/spring.factories 配置文件，然后将其中key为org.springframework.boot.autoconfigure.EnableAutoConfiguration 的 value 加载到spring容器中。



注解："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ethereal-lu.github.io/posts/"},{"@type":"ListItem","position":2,"name":"SpringBoot学习笔记","item":"https://ethereal-lu.github.io/posts/java/springboot%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SpringBoot学习笔记","name":"SpringBoot学习笔记","description":"Spring Boot 是 Spring 的子项目，正如其名字，提供 Spring 的引导( Boot )的功能。\n通过 Spring Boot ，开发者可以快速配置 Spring 项目，引入各种 Spring MVC、Spring Transaction、Spring AOP、等等框架，而无需不断重复编写繁重的 Spring 配置，降低了 Spring 的使用成本。\n项目创建 新建 spring initializr 项目，在新建过程中引入 spring web 依赖 将所有的controller、pojo、dao等包创建在Application类的同名目录下（约定大于配置），创建在其他目录下会报错 在resources目录下创建banner.txt文件，可以在里面粘贴一些图片用于启动时展示 自动装配原理 父工程 spring-boot-dependencies 对springboot的所有依赖进行管理，其中就有依赖的版本控制，因此我们在pom.xml中引入依赖时，不需要指定版本\n启动器：启动器都以spring-boot-starter打头，就是springboot的启动场景，如spring-boot-starter-web，就会帮我们自动导入web环境所有的依赖。springboot会将所有的功能场景变为一个个的启动器。我们要使用什么功能，只需要找到相对应的启动器并导入即可\n主程序：\n// @SpringBootApplication ：标注这个类是springboot的应用 @SpringBootApplication public class Springboot01HelloworldApplication { public static void main(String[] args) { // 启动springboot SpringApplication.run(Springboot01HelloworldApplication.class, args); } } @SpringBootApplication 是复合注解，主要包括 **@ComponentScan, @EnableAutoConfiguration, @SpringBootConfiguration**三个注解。\n@SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) public @interface SpringBootApplication @ComponentScan 注解：组件扫描。 spring里有四大注解：@Service,@Repository,@Component,@Controller用来定义一个bean.@ComponentScan注解就是用来自动扫描被这些注解标识的类，最终生成ioc容器里的bean． @SpringBootConfiguration 注解：@SpringBootConfiguration继承自@Configuration，二者功能也一致，标注当前类是配置类， 并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。 @EnableAutoConfiguration 注解：从 classpath 中搜索所有的 META-INF/spring.factories 配置文件，然后将其中key为org.springframework.boot.autoconfigure.EnableAutoConfiguration 的 value 加载到spring容器中。 注解：\n","keywords":[],"articleBody":"Spring Boot 是 Spring 的子项目，正如其名字，提供 Spring 的引导( Boot )的功能。\n通过 Spring Boot ，开发者可以快速配置 Spring 项目，引入各种 Spring MVC、Spring Transaction、Spring AOP、等等框架，而无需不断重复编写繁重的 Spring 配置，降低了 Spring 的使用成本。\n项目创建 新建 spring initializr 项目，在新建过程中引入 spring web 依赖 将所有的controller、pojo、dao等包创建在Application类的同名目录下（约定大于配置），创建在其他目录下会报错 在resources目录下创建banner.txt文件，可以在里面粘贴一些图片用于启动时展示 自动装配原理 父工程 spring-boot-dependencies 对springboot的所有依赖进行管理，其中就有依赖的版本控制，因此我们在pom.xml中引入依赖时，不需要指定版本\n启动器：启动器都以spring-boot-starter打头，就是springboot的启动场景，如spring-boot-starter-web，就会帮我们自动导入web环境所有的依赖。springboot会将所有的功能场景变为一个个的启动器。我们要使用什么功能，只需要找到相对应的启动器并导入即可\n主程序：\n// @SpringBootApplication ：标注这个类是springboot的应用 @SpringBootApplication public class Springboot01HelloworldApplication { public static void main(String[] args) { // 启动springboot SpringApplication.run(Springboot01HelloworldApplication.class, args); } } @SpringBootApplication 是复合注解，主要包括 **@ComponentScan, @EnableAutoConfiguration, @SpringBootConfiguration**三个注解。\n@SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) public @interface SpringBootApplication @ComponentScan 注解：组件扫描。 spring里有四大注解：@Service,@Repository,@Component,@Controller用来定义一个bean.@ComponentScan注解就是用来自动扫描被这些注解标识的类，最终生成ioc容器里的bean． @SpringBootConfiguration 注解：@SpringBootConfiguration继承自@Configuration，二者功能也一致，标注当前类是配置类， 并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。 @EnableAutoConfiguration 注解：从 classpath 中搜索所有的 META-INF/spring.factories 配置文件，然后将其中key为org.springframework.boot.autoconfigure.EnableAutoConfiguration 的 value 加载到spring容器中。 注解：\n@Configuration： 表示这是一个配置类 @EnableConfigurationProperties： 自动配置属性，其中传入的类的属性即为配置文件中可以设置的属性 Conditional系列注解：Spring的底层注解，根据不同的条件，判断当前配置或类是否生效，该系列下的每一个注解用于对一种情况做出判断，如： @ConditionalOnClass：判断是否为指定类型的类 @ConditionalOnWebApplication： 判断是否为web应用 @ConditionalOnProperty： 判断属性值是否为指定值 等等 原理粗略理解：\nspring boot启动时会加载大量的自动配置类，而每个自动配置类都有一个条件判断，只有当条件满足时才会被加载，因此我们需要完成什么任务就要在pom.xml文件中导入相关的starter，导入之后，相关的自动配置类的条件就会满足，实现加载。而在加载的过程中又会读取相关的属性，每个自动配置类都包含一个xxxProperties类（该类用于提供相关属性）的实例作为属性，xxxProperties类中的属性既有默认值，又可以绑定到我们创建的配置文件application.yaml中的一个对象，因此如果我们在application.yaml中配置了相关属性，就会在加载自动配置类时覆盖默认值从而实现配置，否则就会读取默认值完成启动。 xxxAutoConfiguration:：自动配置类，向ioc容器中添加组件 xxxProperties：封装配置文件中的相关属性 yaml 配置文件用于修改spring boot自动配置的默认值。官方推荐使用yaml，因此可以将自动生成的application.properties文件删除，再重新创建一个application.yaml文件 application.properties与application.yaml的格式区别： application.properties：语法： key=value application.yaml：语法： key: 空格 value yaml文件的基础语法： # 普通k-v键值对 name: xunlu # 对象 student: name: xunlu gender: male # 对象的行内写法 student: {name: xunlu, gender: male} # 数组 pets: - cat - dog - pig # 数组的行内写法 pets: [cat, dog, pig] yaml可以对实体类赋值，如下,先创建一个Person实体类，再在yaml配置文件中创建person对象： @Component // 注册bean @Data @AllArgsConstructor @NoArgsConstructor @ConfigurationProperties(prefix = \"person\") /* 前文已说yaml文件可以表达对象，prefix = \"person\"就是将配置文件中的person对象与下方Person类进行绑定。 @ConfigurationProperties注解会将配置文件中的person对象的属性与下方Person类的属性一一对应进行绑定 并将所有属性的值映射到这个组件中，完成注入。 */ public class Person { private String name; private Integer age; private Boolean isHappy; private Date birth; private Map\u003cString, ?\u003e maps; private List\u003c?\u003e lists; private Dog dog; } person: name: xunlu # 配置文件不需要用 \"\" 来特别指明该属性为字符串，会根据实体类进行类型转换 age: 18 isHappy: false birth: 2021/5/11 maps: {k1: va, k2: v2} lists: [code, music, girl] dog: name: 旺财 age: yaml还支持松散绑定（感觉用处不大）。中杠\u003c–\u003e驼峰命名，如：Person的first-name与person的firstNmae可以绑定，反之也可以 占位符 books: id: ${random.uuid} # 随机生成一个uuid序列号 price: ${random.int} # 随机生成一个整数 author: xunlu name: ${books.author:xunlu}的第一本书 # 引用books.author的值，若不存在则使用默认值xunlu JSR-303校验 JSR-303校验用于规范化输入，可以将属性指定为只能接收某种格式的值 在pom.xml中导入spring-boot-starter-validation 在类前加注解@Validated 在需要规范化的属性前加相应注解，如在属性emil前加注解@Email(message = \"邮箱格式错误！\")就可以规定该属性只能接收邮箱格式的输入，如果输入格式不符合邮箱的规范就会报错提示message中的值，也可以不指定message，直接为@Email()，有默认提示。除了@Email()，JSR-303还有许多其他的注解用于规定不同格式，用到时在网上搜即可。 多环境配置文件 配置文件可以放置于如下位置，且从上到下优先级逐级降低。且同级目录下properties》yml》yaml file:./config/ file:./config/*/ file:./ classpath:/config/ classpath:/ 多配置文件的切换。当创建了应用于多套环境（如开发环境application-dev.yaml、测试环境application-test.yaml等）的配置文件时，可以通过如下语句切换配置文件 spring: profiles: active: dev 静态资源及模板 静态资源导入 可以放置静态资源的目录：1. maven导入wenbars（一般不用）， 2. /**， 3. /public， 4. /static（默认）， 5. /resources。 /表示resources目录。存放在这些目录下的文件可以通过在地址栏输入localhost:8080/文件名直接访问。优先级：/resources \u003e /static \u003e /public 在templates目录下的所有页面只能通过controller跳转，无法直接访问 模板引擎：导入thymeleaf依赖，在templates目录下创建html文件，就可以使用controller跳转过来了 thymeleaf的使用： 首先需在html页面加上名称空间约束： 所有的html元素都可以被thymeleaf替换：th:元素名 扩展springmvc 自定义类，实现xxxxConfigurer接口，并在类前添加@Configuration注解，然后覆盖相应方法，最后将该组件注册到IOC容器中（即先创建一个类实现WebMvcConfigurer接口并添加@Configuration注解，然后在该类中任意创建一个方法，方法前添加@Bean注解，方法中只需写return new MyxxxxConfiguration()即可） 国际化（即页面支持多种语言） 在页面中添加thymeleaf的命名空间，为当前页面的元素配置多种语言的配置文件，他们会自动装在一个包中。在H5页面中由#{}接收配置文件中的值，然后按照上一节的方法自定义地区解析器（实现LocaleResolver接口，重写resolveLocale方法） 整合MyBatis 项目中导入依赖mybatis-spring-boot-starter。 在配置文件中做如下配置： # 配置数据库连接 spring: datasource: username: root password: gaolu666 url: jdbc:mysql://localhost:3306/mybatis?useSSL=false\u0026useUnicode=true\u0026characterEncoding=utf8\u0026serverTimezone=Asia/Shanghai driver-class-name: com.mysql.cj.jdbc.Driver # 整合mybatis mybatis: type-aliases-package: com.lu.pojo # 起别名 mapper-locations: classpath:mybatis/mapper/*.xml # 配置mapper.xml的位置，classpath即resources目录 写实体类，mapper接口和mapper.xml文件，其中实体类和mapper.xml文件与单独使用mybatis一摸一样，没有增加任何东西，只有mapper接口前需要添加如下两个注解 @Mapper // @Mapper注解表示这是一个mybatis的mapper类 @Repository // @Repository 即添加到ioc容器中，用于自动创建对象 public interface UserMapper {...} 之后在service层调用dao层时，只需在service层的类中注入mapper接口属性即可，如下：由于自动生成对象，直接使用其方法即可。 @Autowired private UserMapper mapper; SpringSecurity（基于AOP） 导入spring-boot-starter-security依赖 写相关安全配置，在config包下创建一个配置类，如下： @EnableWebSecurity // 开启Security功能 public class SecurityConfig extends WebSecurityConfigurerAdapter { // 认证 // withUser方法用于认证用户，参数为用户名；password中的匿名对象用于加密密码；roles方法用于为用户划分权限分类-\u003e一个用户可以有多个角色 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { // 下方为内存认证，若想用数据库认证可以换为 `auth.jdbcAuthentication().dataSource(datasource).withUser()` auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()) .withUser(\"xunlu\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"administer\", \"normal\") .and() .withUser(\"root\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"root\", \"administer\", \"normal\") .and() .withUser(\"other\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"normal\"); } // 授权 // 为不同权限的用户指定能访问的页面 @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/\").permitAll() .antMatchers(\"/dir1/**\").hasRole(\"root\") .antMatchers(\"/dir2/**\").hasRole(\"administer\") .antMatchers(\"/dir3/**\").hasRole(\"normal\"); http.formLogin(); // 没有权限默认转到登录页面 http.logout(); // 开启注销功能，即用户从网站退出登录 // http.logout().logoutUrl(\"/\"); 指定登出页 http.csrf().disable(); // 关闭csrf，防止跨站请求 http.rememberMe(); // 开启记住我功能，用户名和密码写入cookie，默认保存两周 } } } Shiro 核心三大组件： Subject：用户 SecurityManager：管理所有用户 Realm：连接数据 Shiro的快速开始 public class Quickstart { private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class); // 日志 public static void main(String[] args) { Factory\u003cSecurityManager\u003e factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\");// 安全管理工厂 SecurityManager securityManager = factory.getInstance(); // 安全管理实例 SecurityUtils.setSecurityManager(securityManager); Subject currentUser = SecurityUtils.getSubject(); // 获取当前用户 Session session = currentUser.getSession(); // 获取当前用户的session session.setAttribute(\"someKey\", \"aValue\"); String value = (String) session.getAttribute(\"someKey\"); if (value.equals(\"aValue\")) log.info(\"Retrieved the correct value! [\" + value + \"]\"); // 判断当前用户是否被认证 if (!currentUser.isAuthenticated()) { UsernamePasswordToken token = new UsernamePasswordToken(\"lonestarr\", \"vespa\"); // 获取用户令牌 token.setRememberMe(true); // 记住我 try { currentUser.login(token); // 登录 } catch (UnknownAccountException uae) { // 未知用户名 log.info(\"There is no user with username of \" + token.getPrincipal()); } catch (IncorrectCredentialsException ice) { // 密码错误 log.info(\"Password for account \" + token.getPrincipal() + \" was incorrect!\"); } catch (LockedAccountException lae) { // 冻结 log.info(\"The account for username \" + token.getPrincipal() + \" is locked. \" + \"Please contact your administrator to unlock it.\"); } // ... catch more exceptions here (maybe custom ones specific to your application? catch (AuthenticationException ae) { //unexpected condition? error? } } //say who they are: //print their identifying principal (in this case, a username): log.info(\"User [\" + currentUser.getPrincipal() + \"] logged in successfully.\"); //test a role: if (currentUser.hasRole(\"schwartz\")) { // 是否拥有这个角色 log.info(\"May the Schwartz be with you!\"); } else { log.info(\"Hello, mere mortal.\"); } //test a typed permission (not instance-level) 粗粒度地判断权限 if (currentUser.isPermitted(\"lightsaber:wield\")) { log.info(\"You may use a lightsaber ring. Use it wisely.\"); } else { log.info(\"Sorry, lightsaber rings are for schwartz masters only.\"); } //a (very powerful) Instance Level permission: 细粒度地判断权限 if (currentUser.isPermitted(\"winnebago:drive:eagle5\")) { log.info(\"You are permitted to 'drive' the winnebago with license plate (id) 'eagle5'. \" + \"Here are the keys - have fun!\"); } else { log.info(\"Sorry, you aren't allowed to drive the 'eagle5' winnebago!\"); } //all done - log out! currentUser.logout(); System.exit(0); } } 将Shiro整合到SpringBoot （看项目springboot-02-security吧，太多了，写不行了） 导入依赖 shiro-spring 自定义UserRealm public class UserRealm extends AuthorizingRealm{ @Autowired private UserService userService; // 授权 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { System.out.println(\"execute the Authorization procedure !\"); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); // info.addStringPermission(\"user:add\"); // 此处将所有用户都授予了user:add权限，正常应该从数据库的权限表中读取权限,如下方 // 获取当前登录的用户 Subject subject = SecurityUtils.getSubject(); User currentUser = (User) subject.getPrincipal(); // 拿到user info.addStringPermission(currentUser.getPerms()); // 设置权限 return info; } // 认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { System.out.println(\"execute the Authentication procedure !\"); UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken; String username = token.getUsername(); // 通过令牌获取用户名 // connect to the mysql User user = userService.queryUserByName(username); if (user == null) return null; // throw the UnknownAccountException // 密码验证由shiro做，防止源码中出现明文密码,可以配置加密方式 return new SimpleAuthenticationInfo(user, user.getPasswd(),\"\"); } } 配置 @Configuration public class ShiroConfig { // 3. ShiroFilterFactoryBean @Bean // 该注解作用在方法上表明Spring接管该方法，会在IOC容器中创建一个Bean对象（初步推断该方法必须返回一个对象类型） public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(\"securityManager\") DefaultWebSecurityManager securityManager){ ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean(); // 设置安全管理器 bean.setSecurityManager(securityManager); // 添加shiro的内置过滤器 /* * anon:无需认证即可访问 * authc：必须认证才能访问 * user：必须开启“记住我”功能才能使用 * perms：拥有资源的相关权限才能访问 * role：拥有相关角色才能访问 */ Map\u003cString, String\u003e filterMap = new LinkedHashMap\u003c\u003e(); filterMap.put(\"/user/*\", \"authc\"); bean.setFilterChainDefinitionMap(filterMap); // 拦截 // 设置登录请求 bean.setLoginUrl(\"/login\"); return bean; } // 2. DefaultWebSecurityManager @Bean(\"securityManager\") //可以只写@Bean,此时改bean在IOC容器中的默认为方法名 public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(\"userRealm\") UserRealm userRealm) { DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); // 关联UserRealm securityManager.setRealm(userRealm); return securityManager; } // 1. 获取UserRealm对象，即上方自定义的UserRealm类 @Bean(\"userRealm\") // 该注解所修饰的方法所在的类前必须有@Configuration注解 public UserRealm getUserRealm() { return new UserRealm(); } } SpringBoot集成Swagger 导入依赖springfox-swagger2和springfox-swagger-ui 配置 @Configuration // 配置类 @EnableSwagger2 // 开启Swagger public class SwaggerConfig { // 配置Swagger的Docket的bean @Bean public Docket getDocket() { return new Docket(DocumentationType.SWAGGER_2) .groupName(\"lu\") // 指定分组，可以创建多个getDocket方法，每个方法对应一个分组，用于多人协同合作 // .enable(false) 关闭swagger，即不能访问swagger页面。默认开启 .apiInfo(apiInfo()) // 配置api文档信息 .select() // 配置扫描哪些controller // RequestHandlerSelectors有如下方法： // basePackage指定扫描的包 // any 扫描全部 // none 全不扫描 // withMethodAnnotation和withMethodAnnotation按相关注解扫描 .apis(RequestHandlerSelectors.basePackage(\"com.lu.controller\")) .paths(PathSelectors.ant(\"lu/.*\")) // （过滤路劲）用到再查吧，不知道什么玩意 .build(); } // 配置Swagger信息（即修改相关默认值） // apiInfo private ApiInfo apiInfo() { // 作者信息 Contact contact = new Contact(\"驯鹿\", \"https://ethereal-lu.github.io\", \"gaolulu620.163.com\"); return new ApiInfo( \"驯鹿的SwaggerAPI文档\", \"白马非马，驯鹿非鹿\", \"1.0\", \"https://ethereal-lu.github.io/\", contact, \"Apache 2.0\", \"http://www.apache.org/licenses/LICENSE-2.0\", new ArrayList\u003c\u003e() ); } } 配置也可以写在 application.yaml 中，如下：（下方只写了部分，需要时可以再加）\nswagger: enabled: true title: 驯鹿的SwaggerAPI文档 description: 后端API测试 version: 1.0 base-package: com.privacy contact: email: gaolulu620.163.com url: https://ethereal-lu.github.io name: 驯鹿 Swagger相关的注解用时再查，主要实用的注解也就三四个 SpringBoot 文件上传 1、 application.yaml 中配置如下\nspring: servlet: # spring默认的上传文件大小限制是1MB,单次请求文件总数不能大于10MB，如果要移除限制设置为-1 multipart: max-request-size: 20MB # 所有上传文件总和的最大值 max-file-size: 10MB # 单个文件上传最大值 enabled: true server: tomcat: # 内嵌tomcat最大请求吞吐量限制，-1表示没有限制，如果不配置上传文件超过最大限制后tomcat会取消请求，前端的请求将会没有返回 max-swallow-size: -1 2、在 controller 包下创建如下类\n@Api(tags = {\"数据接口\"}) @RestController @RequestMapping(\"/data\") public class DataController { @PostMapping(\"/upload\") @ApiOperation(\"上传文件\") public RestResponse upload(MultipartFile file) { if (file != null) { String fileName = file.getOriginalFilename(); String code = UUID.randomUUID().toString().replaceAll(\"-\", \"\"); assert fileName != null; String newFileName = code + fileName.substring(fileName.lastIndexOf('.')); String currentDateFolder = LocalDate.now().format(DateTimeFormatter.BASIC_ISO_DATE); String destFilePath = \"D:\\\\uploads\" + File.separator + currentDateFolder + File.separator + newFileName; try { File destFile = new File(destFilePath); if (!destFile.getParentFile().exists()) { if (!destFile.getParentFile().mkdirs()){ return ResultGenerator.genFailResult(\"上传失败，请稍后重新上传！\"); } } file.transferTo(destFile); // 这里直接返回的服务器上的物理地址，项目中需要根据实际情况自行处理 return ResultGenerator.genSuccessResult(\"上传成功！\"); } catch (IOException e) { // TODO 异常处理 return ResultGenerator.genFailResult(\"上传失败，请稍后重新上传！\"); } } return ResultGenerator.genFailResult(\"上传文件不能为空\"); } } 任务 异步任务\n两步即可实现 1.在主类XXXApplication前添加@EnableAsync注解 2.在需要实现异步的方法前加上@Async注解。 定时任务\n两步即可实现 1.在主类XXXApplication前添加@EnableScheduling注解 2.在需要定时执行的方法前加上@Scheduled(cron = “\")注解。其中参数的引号中填入cron表达式（用到时网上搜） 邮件发送\n导包spring-boot-starter-mail 在aplication中配置 spring: mail: username: 邮箱名 password: 授权码而非密码 host: smtp.qq.com # qq邮箱还需要开启加密验证 使用 @Autowired JavaMailSenderImpl mailSender; @Test void contextLoads() { // 简单邮件 SimpleMailMessage message = new SimpleMailMessage(); message.setSubject(\"驯鹿，你好呀\"); // 主题 message.setText(\"springboot发送的邮件\"); // 内容 message.setTo(\"983811022@qq.com\"); message.setFrom(\"983811022@qq.com\"); mailSender.send(message); } SpringBoot集成Redis 见Redis学习笔记\n分布式 Dubbo + Zookeeper + SpringBoot RPC RPC（Remote Procedure Call）即远程过程调用，是一种进程间通信方式。它允许程序调用另一台机器上的函数而不需要了解其中的通信细节。\nRPC的核心为：通讯 + 序列化\nDubbo Dubbo 是高新能的基于java的RPC框架\n","wordCount":"1219","inLanguage":"en","datePublished":"2021-05-10T17:39:41Z","dateModified":"2021-05-10T17:39:41Z","author":{"@type":"Person","name":"lu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ethereal-lu.github.io/posts/java/springboot%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"lu","logo":{"@type":"ImageObject","url":"https://ethereal-lu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="lu (Alt + H)">lu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethereal-lu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ethereal-lu.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">SpringBoot学习笔记</h1><div class=post-meta><span title='2021-05-10 17:39:41 +0000 UTC'>2021-05-10</span>&nbsp;·&nbsp;1219 words&nbsp;·&nbsp;lu</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#项目创建>项目创建</a></li><li><a href=#自动装配原理>自动装配原理</a></li><li><a href=#yaml>yaml</a></li><li><a href=#jsr-303校验>JSR-303校验</a></li><li><a href=#多环境配置文件>多环境配置文件</a></li><li><a href=#静态资源及模板>静态资源及模板</a></li><li><a href=#扩展springmvc>扩展springmvc</a></li><li><a href=#国际化即页面支持多种语言>国际化（即页面支持多种语言）</a></li><li><a href=#整合mybatis>整合MyBatis</a></li><li><a href=#springsecurity基于aop>SpringSecurity（基于AOP）</a></li><li><a href=#shiro>Shiro</a></li><li><a href=#springboot集成swagger>SpringBoot集成Swagger</a></li><li><a href=#springboot-文件上传>SpringBoot 文件上传</a></li><li><a href=#任务>任务</a></li><li><a href=#springboot集成redis>SpringBoot集成Redis</a></li><li><a href=#分布式-dubbo--zookeeper--springboot>分布式 Dubbo + Zookeeper + SpringBoot</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p><a href=https://github.com/spring-projects/spring-boot>Spring Boot</a> 是 Spring 的<strong>子项目</strong>，正如其名字，提供 Spring 的引导( <strong>Boot</strong> )的功能。</p><p>通过 Spring Boot ，开发者可以快速配置 Spring 项目，引入各种 Spring MVC、Spring Transaction、Spring AOP、等等框架，而无需不断重复编写繁重的 Spring 配置，降低了 Spring 的使用成本。</p><h3 id=项目创建>项目创建<a hidden class=anchor aria-hidden=true href=#项目创建>#</a></h3><ul><li>新建 spring initializr 项目，在新建过程中引入 spring web 依赖</li><li>将所有的controller、pojo、dao等包创建在Application类的同名目录下（约定大于配置），创建在其他目录下会报错</li><li>在resources目录下创建banner.txt文件，可以在里面粘贴一些图片用于启动时展示</li></ul><hr><h3 id=自动装配原理>自动装配原理<a hidden class=anchor aria-hidden=true href=#自动装配原理>#</a></h3><ul><li><p>父工程 <code>spring-boot-dependencies</code> 对springboot的所有依赖进行管理，其中就有依赖的版本控制，因此我们在pom.xml中引入依赖时，不需要指定版本</p></li><li><p>启动器：启动器都以<code>spring-boot-starter</code>打头，就是springboot的启动场景，如<code>spring-boot-starter-web</code>，就会帮我们自动导入web环境所有的依赖。springboot会将所有的功能场景变为一个个的启动器。我们要使用什么功能，只需要找到相对应的启动器并导入即可</p></li><li><p>主程序：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// @SpringBootApplication ：标注这个类是springboot的应用</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SpringBootApplication</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Springboot01HelloworldApplication</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 启动springboot</span>
</span></span><span style=display:flex><span>        SpringApplication.<span style=color:#a6e22e>run</span>(Springboot01HelloworldApplication.<span style=color:#a6e22e>class</span>, args);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>@SpringBootApplication</code> 是复合注解，主要包括 **<code>@ComponentScan</code>, <code>@EnableAutoConfiguration</code>, <code>@SpringBootConfiguration</code>**三个注解。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@SpringBootConfiguration</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@EnableAutoConfiguration</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@ComponentScan</span>(
</span></span><span style=display:flex><span>    excludeFilters <span style=color:#f92672>=</span> {<span style=color:#a6e22e>@Filter</span>(
</span></span><span style=display:flex><span>    type <span style=color:#f92672>=</span> FilterType.<span style=color:#a6e22e>CUSTOM</span>,
</span></span><span style=display:flex><span>    classes <span style=color:#f92672>=</span> {TypeExcludeFilter.<span style=color:#a6e22e>class</span>}
</span></span><span style=display:flex><span>), <span style=color:#a6e22e>@Filter</span>(
</span></span><span style=display:flex><span>    type <span style=color:#f92672>=</span> FilterType.<span style=color:#a6e22e>CUSTOM</span>,
</span></span><span style=display:flex><span>    classes <span style=color:#f92672>=</span> {AutoConfigurationExcludeFilter.<span style=color:#a6e22e>class</span>}
</span></span><span style=display:flex><span>)}
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>@interface</span> SpringBootApplication
</span></span></code></pre></div><ul><li><strong><code>@ComponentScan 注解</code></strong>：组件扫描。 spring里有四大注解：<code>@Service</code>,<code>@Repository</code>,<code>@Component</code>,<code>@Controller</code>用来定义一个bean.<code>@ComponentScan</code>注解就是用来自动扫描被这些注解标识的类，最终生成ioc容器里的bean．</li><li><strong><code>@SpringBootConfiguration 注解</code></strong>：@SpringBootConfiguration继承自@Configuration，二者功能也一致，标注当前类是配置类， 并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。</li><li><strong><code>@EnableAutoConfiguration 注解</code></strong>：从 classpath 中搜索所有的 META-INF/spring.factories 配置文件，然后将其中key为org.springframework.boot.autoconfigure.EnableAutoConfiguration 的 value 加载到spring容器中。</li></ul></li><li><p>注解：</p><ul><li><code>@Configuration</code>： 表示这是一个配置类</li><li><code>@EnableConfigurationProperties</code>： 自动配置属性，其中传入的类的属性即为配置文件中可以设置的属性</li><li>Conditional系列注解：Spring的底层注解，根据不同的条件，判断当前配置或类是否生效，该系列下的每一个注解用于对一种情况做出判断，如：<ul><li><code>@ConditionalOnClass</code>：判断是否为指定类型的类</li><li><code>@ConditionalOnWebApplication</code>： 判断是否为web应用</li><li><code>@ConditionalOnProperty</code>： 判断属性值是否为指定值</li><li>等等</li></ul></li></ul></li><li><p>原理粗略理解：</p><ul><li>spring boot启动时会加载大量的自动配置类，而每个自动配置类都有一个条件判断，只有当条件满足时才会被加载，因此我们需要完成什么任务就要在pom.xml文件中导入相关的starter，导入之后，相关的自动配置类的条件就会满足，实现加载。而在加载的过程中又会读取相关的属性，每个自动配置类都包含一个xxxProperties类（该类用于提供相关属性）的实例作为属性，xxxProperties类中的属性既有默认值，又可以绑定到我们创建的配置文件application.yaml中的一个对象，因此如果我们在application.yaml中配置了相关属性，就会在加载自动配置类时覆盖默认值从而实现配置，否则就会读取默认值完成启动。<ul><li>xxxAutoConfiguration:：自动配置类，向ioc容器中添加组件</li><li>xxxProperties：封装配置文件中的相关属性</li></ul></li></ul></li></ul><hr><h3 id=yaml>yaml<a hidden class=anchor aria-hidden=true href=#yaml>#</a></h3><ul><li>配置文件用于修改spring boot自动配置的默认值。官方推荐使用yaml，因此可以将自动生成的application.properties文件删除，再重新创建一个application.yaml文件</li><li>application.properties与application.yaml的格式区别：<ul><li>application.properties：语法： key=value</li><li>application.yaml：语法： key: 空格 value</li></ul></li><li>yaml文件的基础语法：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># 普通k-v键值对</span>
</span></span><span style=display:flex><span><span style=color:#f92672>name</span>: <span style=color:#ae81ff>xunlu</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 对象</span>
</span></span><span style=display:flex><span><span style=color:#f92672>student</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>xunlu</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>gender</span>: <span style=color:#ae81ff>male</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 对象的行内写法</span>
</span></span><span style=display:flex><span><span style=color:#f92672>student</span>: {<span style=color:#f92672>name: xunlu, gender</span>: <span style=color:#ae81ff>male}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 数组</span>
</span></span><span style=display:flex><span><span style=color:#f92672>pets</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>cat</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>dog</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>pig</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 数组的行内写法</span>
</span></span><span style=display:flex><span><span style=color:#f92672>pets</span>: [<span style=color:#ae81ff>cat, dog, pig]</span>
</span></span></code></pre></div><ul><li>yaml可以对实体类赋值，如下,先创建一个Person实体类，再在yaml配置文件中创建person对象：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Component</span>  <span style=color:#75715e>// 注册bean</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Data</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@AllArgsConstructor</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@NoArgsConstructor</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@ConfigurationProperties</span>(prefix <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;person&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>前文已说yaml文件可以表达对象，prefix = &#34;person&#34;就是将配置文件中的person对象与下方Person类进行绑定。
</span></span></span><span style=display:flex><span><span style=color:#75715e>@ConfigurationProperties注解会将配置文件中的person对象的属性与下方Person类的属性一一对应进行绑定
</span></span></span><span style=display:flex><span><span style=color:#75715e>    并将所有属性的值映射到这个组件中，完成注入。
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Integer age;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Boolean isHappy;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Date birth;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Map<span style=color:#f92672>&lt;</span>String, <span style=color:#f92672>?&gt;</span> maps;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> List<span style=color:#f92672>&lt;?&gt;</span> lists;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Dog dog;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>person</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>xunlu </span> <span style=color:#75715e># 配置文件不需要用 &#34;&#34; 来特别指明该属性为字符串，会根据实体类进行类型转换</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>age</span>: <span style=color:#ae81ff>18</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>isHappy</span>: <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>birth</span>: <span style=color:#ae81ff>2021</span><span style=color:#ae81ff>/5/11</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>maps</span>: {<span style=color:#f92672>k1: va, k2</span>: <span style=color:#ae81ff>v2}</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>lists</span>: [<span style=color:#ae81ff>code, music, girl]</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>dog</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>旺财</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>age</span>:
</span></span></code></pre></div><ul><li>yaml还支持松散绑定（感觉用处不大）。中杠&lt;&ndash;>驼峰命名，如：Person的first-name与person的firstNmae可以绑定，反之也可以</li><li>占位符</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>books</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>id</span>: <span style=color:#ae81ff>${random.uuid}   </span> <span style=color:#75715e># 随机生成一个uuid序列号</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>price</span>: <span style=color:#ae81ff>${random.int} </span> <span style=color:#75715e># 随机生成一个整数</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>author</span>: <span style=color:#ae81ff>xunlu</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>${books.author:xunlu}的第一本书 </span> <span style=color:#75715e># 引用books.author的值，若不存在则使用默认值xunlu</span>
</span></span></code></pre></div><hr><h3 id=jsr-303校验>JSR-303校验<a hidden class=anchor aria-hidden=true href=#jsr-303校验>#</a></h3><ul><li>JSR-303校验用于规范化输入，可以将属性指定为只能接收某种格式的值</li></ul><ol><li>在pom.xml中导入spring-boot-starter-validation</li><li>在类前加注解<code>@Validated</code></li><li>在需要规范化的属性前加相应注解，如在属性emil前加注解<code>@Email(message = "邮箱格式错误！")</code>就可以规定该属性只能接收邮箱格式的输入，如果输入格式不符合邮箱的规范就会报错提示message中的值，也可以不指定message，直接为<code>@Email()</code>，有默认提示。除了<code>@Email()</code>，JSR-303还有许多其他的注解用于规定不同格式，用到时在网上搜即可。</li></ol><hr><h3 id=多环境配置文件>多环境配置文件<a hidden class=anchor aria-hidden=true href=#多环境配置文件>#</a></h3><ul><li>配置文件可以放置于如下位置，且从上到下优先级逐级降低。且同级目录下properties》yml》yaml<ol><li>file:./config/</li><li>file:./config/*/</li><li>file:./</li><li>classpath:/config/</li><li>classpath:/</li></ol></li><li>多配置文件的切换。当创建了应用于多套环境（如开发环境application-dev.yaml、测试环境application-test.yaml等）的配置文件时，可以通过如下语句切换配置文件<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>profiles</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>active</span>: <span style=color:#ae81ff>dev</span>
</span></span></code></pre></div></li></ul><hr><h3 id=静态资源及模板>静态资源及模板<a hidden class=anchor aria-hidden=true href=#静态资源及模板>#</a></h3><ul><li>静态资源导入<ul><li>可以放置静态资源的目录：1. maven导入wenbars（一般不用）， 2. /**， 3. /public， 4. /static（默认）， 5. /resources。 /表示resources目录。存放在这些目录下的文件可以通过在地址栏输入localhost:8080/文件名直接访问。优先级：/resources > /static > /public</li></ul></li><li>在templates目录下的所有页面只能通过controller跳转，无法直接访问</li><li>模板引擎：导入thymeleaf依赖，在templates目录下创建html文件，就可以使用controller跳转过来了<ul><li>thymeleaf的使用：<ul><li>首先需在html页面加上名称空间约束：<code>&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"></code></li><li>所有的html元素都可以被thymeleaf替换：th:元素名</li></ul></li></ul></li></ul><hr><h3 id=扩展springmvc>扩展springmvc<a hidden class=anchor aria-hidden=true href=#扩展springmvc>#</a></h3><ul><li>自定义类，实现xxxxConfigurer接口，并在类前添加@Configuration注解，然后覆盖相应方法，最后将该组件注册到IOC容器中（即先创建一个类实现WebMvcConfigurer接口并添加@Configuration注解，然后在该类中任意创建一个方法，方法前添加@Bean注解，方法中只需写<code>return new MyxxxxConfiguration()</code>即可）</li></ul><hr><h3 id=国际化即页面支持多种语言>国际化（即页面支持多种语言）<a hidden class=anchor aria-hidden=true href=#国际化即页面支持多种语言>#</a></h3><ul><li>在页面中添加thymeleaf的命名空间，为当前页面的元素配置多种语言的配置文件，他们会自动装在一个包中。在H5页面中由#{}接收配置文件中的值，然后按照上一节的方法自定义地区解析器（实现LocaleResolver接口，重写resolveLocale方法）</li></ul><hr><h3 id=整合mybatis>整合MyBatis<a hidden class=anchor aria-hidden=true href=#整合mybatis>#</a></h3><ul><li>项目中导入依赖<code>mybatis-spring-boot-starter</code>。</li><li>在配置文件中做如下配置：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># 配置数据库连接</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>datasource</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>username</span>: <span style=color:#ae81ff>root</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>password</span>: <span style=color:#ae81ff>gaolu666</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>url</span>: <span style=color:#ae81ff>jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>driver-class-name</span>: <span style=color:#ae81ff>com.mysql.cj.jdbc.Driver</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 整合mybatis</span>
</span></span><span style=display:flex><span><span style=color:#f92672>mybatis</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>type-aliases-package</span>: <span style=color:#ae81ff>com.lu.pojo                  </span> <span style=color:#75715e># 起别名</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>mapper-locations</span>: <span style=color:#ae81ff>classpath:mybatis/mapper/*.xml   </span> <span style=color:#75715e># 配置mapper.xml的位置，classpath即resources目录</span>
</span></span></code></pre></div><ul><li>写实体类，mapper接口和mapper.xml文件，其中实体类和mapper.xml文件与单独使用mybatis一摸一样，没有增加任何东西，只有mapper接口前需要添加如下两个注解</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Mapper</span>         <span style=color:#75715e>// @Mapper注解表示这是一个mybatis的mapper类</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Repository</span>     <span style=color:#75715e>// @Repository 即添加到ioc容器中，用于自动创建对象</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>UserMapper</span> {...}
</span></span></code></pre></div><ul><li>之后在service层调用dao层时，只需在service层的类中注入mapper接口属性即可，如下：由于自动生成对象，直接使用其方法即可。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> UserMapper mapper;
</span></span></code></pre></div><hr><h3 id=springsecurity基于aop>SpringSecurity（基于AOP）<a hidden class=anchor aria-hidden=true href=#springsecurity基于aop>#</a></h3><ul><li>导入<code>spring-boot-starter-security</code>依赖</li><li>写相关安全配置，在config包下创建一个配置类，如下：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@EnableWebSecurity</span>    <span style=color:#75715e>// 开启Security功能</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SecurityConfig</span> <span style=color:#66d9ef>extends</span> WebSecurityConfigurerAdapter {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 认证</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// withUser方法用于认证用户，参数为用户名；password中的匿名对象用于加密密码；roles方法用于为用户划分权限分类-&gt;一个用户可以有多个角色</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>configure</span>(AuthenticationManagerBuilder auth) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 下方为内存认证，若想用数据库认证可以换为 `auth.jdbcAuthentication().dataSource(datasource).withUser()`</span>
</span></span><span style=display:flex><span>        auth.<span style=color:#a6e22e>inMemoryAuthentication</span>().<span style=color:#a6e22e>passwordEncoder</span>(<span style=color:#66d9ef>new</span> BCryptPasswordEncoder())
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>withUser</span>(<span style=color:#e6db74>&#34;xunlu&#34;</span>).<span style=color:#a6e22e>password</span>(<span style=color:#66d9ef>new</span> BCryptPasswordEncoder().<span style=color:#a6e22e>encode</span>(<span style=color:#e6db74>&#34;123456&#34;</span>)).<span style=color:#a6e22e>roles</span>(<span style=color:#e6db74>&#34;administer&#34;</span>, <span style=color:#e6db74>&#34;normal&#34;</span>)
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>and</span>()
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>withUser</span>(<span style=color:#e6db74>&#34;root&#34;</span>).<span style=color:#a6e22e>password</span>(<span style=color:#66d9ef>new</span> BCryptPasswordEncoder().<span style=color:#a6e22e>encode</span>(<span style=color:#e6db74>&#34;123456&#34;</span>)).<span style=color:#a6e22e>roles</span>(<span style=color:#e6db74>&#34;root&#34;</span>, <span style=color:#e6db74>&#34;administer&#34;</span>, <span style=color:#e6db74>&#34;normal&#34;</span>)
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>and</span>()
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>withUser</span>(<span style=color:#e6db74>&#34;other&#34;</span>).<span style=color:#a6e22e>password</span>(<span style=color:#66d9ef>new</span> BCryptPasswordEncoder().<span style=color:#a6e22e>encode</span>(<span style=color:#e6db74>&#34;123456&#34;</span>)).<span style=color:#a6e22e>roles</span>(<span style=color:#e6db74>&#34;normal&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 授权</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 为不同权限的用户指定能访问的页面</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>configure</span>(HttpSecurity http) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        http.<span style=color:#a6e22e>authorizeRequests</span>()
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>antMatchers</span>(<span style=color:#e6db74>&#34;/&#34;</span>).<span style=color:#a6e22e>permitAll</span>()
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>antMatchers</span>(<span style=color:#e6db74>&#34;/dir1/**&#34;</span>).<span style=color:#a6e22e>hasRole</span>(<span style=color:#e6db74>&#34;root&#34;</span>)
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>antMatchers</span>(<span style=color:#e6db74>&#34;/dir2/**&#34;</span>).<span style=color:#a6e22e>hasRole</span>(<span style=color:#e6db74>&#34;administer&#34;</span>)
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>antMatchers</span>(<span style=color:#e6db74>&#34;/dir3/**&#34;</span>).<span style=color:#a6e22e>hasRole</span>(<span style=color:#e6db74>&#34;normal&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        http.<span style=color:#a6e22e>formLogin</span>();   <span style=color:#75715e>// 没有权限默认转到登录页面</span>
</span></span><span style=display:flex><span>        http.<span style=color:#a6e22e>logout</span>();      <span style=color:#75715e>// 开启注销功能，即用户从网站退出登录</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// http.logout().logoutUrl(&#34;/&#34;);  指定登出页</span>
</span></span><span style=display:flex><span>        http.<span style=color:#a6e22e>csrf</span>().<span style=color:#a6e22e>disable</span>();  <span style=color:#75715e>// 关闭csrf，防止跨站请求</span>
</span></span><span style=display:flex><span>        http.<span style=color:#a6e22e>rememberMe</span>();      <span style=color:#75715e>// 开启记住我功能，用户名和密码写入cookie，默认保存两周</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=shiro>Shiro<a hidden class=anchor aria-hidden=true href=#shiro>#</a></h3><ul><li>核心三大组件：<ul><li>Subject：用户</li><li>SecurityManager：管理所有用户</li><li>Realm：连接数据</li></ul></li><li>Shiro的快速开始</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Quickstart</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>transient</span> Logger log <span style=color:#f92672>=</span> LoggerFactory.<span style=color:#a6e22e>getLogger</span>(Quickstart.<span style=color:#a6e22e>class</span>); <span style=color:#75715e>// 日志</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {                  
</span></span><span style=display:flex><span>        Factory<span style=color:#f92672>&lt;</span>SecurityManager<span style=color:#f92672>&gt;</span> factory <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> IniSecurityManagerFactory(<span style=color:#e6db74>&#34;classpath:shiro.ini&#34;</span>);<span style=color:#75715e>// 安全管理工厂   </span>
</span></span><span style=display:flex><span>        SecurityManager securityManager <span style=color:#f92672>=</span> factory.<span style=color:#a6e22e>getInstance</span>();   <span style=color:#75715e>// 安全管理实例</span>
</span></span><span style=display:flex><span>        SecurityUtils.<span style=color:#a6e22e>setSecurityManager</span>(securityManager);
</span></span><span style=display:flex><span>        Subject currentUser <span style=color:#f92672>=</span> SecurityUtils.<span style=color:#a6e22e>getSubject</span>();   <span style=color:#75715e>// 获取当前用户</span>
</span></span><span style=display:flex><span>        Session session <span style=color:#f92672>=</span> currentUser.<span style=color:#a6e22e>getSession</span>();         <span style=color:#75715e>// 获取当前用户的session</span>
</span></span><span style=display:flex><span>        session.<span style=color:#a6e22e>setAttribute</span>(<span style=color:#e6db74>&#34;someKey&#34;</span>, <span style=color:#e6db74>&#34;aValue&#34;</span>);
</span></span><span style=display:flex><span>        String value <span style=color:#f92672>=</span> (String) session.<span style=color:#a6e22e>getAttribute</span>(<span style=color:#e6db74>&#34;someKey&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (value.<span style=color:#a6e22e>equals</span>(<span style=color:#e6db74>&#34;aValue&#34;</span>))
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Retrieved the correct value! [&#34;</span> <span style=color:#f92672>+</span> value <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 判断当前用户是否被认证</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>currentUser.<span style=color:#a6e22e>isAuthenticated</span>()) {
</span></span><span style=display:flex><span>            UsernamePasswordToken token <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> UsernamePasswordToken(<span style=color:#e6db74>&#34;lonestarr&#34;</span>, <span style=color:#e6db74>&#34;vespa&#34;</span>);  <span style=color:#75715e>// 获取用户令牌</span>
</span></span><span style=display:flex><span>            token.<span style=color:#a6e22e>setRememberMe</span>(<span style=color:#66d9ef>true</span>);  <span style=color:#75715e>// 记住我</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                currentUser.<span style=color:#a6e22e>login</span>(token);   <span style=color:#75715e>// 登录</span>
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (UnknownAccountException uae) {   <span style=color:#75715e>// 未知用户名</span>
</span></span><span style=display:flex><span>                log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;There is no user with username of &#34;</span> <span style=color:#f92672>+</span> token.<span style=color:#a6e22e>getPrincipal</span>());
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (IncorrectCredentialsException ice) {    <span style=color:#75715e>// 密码错误</span>
</span></span><span style=display:flex><span>                log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Password for account &#34;</span> <span style=color:#f92672>+</span> token.<span style=color:#a6e22e>getPrincipal</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; was incorrect!&#34;</span>);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (LockedAccountException lae) {           <span style=color:#75715e>// 冻结</span>
</span></span><span style=display:flex><span>                log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;The account for username &#34;</span> <span style=color:#f92672>+</span> token.<span style=color:#a6e22e>getPrincipal</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; is locked.  &#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#34;Please contact your administrator to unlock it.&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ... catch more exceptions here (maybe custom ones specific to your application?</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>catch</span> (AuthenticationException ae) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>//unexpected condition?  error?</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>//say who they are:</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//print their identifying principal (in this case, a username):</span>
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;User [&#34;</span> <span style=color:#f92672>+</span> currentUser.<span style=color:#a6e22e>getPrincipal</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;] logged in successfully.&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//test a role:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (currentUser.<span style=color:#a6e22e>hasRole</span>(<span style=color:#e6db74>&#34;schwartz&#34;</span>)) {  <span style=color:#75715e>// 是否拥有这个角色</span>
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;May the Schwartz be with you!&#34;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Hello, mere mortal.&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//test a typed permission (not instance-level)    粗粒度地判断权限</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (currentUser.<span style=color:#a6e22e>isPermitted</span>(<span style=color:#e6db74>&#34;lightsaber:wield&#34;</span>)) { 
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;You may use a lightsaber ring.  Use it wisely.&#34;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Sorry, lightsaber rings are for schwartz masters only.&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//a (very powerful) Instance Level permission:    细粒度地判断权限</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (currentUser.<span style=color:#a6e22e>isPermitted</span>(<span style=color:#e6db74>&#34;winnebago:drive:eagle5&#34;</span>)) {
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;You are permitted to &#39;drive&#39; the winnebago with license plate (id) &#39;eagle5&#39;.  &#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#34;Here are the keys - have fun!&#34;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Sorry, you aren&#39;t allowed to drive the &#39;eagle5&#39; winnebago!&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//all done - log out!</span>
</span></span><span style=display:flex><span>        currentUser.<span style=color:#a6e22e>logout</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>exit</span>(0);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>将Shiro整合到SpringBoot （看项目springboot-02-security吧，太多了，写不行了）<ol><li>导入依赖 shiro-spring</li><li>自定义UserRealm</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserRealm</span> <span style=color:#66d9ef>extends</span> AuthorizingRealm{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> UserService userService;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 授权</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> AuthorizationInfo <span style=color:#a6e22e>doGetAuthorizationInfo</span>(PrincipalCollection principalCollection) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;execute the Authorization procedure !&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        SimpleAuthorizationInfo info <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SimpleAuthorizationInfo();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// info.addStringPermission(&#34;user:add&#34;); // 此处将所有用户都授予了user:add权限，正常应该从数据库的权限表中读取权限,如下方</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取当前登录的用户</span>
</span></span><span style=display:flex><span>        Subject subject <span style=color:#f92672>=</span> SecurityUtils.<span style=color:#a6e22e>getSubject</span>();
</span></span><span style=display:flex><span>        User currentUser <span style=color:#f92672>=</span> (User) subject.<span style=color:#a6e22e>getPrincipal</span>(); <span style=color:#75715e>// 拿到user</span>
</span></span><span style=display:flex><span>        info.<span style=color:#a6e22e>addStringPermission</span>(currentUser.<span style=color:#a6e22e>getPerms</span>()); <span style=color:#75715e>// 设置权限</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> info;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 认证</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> AuthenticationInfo <span style=color:#a6e22e>doGetAuthenticationInfo</span>(AuthenticationToken authenticationToken) <span style=color:#66d9ef>throws</span> AuthenticationException {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;execute the Authentication procedure !&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        UsernamePasswordToken token <span style=color:#f92672>=</span> (UsernamePasswordToken) authenticationToken;
</span></span><span style=display:flex><span>        String username <span style=color:#f92672>=</span> token.<span style=color:#a6e22e>getUsername</span>();   <span style=color:#75715e>// 通过令牌获取用户名</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// connect to the mysql</span>
</span></span><span style=display:flex><span>        User user <span style=color:#f92672>=</span> userService.<span style=color:#a6e22e>queryUserByName</span>(username);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (user <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;   <span style=color:#75715e>// throw the UnknownAccountException</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 密码验证由shiro做，防止源码中出现明文密码,可以配置加密方式</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> SimpleAuthenticationInfo(user, user.<span style=color:#a6e22e>getPasswd</span>(),<span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>配置</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Configuration</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ShiroConfig</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 3. ShiroFilterFactoryBean</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@Bean</span>  <span style=color:#75715e>// 该注解作用在方法上表明Spring接管该方法，会在IOC容器中创建一个Bean对象（初步推断该方法必须返回一个对象类型）</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> ShiroFilterFactoryBean <span style=color:#a6e22e>getShiroFilterFactoryBean</span>(<span style=color:#a6e22e>@Qualifier</span>(<span style=color:#e6db74>&#34;securityManager&#34;</span>) DefaultWebSecurityManager securityManager){
</span></span><span style=display:flex><span>      ShiroFilterFactoryBean bean <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ShiroFilterFactoryBean();
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 设置安全管理器</span>
</span></span><span style=display:flex><span>      bean.<span style=color:#a6e22e>setSecurityManager</span>(securityManager);
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 添加shiro的内置过滤器</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>       * anon:无需认证即可访问
</span></span></span><span style=display:flex><span><span style=color:#75715e>       * authc：必须认证才能访问
</span></span></span><span style=display:flex><span><span style=color:#75715e>       * user：必须开启“记住我”功能才能使用
</span></span></span><span style=display:flex><span><span style=color:#75715e>       * perms：拥有资源的相关权限才能访问
</span></span></span><span style=display:flex><span><span style=color:#75715e>       * role：拥有相关角色才能访问
</span></span></span><span style=display:flex><span><span style=color:#75715e>       */</span>
</span></span><span style=display:flex><span>      Map<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> filterMap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LinkedHashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>      filterMap.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;/user/*&#34;</span>, <span style=color:#e6db74>&#34;authc&#34;</span>);
</span></span><span style=display:flex><span>      bean.<span style=color:#a6e22e>setFilterChainDefinitionMap</span>(filterMap); <span style=color:#75715e>// 拦截</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 设置登录请求</span>
</span></span><span style=display:flex><span>      bean.<span style=color:#a6e22e>setLoginUrl</span>(<span style=color:#e6db74>&#34;/login&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> bean;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 2. DefaultWebSecurityManager</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@Bean</span>(<span style=color:#e6db74>&#34;securityManager&#34;</span>)  <span style=color:#75715e>//可以只写@Bean,此时改bean在IOC容器中的默认为方法名</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> DefaultWebSecurityManager <span style=color:#a6e22e>getDefaultWebSecurityManager</span>(<span style=color:#a6e22e>@Qualifier</span>(<span style=color:#e6db74>&#34;userRealm&#34;</span>) UserRealm userRealm) {
</span></span><span style=display:flex><span>      DefaultWebSecurityManager securityManager <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DefaultWebSecurityManager();
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 关联UserRealm</span>
</span></span><span style=display:flex><span>      securityManager.<span style=color:#a6e22e>setRealm</span>(userRealm);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> securityManager;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 1. 获取UserRealm对象，即上方自定义的UserRealm类</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@Bean</span>(<span style=color:#e6db74>&#34;userRealm&#34;</span>) <span style=color:#75715e>// 该注解所修饰的方法所在的类前必须有@Configuration注解</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> UserRealm <span style=color:#a6e22e>getUserRealm</span>() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> UserRealm();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><hr><h3 id=springboot集成swagger>SpringBoot集成Swagger<a hidden class=anchor aria-hidden=true href=#springboot集成swagger>#</a></h3><ul><li>导入依赖<code>springfox-swagger2</code>和<code>springfox-swagger-ui</code></li><li>配置</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Configuration</span>   <span style=color:#75715e>// 配置类</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@EnableSwagger2</span>  <span style=color:#75715e>// 开启Swagger</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SwaggerConfig</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 配置Swagger的Docket的bean</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> Docket <span style=color:#a6e22e>getDocket</span>() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Docket(DocumentationType.<span style=color:#a6e22e>SWAGGER_2</span>)
</span></span><span style=display:flex><span>              .<span style=color:#a6e22e>groupName</span>(<span style=color:#e6db74>&#34;lu&#34;</span>)     <span style=color:#75715e>// 指定分组，可以创建多个getDocket方法，每个方法对应一个分组，用于多人协同合作</span>
</span></span><span style=display:flex><span>              <span style=color:#75715e>// .enable(false)    关闭swagger，即不能访问swagger页面。默认开启</span>
</span></span><span style=display:flex><span>              .<span style=color:#a6e22e>apiInfo</span>(apiInfo())  <span style=color:#75715e>// 配置api文档信息</span>
</span></span><span style=display:flex><span>              .<span style=color:#a6e22e>select</span>()            <span style=color:#75715e>// 配置扫描哪些controller</span>
</span></span><span style=display:flex><span>              <span style=color:#75715e>// RequestHandlerSelectors有如下方法：</span>
</span></span><span style=display:flex><span>              <span style=color:#75715e>// basePackage指定扫描的包</span>
</span></span><span style=display:flex><span>              <span style=color:#75715e>// any 扫描全部</span>
</span></span><span style=display:flex><span>              <span style=color:#75715e>// none 全不扫描</span>
</span></span><span style=display:flex><span>              <span style=color:#75715e>// withMethodAnnotation和withMethodAnnotation按相关注解扫描</span>
</span></span><span style=display:flex><span>              .<span style=color:#a6e22e>apis</span>(RequestHandlerSelectors.<span style=color:#a6e22e>basePackage</span>(<span style=color:#e6db74>&#34;com.lu.controller&#34;</span>))
</span></span><span style=display:flex><span>              .<span style=color:#a6e22e>paths</span>(PathSelectors.<span style=color:#a6e22e>ant</span>(<span style=color:#e6db74>&#34;lu/.*&#34;</span>)) <span style=color:#75715e>// （过滤路劲）用到再查吧，不知道什么玩意</span>
</span></span><span style=display:flex><span>              .<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 配置Swagger信息（即修改相关默认值）</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// apiInfo</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> ApiInfo <span style=color:#a6e22e>apiInfo</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 作者信息</span>
</span></span><span style=display:flex><span>      Contact contact <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Contact(<span style=color:#e6db74>&#34;驯鹿&#34;</span>, <span style=color:#e6db74>&#34;https://ethereal-lu.github.io&#34;</span>, <span style=color:#e6db74>&#34;gaolulu620.163.com&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> ApiInfo(
</span></span><span style=display:flex><span>              <span style=color:#e6db74>&#34;驯鹿的SwaggerAPI文档&#34;</span>,
</span></span><span style=display:flex><span>              <span style=color:#e6db74>&#34;白马非马，驯鹿非鹿&#34;</span>,
</span></span><span style=display:flex><span>              <span style=color:#e6db74>&#34;1.0&#34;</span>,
</span></span><span style=display:flex><span>              <span style=color:#e6db74>&#34;https://ethereal-lu.github.io/&#34;</span>,
</span></span><span style=display:flex><span>              contact,
</span></span><span style=display:flex><span>              <span style=color:#e6db74>&#34;Apache 2.0&#34;</span>,
</span></span><span style=display:flex><span>              <span style=color:#e6db74>&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;</span>,
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>()
</span></span><span style=display:flex><span>      );
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>配置也可以写在 application.yaml 中，如下：（下方只写了部分，需要时可以再加）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>swagger</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>enabled</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>title</span>: <span style=color:#ae81ff>驯鹿的SwaggerAPI文档</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>description</span>: <span style=color:#ae81ff>后端API测试</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>version</span>: <span style=color:#ae81ff>1.0</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>base-package</span>: <span style=color:#ae81ff>com.privacy</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>contact</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>email</span>: <span style=color:#ae81ff>gaolulu620.163.com</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>url</span>: <span style=color:#ae81ff>https://ethereal-lu.github.io</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>驯鹿</span>
</span></span></code></pre></div><ul><li>Swagger相关的注解用时再查，主要实用的注解也就三四个</li></ul><hr><h3 id=springboot-文件上传>SpringBoot 文件上传<a hidden class=anchor aria-hidden=true href=#springboot-文件上传>#</a></h3><p>1、 application.yaml 中配置如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>servlet</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># spring默认的上传文件大小限制是1MB,单次请求文件总数不能大于10MB，如果要移除限制设置为-1</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>multipart</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>max-request-size</span>: <span style=color:#ae81ff>20MB   </span> <span style=color:#75715e># 所有上传文件总和的最大值</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>max-file-size</span>: <span style=color:#ae81ff>10MB      </span> <span style=color:#75715e># 单个文件上传最大值</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>enabled</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>server</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>tomcat</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># 内嵌tomcat最大请求吞吐量限制，-1表示没有限制，如果不配置上传文件超过最大限制后tomcat会取消请求，前端的请求将会没有返回</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>max-swallow-size</span>: -<span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>2、在 controller 包下创建如下类</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Api</span>(tags <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#34;数据接口&#34;</span>})
</span></span><span style=display:flex><span><span style=color:#a6e22e>@RestController</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@RequestMapping</span>(<span style=color:#e6db74>&#34;/data&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DataController</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@PostMapping</span>(<span style=color:#e6db74>&#34;/upload&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@ApiOperation</span>(<span style=color:#e6db74>&#34;上传文件&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> RestResponse <span style=color:#a6e22e>upload</span>(MultipartFile file) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (file <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            String fileName <span style=color:#f92672>=</span> file.<span style=color:#a6e22e>getOriginalFilename</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            String code <span style=color:#f92672>=</span> UUID.<span style=color:#a6e22e>randomUUID</span>().<span style=color:#a6e22e>toString</span>().<span style=color:#a6e22e>replaceAll</span>(<span style=color:#e6db74>&#34;-&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>assert</span> fileName <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            String newFileName <span style=color:#f92672>=</span> code <span style=color:#f92672>+</span> fileName.<span style=color:#a6e22e>substring</span>(fileName.<span style=color:#a6e22e>lastIndexOf</span>(<span style=color:#e6db74>&#39;.&#39;</span>));
</span></span><span style=display:flex><span>            String currentDateFolder <span style=color:#f92672>=</span> LocalDate.<span style=color:#a6e22e>now</span>().<span style=color:#a6e22e>format</span>(DateTimeFormatter.<span style=color:#a6e22e>BASIC_ISO_DATE</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            String destFilePath <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;D:\\uploads&#34;</span> <span style=color:#f92672>+</span> File.<span style=color:#a6e22e>separator</span> <span style=color:#f92672>+</span> currentDateFolder <span style=color:#f92672>+</span> File.<span style=color:#a6e22e>separator</span> <span style=color:#f92672>+</span> newFileName;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                File destFile <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> File(destFilePath);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>destFile.<span style=color:#a6e22e>getParentFile</span>().<span style=color:#a6e22e>exists</span>()) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>destFile.<span style=color:#a6e22e>getParentFile</span>().<span style=color:#a6e22e>mkdirs</span>()){
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> ResultGenerator.<span style=color:#a6e22e>genFailResult</span>(<span style=color:#e6db74>&#34;上传失败，请稍后重新上传！&#34;</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                file.<span style=color:#a6e22e>transferTo</span>(destFile);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 这里直接返回的服务器上的物理地址，项目中需要根据实际情况自行处理</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> ResultGenerator.<span style=color:#a6e22e>genSuccessResult</span>(<span style=color:#e6db74>&#34;上传成功！&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (IOException e) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// TODO 异常处理</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> ResultGenerator.<span style=color:#a6e22e>genFailResult</span>(<span style=color:#e6db74>&#34;上传失败，请稍后重新上传！&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ResultGenerator.<span style=color:#a6e22e>genFailResult</span>(<span style=color:#e6db74>&#34;上传文件不能为空&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=任务>任务<a hidden class=anchor aria-hidden=true href=#任务>#</a></h3><ul><li><p><strong>异步任务</strong></p><ul><li>两步即可实现<ul><li>1.在主类XXXApplication前添加@EnableAsync注解</li><li>2.在需要实现异步的方法前加上@Async注解。</li></ul></li></ul></li><li><p><strong>定时任务</strong></p><ul><li>两步即可实现<ul><li>1.在主类XXXApplication前添加@EnableScheduling注解</li><li>2.在需要定时执行的方法前加上@Scheduled(cron = &ldquo;")注解。其中参数的引号中填入cron表达式（用到时网上搜）</li></ul></li></ul></li><li><p><strong>邮件发送</strong></p><ul><li>导包spring-boot-starter-mail</li><li>在aplication中配置</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>mail</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>username</span>: <span style=color:#ae81ff>邮箱名</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>password</span>: <span style=color:#ae81ff>授权码而非密码</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>host</span>: <span style=color:#ae81ff>smtp.qq.com</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># qq邮箱还需要开启加密验证</span>
</span></span></code></pre></div><ul><li>使用</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>  <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>  JavaMailSenderImpl mailSender;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>contextLoads</span>() {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 简单邮件</span>
</span></span><span style=display:flex><span>      SimpleMailMessage message <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SimpleMailMessage();
</span></span><span style=display:flex><span>      message.<span style=color:#a6e22e>setSubject</span>(<span style=color:#e6db74>&#34;驯鹿，你好呀&#34;</span>); <span style=color:#75715e>// 主题</span>
</span></span><span style=display:flex><span>      message.<span style=color:#a6e22e>setText</span>(<span style=color:#e6db74>&#34;springboot发送的邮件&#34;</span>); <span style=color:#75715e>// 内容</span>
</span></span><span style=display:flex><span>      message.<span style=color:#a6e22e>setTo</span>(<span style=color:#e6db74>&#34;983811022@qq.com&#34;</span>);
</span></span><span style=display:flex><span>      message.<span style=color:#a6e22e>setFrom</span>(<span style=color:#e6db74>&#34;983811022@qq.com&#34;</span>);
</span></span><span style=display:flex><span>      mailSender.<span style=color:#a6e22e>send</span>(message);
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div></li></ul><hr><h3 id=springboot集成redis>SpringBoot集成Redis<a hidden class=anchor aria-hidden=true href=#springboot集成redis>#</a></h3><p>见<a href=https://ethereal-lu.github.io/2021/05/22/Spring%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis%E7%AC%94%E8%AE%B0/>Redis学习笔记</a></p><hr><h3 id=分布式-dubbo--zookeeper--springboot>分布式 Dubbo + Zookeeper + SpringBoot<a hidden class=anchor aria-hidden=true href=#分布式-dubbo--zookeeper--springboot>#</a></h3><h5 id=rpc>RPC<a hidden class=anchor aria-hidden=true href=#rpc>#</a></h5><p>RPC（Remote Procedure Call）即远程过程调用，是一种进程间通信方式。它允许程序调用另一台机器上的函数而不需要了解其中的通信细节。</p><p>RPC的核心为：通讯 + 序列化</p><h5 id=dubbo>Dubbo<a hidden class=anchor aria-hidden=true href=#dubbo>#</a></h5><p>Dubbo 是高新能的基于java的RPC框架</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethereal-lu.github.io/posts/java/annotation%E7%AC%94%E8%AE%B0/><span class=title>« Prev</span><br><span>Annotation学习笔记</span>
</a><a class=next href=https://ethereal-lu.github.io/posts/java/mybatis%E7%AC%94%E8%AE%B0/><span class=title>Next »</span><br><span>mybatis学习笔记</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>