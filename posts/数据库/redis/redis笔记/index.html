<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Redis基础 | lu</title>
<meta name=keywords content><meta name=description content='概述
Redis是什么？
Redis（Remote Dictionary Server )，即远程字典服务！
Redis能干吗？  &mdash;》 数据库、缓存、中间件

内存存储、持久化（rdb、aof）
效率高，可用于缓存
发布订阅系统
地图信息分析
计时器、计数器 。。。

Redis 通过“Redis序列化协议”（简称“RESP”），实现客户端与服务端之间的连接通信，其底层是通过TCP来完成的。

Linux安装配置redis
下载并解压redis后，将解压好的包移动到/usr/local/redis中，然后cd /usr/local/redis，依次在该目录下执行make，make test（也可以不执行）和make install。之后将该目录下的redis.conf备份，再vim redis.conf，将daemonize的值从no改为yes。cd /usr/local/bin，执行redis-server ../redis/redis.conf。配置完成。

redis 是单线程
对Redis来说，执行get、set以及eval等API，都是一个一个的任务，这些任务都会由Redis的线程（单线程）去负责执行，任务要么执行成功，要么执行失败，这就是Redis的命令是原子性的原因。
redis 6 引入了多线程
redis 5 及之前的版本一直使用的是单线程，多线程是 Redis6.0 推出的一个新特性。 Redis 的核心线程负责网络 IO ，命令处理以及写数据到缓冲，而随着网络硬件的性能提升，单个主线程处理⽹络请求的速度跟不上底层⽹络硬件的速度，导致网络 IO 的处理成为了 Redis 的性能瓶颈。
而 Redis6.0 就是从单线程处理网络请求到多线程处理，通过多个 IO 线程并⾏处理网络操作提升实例的整体处理性能。需要注意的是对于读写命令，Redis 仍然使⽤单线程来处理，这是因为继续使⽤单线程执行命令操作，就不⽤为了保证 Lua 脚本、事务的原⼦性，额外开发多线程互斥机制了。
redis 将所有的数据都放在内存中。单线程避免切换上下文，所以快。
多线程开发中并发访问控制是⼀个难点，需要精细的设计才能处理。如果只是简单地处理，比如简单地采⽤⼀个粗粒度互斥锁，只会出现不理想的结果。即便增加了线程，系统吞吐率也不会随着线程的增加而增加，因为大部分线程还在等待获取访问共享资源的互斥锁。而且，大部分采用多线程开发引入的同步原语保护共享资源的并发访问，也会降低系统代码的易调试性和可维护性。而正是以上这些问题，才让 Redis 采⽤了单线程模式。
官方解释：因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦)。

基础知识
redis所有命令不区分大小写
数据库基本命令
redis默认有16个数据库（0~15），默认使用第0个数据库。数据库之间数据相互隔离
127.0.0.1:6379> SELECT 3      # 切换数据库
OK
127.0.0.1:6379[3]> DBSIZE     # 查看当前数据库大小
(integer) 0
127.0.0.1:6379> FLUSHDB       # 清空当前数据库
OK
127.0.0.1:6379> FLUSHALL      # 清空所有数据库
OK
127.0.0.1:6379> SHUTDOWN      # 关闭redis服务
Redis-key基本命令
127.0.0.1:6379> set age 18            # 添加键值对
OK
127.0.0.1:6379> get name              # 通过key获取value
"xunlu"
127.0.0.1:6379> KEYS *                # KEYS + 正则表达式。返回所有符合正则表达式的键
1) "age"
2) "name"
127.0.0.1:6379> EXISTS name           # 判断是否存在指定的key
(integer) 1                           # 返回1则存在，0则不存在
127.0.0.1:6379> EXPIRE name 10        # 设置键name的有效期为10秒
(integer) 1
127.0.0.1:6379> ttl name              # 查看键name的有效时间还剩下多少
(integer) 4
127.0.0.1:6379> MOVE name 1           # 将键值对移动到指定的数据库中
(integer) 1
127.0.0.1:6379> DEL name              # 删除键值对
(integer) 1
127.0.0.1:6379> TYPE age              # 获取当前键对应值的类型
string

数据类型
五种基本数据类型

String  &mdash;>  应用：计数器（如访问量，点赞数等）

127.0.0.1:6379> set name xunlu
OK
127.0.0.1:6379> APPEND name feilu              # 追加字符串，类似StringBuilder的append
(integer) 10                                   # 若追加的键不存在，则新建键值对
127.0.0.1:6379> get name
"xunlufeilu"
-----------------------------------------------
127.0.0.1:6379> STRLEN name					 # 返回值的长度
(integer) 10
-----------------------------------------------
127.0.0.1:6379> set views 0
OK
127.0.0.1:6379> INCR views                     # 每执行一次，值就会加1.（只能作用于integer类型）
(integer) 1
127.0.0.1:6379> INCR views
(integer) 2
127.0.0.1:6379> DECR views                     # 每执行一次，值就会减1.（只能作用于integer类型）
(integer) 1
127.0.0.1:6379> INCRBY views 10                # 指定增加的步长
(integer) 11
127.0.0.1:6379> DECRBY views 10                # 指定减少的步长
(integer) 1
-----------------------------------------------
127.0.0.1:6379> set name xunlu
OK
127.0.0.1:6379> GETRANGE name 0 2              # 截取部分值（start和end都包括在内）
"xun"
127.0.0.1:6379> GETRANGE name 0 -1             # == get name
"xunlu"
127.0.0.1:6379> SETRANGE name 0 gao            # 替换部分字符，起始替换位置 + 替换的值
(integer) 5
127.0.0.1:6379> get name
"gaolu"
-----------------------------------------------
# setex(set with expire)   【原子性操作】
# setnx(set if not exist)  【原子性操作】
127.0.0.1:6379> setex name 30 xunlu            # 新建键值对，并设置有效期为30秒
OK   # 等同于 set name xunlu ex 30
127.0.0.1:6379> setnx gender male              # nx表示键不存在时才能正确执行，即只能新建
OK   # 等同于 set gender male nx               # 常用于分布式锁
127.0.0.1:6379> get gender
"male"
127.0.0.1:6379> set gender female nx           # 此时键gender已经存在，执行失败
(nil)
-----------------------------------------------
127.0.0.1:6379> MSET k1 v1 k2 v1 k3 v1         # 批量创建键值对
OK
127.0.0.1:6379> KEYS *
1) "k1"                                        # msetnx 【原子性操作】
2) "k3"
3) "k2"
127.0.0.1:6379> MGET k1 k2 k3                  # 批量获取 
1) "v1"
2) "v1"
3) "v1"
------------------------------------------------
127.0.0.1:6379> set user {id:1,name:xunlu,age:3} # 可以将值设为json字符串，然后通过json解析
OK
127.0.0.1:6379> mset user:name xunlu user:age 18 # redis支持键中存在`:`冒号，亦可用于解析
OK
------------------------------------------------
127.0.0.1:6379> getset db redis                  # 先get再set。没有返回nil，再设新值
(nil)
127.0.0.1:6379> getset db redis                  # 有则返回旧值，再设新值
"redis"

List（双向链表）

绝大部分的list命令都以l开头，list的名字也可作为key，故有些redis-key的命令也可用
应用：消息队列、栈



# 添加、范围读取
LPUSH key element [element ...]                   # key为列表的名字，添加到列表的头部
RPUSH key element [element ...]                   # 添加到列表的尾部                 
127.0.0.1:6379> LPUSH list mid                    # 列表名为list，head、mid、tail为元素
(integer) 1
127.0.0.1:6379> LPUSH list head
(integer) 2
127.0.0.1:6379> RPUSH list tail
(integer) 3
127.0.0.1:6379> LRANGE list 0 -1
1) "head"
2) "mid"
3) "tail"
127.0.0.1:6379> LRANGE list 0 1                   # 从头向尾读，没有RRANGE这个命令
1) "head"
2) "mid"
--------------------------------------------------
# 删除、改变list
LPOP key [count]                                  # 从头部弹出元素
RPOP key [count]                                  # 从尾部弹出元素
LREM key count element                            # 根据值移除元素，count表示从多个相同的值中移除的个数
LTRIM key start stop                              # 将列表截断，只保留[start ~ stop]的值
--------------------------------------------------
# 按下标索引
127.0.0.1:6379> LINDEX list 0                     # 获取list的第i个值
"head"
127.0.0.1:6379> LINDEX list 1
"mid"
--------------------------------------------------
# 长度
127.0.0.1:6379> LLEN list                         # 获取list的长度
(integer) 3
--------------------------------------------------
# 组合命令
RPOPLPUSH source destination                     # 从容器source的尾部弹出并添加到容器destination的头部
"tail"                                           # source和destination自然可以是同一个列表
-------------------------------------------------
# 修改列表中的值
LSET key index element                           # 修改列表指定下标处的值
127.0.0.1:6379> LSET list 0 prehead
OK
-------------------------------------------------
# 插值
LINSERT key BEFORE|AFTER pivot element          # pivot为列表中已有的元素，往列表中元素的前或后插入元素

Set（无序不重复）（命令都以s打头）

# 添加、查看
SADD key member [member ...]                    # 添加元素（可以批量）
127.0.0.1:6379> SADD set first second third
(integer) 3
127.0.0.1:6379> SMEMBERS set                    # 查看所有元素
1) "second"
2) "third"
3) "first"
127.0.0.1:6379> SISMEMBER set first             # 判断是否包含指定元素
(integer) 1
127.0.0.1:6379> SISMEMBER set fifth
(integer) 0
127.0.0.1:6379> SCARD set				       # 集合的长度
(integer) 3
-------------------------------------------------
# 移除
SREM key member [member ...]                    # 删除指定元素（可以批量）
SPOP key [count]                                # 随机删除元素（可以指定个数）
SMOVE source destination member                 # 将指定元素从集合source移动到集合destination
-------------------------------------------------
SRANDMEMBER key [count]                         # 随机返回元素（可以指定个数）
-------------------------------------------------
# 集合计算
# 差集     
SDIFF set1 set2                                 # 集合set1中有但set2中没有的元素
# 交集
SINTER set1 set2                                # 交
# 并集
SUNION set1 set2                                # 并

Hash（命令都以h打头）

相当于map，则变为key-(key-value)，故（更适合对象的存储）



# 添加
HSET key field value [field value ...]           # 存值，key为hash容器的名字
HMSET key field value [field value ...]          # 批量存值
127.0.0.1:6379> HSET hash name xunlu
(integer) 1
127.0.0.1:6379> HSET hash age 18
(integer) 1
-------------------------------------------------
# 查看
HGET key field                                   # 指定字段的取值
HMGET key field [field ...]                      # 批量取值
127.0.0.1:6379> HGET hash name
"xunlu"
127.0.0.1:6379> HGETALL hash                     # 查看全部内容
1) "name"
2) "xunlu"
3) "age"
4) "18"
-------------------------------------------------
# 删除
HDEL key field [field ...]                       # 删除指定元素（可批量）
-------------------------------------------------
# 长度
127.0.0.1:6379> HLEN hash
(integer) 2
-------------------------------------------------
# 是否存在
HEXISTS key field                                # 判断指定字段是否存在
-------------------------------------------------
127.0.0.1:6379> HKEYS hash                       # 取全部字段名
1) "name"
2) "age"
127.0.0.1:6379> HVALS hash                       # 取全部字段的值
1) "xunlu"
2) "18"
-------------------------------------------------
# 自增、自减
HINCRBY key field increment                      # field = field + increment （increment为负数即为减）
-------------------------------------------------
HSETNX key field value                           # 和setnx作用类似

Zset（有序集合）【底层为跳表】

# 添加、查看
ZADD key score member [score member ...]          # score用于排序
127.0.0.1:6379> ZADD salary 2500 mary 3000 alice 1000 lisa
(integer) 3
ZRANGE salary 0 -1                                # 返回所有数据
--------------------------------------------------
# 排序
ZRANGE salary 100 0 byscore rev withscores        # ZRANGE 后可跟上多个参数来约束比较，如通过score、降序、带上score
ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]      # 小到大
ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]   # 大到小
127.0.0.1:6379> ZRANGEBYSCORE salary -inf +inf    # 返回score在-inf +inf之间元素的排序，小到大
1) "lisa"
2) "mary"
3) "alice"
--------------------------------------------------
# 移除
ZREM key member [member ...]
--------------------------------------------------
# 长度
127.0.0.1:6379> ZCARD salary                      # 总个数
(integer) 3
127.0.0.1:6379> zcount salary 2000 3000           # 指定区间个数（score的区间）
(integer) 2
三种特殊数据类型

Geospatial 地理位置 【底层由Zset实现、因此可以使用zset的命令，如ZREM等】

# 添加城市及经纬度信息
GEOADD key [NX|XX] [CH] longitude latitude member [longitude latitude member ...]
127.0.0.1:6379> GEOADD china:city 116.40 39.90 beijing     # 经度、纬度
(integer) 1
127.0.0.1:6379> GEOADD china:city 121.47 31.23 shanghai
(integer) 1
127.0.0.1:6379> type china:city                            # 底层由Zset实现
zset
------------------------------------------------------------
# 获取指定城市的经纬度信息
GEOPOS key member [member ...]
127.0.0.1:6379> GEOPOS china:city beijing
1) 1) "116.39999896287918091"
   2) "39.90000009167092543"
-------------------------------------------------------------
# 获取两地的距离（直线距离）
GEODIST key member1 member2 [m|km|ft|mi]                     # 可指定单位，默认为米
127.0.0.1:6379> GEODIST china:city beijing shanghai km
"1067.3788"
-------------------------------------------------------------
# 获取范围内的元素
GEORADIUS key longitude latitude radius m|km|ft|mi          # 根据指定经纬度和半径获取范围内的元素
127.0.0.1:6379> GEORADIUS china:city 120 30 500 km          # 经度、维度、半径
1) "hangzhou"
2) "shanghai"
GEORADIUSBYMEMBER key member radius m|km|ft|mi              # 根据元素名和半径获取范围内的元素

Hypeloglog（基数统计、即去重后计数）【占用内存很小，最大只需要12KB】（有0.81%错误率）&mdash; 使用伯努利概率分布，根据第一个 1 出现的位置推测有多少基数。

PFADD key element [element ...]                  # 添加
PFCOUNT key [key ...]                            # 基数统计
127.0.0.1:6379> pfadd key a a a a l k j h j k l d
(integer) 1
127.0.0.1:6379> PFCOUNT key
(integer) 6
PFMERGE destkey sourcekey [sourcekey ...]        # 合并

Bitmaps（位图）

位存储、只有两种状态的都可以用它存储



SETBIT key offset value                          # 添加，其中value的值只能是 0 或 1
GETBIT key offset                                # 查看
BITCOUNT key [start end]                         # 统计value为 1 的个数

发布订阅
基于频道
基于频道(Channel)的发布/订阅有两个命令分别是 publish 和 subscribe 。'><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E7%AC%94%E8%AE%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E7%AC%94%E8%AE%B0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="lu"><meta property="og:title" content="Redis基础"><meta property="og:description" content='概述 Redis是什么？
Redis（Remote Dictionary Server )，即远程字典服务！
Redis能干吗？ —》 数据库、缓存、中间件
内存存储、持久化（rdb、aof） 效率高，可用于缓存 发布订阅系统 地图信息分析 计时器、计数器 。。。 Redis 通过“Redis序列化协议”（简称“RESP”），实现客户端与服务端之间的连接通信，其底层是通过TCP来完成的。
Linux安装配置redis 下载并解压redis后，将解压好的包移动到/usr/local/redis中，然后cd /usr/local/redis，依次在该目录下执行make，make test（也可以不执行）和make install。之后将该目录下的redis.conf备份，再vim redis.conf，将daemonize的值从no改为yes。cd /usr/local/bin，执行redis-server ../redis/redis.conf。配置完成。
redis 是单线程 对Redis来说，执行get、set以及eval等API，都是一个一个的任务，这些任务都会由Redis的线程（单线程）去负责执行，任务要么执行成功，要么执行失败，这就是Redis的命令是原子性的原因。
redis 6 引入了多线程 redis 5 及之前的版本一直使用的是单线程，多线程是 Redis6.0 推出的一个新特性。 Redis 的核心线程负责网络 IO ，命令处理以及写数据到缓冲，而随着网络硬件的性能提升，单个主线程处理⽹络请求的速度跟不上底层⽹络硬件的速度，导致网络 IO 的处理成为了 Redis 的性能瓶颈。
而 Redis6.0 就是从单线程处理网络请求到多线程处理，通过多个 IO 线程并⾏处理网络操作提升实例的整体处理性能。需要注意的是对于读写命令，Redis 仍然使⽤单线程来处理，这是因为继续使⽤单线程执行命令操作，就不⽤为了保证 Lua 脚本、事务的原⼦性，额外开发多线程互斥机制了。
redis 将所有的数据都放在内存中。单线程避免切换上下文，所以快。
多线程开发中并发访问控制是⼀个难点，需要精细的设计才能处理。如果只是简单地处理，比如简单地采⽤⼀个粗粒度互斥锁，只会出现不理想的结果。即便增加了线程，系统吞吐率也不会随着线程的增加而增加，因为大部分线程还在等待获取访问共享资源的互斥锁。而且，大部分采用多线程开发引入的同步原语保护共享资源的并发访问，也会降低系统代码的易调试性和可维护性。而正是以上这些问题，才让 Redis 采⽤了单线程模式。
官方解释：因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦)。
基础知识 redis所有命令不区分大小写
数据库基本命令 redis默认有16个数据库（0~15），默认使用第0个数据库。数据库之间数据相互隔离
127.0.0.1:6379> SELECT 3 # 切换数据库 OK 127.0.0.1:6379[3]> DBSIZE # 查看当前数据库大小 (integer) 0 127.0.0.1:6379> FLUSHDB # 清空当前数据库 OK 127.0.0.1:6379> FLUSHALL # 清空所有数据库 OK 127.0.0.1:6379> SHUTDOWN # 关闭redis服务 Redis-key基本命令 127.0.0.1:6379> set age 18 # 添加键值对 OK 127.0.0.1:6379> get name # 通过key获取value "xunlu" 127.0.0.1:6379> KEYS * # KEYS + 正则表达式。返回所有符合正则表达式的键 1) "age" 2) "name" 127.0.0.1:6379> EXISTS name # 判断是否存在指定的key (integer) 1 # 返回1则存在，0则不存在 127.0.0.1:6379> EXPIRE name 10 # 设置键name的有效期为10秒 (integer) 1 127.0.0.1:6379> ttl name # 查看键name的有效时间还剩下多少 (integer) 4 127.0.0.1:6379> MOVE name 1 # 将键值对移动到指定的数据库中 (integer) 1 127.0.0.1:6379> DEL name # 删除键值对 (integer) 1 127.0.0.1:6379> TYPE age # 获取当前键对应值的类型 string 数据类型 五种基本数据类型 String —> 应用：计数器（如访问量，点赞数等） 127.0.0.1:6379> set name xunlu OK 127.0.0.1:6379> APPEND name feilu # 追加字符串，类似StringBuilder的append (integer) 10 # 若追加的键不存在，则新建键值对 127.0.0.1:6379> get name "xunlufeilu" ----------------------------------------------- 127.0.0.1:6379> STRLEN name	# 返回值的长度 (integer) 10 ----------------------------------------------- 127.0.0.1:6379> set views 0 OK 127.0.0.1:6379> INCR views # 每执行一次，值就会加1.（只能作用于integer类型） (integer) 1 127.0.0.1:6379> INCR views (integer) 2 127.0.0.1:6379> DECR views # 每执行一次，值就会减1.（只能作用于integer类型） (integer) 1 127.0.0.1:6379> INCRBY views 10 # 指定增加的步长 (integer) 11 127.0.0.1:6379> DECRBY views 10 # 指定减少的步长 (integer) 1 ----------------------------------------------- 127.0.0.1:6379> set name xunlu OK 127.0.0.1:6379> GETRANGE name 0 2 # 截取部分值（start和end都包括在内） "xun" 127.0.0.1:6379> GETRANGE name 0 -1 # == get name "xunlu" 127.0.0.1:6379> SETRANGE name 0 gao # 替换部分字符，起始替换位置 + 替换的值 (integer) 5 127.0.0.1:6379> get name "gaolu" ----------------------------------------------- # setex(set with expire) 【原子性操作】 # setnx(set if not exist) 【原子性操作】 127.0.0.1:6379> setex name 30 xunlu # 新建键值对，并设置有效期为30秒 OK # 等同于 set name xunlu ex 30 127.0.0.1:6379> setnx gender male # nx表示键不存在时才能正确执行，即只能新建 OK # 等同于 set gender male nx # 常用于分布式锁 127.0.0.1:6379> get gender "male" 127.0.0.1:6379> set gender female nx # 此时键gender已经存在，执行失败 (nil) ----------------------------------------------- 127.0.0.1:6379> MSET k1 v1 k2 v1 k3 v1 # 批量创建键值对 OK 127.0.0.1:6379> KEYS * 1) "k1" # msetnx 【原子性操作】 2) "k3" 3) "k2" 127.0.0.1:6379> MGET k1 k2 k3 # 批量获取 1) "v1" 2) "v1" 3) "v1" ------------------------------------------------ 127.0.0.1:6379> set user {id:1,name:xunlu,age:3} # 可以将值设为json字符串，然后通过json解析 OK 127.0.0.1:6379> mset user:name xunlu user:age 18 # redis支持键中存在`:`冒号，亦可用于解析 OK ------------------------------------------------ 127.0.0.1:6379> getset db redis # 先get再set。没有返回nil，再设新值 (nil) 127.0.0.1:6379> getset db redis # 有则返回旧值，再设新值 "redis" List（双向链表） 绝大部分的list命令都以l开头，list的名字也可作为key，故有些redis-key的命令也可用 应用：消息队列、栈 # 添加、范围读取 LPUSH key element [element ...] # key为列表的名字，添加到列表的头部 RPUSH key element [element ...] # 添加到列表的尾部 127.0.0.1:6379> LPUSH list mid # 列表名为list，head、mid、tail为元素 (integer) 1 127.0.0.1:6379> LPUSH list head (integer) 2 127.0.0.1:6379> RPUSH list tail (integer) 3 127.0.0.1:6379> LRANGE list 0 -1 1) "head" 2) "mid" 3) "tail" 127.0.0.1:6379> LRANGE list 0 1 # 从头向尾读，没有RRANGE这个命令 1) "head" 2) "mid" -------------------------------------------------- # 删除、改变list LPOP key [count] # 从头部弹出元素 RPOP key [count] # 从尾部弹出元素 LREM key count element # 根据值移除元素，count表示从多个相同的值中移除的个数 LTRIM key start stop # 将列表截断，只保留[start ~ stop]的值 -------------------------------------------------- # 按下标索引 127.0.0.1:6379> LINDEX list 0 # 获取list的第i个值 "head" 127.0.0.1:6379> LINDEX list 1 "mid" -------------------------------------------------- # 长度 127.0.0.1:6379> LLEN list # 获取list的长度 (integer) 3 -------------------------------------------------- # 组合命令 RPOPLPUSH source destination # 从容器source的尾部弹出并添加到容器destination的头部 "tail" # source和destination自然可以是同一个列表 ------------------------------------------------- # 修改列表中的值 LSET key index element # 修改列表指定下标处的值 127.0.0.1:6379> LSET list 0 prehead OK ------------------------------------------------- # 插值 LINSERT key BEFORE|AFTER pivot element # pivot为列表中已有的元素，往列表中元素的前或后插入元素 Set（无序不重复）（命令都以s打头） # 添加、查看 SADD key member [member ...] # 添加元素（可以批量） 127.0.0.1:6379> SADD set first second third (integer) 3 127.0.0.1:6379> SMEMBERS set # 查看所有元素 1) "second" 2) "third" 3) "first" 127.0.0.1:6379> SISMEMBER set first # 判断是否包含指定元素 (integer) 1 127.0.0.1:6379> SISMEMBER set fifth (integer) 0 127.0.0.1:6379> SCARD set	# 集合的长度 (integer) 3 ------------------------------------------------- # 移除 SREM key member [member ...] # 删除指定元素（可以批量） SPOP key [count] # 随机删除元素（可以指定个数） SMOVE source destination member # 将指定元素从集合source移动到集合destination ------------------------------------------------- SRANDMEMBER key [count] # 随机返回元素（可以指定个数） ------------------------------------------------- # 集合计算 # 差集 SDIFF set1 set2 # 集合set1中有但set2中没有的元素 # 交集 SINTER set1 set2 # 交 # 并集 SUNION set1 set2 # 并 Hash（命令都以h打头） 相当于map，则变为key-(key-value)，故（更适合对象的存储） # 添加 HSET key field value [field value ...] # 存值，key为hash容器的名字 HMSET key field value [field value ...] # 批量存值 127.0.0.1:6379> HSET hash name xunlu (integer) 1 127.0.0.1:6379> HSET hash age 18 (integer) 1 ------------------------------------------------- # 查看 HGET key field # 指定字段的取值 HMGET key field [field ...] # 批量取值 127.0.0.1:6379> HGET hash name "xunlu" 127.0.0.1:6379> HGETALL hash # 查看全部内容 1) "name" 2) "xunlu" 3) "age" 4) "18" ------------------------------------------------- # 删除 HDEL key field [field ...] # 删除指定元素（可批量） ------------------------------------------------- # 长度 127.0.0.1:6379> HLEN hash (integer) 2 ------------------------------------------------- # 是否存在 HEXISTS key field # 判断指定字段是否存在 ------------------------------------------------- 127.0.0.1:6379> HKEYS hash # 取全部字段名 1) "name" 2) "age" 127.0.0.1:6379> HVALS hash # 取全部字段的值 1) "xunlu" 2) "18" ------------------------------------------------- # 自增、自减 HINCRBY key field increment # field = field + increment （increment为负数即为减） ------------------------------------------------- HSETNX key field value # 和setnx作用类似 Zset（有序集合）【底层为跳表】 # 添加、查看 ZADD key score member [score member ...] # score用于排序 127.0.0.1:6379> ZADD salary 2500 mary 3000 alice 1000 lisa (integer) 3 ZRANGE salary 0 -1 # 返回所有数据 -------------------------------------------------- # 排序 ZRANGE salary 100 0 byscore rev withscores # ZRANGE 后可跟上多个参数来约束比较，如通过score、降序、带上score ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] # 小到大 ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count] # 大到小 127.0.0.1:6379> ZRANGEBYSCORE salary -inf +inf # 返回score在-inf +inf之间元素的排序，小到大 1) "lisa" 2) "mary" 3) "alice" -------------------------------------------------- # 移除 ZREM key member [member ...] -------------------------------------------------- # 长度 127.0.0.1:6379> ZCARD salary # 总个数 (integer) 3 127.0.0.1:6379> zcount salary 2000 3000 # 指定区间个数（score的区间） (integer) 2 三种特殊数据类型 Geospatial 地理位置 【底层由Zset实现、因此可以使用zset的命令，如ZREM等】 # 添加城市及经纬度信息 GEOADD key [NX|XX] [CH] longitude latitude member [longitude latitude member ...] 127.0.0.1:6379> GEOADD china:city 116.40 39.90 beijing # 经度、纬度 (integer) 1 127.0.0.1:6379> GEOADD china:city 121.47 31.23 shanghai (integer) 1 127.0.0.1:6379> type china:city # 底层由Zset实现 zset ------------------------------------------------------------ # 获取指定城市的经纬度信息 GEOPOS key member [member ...] 127.0.0.1:6379> GEOPOS china:city beijing 1) 1) "116.39999896287918091" 2) "39.90000009167092543" ------------------------------------------------------------- # 获取两地的距离（直线距离） GEODIST key member1 member2 [m|km|ft|mi] # 可指定单位，默认为米 127.0.0.1:6379> GEODIST china:city beijing shanghai km "1067.3788" ------------------------------------------------------------- # 获取范围内的元素 GEORADIUS key longitude latitude radius m|km|ft|mi # 根据指定经纬度和半径获取范围内的元素 127.0.0.1:6379> GEORADIUS china:city 120 30 500 km # 经度、维度、半径 1) "hangzhou" 2) "shanghai" GEORADIUSBYMEMBER key member radius m|km|ft|mi # 根据元素名和半径获取范围内的元素 Hypeloglog（基数统计、即去重后计数）【占用内存很小，最大只需要12KB】（有0.81%错误率）— 使用伯努利概率分布，根据第一个 1 出现的位置推测有多少基数。 PFADD key element [element ...] # 添加 PFCOUNT key [key ...] # 基数统计 127.0.0.1:6379> pfadd key a a a a l k j h j k l d (integer) 1 127.0.0.1:6379> PFCOUNT key (integer) 6 PFMERGE destkey sourcekey [sourcekey ...] # 合并 Bitmaps（位图） 位存储、只有两种状态的都可以用它存储 SETBIT key offset value # 添加，其中value的值只能是 0 或 1 GETBIT key offset # 查看 BITCOUNT key [start end] # 统计value为 1 的个数 发布订阅 基于频道 基于频道(Channel)的发布/订阅有两个命令分别是 publish 和 subscribe 。'><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-01T17:39:41+00:00"><meta property="article:modified_time" content="2022-04-01T17:39:41+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redis基础"><meta name=twitter:description content='概述
Redis是什么？
Redis（Remote Dictionary Server )，即远程字典服务！
Redis能干吗？  &mdash;》 数据库、缓存、中间件

内存存储、持久化（rdb、aof）
效率高，可用于缓存
发布订阅系统
地图信息分析
计时器、计数器 。。。

Redis 通过“Redis序列化协议”（简称“RESP”），实现客户端与服务端之间的连接通信，其底层是通过TCP来完成的。

Linux安装配置redis
下载并解压redis后，将解压好的包移动到/usr/local/redis中，然后cd /usr/local/redis，依次在该目录下执行make，make test（也可以不执行）和make install。之后将该目录下的redis.conf备份，再vim redis.conf，将daemonize的值从no改为yes。cd /usr/local/bin，执行redis-server ../redis/redis.conf。配置完成。

redis 是单线程
对Redis来说，执行get、set以及eval等API，都是一个一个的任务，这些任务都会由Redis的线程（单线程）去负责执行，任务要么执行成功，要么执行失败，这就是Redis的命令是原子性的原因。
redis 6 引入了多线程
redis 5 及之前的版本一直使用的是单线程，多线程是 Redis6.0 推出的一个新特性。 Redis 的核心线程负责网络 IO ，命令处理以及写数据到缓冲，而随着网络硬件的性能提升，单个主线程处理⽹络请求的速度跟不上底层⽹络硬件的速度，导致网络 IO 的处理成为了 Redis 的性能瓶颈。
而 Redis6.0 就是从单线程处理网络请求到多线程处理，通过多个 IO 线程并⾏处理网络操作提升实例的整体处理性能。需要注意的是对于读写命令，Redis 仍然使⽤单线程来处理，这是因为继续使⽤单线程执行命令操作，就不⽤为了保证 Lua 脚本、事务的原⼦性，额外开发多线程互斥机制了。
redis 将所有的数据都放在内存中。单线程避免切换上下文，所以快。
多线程开发中并发访问控制是⼀个难点，需要精细的设计才能处理。如果只是简单地处理，比如简单地采⽤⼀个粗粒度互斥锁，只会出现不理想的结果。即便增加了线程，系统吞吐率也不会随着线程的增加而增加，因为大部分线程还在等待获取访问共享资源的互斥锁。而且，大部分采用多线程开发引入的同步原语保护共享资源的并发访问，也会降低系统代码的易调试性和可维护性。而正是以上这些问题，才让 Redis 采⽤了单线程模式。
官方解释：因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦)。

基础知识
redis所有命令不区分大小写
数据库基本命令
redis默认有16个数据库（0~15），默认使用第0个数据库。数据库之间数据相互隔离
127.0.0.1:6379> SELECT 3      # 切换数据库
OK
127.0.0.1:6379[3]> DBSIZE     # 查看当前数据库大小
(integer) 0
127.0.0.1:6379> FLUSHDB       # 清空当前数据库
OK
127.0.0.1:6379> FLUSHALL      # 清空所有数据库
OK
127.0.0.1:6379> SHUTDOWN      # 关闭redis服务
Redis-key基本命令
127.0.0.1:6379> set age 18            # 添加键值对
OK
127.0.0.1:6379> get name              # 通过key获取value
"xunlu"
127.0.0.1:6379> KEYS *                # KEYS + 正则表达式。返回所有符合正则表达式的键
1) "age"
2) "name"
127.0.0.1:6379> EXISTS name           # 判断是否存在指定的key
(integer) 1                           # 返回1则存在，0则不存在
127.0.0.1:6379> EXPIRE name 10        # 设置键name的有效期为10秒
(integer) 1
127.0.0.1:6379> ttl name              # 查看键name的有效时间还剩下多少
(integer) 4
127.0.0.1:6379> MOVE name 1           # 将键值对移动到指定的数据库中
(integer) 1
127.0.0.1:6379> DEL name              # 删除键值对
(integer) 1
127.0.0.1:6379> TYPE age              # 获取当前键对应值的类型
string

数据类型
五种基本数据类型

String  &mdash;>  应用：计数器（如访问量，点赞数等）

127.0.0.1:6379> set name xunlu
OK
127.0.0.1:6379> APPEND name feilu              # 追加字符串，类似StringBuilder的append
(integer) 10                                   # 若追加的键不存在，则新建键值对
127.0.0.1:6379> get name
"xunlufeilu"
-----------------------------------------------
127.0.0.1:6379> STRLEN name					 # 返回值的长度
(integer) 10
-----------------------------------------------
127.0.0.1:6379> set views 0
OK
127.0.0.1:6379> INCR views                     # 每执行一次，值就会加1.（只能作用于integer类型）
(integer) 1
127.0.0.1:6379> INCR views
(integer) 2
127.0.0.1:6379> DECR views                     # 每执行一次，值就会减1.（只能作用于integer类型）
(integer) 1
127.0.0.1:6379> INCRBY views 10                # 指定增加的步长
(integer) 11
127.0.0.1:6379> DECRBY views 10                # 指定减少的步长
(integer) 1
-----------------------------------------------
127.0.0.1:6379> set name xunlu
OK
127.0.0.1:6379> GETRANGE name 0 2              # 截取部分值（start和end都包括在内）
"xun"
127.0.0.1:6379> GETRANGE name 0 -1             # == get name
"xunlu"
127.0.0.1:6379> SETRANGE name 0 gao            # 替换部分字符，起始替换位置 + 替换的值
(integer) 5
127.0.0.1:6379> get name
"gaolu"
-----------------------------------------------
# setex(set with expire)   【原子性操作】
# setnx(set if not exist)  【原子性操作】
127.0.0.1:6379> setex name 30 xunlu            # 新建键值对，并设置有效期为30秒
OK   # 等同于 set name xunlu ex 30
127.0.0.1:6379> setnx gender male              # nx表示键不存在时才能正确执行，即只能新建
OK   # 等同于 set gender male nx               # 常用于分布式锁
127.0.0.1:6379> get gender
"male"
127.0.0.1:6379> set gender female nx           # 此时键gender已经存在，执行失败
(nil)
-----------------------------------------------
127.0.0.1:6379> MSET k1 v1 k2 v1 k3 v1         # 批量创建键值对
OK
127.0.0.1:6379> KEYS *
1) "k1"                                        # msetnx 【原子性操作】
2) "k3"
3) "k2"
127.0.0.1:6379> MGET k1 k2 k3                  # 批量获取 
1) "v1"
2) "v1"
3) "v1"
------------------------------------------------
127.0.0.1:6379> set user {id:1,name:xunlu,age:3} # 可以将值设为json字符串，然后通过json解析
OK
127.0.0.1:6379> mset user:name xunlu user:age 18 # redis支持键中存在`:`冒号，亦可用于解析
OK
------------------------------------------------
127.0.0.1:6379> getset db redis                  # 先get再set。没有返回nil，再设新值
(nil)
127.0.0.1:6379> getset db redis                  # 有则返回旧值，再设新值
"redis"

List（双向链表）

绝大部分的list命令都以l开头，list的名字也可作为key，故有些redis-key的命令也可用
应用：消息队列、栈



# 添加、范围读取
LPUSH key element [element ...]                   # key为列表的名字，添加到列表的头部
RPUSH key element [element ...]                   # 添加到列表的尾部                 
127.0.0.1:6379> LPUSH list mid                    # 列表名为list，head、mid、tail为元素
(integer) 1
127.0.0.1:6379> LPUSH list head
(integer) 2
127.0.0.1:6379> RPUSH list tail
(integer) 3
127.0.0.1:6379> LRANGE list 0 -1
1) "head"
2) "mid"
3) "tail"
127.0.0.1:6379> LRANGE list 0 1                   # 从头向尾读，没有RRANGE这个命令
1) "head"
2) "mid"
--------------------------------------------------
# 删除、改变list
LPOP key [count]                                  # 从头部弹出元素
RPOP key [count]                                  # 从尾部弹出元素
LREM key count element                            # 根据值移除元素，count表示从多个相同的值中移除的个数
LTRIM key start stop                              # 将列表截断，只保留[start ~ stop]的值
--------------------------------------------------
# 按下标索引
127.0.0.1:6379> LINDEX list 0                     # 获取list的第i个值
"head"
127.0.0.1:6379> LINDEX list 1
"mid"
--------------------------------------------------
# 长度
127.0.0.1:6379> LLEN list                         # 获取list的长度
(integer) 3
--------------------------------------------------
# 组合命令
RPOPLPUSH source destination                     # 从容器source的尾部弹出并添加到容器destination的头部
"tail"                                           # source和destination自然可以是同一个列表
-------------------------------------------------
# 修改列表中的值
LSET key index element                           # 修改列表指定下标处的值
127.0.0.1:6379> LSET list 0 prehead
OK
-------------------------------------------------
# 插值
LINSERT key BEFORE|AFTER pivot element          # pivot为列表中已有的元素，往列表中元素的前或后插入元素

Set（无序不重复）（命令都以s打头）

# 添加、查看
SADD key member [member ...]                    # 添加元素（可以批量）
127.0.0.1:6379> SADD set first second third
(integer) 3
127.0.0.1:6379> SMEMBERS set                    # 查看所有元素
1) "second"
2) "third"
3) "first"
127.0.0.1:6379> SISMEMBER set first             # 判断是否包含指定元素
(integer) 1
127.0.0.1:6379> SISMEMBER set fifth
(integer) 0
127.0.0.1:6379> SCARD set				       # 集合的长度
(integer) 3
-------------------------------------------------
# 移除
SREM key member [member ...]                    # 删除指定元素（可以批量）
SPOP key [count]                                # 随机删除元素（可以指定个数）
SMOVE source destination member                 # 将指定元素从集合source移动到集合destination
-------------------------------------------------
SRANDMEMBER key [count]                         # 随机返回元素（可以指定个数）
-------------------------------------------------
# 集合计算
# 差集     
SDIFF set1 set2                                 # 集合set1中有但set2中没有的元素
# 交集
SINTER set1 set2                                # 交
# 并集
SUNION set1 set2                                # 并

Hash（命令都以h打头）

相当于map，则变为key-(key-value)，故（更适合对象的存储）



# 添加
HSET key field value [field value ...]           # 存值，key为hash容器的名字
HMSET key field value [field value ...]          # 批量存值
127.0.0.1:6379> HSET hash name xunlu
(integer) 1
127.0.0.1:6379> HSET hash age 18
(integer) 1
-------------------------------------------------
# 查看
HGET key field                                   # 指定字段的取值
HMGET key field [field ...]                      # 批量取值
127.0.0.1:6379> HGET hash name
"xunlu"
127.0.0.1:6379> HGETALL hash                     # 查看全部内容
1) "name"
2) "xunlu"
3) "age"
4) "18"
-------------------------------------------------
# 删除
HDEL key field [field ...]                       # 删除指定元素（可批量）
-------------------------------------------------
# 长度
127.0.0.1:6379> HLEN hash
(integer) 2
-------------------------------------------------
# 是否存在
HEXISTS key field                                # 判断指定字段是否存在
-------------------------------------------------
127.0.0.1:6379> HKEYS hash                       # 取全部字段名
1) "name"
2) "age"
127.0.0.1:6379> HVALS hash                       # 取全部字段的值
1) "xunlu"
2) "18"
-------------------------------------------------
# 自增、自减
HINCRBY key field increment                      # field = field + increment （increment为负数即为减）
-------------------------------------------------
HSETNX key field value                           # 和setnx作用类似

Zset（有序集合）【底层为跳表】

# 添加、查看
ZADD key score member [score member ...]          # score用于排序
127.0.0.1:6379> ZADD salary 2500 mary 3000 alice 1000 lisa
(integer) 3
ZRANGE salary 0 -1                                # 返回所有数据
--------------------------------------------------
# 排序
ZRANGE salary 100 0 byscore rev withscores        # ZRANGE 后可跟上多个参数来约束比较，如通过score、降序、带上score
ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]      # 小到大
ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]   # 大到小
127.0.0.1:6379> ZRANGEBYSCORE salary -inf +inf    # 返回score在-inf +inf之间元素的排序，小到大
1) "lisa"
2) "mary"
3) "alice"
--------------------------------------------------
# 移除
ZREM key member [member ...]
--------------------------------------------------
# 长度
127.0.0.1:6379> ZCARD salary                      # 总个数
(integer) 3
127.0.0.1:6379> zcount salary 2000 3000           # 指定区间个数（score的区间）
(integer) 2
三种特殊数据类型

Geospatial 地理位置 【底层由Zset实现、因此可以使用zset的命令，如ZREM等】

# 添加城市及经纬度信息
GEOADD key [NX|XX] [CH] longitude latitude member [longitude latitude member ...]
127.0.0.1:6379> GEOADD china:city 116.40 39.90 beijing     # 经度、纬度
(integer) 1
127.0.0.1:6379> GEOADD china:city 121.47 31.23 shanghai
(integer) 1
127.0.0.1:6379> type china:city                            # 底层由Zset实现
zset
------------------------------------------------------------
# 获取指定城市的经纬度信息
GEOPOS key member [member ...]
127.0.0.1:6379> GEOPOS china:city beijing
1) 1) "116.39999896287918091"
   2) "39.90000009167092543"
-------------------------------------------------------------
# 获取两地的距离（直线距离）
GEODIST key member1 member2 [m|km|ft|mi]                     # 可指定单位，默认为米
127.0.0.1:6379> GEODIST china:city beijing shanghai km
"1067.3788"
-------------------------------------------------------------
# 获取范围内的元素
GEORADIUS key longitude latitude radius m|km|ft|mi          # 根据指定经纬度和半径获取范围内的元素
127.0.0.1:6379> GEORADIUS china:city 120 30 500 km          # 经度、维度、半径
1) "hangzhou"
2) "shanghai"
GEORADIUSBYMEMBER key member radius m|km|ft|mi              # 根据元素名和半径获取范围内的元素

Hypeloglog（基数统计、即去重后计数）【占用内存很小，最大只需要12KB】（有0.81%错误率）&mdash; 使用伯努利概率分布，根据第一个 1 出现的位置推测有多少基数。

PFADD key element [element ...]                  # 添加
PFCOUNT key [key ...]                            # 基数统计
127.0.0.1:6379> pfadd key a a a a l k j h j k l d
(integer) 1
127.0.0.1:6379> PFCOUNT key
(integer) 6
PFMERGE destkey sourcekey [sourcekey ...]        # 合并

Bitmaps（位图）

位存储、只有两种状态的都可以用它存储



SETBIT key offset value                          # 添加，其中value的值只能是 0 或 1
GETBIT key offset                                # 查看
BITCOUNT key [start end]                         # 统计value为 1 的个数

发布订阅
基于频道
基于频道(Channel)的发布/订阅有两个命令分别是 publish 和 subscribe 。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ethereal-lu.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Redis基础","item":"https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis基础","name":"Redis基础","description":"概述 Redis是什么？\nRedis（Remote Dictionary Server )，即远程字典服务！\nRedis能干吗？ \u0026mdash;》 数据库、缓存、中间件\n内存存储、持久化（rdb、aof） 效率高，可用于缓存 发布订阅系统 地图信息分析 计时器、计数器 。。。 Redis 通过“Redis序列化协议”（简称“RESP”），实现客户端与服务端之间的连接通信，其底层是通过TCP来完成的。\nLinux安装配置redis 下载并解压redis后，将解压好的包移动到/usr/local/redis中，然后cd /usr/local/redis，依次在该目录下执行make，make test（也可以不执行）和make install。之后将该目录下的redis.conf备份，再vim redis.conf，将daemonize的值从no改为yes。cd /usr/local/bin，执行redis-server ../redis/redis.conf。配置完成。\nredis 是单线程 对Redis来说，执行get、set以及eval等API，都是一个一个的任务，这些任务都会由Redis的线程（单线程）去负责执行，任务要么执行成功，要么执行失败，这就是Redis的命令是原子性的原因。\nredis 6 引入了多线程 redis 5 及之前的版本一直使用的是单线程，多线程是 Redis6.0 推出的一个新特性。 Redis 的核心线程负责网络 IO ，命令处理以及写数据到缓冲，而随着网络硬件的性能提升，单个主线程处理⽹络请求的速度跟不上底层⽹络硬件的速度，导致网络 IO 的处理成为了 Redis 的性能瓶颈。\n而 Redis6.0 就是从单线程处理网络请求到多线程处理，通过多个 IO 线程并⾏处理网络操作提升实例的整体处理性能。需要注意的是对于读写命令，Redis 仍然使⽤单线程来处理，这是因为继续使⽤单线程执行命令操作，就不⽤为了保证 Lua 脚本、事务的原⼦性，额外开发多线程互斥机制了。\nredis 将所有的数据都放在内存中。单线程避免切换上下文，所以快。\n多线程开发中并发访问控制是⼀个难点，需要精细的设计才能处理。如果只是简单地处理，比如简单地采⽤⼀个粗粒度互斥锁，只会出现不理想的结果。即便增加了线程，系统吞吐率也不会随着线程的增加而增加，因为大部分线程还在等待获取访问共享资源的互斥锁。而且，大部分采用多线程开发引入的同步原语保护共享资源的并发访问，也会降低系统代码的易调试性和可维护性。而正是以上这些问题，才让 Redis 采⽤了单线程模式。\n官方解释：因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦)。\n基础知识 redis所有命令不区分大小写\n数据库基本命令 redis默认有16个数据库（0~15），默认使用第0个数据库。数据库之间数据相互隔离\n127.0.0.1:6379\u0026gt; SELECT 3 # 切换数据库 OK 127.0.0.1:6379[3]\u0026gt; DBSIZE # 查看当前数据库大小 (integer) 0 127.0.0.1:6379\u0026gt; FLUSHDB # 清空当前数据库 OK 127.0.0.1:6379\u0026gt; FLUSHALL # 清空所有数据库 OK 127.0.0.1:6379\u0026gt; SHUTDOWN # 关闭redis服务 Redis-key基本命令 127.0.0.1:6379\u0026gt; set age 18 # 添加键值对 OK 127.0.0.1:6379\u0026gt; get name # 通过key获取value \u0026#34;xunlu\u0026#34; 127.0.0.1:6379\u0026gt; KEYS * # KEYS + 正则表达式。返回所有符合正则表达式的键 1) \u0026#34;age\u0026#34; 2) \u0026#34;name\u0026#34; 127.0.0.1:6379\u0026gt; EXISTS name # 判断是否存在指定的key (integer) 1 # 返回1则存在，0则不存在 127.0.0.1:6379\u0026gt; EXPIRE name 10 # 设置键name的有效期为10秒 (integer) 1 127.0.0.1:6379\u0026gt; ttl name # 查看键name的有效时间还剩下多少 (integer) 4 127.0.0.1:6379\u0026gt; MOVE name 1 # 将键值对移动到指定的数据库中 (integer) 1 127.0.0.1:6379\u0026gt; DEL name # 删除键值对 (integer) 1 127.0.0.1:6379\u0026gt; TYPE age # 获取当前键对应值的类型 string 数据类型 五种基本数据类型 String \u0026mdash;\u0026gt; 应用：计数器（如访问量，点赞数等） 127.0.0.1:6379\u0026gt; set name xunlu OK 127.0.0.1:6379\u0026gt; APPEND name feilu # 追加字符串，类似StringBuilder的append (integer) 10 # 若追加的键不存在，则新建键值对 127.0.0.1:6379\u0026gt; get name \u0026#34;xunlufeilu\u0026#34; ----------------------------------------------- 127.0.0.1:6379\u0026gt; STRLEN name\t# 返回值的长度 (integer) 10 ----------------------------------------------- 127.0.0.1:6379\u0026gt; set views 0 OK 127.0.0.1:6379\u0026gt; INCR views # 每执行一次，值就会加1.（只能作用于integer类型） (integer) 1 127.0.0.1:6379\u0026gt; INCR views (integer) 2 127.0.0.1:6379\u0026gt; DECR views # 每执行一次，值就会减1.（只能作用于integer类型） (integer) 1 127.0.0.1:6379\u0026gt; INCRBY views 10 # 指定增加的步长 (integer) 11 127.0.0.1:6379\u0026gt; DECRBY views 10 # 指定减少的步长 (integer) 1 ----------------------------------------------- 127.0.0.1:6379\u0026gt; set name xunlu OK 127.0.0.1:6379\u0026gt; GETRANGE name 0 2 # 截取部分值（start和end都包括在内） \u0026#34;xun\u0026#34; 127.0.0.1:6379\u0026gt; GETRANGE name 0 -1 # == get name \u0026#34;xunlu\u0026#34; 127.0.0.1:6379\u0026gt; SETRANGE name 0 gao # 替换部分字符，起始替换位置 + 替换的值 (integer) 5 127.0.0.1:6379\u0026gt; get name \u0026#34;gaolu\u0026#34; ----------------------------------------------- # setex(set with expire) 【原子性操作】 # setnx(set if not exist) 【原子性操作】 127.0.0.1:6379\u0026gt; setex name 30 xunlu # 新建键值对，并设置有效期为30秒 OK # 等同于 set name xunlu ex 30 127.0.0.1:6379\u0026gt; setnx gender male # nx表示键不存在时才能正确执行，即只能新建 OK # 等同于 set gender male nx # 常用于分布式锁 127.0.0.1:6379\u0026gt; get gender \u0026#34;male\u0026#34; 127.0.0.1:6379\u0026gt; set gender female nx # 此时键gender已经存在，执行失败 (nil) ----------------------------------------------- 127.0.0.1:6379\u0026gt; MSET k1 v1 k2 v1 k3 v1 # 批量创建键值对 OK 127.0.0.1:6379\u0026gt; KEYS * 1) \u0026#34;k1\u0026#34; # msetnx 【原子性操作】 2) \u0026#34;k3\u0026#34; 3) \u0026#34;k2\u0026#34; 127.0.0.1:6379\u0026gt; MGET k1 k2 k3 # 批量获取 1) \u0026#34;v1\u0026#34; 2) \u0026#34;v1\u0026#34; 3) \u0026#34;v1\u0026#34; ------------------------------------------------ 127.0.0.1:6379\u0026gt; set user {id:1,name:xunlu,age:3} # 可以将值设为json字符串，然后通过json解析 OK 127.0.0.1:6379\u0026gt; mset user:name xunlu user:age 18 # redis支持键中存在`:`冒号，亦可用于解析 OK ------------------------------------------------ 127.0.0.1:6379\u0026gt; getset db redis # 先get再set。没有返回nil，再设新值 (nil) 127.0.0.1:6379\u0026gt; getset db redis # 有则返回旧值，再设新值 \u0026#34;redis\u0026#34; List（双向链表） 绝大部分的list命令都以l开头，list的名字也可作为key，故有些redis-key的命令也可用 应用：消息队列、栈 # 添加、范围读取 LPUSH key element [element ...] # key为列表的名字，添加到列表的头部 RPUSH key element [element ...] # 添加到列表的尾部 127.0.0.1:6379\u0026gt; LPUSH list mid # 列表名为list，head、mid、tail为元素 (integer) 1 127.0.0.1:6379\u0026gt; LPUSH list head (integer) 2 127.0.0.1:6379\u0026gt; RPUSH list tail (integer) 3 127.0.0.1:6379\u0026gt; LRANGE list 0 -1 1) \u0026#34;head\u0026#34; 2) \u0026#34;mid\u0026#34; 3) \u0026#34;tail\u0026#34; 127.0.0.1:6379\u0026gt; LRANGE list 0 1 # 从头向尾读，没有RRANGE这个命令 1) \u0026#34;head\u0026#34; 2) \u0026#34;mid\u0026#34; -------------------------------------------------- # 删除、改变list LPOP key [count] # 从头部弹出元素 RPOP key [count] # 从尾部弹出元素 LREM key count element # 根据值移除元素，count表示从多个相同的值中移除的个数 LTRIM key start stop # 将列表截断，只保留[start ~ stop]的值 -------------------------------------------------- # 按下标索引 127.0.0.1:6379\u0026gt; LINDEX list 0 # 获取list的第i个值 \u0026#34;head\u0026#34; 127.0.0.1:6379\u0026gt; LINDEX list 1 \u0026#34;mid\u0026#34; -------------------------------------------------- # 长度 127.0.0.1:6379\u0026gt; LLEN list # 获取list的长度 (integer) 3 -------------------------------------------------- # 组合命令 RPOPLPUSH source destination # 从容器source的尾部弹出并添加到容器destination的头部 \u0026#34;tail\u0026#34; # source和destination自然可以是同一个列表 ------------------------------------------------- # 修改列表中的值 LSET key index element # 修改列表指定下标处的值 127.0.0.1:6379\u0026gt; LSET list 0 prehead OK ------------------------------------------------- # 插值 LINSERT key BEFORE|AFTER pivot element # pivot为列表中已有的元素，往列表中元素的前或后插入元素 Set（无序不重复）（命令都以s打头） # 添加、查看 SADD key member [member ...] # 添加元素（可以批量） 127.0.0.1:6379\u0026gt; SADD set first second third (integer) 3 127.0.0.1:6379\u0026gt; SMEMBERS set # 查看所有元素 1) \u0026#34;second\u0026#34; 2) \u0026#34;third\u0026#34; 3) \u0026#34;first\u0026#34; 127.0.0.1:6379\u0026gt; SISMEMBER set first # 判断是否包含指定元素 (integer) 1 127.0.0.1:6379\u0026gt; SISMEMBER set fifth (integer) 0 127.0.0.1:6379\u0026gt; SCARD set\t# 集合的长度 (integer) 3 ------------------------------------------------- # 移除 SREM key member [member ...] # 删除指定元素（可以批量） SPOP key [count] # 随机删除元素（可以指定个数） SMOVE source destination member # 将指定元素从集合source移动到集合destination ------------------------------------------------- SRANDMEMBER key [count] # 随机返回元素（可以指定个数） ------------------------------------------------- # 集合计算 # 差集 SDIFF set1 set2 # 集合set1中有但set2中没有的元素 # 交集 SINTER set1 set2 # 交 # 并集 SUNION set1 set2 # 并 Hash（命令都以h打头） 相当于map，则变为key-(key-value)，故（更适合对象的存储） # 添加 HSET key field value [field value ...] # 存值，key为hash容器的名字 HMSET key field value [field value ...] # 批量存值 127.0.0.1:6379\u0026gt; HSET hash name xunlu (integer) 1 127.0.0.1:6379\u0026gt; HSET hash age 18 (integer) 1 ------------------------------------------------- # 查看 HGET key field # 指定字段的取值 HMGET key field [field ...] # 批量取值 127.0.0.1:6379\u0026gt; HGET hash name \u0026#34;xunlu\u0026#34; 127.0.0.1:6379\u0026gt; HGETALL hash # 查看全部内容 1) \u0026#34;name\u0026#34; 2) \u0026#34;xunlu\u0026#34; 3) \u0026#34;age\u0026#34; 4) \u0026#34;18\u0026#34; ------------------------------------------------- # 删除 HDEL key field [field ...] # 删除指定元素（可批量） ------------------------------------------------- # 长度 127.0.0.1:6379\u0026gt; HLEN hash (integer) 2 ------------------------------------------------- # 是否存在 HEXISTS key field # 判断指定字段是否存在 ------------------------------------------------- 127.0.0.1:6379\u0026gt; HKEYS hash # 取全部字段名 1) \u0026#34;name\u0026#34; 2) \u0026#34;age\u0026#34; 127.0.0.1:6379\u0026gt; HVALS hash # 取全部字段的值 1) \u0026#34;xunlu\u0026#34; 2) \u0026#34;18\u0026#34; ------------------------------------------------- # 自增、自减 HINCRBY key field increment # field = field + increment （increment为负数即为减） ------------------------------------------------- HSETNX key field value # 和setnx作用类似 Zset（有序集合）【底层为跳表】 # 添加、查看 ZADD key score member [score member ...] # score用于排序 127.0.0.1:6379\u0026gt; ZADD salary 2500 mary 3000 alice 1000 lisa (integer) 3 ZRANGE salary 0 -1 # 返回所有数据 -------------------------------------------------- # 排序 ZRANGE salary 100 0 byscore rev withscores # ZRANGE 后可跟上多个参数来约束比较，如通过score、降序、带上score ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] # 小到大 ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count] # 大到小 127.0.0.1:6379\u0026gt; ZRANGEBYSCORE salary -inf +inf # 返回score在-inf +inf之间元素的排序，小到大 1) \u0026#34;lisa\u0026#34; 2) \u0026#34;mary\u0026#34; 3) \u0026#34;alice\u0026#34; -------------------------------------------------- # 移除 ZREM key member [member ...] -------------------------------------------------- # 长度 127.0.0.1:6379\u0026gt; ZCARD salary # 总个数 (integer) 3 127.0.0.1:6379\u0026gt; zcount salary 2000 3000 # 指定区间个数（score的区间） (integer) 2 三种特殊数据类型 Geospatial 地理位置 【底层由Zset实现、因此可以使用zset的命令，如ZREM等】 # 添加城市及经纬度信息 GEOADD key [NX|XX] [CH] longitude latitude member [longitude latitude member ...] 127.0.0.1:6379\u0026gt; GEOADD china:city 116.40 39.90 beijing # 经度、纬度 (integer) 1 127.0.0.1:6379\u0026gt; GEOADD china:city 121.47 31.23 shanghai (integer) 1 127.0.0.1:6379\u0026gt; type china:city # 底层由Zset实现 zset ------------------------------------------------------------ # 获取指定城市的经纬度信息 GEOPOS key member [member ...] 127.0.0.1:6379\u0026gt; GEOPOS china:city beijing 1) 1) \u0026#34;116.39999896287918091\u0026#34; 2) \u0026#34;39.90000009167092543\u0026#34; ------------------------------------------------------------- # 获取两地的距离（直线距离） GEODIST key member1 member2 [m|km|ft|mi] # 可指定单位，默认为米 127.0.0.1:6379\u0026gt; GEODIST china:city beijing shanghai km \u0026#34;1067.3788\u0026#34; ------------------------------------------------------------- # 获取范围内的元素 GEORADIUS key longitude latitude radius m|km|ft|mi # 根据指定经纬度和半径获取范围内的元素 127.0.0.1:6379\u0026gt; GEORADIUS china:city 120 30 500 km # 经度、维度、半径 1) \u0026#34;hangzhou\u0026#34; 2) \u0026#34;shanghai\u0026#34; GEORADIUSBYMEMBER key member radius m|km|ft|mi # 根据元素名和半径获取范围内的元素 Hypeloglog（基数统计、即去重后计数）【占用内存很小，最大只需要12KB】（有0.81%错误率）\u0026mdash; 使用伯努利概率分布，根据第一个 1 出现的位置推测有多少基数。 PFADD key element [element ...] # 添加 PFCOUNT key [key ...] # 基数统计 127.0.0.1:6379\u0026gt; pfadd key a a a a l k j h j k l d (integer) 1 127.0.0.1:6379\u0026gt; PFCOUNT key (integer) 6 PFMERGE destkey sourcekey [sourcekey ...] # 合并 Bitmaps（位图） 位存储、只有两种状态的都可以用它存储 SETBIT key offset value # 添加，其中value的值只能是 0 或 1 GETBIT key offset # 查看 BITCOUNT key [start end] # 统计value为 1 的个数 发布订阅 基于频道 基于频道(Channel)的发布/订阅有两个命令分别是 publish 和 subscribe 。\n","keywords":[],"articleBody":"概述 Redis是什么？\nRedis（Remote Dictionary Server )，即远程字典服务！\nRedis能干吗？ —》 数据库、缓存、中间件\n内存存储、持久化（rdb、aof） 效率高，可用于缓存 发布订阅系统 地图信息分析 计时器、计数器 。。。 Redis 通过“Redis序列化协议”（简称“RESP”），实现客户端与服务端之间的连接通信，其底层是通过TCP来完成的。\nLinux安装配置redis 下载并解压redis后，将解压好的包移动到/usr/local/redis中，然后cd /usr/local/redis，依次在该目录下执行make，make test（也可以不执行）和make install。之后将该目录下的redis.conf备份，再vim redis.conf，将daemonize的值从no改为yes。cd /usr/local/bin，执行redis-server ../redis/redis.conf。配置完成。\nredis 是单线程 对Redis来说，执行get、set以及eval等API，都是一个一个的任务，这些任务都会由Redis的线程（单线程）去负责执行，任务要么执行成功，要么执行失败，这就是Redis的命令是原子性的原因。\nredis 6 引入了多线程 redis 5 及之前的版本一直使用的是单线程，多线程是 Redis6.0 推出的一个新特性。 Redis 的核心线程负责网络 IO ，命令处理以及写数据到缓冲，而随着网络硬件的性能提升，单个主线程处理⽹络请求的速度跟不上底层⽹络硬件的速度，导致网络 IO 的处理成为了 Redis 的性能瓶颈。\n而 Redis6.0 就是从单线程处理网络请求到多线程处理，通过多个 IO 线程并⾏处理网络操作提升实例的整体处理性能。需要注意的是对于读写命令，Redis 仍然使⽤单线程来处理，这是因为继续使⽤单线程执行命令操作，就不⽤为了保证 Lua 脚本、事务的原⼦性，额外开发多线程互斥机制了。\nredis 将所有的数据都放在内存中。单线程避免切换上下文，所以快。\n多线程开发中并发访问控制是⼀个难点，需要精细的设计才能处理。如果只是简单地处理，比如简单地采⽤⼀个粗粒度互斥锁，只会出现不理想的结果。即便增加了线程，系统吞吐率也不会随着线程的增加而增加，因为大部分线程还在等待获取访问共享资源的互斥锁。而且，大部分采用多线程开发引入的同步原语保护共享资源的并发访问，也会降低系统代码的易调试性和可维护性。而正是以上这些问题，才让 Redis 采⽤了单线程模式。\n官方解释：因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦)。\n基础知识 redis所有命令不区分大小写\n数据库基本命令 redis默认有16个数据库（0~15），默认使用第0个数据库。数据库之间数据相互隔离\n127.0.0.1:6379\u003e SELECT 3 # 切换数据库 OK 127.0.0.1:6379[3]\u003e DBSIZE # 查看当前数据库大小 (integer) 0 127.0.0.1:6379\u003e FLUSHDB # 清空当前数据库 OK 127.0.0.1:6379\u003e FLUSHALL # 清空所有数据库 OK 127.0.0.1:6379\u003e SHUTDOWN # 关闭redis服务 Redis-key基本命令 127.0.0.1:6379\u003e set age 18 # 添加键值对 OK 127.0.0.1:6379\u003e get name # 通过key获取value \"xunlu\" 127.0.0.1:6379\u003e KEYS * # KEYS + 正则表达式。返回所有符合正则表达式的键 1) \"age\" 2) \"name\" 127.0.0.1:6379\u003e EXISTS name # 判断是否存在指定的key (integer) 1 # 返回1则存在，0则不存在 127.0.0.1:6379\u003e EXPIRE name 10 # 设置键name的有效期为10秒 (integer) 1 127.0.0.1:6379\u003e ttl name # 查看键name的有效时间还剩下多少 (integer) 4 127.0.0.1:6379\u003e MOVE name 1 # 将键值对移动到指定的数据库中 (integer) 1 127.0.0.1:6379\u003e DEL name # 删除键值对 (integer) 1 127.0.0.1:6379\u003e TYPE age # 获取当前键对应值的类型 string 数据类型 五种基本数据类型 String —\u003e 应用：计数器（如访问量，点赞数等） 127.0.0.1:6379\u003e set name xunlu OK 127.0.0.1:6379\u003e APPEND name feilu # 追加字符串，类似StringBuilder的append (integer) 10 # 若追加的键不存在，则新建键值对 127.0.0.1:6379\u003e get name \"xunlufeilu\" ----------------------------------------------- 127.0.0.1:6379\u003e STRLEN name\t# 返回值的长度 (integer) 10 ----------------------------------------------- 127.0.0.1:6379\u003e set views 0 OK 127.0.0.1:6379\u003e INCR views # 每执行一次，值就会加1.（只能作用于integer类型） (integer) 1 127.0.0.1:6379\u003e INCR views (integer) 2 127.0.0.1:6379\u003e DECR views # 每执行一次，值就会减1.（只能作用于integer类型） (integer) 1 127.0.0.1:6379\u003e INCRBY views 10 # 指定增加的步长 (integer) 11 127.0.0.1:6379\u003e DECRBY views 10 # 指定减少的步长 (integer) 1 ----------------------------------------------- 127.0.0.1:6379\u003e set name xunlu OK 127.0.0.1:6379\u003e GETRANGE name 0 2 # 截取部分值（start和end都包括在内） \"xun\" 127.0.0.1:6379\u003e GETRANGE name 0 -1 # == get name \"xunlu\" 127.0.0.1:6379\u003e SETRANGE name 0 gao # 替换部分字符，起始替换位置 + 替换的值 (integer) 5 127.0.0.1:6379\u003e get name \"gaolu\" ----------------------------------------------- # setex(set with expire) 【原子性操作】 # setnx(set if not exist) 【原子性操作】 127.0.0.1:6379\u003e setex name 30 xunlu # 新建键值对，并设置有效期为30秒 OK # 等同于 set name xunlu ex 30 127.0.0.1:6379\u003e setnx gender male # nx表示键不存在时才能正确执行，即只能新建 OK # 等同于 set gender male nx # 常用于分布式锁 127.0.0.1:6379\u003e get gender \"male\" 127.0.0.1:6379\u003e set gender female nx # 此时键gender已经存在，执行失败 (nil) ----------------------------------------------- 127.0.0.1:6379\u003e MSET k1 v1 k2 v1 k3 v1 # 批量创建键值对 OK 127.0.0.1:6379\u003e KEYS * 1) \"k1\" # msetnx 【原子性操作】 2) \"k3\" 3) \"k2\" 127.0.0.1:6379\u003e MGET k1 k2 k3 # 批量获取 1) \"v1\" 2) \"v1\" 3) \"v1\" ------------------------------------------------ 127.0.0.1:6379\u003e set user {id:1,name:xunlu,age:3} # 可以将值设为json字符串，然后通过json解析 OK 127.0.0.1:6379\u003e mset user:name xunlu user:age 18 # redis支持键中存在`:`冒号，亦可用于解析 OK ------------------------------------------------ 127.0.0.1:6379\u003e getset db redis # 先get再set。没有返回nil，再设新值 (nil) 127.0.0.1:6379\u003e getset db redis # 有则返回旧值，再设新值 \"redis\" List（双向链表） 绝大部分的list命令都以l开头，list的名字也可作为key，故有些redis-key的命令也可用 应用：消息队列、栈 # 添加、范围读取 LPUSH key element [element ...] # key为列表的名字，添加到列表的头部 RPUSH key element [element ...] # 添加到列表的尾部 127.0.0.1:6379\u003e LPUSH list mid # 列表名为list，head、mid、tail为元素 (integer) 1 127.0.0.1:6379\u003e LPUSH list head (integer) 2 127.0.0.1:6379\u003e RPUSH list tail (integer) 3 127.0.0.1:6379\u003e LRANGE list 0 -1 1) \"head\" 2) \"mid\" 3) \"tail\" 127.0.0.1:6379\u003e LRANGE list 0 1 # 从头向尾读，没有RRANGE这个命令 1) \"head\" 2) \"mid\" -------------------------------------------------- # 删除、改变list LPOP key [count] # 从头部弹出元素 RPOP key [count] # 从尾部弹出元素 LREM key count element # 根据值移除元素，count表示从多个相同的值中移除的个数 LTRIM key start stop # 将列表截断，只保留[start ~ stop]的值 -------------------------------------------------- # 按下标索引 127.0.0.1:6379\u003e LINDEX list 0 # 获取list的第i个值 \"head\" 127.0.0.1:6379\u003e LINDEX list 1 \"mid\" -------------------------------------------------- # 长度 127.0.0.1:6379\u003e LLEN list # 获取list的长度 (integer) 3 -------------------------------------------------- # 组合命令 RPOPLPUSH source destination # 从容器source的尾部弹出并添加到容器destination的头部 \"tail\" # source和destination自然可以是同一个列表 ------------------------------------------------- # 修改列表中的值 LSET key index element # 修改列表指定下标处的值 127.0.0.1:6379\u003e LSET list 0 prehead OK ------------------------------------------------- # 插值 LINSERT key BEFORE|AFTER pivot element # pivot为列表中已有的元素，往列表中元素的前或后插入元素 Set（无序不重复）（命令都以s打头） # 添加、查看 SADD key member [member ...] # 添加元素（可以批量） 127.0.0.1:6379\u003e SADD set first second third (integer) 3 127.0.0.1:6379\u003e SMEMBERS set # 查看所有元素 1) \"second\" 2) \"third\" 3) \"first\" 127.0.0.1:6379\u003e SISMEMBER set first # 判断是否包含指定元素 (integer) 1 127.0.0.1:6379\u003e SISMEMBER set fifth (integer) 0 127.0.0.1:6379\u003e SCARD set\t# 集合的长度 (integer) 3 ------------------------------------------------- # 移除 SREM key member [member ...] # 删除指定元素（可以批量） SPOP key [count] # 随机删除元素（可以指定个数） SMOVE source destination member # 将指定元素从集合source移动到集合destination ------------------------------------------------- SRANDMEMBER key [count] # 随机返回元素（可以指定个数） ------------------------------------------------- # 集合计算 # 差集 SDIFF set1 set2 # 集合set1中有但set2中没有的元素 # 交集 SINTER set1 set2 # 交 # 并集 SUNION set1 set2 # 并 Hash（命令都以h打头） 相当于map，则变为key-(key-value)，故（更适合对象的存储） # 添加 HSET key field value [field value ...] # 存值，key为hash容器的名字 HMSET key field value [field value ...] # 批量存值 127.0.0.1:6379\u003e HSET hash name xunlu (integer) 1 127.0.0.1:6379\u003e HSET hash age 18 (integer) 1 ------------------------------------------------- # 查看 HGET key field # 指定字段的取值 HMGET key field [field ...] # 批量取值 127.0.0.1:6379\u003e HGET hash name \"xunlu\" 127.0.0.1:6379\u003e HGETALL hash # 查看全部内容 1) \"name\" 2) \"xunlu\" 3) \"age\" 4) \"18\" ------------------------------------------------- # 删除 HDEL key field [field ...] # 删除指定元素（可批量） ------------------------------------------------- # 长度 127.0.0.1:6379\u003e HLEN hash (integer) 2 ------------------------------------------------- # 是否存在 HEXISTS key field # 判断指定字段是否存在 ------------------------------------------------- 127.0.0.1:6379\u003e HKEYS hash # 取全部字段名 1) \"name\" 2) \"age\" 127.0.0.1:6379\u003e HVALS hash # 取全部字段的值 1) \"xunlu\" 2) \"18\" ------------------------------------------------- # 自增、自减 HINCRBY key field increment # field = field + increment （increment为负数即为减） ------------------------------------------------- HSETNX key field value # 和setnx作用类似 Zset（有序集合）【底层为跳表】 # 添加、查看 ZADD key score member [score member ...] # score用于排序 127.0.0.1:6379\u003e ZADD salary 2500 mary 3000 alice 1000 lisa (integer) 3 ZRANGE salary 0 -1 # 返回所有数据 -------------------------------------------------- # 排序 ZRANGE salary 100 0 byscore rev withscores # ZRANGE 后可跟上多个参数来约束比较，如通过score、降序、带上score ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] # 小到大 ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count] # 大到小 127.0.0.1:6379\u003e ZRANGEBYSCORE salary -inf +inf # 返回score在-inf +inf之间元素的排序，小到大 1) \"lisa\" 2) \"mary\" 3) \"alice\" -------------------------------------------------- # 移除 ZREM key member [member ...] -------------------------------------------------- # 长度 127.0.0.1:6379\u003e ZCARD salary # 总个数 (integer) 3 127.0.0.1:6379\u003e zcount salary 2000 3000 # 指定区间个数（score的区间） (integer) 2 三种特殊数据类型 Geospatial 地理位置 【底层由Zset实现、因此可以使用zset的命令，如ZREM等】 # 添加城市及经纬度信息 GEOADD key [NX|XX] [CH] longitude latitude member [longitude latitude member ...] 127.0.0.1:6379\u003e GEOADD china:city 116.40 39.90 beijing # 经度、纬度 (integer) 1 127.0.0.1:6379\u003e GEOADD china:city 121.47 31.23 shanghai (integer) 1 127.0.0.1:6379\u003e type china:city # 底层由Zset实现 zset ------------------------------------------------------------ # 获取指定城市的经纬度信息 GEOPOS key member [member ...] 127.0.0.1:6379\u003e GEOPOS china:city beijing 1) 1) \"116.39999896287918091\" 2) \"39.90000009167092543\" ------------------------------------------------------------- # 获取两地的距离（直线距离） GEODIST key member1 member2 [m|km|ft|mi] # 可指定单位，默认为米 127.0.0.1:6379\u003e GEODIST china:city beijing shanghai km \"1067.3788\" ------------------------------------------------------------- # 获取范围内的元素 GEORADIUS key longitude latitude radius m|km|ft|mi # 根据指定经纬度和半径获取范围内的元素 127.0.0.1:6379\u003e GEORADIUS china:city 120 30 500 km # 经度、维度、半径 1) \"hangzhou\" 2) \"shanghai\" GEORADIUSBYMEMBER key member radius m|km|ft|mi # 根据元素名和半径获取范围内的元素 Hypeloglog（基数统计、即去重后计数）【占用内存很小，最大只需要12KB】（有0.81%错误率）— 使用伯努利概率分布，根据第一个 1 出现的位置推测有多少基数。 PFADD key element [element ...] # 添加 PFCOUNT key [key ...] # 基数统计 127.0.0.1:6379\u003e pfadd key a a a a l k j h j k l d (integer) 1 127.0.0.1:6379\u003e PFCOUNT key (integer) 6 PFMERGE destkey sourcekey [sourcekey ...] # 合并 Bitmaps（位图） 位存储、只有两种状态的都可以用它存储 SETBIT key offset value # 添加，其中value的值只能是 0 或 1 GETBIT key offset # 查看 BITCOUNT key [start end] # 统计value为 1 的个数 发布订阅 基于频道 基于频道(Channel)的发布/订阅有两个命令分别是 publish 和 subscribe 。\n先订阅，再发布；即可以先订阅一个不存在的 channel 先发布，再订阅；则只能收到订阅之后发布的消息。 127.0.0.1:6379\u003e publish work dowork // publish channel message 127.0.0.1:6379\u003e subscribe work // subscribe channel Reading messages... (press Ctrl-C to quit) 1) \"subscribe\" 2) \"work\" 3) (integer) 1 进入订阅状态后消息类型的取值可能是以下3个:\nsubscribe。表示订阅成功的反馈信息。第二个值是订阅成功的频道名称，第三个是当前客户端订阅的频道数量。 message。表示接收到的消息，第二个值表示产生消息的频道名称，第三个值是消息的内容。 unsubscribe。表示成功取消订阅某个频道。第二个值是对应的频道名称，第三个值是当前客户端订阅的频道数量，当此值为0时客户端会退出订阅状态，之后就可以执行其他非\"发布/订阅\"模式的命令了。 基于模式 publish 命令不变，订阅使用 psubscribe 。\n模式即通配符匹配，只能用 psubscribe 订阅时使用，发布时使用通配符会当作普通字符。\n通配符中 ? 表示1个占位符，* 表示任意个占位符(包括0)，?* 表示1个以上占位符。\n底层 底层是通过字典（pubsub_channels）实现的，这个字典就用于保存订阅频道的信息：字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。\n当客户端调用 SUBSCRIBE 命令时， 程序就将客户端和要订阅的频道在 pubsub_channels 字典中关联起来。\n当调用 PUBLISH channel message 命令， 程序首先根据 channel 定位到字典的键， 然后将信息发送给字典值链表中的所有客户端。\n使用 UNSUBSCRIBE 命令可以退订指定的频道， 这个命令执行的是订阅的反操作： 它从 pubsub_channels 字典的给定频道（键）中， 删除关于当前客户端的信息， 这样被退订频道的信息就不会再发送给这个客户端。\n事务 Redis事务的本质是一组命令的集合。事务执行一次执行多个命令。一个事务中的所有命令都会被序列化，在事务执行过程中，会按顺序执行。其他客户端提交的命令请求不会插入到事务队列中执行。 （一次性、顺序性、排他性）\nMULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。 Redis的单条命令保证原子性，但是Redis的事务不保证原子性！\n认为Redis不保证原子性是因为Redis 事务不支持事务回滚机制。\n对于编译时异常：提前检查命令格式，若有错误，则返回错误且整个事务都不执行。 对于运行时异常：错误之前的命令正常执行，错误命令返回错误，错误之后的命令正常执行。 Redis事务没有隔离级别的概念\n因为是单线程操作。\nRedis 不支持持久性\n因为 rdb 和 aof 都是异步执行。\nRedis 支持一致性\n单条命令失败会回滚\nRedis事务执行 开启事务（multi） 命令入队 执行事务 （exec） # 正常执行事务 127.0.0.1:6379\u003e MULTI # 开启事务 OK # 命令入队 127.0.0.1:6379(TX)\u003e set k1 v1 QUEUED 127.0.0.1:6379(TX)\u003e set k2 v2 QUEUED 127.0.0.1:6379(TX)\u003e get k2 QUEUED 127.0.0.1:6379(TX)\u003e set k3 v3 QUEUED 127.0.0.1:6379(TX)\u003e exec # 执行事务 1) OK 2) OK 3) \"v2\" 4) OK ---------------------------------------- # 放弃事务 127.0.0.1:6379\u003e MULTI OK 127.0.0.1:6379(TX)\u003e set k1 v1 QUEUED 127.0.0.1:6379(TX)\u003e set k2 v2 QUEUED 127.0.0.1:6379(TX)\u003e set k4 v4 QUEUED 127.0.0.1:6379(TX)\u003e DISCARD # 放弃事务（所有命令都不执行） OK 127.0.0.1:6379\u003e get k4 (nil) # 说明 set k4 v4 命令并未执行 监控（watch） WATCH命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），整个事务就不会执行。监控一直持续到EXEC命令（事务中的命令是在EXEC之后才执行的，所以在MULTI命令后可以修改WATCH监控的键值）（只要执行了EXEC命令或者DISCARD命令，不论其执行是否成功，都会自动取消所有的监控；因此在事务中修改被监视键时，WATCH已被取消，不生效了）\n乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。\n因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。\n悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。\n因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据\n# 正常执行成功（即在事务执行期间确实没有修改数据） 127.0.0.1:6379\u003e set in 100 OK 127.0.0.1:6379\u003e set out 0 OK 127.0.0.1:6379\u003e WATCH in # 监控 in 对象 OK 127.0.0.1:6379\u003e MULTI OK 127.0.0.1:6379(TX)\u003e INCRBY in -20 QUEUED 127.0.0.1:6379(TX)\u003e INCRBY out 20 QUEUED 127.0.0.1:6379(TX)\u003e EXEC # 事务正常结束，在事务执行期间外部没有修改数据 1) (integer) 80 2) (integer) 20 WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。\n# 在事务执行期间外部了修改数据，则执行失败 127.0.0.1:6379\u003e set in 100 OK 127.0.0.1:6379\u003e set out 0 OK 127.0.0.1:6379\u003e WATCH in # 监控 in 对象 OK 127.0.0.1:6379\u003e MULTI OK 127.0.0.1:6379(TX)\u003e INCRBY in -20 QUEUED 127.0.0.1:6379(TX)\u003e INCRBY out 20 QUEUED ------------------------------------------- # 此处为另外打开一个bash执行的操作 127.0.0.1:6379\u003e set in 200 # 模拟另一个线程修改数据 OK ------------------------------------------- # 返回原bash执行事务 127.0.0.1:6379(TX)\u003e EXEC # WATCH 监控到 in 对象发生改变，执行失败 (nil) UNWATCH 可以取消监视。\nJedis Jedis是Redis官方推荐的java连接开发工具，是java操作redis的中间件。\n导入依赖jedis和fastjson 测试连接 public class TestPing { public static void main(String[] args) { Jedis jedis = new Jedis(\"192.168.202.128\", 6379); // jedis 所有的命令都是之前学习的redis的命令【全部一样】 System.out.println(jedis.ping()); jedis.close(); // 关闭连接 } } 关于事务 public class TestPing { public static void main(String[] args) { Jedis jedis = new Jedis(\"192.168.233.128\", 6379); jedis.flushDB(); Transaction transaction = jedis.multi(); // 开启事务 try { transaction.set(\"name\", \"xunlu\"); transaction.set(\"age\", \"18\"); transaction.incr(\"name\"); // 此处为运行时错误，正常执行其余指令 transaction.exec(); } catch (Exception e) { // 此句是为了在当try块中出现如10/0等java的错误，而非redis的错误时放弃执行事务的。 transaction.discard(); e.printStackTrace(); } System.out.println(jedis.get(\"name\")); jedis.close(); // 关闭连接 } } SpringBoot整合 在SpringBoot 2.x之后，底层由jedis换为了lettuce。\njedis：采用的直连，多个线程操作是不安全的，想要避免不安全需要使用jedis pool连接池。更像 bio模式\nlettuce：采用netty，实例可以在多个线程中共享，不存在不安全发情况，可以减少线程数据。更像 nio模式\n1、 导入依赖\norg.springframework.boot spring-boot-starter-data-redis 2、 配置连接\nspring.redis.host=192.168.233.128 # 配置ip spring.redis.port=6379 # 端口号默认为6379，可以不配 3、 使用介绍\n@Autowired private RedisTemplate\u003c?, ?\u003e redisTemplate; // 注入模板类 @Test void contextLoads() { // 获取连接 (一般很少用) RedisConnection connection = redisTemplate.getConnectionFactory().getConnection(); connection.flushDb(); /* * opsForValue() 操作字符串 * opsForList() 操作List * opsForGeo() 操作Geo * 等等，类似上方对于8中数据类型都可以操作，选定操作对象后，具体方法和redis完全一样 */ redisTemplate.opsForValue().set(\"name\", \"xunlu\"); // 一些基本操作和常用方法都可以直接使用 redisTemplate.multi(); // 开启事务 redisTemplate.keys(); // 查询键 redisTemplate.rename(); // 重命名 } 序列化 由于redis是要存储的，因此redis对象必须实现序列化（实际开发中，所有pojo包下的对象都需要实现序列化）。springboot默认的序列化为JdkSerializationRedisSerializer，该序列化会使中文转义。我们一般使用JSON来序列化。\n// 固定通用的配置，用到时直接复制即可 @Configuration public class RedisConfig { // 编写自己的Template @Bean public RedisTemplate\u003cString, Object\u003e redisTemplate(RedisConnectionFactory redisConnectionFactory) { RedisTemplate\u003cString, Object\u003e template = new RedisTemplate\u003c\u003e(); template.setConnectionFactory(redisConnectionFactory); // json的序列化配置 Jackson2JsonRedisSerializer\u003cObject\u003e jsonRedisSerializer = new Jackson2JsonRedisSerializer\u003c\u003e(Object.class); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance); jsonRedisSerializer.setObjectMapper(objectMapper); // String的序列化配置 StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); template.setKeySerializer(stringRedisSerializer); // key采用string序列化方法 template.setValueSerializer(jsonRedisSerializer); // Value采用json序列化方法 template.setHashKeySerializer(stringRedisSerializer); // HashKey采用string序列化方法 template.setHashValueSerializer(jsonRedisSerializer); // HashValue采用json序列化方法 template.afterPropertiesSet(); return template; } } Redis.conf 解析 redis.conf 解析\nredis的淘汰机制 redis的过期策略\nredis有两种过期策略，定期删除和惰性删除\n定期删除：redis每个100ms随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。 惰性删除：在获取某个key的时候，redis检查一下，如果该key设置了过期时间则判断该过期时间是否已经过期，如果过期了就直接删掉并不返回任何东西。 redis的内存淘汰机制\n当redis内存快耗尽时，redis会启动内存淘汰机制，将部分key清掉以腾出内存。\nredis提供6中数据淘汰策略，可在redis.conf中配置：maxmemory-policy noeviction\nnoeviction：禁止驱逐数据。默认配置都是这个。当内存使用达到阀值的时候，所有引起申请内存的命令都会报错。 volatile-lru：从设置了过期时间的数据集中挑选最近最久未使用的数据淘汰。 volatile-ttl：从已设置了过期时间的数据集中挑选即将要过期的数据淘汰。 volatile-random：从已设置了过期时间的数据集中任意选择数据淘汰。 allkeys-lru：从数据集中挑选最近最久未使用的数据淘汰。 allkeys-random：从数据集中任意选择数据淘汰。 当Redis确定好要驱逐某个键值对后，会删除这个数据，并将这个数据变更消息同步到本地和从机。\nLRU和LFU区别：\nLRU是最近最久未使用，LFU是最近最少使用。\n举例：若页框数量为 3，页面顺序如：1 2 1 2 3 4；则4号页面进入时会发生页面置换。若使用LRU置换的是1；若使用LFU置换的是3\nLRU是从时间上看，最后一次调用到页面置换时刻间隔最久的置换出去；LRU可通过HashMap＋双向链表实现。\nLFU是从使用频次上看，内存中的所有页面中使用频次最少的置换出去；LFU可通过HashMap＋PriorityQueue实现。\n","wordCount":"1606","inLanguage":"en","datePublished":"2022-04-01T17:39:41Z","dateModified":"2022-04-01T17:39:41Z","author":{"@type":"Person","name":"lu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"lu","logo":{"@type":"ImageObject","url":"https://ethereal-lu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="lu (Alt + H)">lu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethereal-lu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ethereal-lu.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Redis基础</h1><div class=post-meta><span title='2022-04-01 17:39:41 +0000 UTC'>2022-04-01</span>&nbsp;·&nbsp;1606 words&nbsp;·&nbsp;lu</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#概述>概述</a></li><li><a href=#linux安装配置redis>Linux安装配置redis</a></li><li><a href=#redis-是单线程>redis 是单线程</a></li><li><a href=#基础知识>基础知识</a></li><li><a href=#数据类型>数据类型</a></li><li><a href=#发布订阅>发布订阅</a></li><li><a href=#事务>事务</a></li><li><a href=#jedis>Jedis</a></li><li><a href=#springboot整合>SpringBoot整合</a></li><li><a href=#redisconf-解析>Redis.conf 解析</a></li><li><a href=#redis的淘汰机制>redis的淘汰机制</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h3 id=概述>概述<a hidden class=anchor aria-hidden=true href=#概述>#</a></h3><p>Redis是什么？</p><p>Redis（Remote Dictionary Server )，即远程字典服务！</p><p>Redis能干吗？ &mdash;》 数据库、缓存、中间件</p><ol><li>内存存储、持久化（rdb、aof）</li><li>效率高，可用于缓存</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器、计数器 。。。</li></ol><p>Redis 通过“Redis序列化协议”（简称“RESP”），实现客户端与服务端之间的连接通信，其底层是通过TCP来完成的。</p><hr><h3 id=linux安装配置redis>Linux安装配置redis<a hidden class=anchor aria-hidden=true href=#linux安装配置redis>#</a></h3><p>下载并解压redis后，将解压好的包移动到<code>/usr/local/redis</code>中，然后<code>cd /usr/local/redis</code>，依次在该目录下执行<code>make</code>，<code>make test</code>（也可以不执行）和<code>make install</code>。之后将该目录下的<code>redis.conf</code>备份，再<code>vim redis.conf</code>，将<code>daemonize</code>的值从no改为yes。<code>cd /usr/local/bin</code>，执行<code>redis-server ../redis/redis.conf</code>。配置完成。</p><hr><h3 id=redis-是单线程>redis 是单线程<a hidden class=anchor aria-hidden=true href=#redis-是单线程>#</a></h3><p>对Redis来说，执行get、set以及eval等API，都是一个一个的任务，这些任务都会由Redis的线程（单线程）去负责执行，任务要么执行成功，要么执行失败，这就是Redis的命令是原子性的原因。</p><h5 id=redis-6-引入了多线程>redis 6 引入了多线程<a hidden class=anchor aria-hidden=true href=#redis-6-引入了多线程>#</a></h5><p>redis 5 及之前的版本一直使用的是单线程，多线程是 Redis6.0 推出的一个新特性。 Redis 的核心线程负责网络 IO ，命令处理以及写数据到缓冲，而随着网络硬件的性能提升，单个主线程处理⽹络请求的速度跟不上底层⽹络硬件的速度，导致网络 IO 的处理成为了 Redis 的性能瓶颈。</p><p>而 Redis6.0 就是从单线程处理网络请求到多线程处理，通过多个 IO 线程并⾏处理网络操作提升实例的整体处理性能。需要注意的是对于读写命令，Redis 仍然使⽤单线程来处理，这是因为继续使⽤单线程执行命令操作，就不⽤为了保证 Lua 脚本、事务的原⼦性，额外开发多线程互斥机制了。</p><p>redis 将所有的数据都放在内存中。单线程避免切换上下文，所以快。</p><p>多线程开发中并发访问控制是⼀个难点，需要精细的设计才能处理。如果只是简单地处理，比如简单地采⽤⼀个粗粒度互斥锁，只会出现不理想的结果。即便增加了线程，系统吞吐率也不会随着线程的增加而增加，因为大部分线程还在等待获取访问共享资源的互斥锁。而且，大部分采用多线程开发引入的同步原语保护共享资源的并发访问，也会降低系统代码的易调试性和可维护性。而正是以上这些问题，才让 Redis 采⽤了单线程模式。</p><p>官方解释：因为Redis是基于内存的操作，CPU不是Redis的瓶颈，<strong>Redis的瓶颈最有可能是机器内存的大小或者网络带宽</strong>。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦)。</p><hr><h3 id=基础知识>基础知识<a hidden class=anchor aria-hidden=true href=#基础知识>#</a></h3><p>redis所有命令不区分大小写</p><h5 id=数据库基本命令>数据库基本命令<a hidden class=anchor aria-hidden=true href=#数据库基本命令>#</a></h5><p>redis默认有16个数据库（0~15），默认使用第0个数据库。数据库之间数据相互隔离</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>127.0.0.1:6379&gt; SELECT <span style=color:#ae81ff>3</span>      <span style=color:#75715e># 切换数据库</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379<span style=color:#f92672>[</span>3<span style=color:#f92672>]</span>&gt; DBSIZE     <span style=color:#75715e># 查看当前数据库大小</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; FLUSHDB       <span style=color:#75715e># 清空当前数据库</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; FLUSHALL      <span style=color:#75715e># 清空所有数据库</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; SHUTDOWN      <span style=color:#75715e># 关闭redis服务</span>
</span></span></code></pre></div><h5 id=redis-key基本命令>Redis-key基本命令<a hidden class=anchor aria-hidden=true href=#redis-key基本命令>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>127.0.0.1:6379&gt; set age <span style=color:#ae81ff>18</span>            <span style=color:#75715e># 添加键值对</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; get name              <span style=color:#75715e># 通过key获取value</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;xunlu&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; KEYS *                <span style=color:#75715e># KEYS + 正则表达式。返回所有符合正则表达式的键</span>
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;age&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;name&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; EXISTS name           <span style=color:#75715e># 判断是否存在指定的key</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>                           <span style=color:#75715e># 返回1则存在，0则不存在</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; EXPIRE name <span style=color:#ae81ff>10</span>        <span style=color:#75715e># 设置键name的有效期为10秒</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; ttl name              <span style=color:#75715e># 查看键name的有效时间还剩下多少</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; MOVE name <span style=color:#ae81ff>1</span>           <span style=color:#75715e># 将键值对移动到指定的数据库中</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; DEL name              <span style=color:#75715e># 删除键值对</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; TYPE age              <span style=color:#75715e># 获取当前键对应值的类型</span>
</span></span><span style=display:flex><span>string
</span></span></code></pre></div><hr><h3 id=数据类型>数据类型<a hidden class=anchor aria-hidden=true href=#数据类型>#</a></h3><h5 id=五种基本数据类型>五种基本数据类型<a hidden class=anchor aria-hidden=true href=#五种基本数据类型>#</a></h5><ul><li>String &mdash;> 应用：计数器（如访问量，点赞数等）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>127.0.0.1:6379&gt; set name xunlu
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; APPEND name feilu              <span style=color:#75715e># 追加字符串，类似StringBuilder的append</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>10</span>                                   <span style=color:#75715e># 若追加的键不存在，则新建键值对</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; get name
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;xunlufeilu&#34;</span>
</span></span><span style=display:flex><span>-----------------------------------------------
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; STRLEN name					 <span style=color:#75715e># 返回值的长度</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>-----------------------------------------------
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; set views <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; INCR views                     <span style=color:#75715e># 每执行一次，值就会加1.（只能作用于integer类型）</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; INCR views
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; DECR views                     <span style=color:#75715e># 每执行一次，值就会减1.（只能作用于integer类型）</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; INCRBY views <span style=color:#ae81ff>10</span>                <span style=color:#75715e># 指定增加的步长</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>11</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; DECRBY views <span style=color:#ae81ff>10</span>                <span style=color:#75715e># 指定减少的步长</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>-----------------------------------------------
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; set name xunlu
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; GETRANGE name <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>2</span>              <span style=color:#75715e># 截取部分值（start和end都包括在内）</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;xun&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; GETRANGE name <span style=color:#ae81ff>0</span> -1             <span style=color:#75715e># == get name</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;xunlu&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; SETRANGE name <span style=color:#ae81ff>0</span> gao            <span style=color:#75715e># 替换部分字符，起始替换位置 + 替换的值</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; get name
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;gaolu&#34;</span>
</span></span><span style=display:flex><span>-----------------------------------------------
</span></span><span style=display:flex><span><span style=color:#75715e># setex(set with expire)   【原子性操作】</span>
</span></span><span style=display:flex><span><span style=color:#75715e># setnx(set if not exist)  【原子性操作】</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; setex name <span style=color:#ae81ff>30</span> xunlu            <span style=color:#75715e># 新建键值对，并设置有效期为30秒</span>
</span></span><span style=display:flex><span>OK   <span style=color:#75715e># 等同于 set name xunlu ex 30</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; setnx gender male              <span style=color:#75715e># nx表示键不存在时才能正确执行，即只能新建</span>
</span></span><span style=display:flex><span>OK   <span style=color:#75715e># 等同于 set gender male nx               # 常用于分布式锁</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; get gender
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;male&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; set gender female nx           <span style=color:#75715e># 此时键gender已经存在，执行失败</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>nil<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>-----------------------------------------------
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; MSET k1 v1 k2 v1 k3 v1         <span style=color:#75715e># 批量创建键值对</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; KEYS *
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;k1&#34;</span>                                        <span style=color:#75715e># msetnx 【原子性操作】</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;k3&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;k2&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; MGET k1 k2 k3                  <span style=color:#75715e># 批量获取 </span>
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;v1&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;v1&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;v1&#34;</span>
</span></span><span style=display:flex><span>------------------------------------------------
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; set user <span style=color:#f92672>{</span>id:1,name:xunlu,age:3<span style=color:#f92672>}</span> <span style=color:#75715e># 可以将值设为json字符串，然后通过json解析</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; mset user:name xunlu user:age <span style=color:#ae81ff>18</span> <span style=color:#75715e># redis支持键中存在`:`冒号，亦可用于解析</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>------------------------------------------------
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; getset db redis                  <span style=color:#75715e># 先get再set。没有返回nil，再设新值</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>nil<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; getset db redis                  <span style=color:#75715e># 有则返回旧值，再设新值</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;redis&#34;</span>
</span></span></code></pre></div><ul><li>List（双向链表）<ul><li>绝大部分的list命令都以l开头，list的名字也可作为key，故有些redis-key的命令也可用</li><li>应用：消息队列、栈</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 添加、范围读取</span>
</span></span><span style=display:flex><span>LPUSH key element <span style=color:#f92672>[</span>element ...<span style=color:#f92672>]</span>                   <span style=color:#75715e># key为列表的名字，添加到列表的头部</span>
</span></span><span style=display:flex><span>RPUSH key element <span style=color:#f92672>[</span>element ...<span style=color:#f92672>]</span>                   <span style=color:#75715e># 添加到列表的尾部                 </span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; LPUSH list mid                    <span style=color:#75715e># 列表名为list，head、mid、tail为元素</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; LPUSH list head
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; RPUSH list tail
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; LRANGE list <span style=color:#ae81ff>0</span> -1
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;head&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;mid&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;tail&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; LRANGE list <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span>                   <span style=color:#75715e># 从头向尾读，没有RRANGE这个命令</span>
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;head&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;mid&#34;</span>
</span></span><span style=display:flex><span>--------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#75715e># 删除、改变list</span>
</span></span><span style=display:flex><span>LPOP key <span style=color:#f92672>[</span>count<span style=color:#f92672>]</span>                                  <span style=color:#75715e># 从头部弹出元素</span>
</span></span><span style=display:flex><span>RPOP key <span style=color:#f92672>[</span>count<span style=color:#f92672>]</span>                                  <span style=color:#75715e># 从尾部弹出元素</span>
</span></span><span style=display:flex><span>LREM key count element                            <span style=color:#75715e># 根据值移除元素，count表示从多个相同的值中移除的个数</span>
</span></span><span style=display:flex><span>LTRIM key start stop                              <span style=color:#75715e># 将列表截断，只保留[start ~ stop]的值</span>
</span></span><span style=display:flex><span>--------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#75715e># 按下标索引</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; LINDEX list <span style=color:#ae81ff>0</span>                     <span style=color:#75715e># 获取list的第i个值</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;head&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; LINDEX list <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;mid&#34;</span>
</span></span><span style=display:flex><span>--------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#75715e># 长度</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; LLEN list                         <span style=color:#75715e># 获取list的长度</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>--------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#75715e># 组合命令</span>
</span></span><span style=display:flex><span>RPOPLPUSH source destination                     <span style=color:#75715e># 从容器source的尾部弹出并添加到容器destination的头部</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;tail&#34;</span>                                           <span style=color:#75715e># source和destination自然可以是同一个列表</span>
</span></span><span style=display:flex><span>-------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#75715e># 修改列表中的值</span>
</span></span><span style=display:flex><span>LSET key index element                           <span style=color:#75715e># 修改列表指定下标处的值</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; LSET list <span style=color:#ae81ff>0</span> prehead
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>-------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#75715e># 插值</span>
</span></span><span style=display:flex><span>LINSERT key BEFORE|AFTER pivot element          <span style=color:#75715e># pivot为列表中已有的元素，往列表中元素的前或后插入元素</span>
</span></span></code></pre></div><ul><li>Set（无序不重复）（命令都以s打头）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 添加、查看</span>
</span></span><span style=display:flex><span>SADD key member <span style=color:#f92672>[</span>member ...<span style=color:#f92672>]</span>                    <span style=color:#75715e># 添加元素（可以批量）</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; SADD set first second third
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; SMEMBERS set                    <span style=color:#75715e># 查看所有元素</span>
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;second&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;third&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;first&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; SISMEMBER set first             <span style=color:#75715e># 判断是否包含指定元素</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; SISMEMBER set fifth
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; SCARD set				       <span style=color:#75715e># 集合的长度</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>-------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#75715e># 移除</span>
</span></span><span style=display:flex><span>SREM key member <span style=color:#f92672>[</span>member ...<span style=color:#f92672>]</span>                    <span style=color:#75715e># 删除指定元素（可以批量）</span>
</span></span><span style=display:flex><span>SPOP key <span style=color:#f92672>[</span>count<span style=color:#f92672>]</span>                                <span style=color:#75715e># 随机删除元素（可以指定个数）</span>
</span></span><span style=display:flex><span>SMOVE source destination member                 <span style=color:#75715e># 将指定元素从集合source移动到集合destination</span>
</span></span><span style=display:flex><span>-------------------------------------------------
</span></span><span style=display:flex><span>SRANDMEMBER key <span style=color:#f92672>[</span>count<span style=color:#f92672>]</span>                         <span style=color:#75715e># 随机返回元素（可以指定个数）</span>
</span></span><span style=display:flex><span>-------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#75715e># 集合计算</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 差集     </span>
</span></span><span style=display:flex><span>SDIFF set1 set2                                 <span style=color:#75715e># 集合set1中有但set2中没有的元素</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 交集</span>
</span></span><span style=display:flex><span>SINTER set1 set2                                <span style=color:#75715e># 交</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 并集</span>
</span></span><span style=display:flex><span>SUNION set1 set2                                <span style=color:#75715e># 并</span>
</span></span></code></pre></div><ul><li>Hash（命令都以h打头）<ul><li>相当于map，则变为key-(key-value)，故（更适合对象的存储）</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 添加</span>
</span></span><span style=display:flex><span>HSET key field value <span style=color:#f92672>[</span>field value ...<span style=color:#f92672>]</span>           <span style=color:#75715e># 存值，key为hash容器的名字</span>
</span></span><span style=display:flex><span>HMSET key field value <span style=color:#f92672>[</span>field value ...<span style=color:#f92672>]</span>          <span style=color:#75715e># 批量存值</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; HSET hash name xunlu
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; HSET hash age <span style=color:#ae81ff>18</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>-------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#75715e># 查看</span>
</span></span><span style=display:flex><span>HGET key field                                   <span style=color:#75715e># 指定字段的取值</span>
</span></span><span style=display:flex><span>HMGET key field <span style=color:#f92672>[</span>field ...<span style=color:#f92672>]</span>                      <span style=color:#75715e># 批量取值</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; HGET hash name
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;xunlu&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; HGETALL hash                     <span style=color:#75715e># 查看全部内容</span>
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;name&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;xunlu&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;age&#34;</span>
</span></span><span style=display:flex><span>4<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;18&#34;</span>
</span></span><span style=display:flex><span>-------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#75715e># 删除</span>
</span></span><span style=display:flex><span>HDEL key field <span style=color:#f92672>[</span>field ...<span style=color:#f92672>]</span>                       <span style=color:#75715e># 删除指定元素（可批量）</span>
</span></span><span style=display:flex><span>-------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#75715e># 长度</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; HLEN hash
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>-------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#75715e># 是否存在</span>
</span></span><span style=display:flex><span>HEXISTS key field                                <span style=color:#75715e># 判断指定字段是否存在</span>
</span></span><span style=display:flex><span>-------------------------------------------------
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; HKEYS hash                       <span style=color:#75715e># 取全部字段名</span>
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;name&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;age&#34;</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; HVALS hash                       <span style=color:#75715e># 取全部字段的值</span>
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;xunlu&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;18&#34;</span>
</span></span><span style=display:flex><span>-------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#75715e># 自增、自减</span>
</span></span><span style=display:flex><span>HINCRBY key field increment                      <span style=color:#75715e># field = field + increment （increment为负数即为减）</span>
</span></span><span style=display:flex><span>-------------------------------------------------
</span></span><span style=display:flex><span>HSETNX key field value                           <span style=color:#75715e># 和setnx作用类似</span>
</span></span></code></pre></div><ul><li>Zset（有序集合）【底层为跳表】</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 添加、查看</span>
</span></span><span style=display:flex><span>ZADD key score member <span style=color:#f92672>[</span>score member ...<span style=color:#f92672>]</span>          <span style=color:#75715e># score用于排序</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; ZADD salary <span style=color:#ae81ff>2500</span> mary <span style=color:#ae81ff>3000</span> alice <span style=color:#ae81ff>1000</span> lisa
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>ZRANGE salary <span style=color:#ae81ff>0</span> -1                                <span style=color:#75715e># 返回所有数据</span>
</span></span><span style=display:flex><span>--------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#75715e># 排序</span>
</span></span><span style=display:flex><span>ZRANGE salary <span style=color:#ae81ff>100</span> <span style=color:#ae81ff>0</span> byscore rev withscores        <span style=color:#75715e># ZRANGE 后可跟上多个参数来约束比较，如通过score、降序、带上score</span>
</span></span><span style=display:flex><span>ZRANGEBYSCORE key min max <span style=color:#f92672>[</span>WITHSCORES<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>LIMIT offset count<span style=color:#f92672>]</span>      <span style=color:#75715e># 小到大</span>
</span></span><span style=display:flex><span>ZREVRANGEBYSCORE key max min <span style=color:#f92672>[</span>WITHSCORES<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>LIMIT offset count<span style=color:#f92672>]</span>   <span style=color:#75715e># 大到小</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf    <span style=color:#75715e># 返回score在-inf +inf之间元素的排序，小到大</span>
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;lisa&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;mary&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;alice&#34;</span>
</span></span><span style=display:flex><span>--------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#75715e># 移除</span>
</span></span><span style=display:flex><span>ZREM key member <span style=color:#f92672>[</span>member ...<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>--------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#75715e># 长度</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; ZCARD salary                      <span style=color:#75715e># 总个数</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; zcount salary <span style=color:#ae81ff>2000</span> <span style=color:#ae81ff>3000</span>           <span style=color:#75715e># 指定区间个数（score的区间）</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><h5 id=三种特殊数据类型>三种特殊数据类型<a hidden class=anchor aria-hidden=true href=#三种特殊数据类型>#</a></h5><ul><li>Geospatial 地理位置 【底层由Zset实现、因此可以使用zset的命令，如ZREM等】</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 添加城市及经纬度信息</span>
</span></span><span style=display:flex><span>GEOADD key <span style=color:#f92672>[</span>NX|XX<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>CH<span style=color:#f92672>]</span> longitude latitude member <span style=color:#f92672>[</span>longitude latitude member ...<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; GEOADD china:city 116.40 39.90 beijing     <span style=color:#75715e># 经度、纬度</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; GEOADD china:city 121.47 31.23 shanghai
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; type china:city                            <span style=color:#75715e># 底层由Zset实现</span>
</span></span><span style=display:flex><span>zset
</span></span><span style=display:flex><span>------------------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#75715e># 获取指定城市的经纬度信息</span>
</span></span><span style=display:flex><span>GEOPOS key member <span style=color:#f92672>[</span>member ...<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; GEOPOS china:city beijing
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> 1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;116.39999896287918091&#34;</span>
</span></span><span style=display:flex><span>   2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;39.90000009167092543&#34;</span>
</span></span><span style=display:flex><span>-------------------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#75715e># 获取两地的距离（直线距离）</span>
</span></span><span style=display:flex><span>GEODIST key member1 member2 <span style=color:#f92672>[</span>m|km|ft|mi<span style=color:#f92672>]</span>                     <span style=color:#75715e># 可指定单位，默认为米</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; GEODIST china:city beijing shanghai km
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;1067.3788&#34;</span>
</span></span><span style=display:flex><span>-------------------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#75715e># 获取范围内的元素</span>
</span></span><span style=display:flex><span>GEORADIUS key longitude latitude radius m|km|ft|mi          <span style=color:#75715e># 根据指定经纬度和半径获取范围内的元素</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; GEORADIUS china:city <span style=color:#ae81ff>120</span> <span style=color:#ae81ff>30</span> <span style=color:#ae81ff>500</span> km          <span style=color:#75715e># 经度、维度、半径</span>
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;hangzhou&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;shanghai&#34;</span>
</span></span><span style=display:flex><span>GEORADIUSBYMEMBER key member radius m|km|ft|mi              <span style=color:#75715e># 根据元素名和半径获取范围内的元素</span>
</span></span></code></pre></div><ul><li>Hypeloglog（基数统计、即去重后计数）【占用内存很小，最大只需要12KB】（有0.81%错误率）&mdash; 使用伯努利概率分布，根据第一个 1 出现的位置推测有多少基数。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>PFADD key element <span style=color:#f92672>[</span>element ...<span style=color:#f92672>]</span>                  <span style=color:#75715e># 添加</span>
</span></span><span style=display:flex><span>PFCOUNT key <span style=color:#f92672>[</span>key ...<span style=color:#f92672>]</span>                            <span style=color:#75715e># 基数统计</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; pfadd key a a a a l k j h j k l d
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; PFCOUNT key
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span>PFMERGE destkey sourcekey <span style=color:#f92672>[</span>sourcekey ...<span style=color:#f92672>]</span>        <span style=color:#75715e># 合并</span>
</span></span></code></pre></div><ul><li>Bitmaps（位图）<ul><li>位存储、只有两种状态的都可以用它存储</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>SETBIT key offset value                          <span style=color:#75715e># 添加，其中value的值只能是 0 或 1</span>
</span></span><span style=display:flex><span>GETBIT key offset                                <span style=color:#75715e># 查看</span>
</span></span><span style=display:flex><span>BITCOUNT key <span style=color:#f92672>[</span>start end<span style=color:#f92672>]</span>                         <span style=color:#75715e># 统计value为 1 的个数</span>
</span></span></code></pre></div><hr><h3 id=发布订阅>发布订阅<a hidden class=anchor aria-hidden=true href=#发布订阅>#</a></h3><h4 id=基于频道>基于频道<a hidden class=anchor aria-hidden=true href=#基于频道>#</a></h4><p>基于频道(Channel)的发布/订阅有两个命令分别是 publish 和 subscribe 。</p><ul><li>先订阅，再发布；即可以先订阅一个不存在的 channel</li><li>先发布，再订阅；则只能收到订阅之后发布的消息。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>127.0.0.1:6379&gt; publish work dowork   // publish channel message
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; subscribe work        // subscribe channel 
</span></span><span style=display:flex><span>Reading messages... <span style=color:#f92672>(</span>press Ctrl-C to quit<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;subscribe&#34;</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;work&#34;</span>
</span></span><span style=display:flex><span>3<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>进入订阅状态后消息类型的取值可能是以下3个:</p><ul><li>subscribe。表示订阅成功的反馈信息。第二个值是订阅成功的频道名称，第三个是当前客户端订阅的频道数量。</li><li>message。表示接收到的消息，第二个值表示产生消息的频道名称，第三个值是消息的内容。</li><li>unsubscribe。表示成功取消订阅某个频道。第二个值是对应的频道名称，第三个值是当前客户端订阅的频道数量，当此值为0时客户端会退出订阅状态，之后就可以执行其他非"发布/订阅"模式的命令了。</li></ul><h4 id=基于模式>基于模式<a hidden class=anchor aria-hidden=true href=#基于模式>#</a></h4><p>publish 命令不变，订阅使用 psubscribe 。</p><p>模式即通配符匹配，只能用 psubscribe 订阅时使用，发布时使用通配符会当作普通字符。</p><p>通配符中 ? 表示1个占位符，* 表示任意个占位符(包括0)，?* 表示1个以上占位符。</p><h4 id=底层>底层<a hidden class=anchor aria-hidden=true href=#底层>#</a></h4><p>底层是通过字典（pubsub_channels）实现的，这个字典就用于保存订阅频道的信息：字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。</p><p>当客户端调用 SUBSCRIBE 命令时， 程序就将客户端和要订阅的频道在 pubsub_channels 字典中关联起来。</p><p>当调用 <code>PUBLISH channel message</code> 命令， 程序首先根据 channel 定位到字典的键， 然后将信息发送给字典值链表中的所有客户端。</p><p>使用 UNSUBSCRIBE 命令可以退订指定的频道， 这个命令执行的是订阅的反操作： 它从 pubsub_channels 字典的给定频道（键）中， 删除关于当前客户端的信息， 这样被退订频道的信息就不会再发送给这个客户端。</p><hr><h3 id=事务>事务<a hidden class=anchor aria-hidden=true href=#事务>#</a></h3><p>Redis事务的本质是一组命令的集合。事务执行一次执行多个命令。一个事务中的所有命令都会被序列化，在事务执行过程中，会按顺序执行。其他客户端提交的命令请求不会插入到事务队列中执行。 （一次性、顺序性、排他性）</p><pre tabindex=0><code>MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。
</code></pre><p><strong>Redis的单条命令保证原子性，但是Redis的事务不保证原子性！</strong></p><p>认为Redis不保证原子性是因为<strong>Redis 事务不支持事务回滚机制</strong>。</p><ul><li>对于编译时异常：提前检查命令格式，若有错误，则返回错误且整个事务都不执行。</li><li>对于运行时异常：错误之前的命令正常执行，错误命令返回错误，错误之后的命令正常执行。</li></ul><p><strong>Redis事务没有隔离级别的概念</strong></p><p>因为是单线程操作。</p><p><strong>Redis 不支持持久性</strong></p><p>因为 rdb 和 aof 都是异步执行。</p><p><strong>Redis 支持一致性</strong></p><p>单条命令失败会回滚</p><h5 id=redis事务执行>Redis事务执行<a hidden class=anchor aria-hidden=true href=#redis事务执行>#</a></h5><ul><li>开启事务（multi）</li><li>命令入队</li><li>执行事务 （exec）</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 正常执行事务</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; MULTI                  <span style=color:#75715e># 开启事务</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span><span style=color:#75715e># 命令入队</span>
</span></span><span style=display:flex><span>127.0.0.1:6379<span style=color:#f92672>(</span>TX<span style=color:#f92672>)</span>&gt; set k1 v1          
</span></span><span style=display:flex><span>QUEUED
</span></span><span style=display:flex><span>127.0.0.1:6379<span style=color:#f92672>(</span>TX<span style=color:#f92672>)</span>&gt; set k2 v2
</span></span><span style=display:flex><span>QUEUED
</span></span><span style=display:flex><span>127.0.0.1:6379<span style=color:#f92672>(</span>TX<span style=color:#f92672>)</span>&gt; get k2
</span></span><span style=display:flex><span>QUEUED
</span></span><span style=display:flex><span>127.0.0.1:6379<span style=color:#f92672>(</span>TX<span style=color:#f92672>)</span>&gt; set k3 v3
</span></span><span style=display:flex><span>QUEUED
</span></span><span style=display:flex><span>127.0.0.1:6379<span style=color:#f92672>(</span>TX<span style=color:#f92672>)</span>&gt; exec               <span style=color:#75715e># 执行事务 </span>
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> OK
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> OK
</span></span><span style=display:flex><span>3<span style=color:#f92672>)</span> <span style=color:#e6db74>&#34;v2&#34;</span>
</span></span><span style=display:flex><span>4<span style=color:#f92672>)</span> OK
</span></span><span style=display:flex><span>----------------------------------------
</span></span><span style=display:flex><span><span style=color:#75715e># 放弃事务</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; MULTI 
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379<span style=color:#f92672>(</span>TX<span style=color:#f92672>)</span>&gt; set k1 v1
</span></span><span style=display:flex><span>QUEUED
</span></span><span style=display:flex><span>127.0.0.1:6379<span style=color:#f92672>(</span>TX<span style=color:#f92672>)</span>&gt; set k2 v2
</span></span><span style=display:flex><span>QUEUED
</span></span><span style=display:flex><span>127.0.0.1:6379<span style=color:#f92672>(</span>TX<span style=color:#f92672>)</span>&gt; set k4 v4
</span></span><span style=display:flex><span>QUEUED
</span></span><span style=display:flex><span>127.0.0.1:6379<span style=color:#f92672>(</span>TX<span style=color:#f92672>)</span>&gt; DISCARD             <span style=color:#75715e># 放弃事务（所有命令都不执行）</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; get k4                  
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>nil<span style=color:#f92672>)</span>                                   <span style=color:#75715e># 说明 set k4 v4 命令并未执行</span>
</span></span></code></pre></div><h5 id=监控watch>监控（watch）<a hidden class=anchor aria-hidden=true href=#监控watch>#</a></h5><p>WATCH命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），整个事务就不会执行。监控一直持续到EXEC命令（事务中的命令是在EXEC之后才执行的，所以在MULTI命令后可以修改WATCH监控的键值）（只要执行了EXEC命令或者DISCARD命令，不论其执行是否成功，都会自动取消所有的监控；因此在事务中修改被监视键时，WATCH已被取消，不生效了）</p><p><strong>乐观锁</strong>：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。</p><p>因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。</p><p><strong>悲观锁</strong>：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。</p><p>因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 正常执行成功（即在事务执行期间确实没有修改数据）</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; set in <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; set out <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; WATCH in                 <span style=color:#75715e># 监控 in 对象</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; MULTI
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379<span style=color:#f92672>(</span>TX<span style=color:#f92672>)</span>&gt; INCRBY in -20
</span></span><span style=display:flex><span>QUEUED
</span></span><span style=display:flex><span>127.0.0.1:6379<span style=color:#f92672>(</span>TX<span style=color:#f92672>)</span>&gt; INCRBY out <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>QUEUED
</span></span><span style=display:flex><span>127.0.0.1:6379<span style=color:#f92672>(</span>TX<span style=color:#f92672>)</span>&gt; EXEC                 <span style=color:#75715e># 事务正常结束，在事务执行期间外部没有修改数据</span>
</span></span><span style=display:flex><span>1<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>2<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>integer<span style=color:#f92672>)</span> <span style=color:#ae81ff>20</span>
</span></span></code></pre></div><p>WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 在事务执行期间外部了修改数据，则执行失败</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; set in <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; set out <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; WATCH in                 <span style=color:#75715e># 监控 in 对象</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; MULTI
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>127.0.0.1:6379<span style=color:#f92672>(</span>TX<span style=color:#f92672>)</span>&gt; INCRBY in -20
</span></span><span style=display:flex><span>QUEUED
</span></span><span style=display:flex><span>127.0.0.1:6379<span style=color:#f92672>(</span>TX<span style=color:#f92672>)</span>&gt; INCRBY out <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>QUEUED
</span></span><span style=display:flex><span>-------------------------------------------
</span></span><span style=display:flex><span><span style=color:#75715e># 此处为另外打开一个bash执行的操作</span>
</span></span><span style=display:flex><span>127.0.0.1:6379&gt; set in <span style=color:#ae81ff>200</span>               <span style=color:#75715e># 模拟另一个线程修改数据</span>
</span></span><span style=display:flex><span>OK
</span></span><span style=display:flex><span>-------------------------------------------
</span></span><span style=display:flex><span><span style=color:#75715e># 返回原bash执行事务</span>
</span></span><span style=display:flex><span>127.0.0.1:6379<span style=color:#f92672>(</span>TX<span style=color:#f92672>)</span>&gt; EXEC                 <span style=color:#75715e># WATCH 监控到 in 对象发生改变，执行失败</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>nil<span style=color:#f92672>)</span>
</span></span></code></pre></div><p><code>UNWATCH</code> 可以取消监视。</p><hr><h3 id=jedis>Jedis<a hidden class=anchor aria-hidden=true href=#jedis>#</a></h3><p>Jedis是Redis官方推荐的java连接开发工具，是java操作redis的中间件。</p><ol><li>导入依赖jedis和fastjson</li><li>测试连接</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestPing</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Jedis jedis <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Jedis(<span style=color:#e6db74>&#34;192.168.202.128&#34;</span>, 6379);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// jedis 所有的命令都是之前学习的redis的命令【全部一样】</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(jedis.<span style=color:#a6e22e>ping</span>());
</span></span><span style=display:flex><span>        jedis.<span style=color:#a6e22e>close</span>();       <span style=color:#75715e>// 关闭连接</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>关于事务</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestPing</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Jedis jedis <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Jedis(<span style=color:#e6db74>&#34;192.168.233.128&#34;</span>, 6379);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        jedis.<span style=color:#a6e22e>flushDB</span>();
</span></span><span style=display:flex><span>        Transaction transaction <span style=color:#f92672>=</span> jedis.<span style=color:#a6e22e>multi</span>();    <span style=color:#75715e>// 开启事务</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            transaction.<span style=color:#a6e22e>set</span>(<span style=color:#e6db74>&#34;name&#34;</span>, <span style=color:#e6db74>&#34;xunlu&#34;</span>);
</span></span><span style=display:flex><span>            transaction.<span style=color:#a6e22e>set</span>(<span style=color:#e6db74>&#34;age&#34;</span>, <span style=color:#e6db74>&#34;18&#34;</span>);
</span></span><span style=display:flex><span>            transaction.<span style=color:#a6e22e>incr</span>(<span style=color:#e6db74>&#34;name&#34;</span>);        <span style=color:#75715e>// 此处为运行时错误，正常执行其余指令</span>
</span></span><span style=display:flex><span>            transaction.<span style=color:#a6e22e>exec</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 此句是为了在当try块中出现如10/0等java的错误，而非redis的错误时放弃执行事务的。</span>
</span></span><span style=display:flex><span>            transaction.<span style=color:#a6e22e>discard</span>();
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(jedis.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;name&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        jedis.<span style=color:#a6e22e>close</span>();       <span style=color:#75715e>// 关闭连接</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=springboot整合>SpringBoot整合<a hidden class=anchor aria-hidden=true href=#springboot整合>#</a></h3><p>在SpringBoot 2.x之后，底层由jedis换为了lettuce。</p><p>jedis：采用的直连，多个线程操作是不安全的，想要避免不安全需要使用jedis pool连接池。更像 bio模式</p><p>lettuce：采用netty，实例可以在多个线程中共享，不存在不安全发情况，可以减少线程数据。更像 nio模式</p><p>1、 导入依赖</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.boot<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>spring-boot-starter-data-redis<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>2、 配置连接</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-properties data-lang=properties><span style=display:flex><span><span style=color:#a6e22e>spring.redis.host</span><span style=color:#f92672>=</span><span style=color:#e6db74>192.168.233.128     # 配置ip</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>spring.redis.port</span><span style=color:#f92672>=</span><span style=color:#e6db74>6379                # 端口号默认为6379，可以不配</span>
</span></span></code></pre></div><p>3、 使用介绍</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> RedisTemplate<span style=color:#f92672>&lt;?</span>, <span style=color:#f92672>?&gt;</span> redisTemplate;   <span style=color:#75715e>// 注入模板类</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>contextLoads</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取连接 (一般很少用)</span>
</span></span><span style=display:flex><span>    RedisConnection connection <span style=color:#f92672>=</span> redisTemplate.<span style=color:#a6e22e>getConnectionFactory</span>().<span style=color:#a6e22e>getConnection</span>();
</span></span><span style=display:flex><span>    connection.<span style=color:#a6e22e>flushDb</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * opsForValue()    操作字符串
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * opsForList()     操作List
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * opsForGeo()      操作Geo
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 等等，类似上方对于8中数据类型都可以操作，选定操作对象后，具体方法和redis完全一样
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    redisTemplate.<span style=color:#a6e22e>opsForValue</span>().<span style=color:#a6e22e>set</span>(<span style=color:#e6db74>&#34;name&#34;</span>, <span style=color:#e6db74>&#34;xunlu&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 一些基本操作和常用方法都可以直接使用</span>
</span></span><span style=display:flex><span>    redisTemplate.<span style=color:#a6e22e>multi</span>();       <span style=color:#75715e>// 开启事务</span>
</span></span><span style=display:flex><span>    redisTemplate.<span style=color:#a6e22e>keys</span>();        <span style=color:#75715e>// 查询键</span>
</span></span><span style=display:flex><span>    redisTemplate.<span style=color:#a6e22e>rename</span>();      <span style=color:#75715e>// 重命名</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=序列化>序列化<a hidden class=anchor aria-hidden=true href=#序列化>#</a></h5><p>由于redis是要存储的，因此redis对象必须实现序列化（实际开发中，所有pojo包下的对象都需要实现序列化）。springboot默认的序列化为<code>JdkSerializationRedisSerializer</code>，该序列化会使中文转义。我们一般使用JSON来序列化。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 固定通用的配置，用到时直接复制即可</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Configuration</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RedisConfig</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 编写自己的Template</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> RedisTemplate<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>redisTemplate</span>(RedisConnectionFactory redisConnectionFactory) {
</span></span><span style=display:flex><span>        RedisTemplate<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span> template <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> RedisTemplate<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        template.<span style=color:#a6e22e>setConnectionFactory</span>(redisConnectionFactory);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// json的序列化配置</span>
</span></span><span style=display:flex><span>        Jackson2JsonRedisSerializer<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> jsonRedisSerializer <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Jackson2JsonRedisSerializer<span style=color:#f92672>&lt;&gt;</span>(Object.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>        ObjectMapper objectMapper <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ObjectMapper();
</span></span><span style=display:flex><span>        objectMapper.<span style=color:#a6e22e>setVisibility</span>(PropertyAccessor.<span style=color:#a6e22e>ALL</span>, JsonAutoDetect.<span style=color:#a6e22e>Visibility</span>.<span style=color:#a6e22e>ANY</span>);
</span></span><span style=display:flex><span>        objectMapper.<span style=color:#a6e22e>activateDefaultTyping</span>(LaissezFaireSubTypeValidator.<span style=color:#a6e22e>instance</span>);
</span></span><span style=display:flex><span>        jsonRedisSerializer.<span style=color:#a6e22e>setObjectMapper</span>(objectMapper);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// String的序列化配置</span>
</span></span><span style=display:flex><span>        StringRedisSerializer stringRedisSerializer <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> StringRedisSerializer();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        template.<span style=color:#a6e22e>setKeySerializer</span>(stringRedisSerializer);     <span style=color:#75715e>// key采用string序列化方法</span>
</span></span><span style=display:flex><span>        template.<span style=color:#a6e22e>setValueSerializer</span>(jsonRedisSerializer);     <span style=color:#75715e>// Value采用json序列化方法</span>
</span></span><span style=display:flex><span>        template.<span style=color:#a6e22e>setHashKeySerializer</span>(stringRedisSerializer); <span style=color:#75715e>// HashKey采用string序列化方法</span>
</span></span><span style=display:flex><span>        template.<span style=color:#a6e22e>setHashValueSerializer</span>(jsonRedisSerializer); <span style=color:#75715e>// HashValue采用json序列化方法</span>
</span></span><span style=display:flex><span>        template.<span style=color:#a6e22e>afterPropertiesSet</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> template;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=redisconf-解析>Redis.conf 解析<a hidden class=anchor aria-hidden=true href=#redisconf-解析>#</a></h3><p><a href=%5BRedis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6redis.conf%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84%E8%A7%A3%E6%9E%90-Redis-PHP%E4%B8%AD%E6%96%87%E7%BD%91%5D(https://www.php.cn/redis/470708.html)>redis.conf 解析</a></p><hr><h3 id=redis的淘汰机制>redis的淘汰机制<a hidden class=anchor aria-hidden=true href=#redis的淘汰机制>#</a></h3><p><strong>redis的过期策略</strong></p><p>redis有两种过期策略，定期删除和惰性删除</p><ul><li><strong>定期删除</strong>：redis每个100ms随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。</li><li><strong>惰性删除</strong>：在获取某个key的时候，redis检查一下，如果该key设置了过期时间则判断该过期时间是否已经过期，如果过期了就直接删掉并不返回任何东西。</li></ul><p><strong>redis的内存淘汰机制</strong></p><p>当redis内存快耗尽时，redis会启动内存淘汰机制，将部分key清掉以腾出内存。</p><p>redis提供6中数据淘汰策略，可在redis.conf中配置：maxmemory-policy noeviction</p><ul><li>noeviction：禁止驱逐数据。默认配置都是这个。当内存使用达到阀值的时候，所有引起申请内存的命令都会报错。</li><li>volatile-lru：从设置了过期时间的数据集中挑选最近最久未使用的数据淘汰。</li><li>volatile-ttl：从已设置了过期时间的数据集中挑选即将要过期的数据淘汰。</li><li>volatile-random：从已设置了过期时间的数据集中任意选择数据淘汰。</li><li>allkeys-lru：从数据集中挑选最近最久未使用的数据淘汰。</li><li>allkeys-random：从数据集中任意选择数据淘汰。</li></ul><p>当Redis确定好要驱逐某个键值对后，会删除这个数据，并将这个数据变更消息同步到本地和从机。</p><p><strong>LRU和LFU区别</strong>：</p><p>LRU是最近最久未使用，LFU是最近最少使用。</p><p>举例：若页框数量为 3，页面顺序如：<code>1 2 1 2 3 4</code>；则4号页面进入时会发生页面置换。若使用LRU置换的是1；若使用LFU置换的是3</p><p>LRU是从时间上看，最后一次调用到页面置换时刻间隔最久的置换出去；LRU可通过HashMap＋双向链表实现。</p><p>LFU是从使用频次上看，内存中的所有页面中使用频次最少的置换出去；LFU可通过HashMap＋PriorityQueue实现。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethereal-lu.github.io/posts/%E9%9D%A2%E7%BB%8F/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/><span class=title>« Prev</span><br><span>面经碎知识汇总</span>
</a><a class=next href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/><span class=title>Next »</span><br><span>MySQL主从复制</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>