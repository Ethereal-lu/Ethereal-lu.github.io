<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Redis底层数据结构 | lu</title>
<meta name=keywords content><meta name=description content="1、压缩列表 - ZipList
Redis是基于内存的nosql，有些场景下为了节省内存redis会用“时间”换“空间”。ziplist就是很典型的例子。
1.1、整体布局
ziplist是为了节省内存空间而设计的由一系列特殊编码的连续内存块组成的顺序存储结构，类似于数组，ziplist在内存中是连续存储的，但是不同于数组，为了节省内存 ziplist的每个元素所占的内存大小可以不同（数组中叫元素，ziplist叫节点entry），每个节点可以用来存储一个整数或者一个字符串。存储整数时是采用整数的二进制而不是字符串形式存储。


zlbytes: ziplist的长度（单位: 字节)，是一个32位无符号整数
zltail: ziplist最后一个节点的偏移量，反向遍历ziplist或者pop尾部节点的时候有用。
zllen: ziplist的节点（entry）个数
entry: 节点
zlend: 值为0xFF，用于标记ziplist的结尾

1.2、节点的布局(entry)
每个节点由三部分组成：prevlength、encoding、data

prevlengh: 记录上一个节点的长度，为了方便反向遍历ziplist
encoding: 当前节点的编码规则
data: 当前节点的值，可以是数字或字符串

为了节省内存，根据上一个节点的长度prevlength 可以将ziplist节点分为两类：


entry的前8位小于254，则这8位就表示上一个节点的长度
entry的前8位等于254，则意味着上一个节点的长度无法用8位表示，后面32位才是真实的prevlength。用254 不用255(11111111)作为分界是因为255是zlend的值，它用于判断ziplist是否到达尾部。

根据当前节点存储的数据类型及长度，可以将ziplist节点分为9类：
当 encoding 的高两位为 11 时表明是整数节点，否则表明是字符串节点。其中整数节点共有 6 中类型（int16、int32、int64等），字符串节点共有3中类型（3种类型的字符串长度不同）。
1.3、复杂度

新建 ZipList：O(1)
查找：O(n)
插入：O(n)
删除：O(n)

1.4、总结

ziplist是为节省内存空间而生的。让每个元素按照实际的内容大小存储，不浪费空间。
ziplist是一个为Redis专门提供的底层数据结构之一，本身可以有序也可以无序。当作为list和hash的底层实现时，节点之间没有顺序；当作为zset的底层实现时，节点之间会按照大小顺序排列。

2、快表 - QuickList
在Redis的早期版本中，存储list列表结构时，如果元素少则使用压缩列表ziplist，否则使用双向链表linkedlist。
但是考虑到链表的每个节点都要有两个指针，prev 和 next 指针要占去 16 个字节 (64bit 系统的指针是 8 个字节)。因此Redis3.2版本开始使用 quicklist 代替了 ziplist 和 linkedlist。
quicklist 实际上是 zipList 和 linkedList 的混合体，它将 linkedList 中的多个节点并为一个 quicklistNode，使用 zipList 来紧凑存储，多个 zipList 之间使用双向指针串接起来。"><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity="sha256-1yREUm1+y9sAFUOKf6iQVKZYv3WdBULi5d+BzpS0k+4=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><meta property="og:site_name" content="lu"><meta property="og:title" content="Redis底层数据结构"><meta property="og:description" content="1、压缩列表 - ZipList Redis是基于内存的nosql，有些场景下为了节省内存redis会用“时间”换“空间”。ziplist就是很典型的例子。
1.1、整体布局 ziplist是为了节省内存空间而设计的由一系列特殊编码的连续内存块组成的顺序存储结构，类似于数组，ziplist在内存中是连续存储的，但是不同于数组，为了节省内存 ziplist的每个元素所占的内存大小可以不同（数组中叫元素，ziplist叫节点entry），每个节点可以用来存储一个整数或者一个字符串。存储整数时是采用整数的二进制而不是字符串形式存储。
zlbytes: ziplist的长度（单位: 字节)，是一个32位无符号整数 zltail: ziplist最后一个节点的偏移量，反向遍历ziplist或者pop尾部节点的时候有用。 zllen: ziplist的节点（entry）个数 entry: 节点 zlend: 值为0xFF，用于标记ziplist的结尾 1.2、节点的布局(entry) 每个节点由三部分组成：prevlength、encoding、data
prevlengh: 记录上一个节点的长度，为了方便反向遍历ziplist encoding: 当前节点的编码规则 data: 当前节点的值，可以是数字或字符串 为了节省内存，根据上一个节点的长度prevlength 可以将ziplist节点分为两类：
entry的前8位小于254，则这8位就表示上一个节点的长度 entry的前8位等于254，则意味着上一个节点的长度无法用8位表示，后面32位才是真实的prevlength。用254 不用255(11111111)作为分界是因为255是zlend的值，它用于判断ziplist是否到达尾部。 根据当前节点存储的数据类型及长度，可以将ziplist节点分为9类：
当 encoding 的高两位为 11 时表明是整数节点，否则表明是字符串节点。其中整数节点共有 6 中类型（int16、int32、int64等），字符串节点共有3中类型（3种类型的字符串长度不同）。
1.3、复杂度 新建 ZipList：O(1) 查找：O(n) 插入：O(n) 删除：O(n) 1.4、总结 ziplist是为节省内存空间而生的。让每个元素按照实际的内容大小存储，不浪费空间。 ziplist是一个为Redis专门提供的底层数据结构之一，本身可以有序也可以无序。当作为list和hash的底层实现时，节点之间没有顺序；当作为zset的底层实现时，节点之间会按照大小顺序排列。 2、快表 - QuickList 在Redis的早期版本中，存储list列表结构时，如果元素少则使用压缩列表ziplist，否则使用双向链表linkedlist。
但是考虑到链表的每个节点都要有两个指针，prev 和 next 指针要占去 16 个字节 (64bit 系统的指针是 8 个字节)。因此Redis3.2版本开始使用 quicklist 代替了 ziplist 和 linkedlist。
quicklist 实际上是 zipList 和 linkedList 的混合体，它将 linkedList 中的多个节点并为一个 quicklistNode，使用 zipList 来紧凑存储，多个 zipList 之间使用双向指针串接起来。"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-01T17:39:41+00:00"><meta property="article:modified_time" content="2022-05-01T17:39:41+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redis底层数据结构"><meta name=twitter:description content="1、压缩列表 - ZipList
Redis是基于内存的nosql，有些场景下为了节省内存redis会用“时间”换“空间”。ziplist就是很典型的例子。
1.1、整体布局
ziplist是为了节省内存空间而设计的由一系列特殊编码的连续内存块组成的顺序存储结构，类似于数组，ziplist在内存中是连续存储的，但是不同于数组，为了节省内存 ziplist的每个元素所占的内存大小可以不同（数组中叫元素，ziplist叫节点entry），每个节点可以用来存储一个整数或者一个字符串。存储整数时是采用整数的二进制而不是字符串形式存储。


zlbytes: ziplist的长度（单位: 字节)，是一个32位无符号整数
zltail: ziplist最后一个节点的偏移量，反向遍历ziplist或者pop尾部节点的时候有用。
zllen: ziplist的节点（entry）个数
entry: 节点
zlend: 值为0xFF，用于标记ziplist的结尾

1.2、节点的布局(entry)
每个节点由三部分组成：prevlength、encoding、data

prevlengh: 记录上一个节点的长度，为了方便反向遍历ziplist
encoding: 当前节点的编码规则
data: 当前节点的值，可以是数字或字符串

为了节省内存，根据上一个节点的长度prevlength 可以将ziplist节点分为两类：


entry的前8位小于254，则这8位就表示上一个节点的长度
entry的前8位等于254，则意味着上一个节点的长度无法用8位表示，后面32位才是真实的prevlength。用254 不用255(11111111)作为分界是因为255是zlend的值，它用于判断ziplist是否到达尾部。

根据当前节点存储的数据类型及长度，可以将ziplist节点分为9类：
当 encoding 的高两位为 11 时表明是整数节点，否则表明是字符串节点。其中整数节点共有 6 中类型（int16、int32、int64等），字符串节点共有3中类型（3种类型的字符串长度不同）。
1.3、复杂度

新建 ZipList：O(1)
查找：O(n)
插入：O(n)
删除：O(n)

1.4、总结

ziplist是为节省内存空间而生的。让每个元素按照实际的内容大小存储，不浪费空间。
ziplist是一个为Redis专门提供的底层数据结构之一，本身可以有序也可以无序。当作为list和hash的底层实现时，节点之间没有顺序；当作为zset的底层实现时，节点之间会按照大小顺序排列。

2、快表 - QuickList
在Redis的早期版本中，存储list列表结构时，如果元素少则使用压缩列表ziplist，否则使用双向链表linkedlist。
但是考虑到链表的每个节点都要有两个指针，prev 和 next 指针要占去 16 个字节 (64bit 系统的指针是 8 个字节)。因此Redis3.2版本开始使用 quicklist 代替了 ziplist 和 linkedlist。
quicklist 实际上是 zipList 和 linkedList 的混合体，它将 linkedList 中的多个节点并为一个 quicklistNode，使用 zipList 来紧凑存储，多个 zipList 之间使用双向指针串接起来。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ethereal-lu.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Redis底层数据结构","item":"https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis底层数据结构","name":"Redis底层数据结构","description":"1、压缩列表 - ZipList Redis是基于内存的nosql，有些场景下为了节省内存redis会用“时间”换“空间”。ziplist就是很典型的例子。\n1.1、整体布局 ziplist是为了节省内存空间而设计的由一系列特殊编码的连续内存块组成的顺序存储结构，类似于数组，ziplist在内存中是连续存储的，但是不同于数组，为了节省内存 ziplist的每个元素所占的内存大小可以不同（数组中叫元素，ziplist叫节点entry），每个节点可以用来存储一个整数或者一个字符串。存储整数时是采用整数的二进制而不是字符串形式存储。\nzlbytes: ziplist的长度（单位: 字节)，是一个32位无符号整数 zltail: ziplist最后一个节点的偏移量，反向遍历ziplist或者pop尾部节点的时候有用。 zllen: ziplist的节点（entry）个数 entry: 节点 zlend: 值为0xFF，用于标记ziplist的结尾 1.2、节点的布局(entry) 每个节点由三部分组成：prevlength、encoding、data\nprevlengh: 记录上一个节点的长度，为了方便反向遍历ziplist encoding: 当前节点的编码规则 data: 当前节点的值，可以是数字或字符串 为了节省内存，根据上一个节点的长度prevlength 可以将ziplist节点分为两类：\nentry的前8位小于254，则这8位就表示上一个节点的长度 entry的前8位等于254，则意味着上一个节点的长度无法用8位表示，后面32位才是真实的prevlength。用254 不用255(11111111)作为分界是因为255是zlend的值，它用于判断ziplist是否到达尾部。 根据当前节点存储的数据类型及长度，可以将ziplist节点分为9类：\n当 encoding 的高两位为 11 时表明是整数节点，否则表明是字符串节点。其中整数节点共有 6 中类型（int16、int32、int64等），字符串节点共有3中类型（3种类型的字符串长度不同）。\n1.3、复杂度 新建 ZipList：O(1) 查找：O(n) 插入：O(n) 删除：O(n) 1.4、总结 ziplist是为节省内存空间而生的。让每个元素按照实际的内容大小存储，不浪费空间。 ziplist是一个为Redis专门提供的底层数据结构之一，本身可以有序也可以无序。当作为list和hash的底层实现时，节点之间没有顺序；当作为zset的底层实现时，节点之间会按照大小顺序排列。 2、快表 - QuickList 在Redis的早期版本中，存储list列表结构时，如果元素少则使用压缩列表ziplist，否则使用双向链表linkedlist。\n但是考虑到链表的每个节点都要有两个指针，prev 和 next 指针要占去 16 个字节 (64bit 系统的指针是 8 个字节)。因此Redis3.2版本开始使用 quicklist 代替了 ziplist 和 linkedlist。\nquicklist 实际上是 zipList 和 linkedList 的混合体，它将 linkedList 中的多个节点并为一个 quicklistNode，使用 zipList 来紧凑存储，多个 zipList 之间使用双向指针串接起来。\n","keywords":[],"articleBody":"1、压缩列表 - ZipList Redis是基于内存的nosql，有些场景下为了节省内存redis会用“时间”换“空间”。ziplist就是很典型的例子。\n1.1、整体布局 ziplist是为了节省内存空间而设计的由一系列特殊编码的连续内存块组成的顺序存储结构，类似于数组，ziplist在内存中是连续存储的，但是不同于数组，为了节省内存 ziplist的每个元素所占的内存大小可以不同（数组中叫元素，ziplist叫节点entry），每个节点可以用来存储一个整数或者一个字符串。存储整数时是采用整数的二进制而不是字符串形式存储。\nzlbytes: ziplist的长度（单位: 字节)，是一个32位无符号整数 zltail: ziplist最后一个节点的偏移量，反向遍历ziplist或者pop尾部节点的时候有用。 zllen: ziplist的节点（entry）个数 entry: 节点 zlend: 值为0xFF，用于标记ziplist的结尾 1.2、节点的布局(entry) 每个节点由三部分组成：prevlength、encoding、data\nprevlengh: 记录上一个节点的长度，为了方便反向遍历ziplist encoding: 当前节点的编码规则 data: 当前节点的值，可以是数字或字符串 为了节省内存，根据上一个节点的长度prevlength 可以将ziplist节点分为两类：\nentry的前8位小于254，则这8位就表示上一个节点的长度 entry的前8位等于254，则意味着上一个节点的长度无法用8位表示，后面32位才是真实的prevlength。用254 不用255(11111111)作为分界是因为255是zlend的值，它用于判断ziplist是否到达尾部。 根据当前节点存储的数据类型及长度，可以将ziplist节点分为9类：\n当 encoding 的高两位为 11 时表明是整数节点，否则表明是字符串节点。其中整数节点共有 6 中类型（int16、int32、int64等），字符串节点共有3中类型（3种类型的字符串长度不同）。\n1.3、复杂度 新建 ZipList：O(1) 查找：O(n) 插入：O(n) 删除：O(n) 1.4、总结 ziplist是为节省内存空间而生的。让每个元素按照实际的内容大小存储，不浪费空间。 ziplist是一个为Redis专门提供的底层数据结构之一，本身可以有序也可以无序。当作为list和hash的底层实现时，节点之间没有顺序；当作为zset的底层实现时，节点之间会按照大小顺序排列。 2、快表 - QuickList 在Redis的早期版本中，存储list列表结构时，如果元素少则使用压缩列表ziplist，否则使用双向链表linkedlist。\n但是考虑到链表的每个节点都要有两个指针，prev 和 next 指针要占去 16 个字节 (64bit 系统的指针是 8 个字节)。因此Redis3.2版本开始使用 quicklist 代替了 ziplist 和 linkedlist。\nquicklist 实际上是 zipList 和 linkedList 的混合体，它将 linkedList 中的多个节点并为一个 quicklistNode，使用 zipList 来紧凑存储，多个 zipList 之间使用双向指针串接起来。\nQuickList 内部默认定义的每个 quicklistNode 中的 ziplist 的大小为 8k 字节。当其大小为 1 时快表退化为链表；当其大小为无穷大时退化为压缩列表。\n3、字典/哈希表 - Dict 本质上就是哈希表, 这个在很多语言中都有。\n和引入红黑树之前的 java 的 HashMap 相同，使用数组加链表的结构。\n一些要点：\n解决哈希冲突：拉链法。\n扩容和收缩：当哈希表保存的键值对太多或者太少时，就要通过 rerehash(重新散列）来对哈希表进行扩展或收缩。具体步骤：\n扩容：创建一个 2 倍大小的新数组；收缩：创建一个一半大小的新数组。 根据哈希值与新数组长度定位新位置并迁移过去。 触发扩容的条件：\n服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。\n服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。\nps：负载因子 = 哈希表已保存节点数量 / 哈希表大小。这里与 java 的 HashMap 不同，它的负载因子不是静态的，而是根据动态变化的负载因子决定是否扩容。\n渐近式 rehash\n什么叫渐进式 rehash？也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。因为数据量大时集中式的扩容会导致长时间STW。所以Redis采用渐进式 rehash,这样在进行渐进式rehash期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行增加操作，一定是在新的哈希表上进行的。\n4、整数集 - IntSet intset是一个由整数组成的有序集合，从而便于进行二分查找，用于快速地判断一个元素是否属于这个集合。它在内存分配上与 ziplist 有些类似，是连续的一整块内存空间，而且对于大整数和小整数（按绝对值）采取了不同的编码，尽量对内存的使用进行了优化。\n下图为整数集合的实际组成，包括三个部分，分别是编码格式encoding，元素数量length，保存元素的数组contents。\n//整数集合结构体 typedef struct intset { uint32_t encoding; //编码格式，有如下三种格式，初始值默认为INTSET_ENC_INT16 uint32_t length; //集合元素数量 int8_t contents[]; //保存元素的数组，元素类型并不一定是ini8_t类型，数组中的元素从小到大排列。 } intset; #define INTSET_ENC_INT16 (sizeof(int16_t)) //16位，2个字节 #define INTSET_ENC_INT32 (sizeof(int32_t)) //32位，4个字节 #define INTSET_ENC_INT64 (sizeof(int64_t)) //64位，8个字节 因为插入的数据的大小是不一样的，为了尽可能的节约内存，所以需要使用不同的类型来存储数据。\n整数集合的升级 contents 数组的长度始终是 encoding * length，初始encoding为 int16，存储 1、2、3、4。但若突然来了一个123456789，此时已超出 int16的编码范围，必须使用int32，因此要升级。\n原始contents 数组的长度为 16 * 4 = 64，升级后的长度为 32 * 5 = 160。在 0~160的空间中从后往前依次将 123456789、4、3、2、1移动到正确位置。从后往前的目的是为了防止值覆盖。\n只支持升级不支持降级，即若此时把123456789删了，encoding 还是 32 位。\n5、跳表 - ZSkipList 跳表是一种可以进行二分查找的有序链表，采用空间换时间的设计思路，跳表在原有的有序链表上面增加了多级索引（例如每两个节点就提取一个节点到上一级），通过索引来实现快速查找。\n5.1、查找数据 原始链表，查找复杂度为O(n)\n每隔两个节点抽取一个出来作为一级索引，查找复杂度为O(n/2) -\u003e O(n)\n继续从一级索引中抽取二级索引，查找复杂度为O(n/2/2)\n最终，最高级索引有两个元素，次高级有4个元素…..一级索引有 n/2 个元素。从最高级索引开始，每级索引能过滤一半的值，因此查找复杂度为O(logN)\n跳表的总高度 h = log2n\n假如原始链表包含 n 个元素，则一级索引元素个数为 n/2、二级索引元素个数为 n/4、三级索引元素个数为 n/8 以此类推。所以，索引节点的总和是：n/2 + n/4 + n/8 + … + 8 + 4 + 2 = n-2，空间复杂度是 O(n)。\n可以每 3 个节点或更多节点抽取一个作为索引，这样能节省空间。\n5.2、插入数据 实际索引不是绝对均匀地每两个节点抽取一个索引，而是每层随机选取 n/2 个节点作为索引，当数据量很大时接近均匀。\n插入数据时，先按查找的方法找到数据应该在的位置，然后插入。再通过 randomLevel()函数确定该节点应该建立几级索引，该函数会确保有 1/2 概率创建一级索引，1/4概率创建二级索引，1/8概率创建三级索引…..等，创建二级索引时同时会创建一级索引，创建三级索引时同时会创建一级和二级索引….等。插入的时间复杂度是 O(logn)\n5.3、删除数据 找到，删掉，若该元素有索引则将其所有索引也删掉。删除元素的时间复杂度为 O(logn)。\n5.4、总结 跳表是可以实现二分查找的有序链表； 每个元素插入时随机生成它的level； 最底层包含所有的元素； 如果一个元素出现在level(x)，那么它肯定出现在x以下的level中； 跳表查询、插入、删除的时间复杂度为O(log n)，与平衡二叉树接近 为什么Redis选择使用跳表而不是红黑树来实现有序集合？\nRedis 中的有序集合(zset) 支持的操作：\n插入一个元素 删除一个元素 查找一个元素 有序输出所有元素 按照范围区间查找元素（比如查找值在 [100, 356] 之间的数据） 其中，前四个操作红黑树也可以完成，且时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。按照区间查找数据时，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了，非常高效。\n本节摘自Skip List–跳表（全网最详细的跳表文章没有之一）\n6、简单动态字符串 - sds sds 中用len 保存了字符串的长度，用一个数组保存了字符串的每个元素。\n与 c 语言的字符串相比有以下好处：\n常数复杂度获取字符串长度：由于保存了 len，复杂度为O(1)，而c语言遍历为O(n) 杜绝缓冲区溢出：sds 在进行字符修改时会根据len判断是否需要扩容，若需要会在扩容后操作，不出现缓冲区溢出问题。 二进制安全：C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而 sds 根据len判断是否结束。 7、redisObject redis 就是 key-value 类型的 nosql 数据库，redis 内部使用一个 dict 来表示这种 key-value 的映射，其中 key 固定使用 sds 存储，但是值却有多种类型，为了在同一个dict内能够存储不同类型的value，这就需要一个通用的数据结构，这个通用的数据结构就是redisObject。\ntypedef struct redisObject { unsigned type:4; // 类型：五大基本类型 unsigned encoding:4; // 编码：integer、hash table、ziplist、skiplist、sds等 unsigned lru:LRU_BITS; // 不重要--- // 当 redis 打开 maxmemory 选项后，会根据 LRU 回收内存 int refcount; // 不重要--- // 引用计数：计数为 0 则回收对象 void *ptr; // 数据指针。指向真正的数据结构，如快表、跳表等。 } robj; 对于同一个type，还可能对应不同的encoding，这说明同样的一个数据类型，可能存在不同的内部表示方式。而不同的内部表示，在内存占用和查找性能上会有所不同。\n如：当type = OBJ_STRING的时候，表示这个robj存储的是一个string，这时encoding可以是下面3种中的一种：\nOBJ_ENCODING_RAW: string采用原生的表示方式，即用sds来表示。 OBJ_ENCODING_INT: string采用数字的表示方式，实际上是一个long型。 OBJ_ENCODING_EMBSTR: string采用一种特殊的嵌入式的sds来表示。 redisObject 作用 五大基本数据类型（string, list, hash, set, sorted set）每个在内部可以有不同的实现方式（dict, sds, ziplist, quicklist, skiplist等），redisObject 将这两者对应起来，是联结两个层面数据结构的桥梁。 为多种数据类型提供一种统一的表示方式。 允许同一类型的数据采用不同的内部表示，从而在某些情况下尽量节省内存。 8、基本类型底层 8.1、String sds 或 long。\nString的内部存储结构一般是sds（Simple Dynamic String，可以动态扩展内存），但是如果一个String类型的value的值是数字，那么Redis内部会把它转成long类型来存储，从而减少内存的使用。\n在对string进行incr, decr等操作的时候，如果它内部是OBJ_ENCODING_INT编码，那么可以直接进行加减操作；如果它内部是OBJ_ENCODING_RAW或OBJ_ENCODING_EMBSTR编码，那么Redis会先试图把sds存储的字符串转成long型，如果能转成功，再进行加减操作。 对一个内部表示成long型的string执行append, setbit, getrange这些命令，针对的仍然是string的值（即十进制表示的字符串），而不是针对内部表示的long型进行操作。 String robj的编码与解码过程\nOBJ_STRING类型的字符串对象的编码和解码过程在Redis里非常重要，应用广泛。\n当我们执行Redis的set命令的时候，Redis首先将接收到的value值（string类型）表示成一个type = OBJ_STRING并且encoding = OBJ_ENCODING_RAW的robj对象，然后在存入内部存储之前先执行一个编码过程，试图将它表示成另一种更节省内存的encoding方式。\n当我们需要获取字符串的值，比如执行get命令的时候，我们需要执行与前面讲的编码过程相反的操作——解码。\n8.2、Hash 压缩列表ziplist 或者 字典dict。\n当Hash中数据项比较少的情况下，Hash底层才用压缩列表ziplist进行存储数据，随着数据的增加，底层的ziplist就可能会转成dict。\n8.3、List quicklist\n8.4、Set 有序整数集合intset 或者 字典dict\n当存储的数据同时满足下面这样两个条件的时候，Redis 就采用整数集合intset来实现set这种数据类型：\n存储的数据都是整数 存储的数据元素个数小于512个 当不能同时满足这两个条件的时候，Redis 就使用dict来存储集合中的数据\n8.5、Sorted Set 压缩列表ziplist 或者 zset\n当存储的数据同时满足下面这两个条件的时候，Redis就使用压缩列表 ziplist\n集合中每个数据的大小都要小于 64 字节 元素个数要小于 128 个 当不能同时满足这两个条件的时候，Redis 就使用zset来实现sorted set，这个zset包含一个dict + 一个skiplist。skiplist用来查询分数，dict用来查询数据到分数(score)的对应关系。\n","wordCount":"427","inLanguage":"en","datePublished":"2022-05-01T17:39:41Z","dateModified":"2022-05-01T17:39:41Z","author":{"@type":"Person","name":"lu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},"publisher":{"@type":"Organization","name":"lu","logo":{"@type":"ImageObject","url":"https://ethereal-lu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="lu (Alt + H)">lu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethereal-lu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ethereal-lu.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Redis底层数据结构</h1><div class=post-meta><span title='2022-05-01 17:39:41 +0000 UTC'>2022-05-01</span>&nbsp;·&nbsp;427 words&nbsp;·&nbsp;lu</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1压缩列表---ziplist>1、压缩列表 - ZipList</a><ul><li><a href=#11整体布局>1.1、整体布局</a></li><li><a href=#12节点的布局entry>1.2、节点的布局(entry)</a></li><li><a href=#13复杂度>1.3、复杂度</a></li><li><a href=#14总结>1.4、总结</a></li></ul></li><li><a href=#2快表---quicklist>2、快表 - QuickList</a></li><li><a href=#3字典哈希表---dict>3、字典/哈希表 - Dict</a></li><li><a href=#4整数集---intset>4、整数集 - IntSet</a><ul><li><a href=#整数集合的升级>整数集合的升级</a></li></ul></li><li><a href=#5跳表---zskiplist>5、跳表 - ZSkipList</a><ul><li><a href=#51查找数据>5.1、查找数据</a></li><li><a href=#52插入数据>5.2、插入数据</a></li><li><a href=#53删除数据>5.3、删除数据</a></li><li><a href=#54总结>5.4、总结</a></li></ul></li><li><a href=#6简单动态字符串---sds>6、简单动态字符串 - sds</a></li><li><a href=#7redisobject>7、redisObject</a><ul><li><a href=#redisobject-作用>redisObject 作用</a></li></ul></li><li><a href=#8基本类型底层>8、基本类型底层</a><ul><li><a href=#81string>8.1、String</a></li><li><a href=#82hash>8.2、Hash</a></li><li><a href=#83list>8.3、List</a></li><li><a href=#84set>8.4、Set</a></li><li><a href=#85sorted-set>8.5、Sorted Set</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=1压缩列表---ziplist>1、压缩列表 - ZipList<a hidden class=anchor aria-hidden=true href=#1压缩列表---ziplist>#</a></h2><p>Redis是基于内存的nosql，有些场景下为了节省内存redis会用“时间”换“空间”。ziplist就是很典型的例子。</p><h3 id=11整体布局>1.1、整体布局<a hidden class=anchor aria-hidden=true href=#11整体布局>#</a></h3><p>ziplist是为了<strong>节省内存空间</strong>而设计的由一系列特殊编码的<strong>连续内存块</strong>组成的<strong>顺序存储</strong>结构，类似于数组，ziplist在内存中是连续存储的，但是不同于数组，为了节省内存 ziplist的每个元素所占的内存大小可以不同（数组中叫元素，ziplist叫节点<strong>entry</strong>），每个节点可以用来存储一个整数或者一个字符串。存储整数时是采用整数的二进制而不是字符串形式存储。</p><p><img alt=ziplist内存布局 loading=lazy src=/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ziplist%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png></p><ul><li>zlbytes: ziplist的长度（单位: 字节)，是一个32位无符号整数</li><li>zltail: ziplist最后一个节点的偏移量，反向遍历ziplist或者pop尾部节点的时候有用。</li><li>zllen: ziplist的节点（entry）个数</li><li>entry: 节点</li><li>zlend: 值为0xFF，用于标记ziplist的结尾</li></ul><h3 id=12节点的布局entry>1.2、节点的布局(entry)<a hidden class=anchor aria-hidden=true href=#12节点的布局entry>#</a></h3><p>每个节点由三部分组成：prevlength、encoding、data</p><ul><li>prevlengh: 记录上一个节点的长度，为了方便反向遍历ziplist</li><li>encoding: 当前节点的编码规则</li><li>data: 当前节点的值，可以是数字或字符串</li></ul><p>为了节省内存，根据上一个节点的长度prevlength 可以将ziplist节点分为两类：</p><p><img alt=entry布局 loading=lazy src=/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/entry%E5%B8%83%E5%B1%80.png></p><ul><li>entry的前8位小于254，则这8位就表示上一个节点的长度</li><li>entry的前8位等于254，则意味着上一个节点的长度无法用8位表示，后面32位才是真实的prevlength。用254 不用255(11111111)作为分界是因为255是zlend的值，它用于判断ziplist是否到达尾部。</li></ul><p>根据当前节点存储的数据类型及长度，可以将ziplist节点分为9类：</p><p>当 encoding 的高两位为 11 时表明是整数节点，否则表明是字符串节点。其中整数节点共有 6 中类型（int16、int32、int64等），字符串节点共有3中类型（3种类型的字符串长度不同）。</p><h3 id=13复杂度>1.3、复杂度<a hidden class=anchor aria-hidden=true href=#13复杂度>#</a></h3><ul><li>新建 ZipList：O(1)</li><li>查找：O(n)</li><li>插入：O(n)</li><li>删除：O(n)</li></ul><h3 id=14总结>1.4、总结<a hidden class=anchor aria-hidden=true href=#14总结>#</a></h3><ul><li>ziplist是为节省内存空间而生的。让每个元素按照实际的内容大小存储，不浪费空间。</li><li>ziplist是一个为Redis专门提供的底层数据结构之一，本身可以有序也可以无序。当作为<strong>list</strong>和<strong>hash</strong>的底层实现时，节点之间没有顺序；当作为<strong>zset</strong>的底层实现时，节点之间会按照大小顺序排列。</li></ul><h2 id=2快表---quicklist>2、快表 - QuickList<a hidden class=anchor aria-hidden=true href=#2快表---quicklist>#</a></h2><p>在Redis的早期版本中，存储list列表结构时，如果元素少则使用压缩列表ziplist，否则使用双向链表linkedlist。</p><p>但是考虑到链表的每个节点都要有两个指针，prev 和 next 指针要占去 16 个字节 (64bit 系统的指针是 8 个字节)。因此Redis3.2版本开始使用 quicklist 代替了 ziplist 和 linkedlist。</p><p>quicklist 实际上是 zipList 和 linkedList 的混合体，它将 linkedList 中的多个节点并为一个 quicklistNode，使用 zipList 来紧凑存储，多个 zipList 之间使用双向指针串接起来。</p><p><img alt=quicklist布局 loading=lazy src=/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/quicklist%E5%B8%83%E5%B1%80.png></p><p>QuickList 内部默认定义的每个 quicklistNode 中的 ziplist 的大小为 8k 字节。当其大小为 1 时快表退化为链表；当其大小为无穷大时退化为压缩列表。</p><h2 id=3字典哈希表---dict>3、字典/哈希表 - Dict<a hidden class=anchor aria-hidden=true href=#3字典哈希表---dict>#</a></h2><p>本质上就是哈希表, 这个在很多语言中都有。</p><p>和引入红黑树之前的 java 的 HashMap 相同，使用数组加链表的结构。</p><p>一些要点：</p><ul><li><p><strong>解决哈希冲突</strong>：拉链法。</p></li><li><p><strong>扩容和收缩</strong>：当哈希表保存的键值对太多或者太少时，就要通过 rerehash(重新散列）来对哈希表进行扩展或收缩。具体步骤：</p><ol><li>扩容：创建一个 2 倍大小的新数组；收缩：创建一个一半大小的新数组。</li><li>根据哈希值与新数组长度定位新位置并迁移过去。</li></ol></li><li><p><strong>触发扩容的条件</strong>：</p><ul><li><p>服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。</p></li><li><p>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。</p></li></ul><p>ps：负载因子 = 哈希表已保存节点数量 / 哈希表大小。这里与 java 的 HashMap 不同，它的负载因子不是静态的，而是根据动态变化的负载因子决定是否扩容。</p></li><li><p><strong>渐近式 rehash</strong></p><p>什么叫渐进式 rehash？也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。因为数据量大时集中式的扩容会导致长时间STW。所以Redis采用渐进式 rehash,这样在进行渐进式rehash期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行增加操作，一定是在新的哈希表上进行的。</p></li></ul><h2 id=4整数集---intset>4、整数集 - IntSet<a hidden class=anchor aria-hidden=true href=#4整数集---intset>#</a></h2><p>intset是一个由整数组成的有序集合，从而便于进行二分查找，用于快速地判断一个元素是否属于这个集合。它在内存分配上与 ziplist 有些类似，是连续的一整块内存空间，而且对于大整数和小整数（按绝对值）采取了不同的编码，尽量对内存的使用进行了优化。</p><p>下图为整数集合的实际组成，包括三个部分，分别是编码格式encoding，元素数量length，保存元素的数组contents。</p><p><img alt=intset布局 loading=lazy src=/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/intset%E5%B8%83%E5%B1%80.png></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>//整数集合结构体
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> intset {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> encoding;  <span style=color:#75715e>//编码格式，有如下三种格式，初始值默认为INTSET_ENC_INT16
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint32_t</span> length;    <span style=color:#75715e>//集合元素数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int8_t</span> contents[];  <span style=color:#75715e>//保存元素的数组，元素类型并不一定是ini8_t类型，数组中的元素从小到大排列。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} intset;               
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define INTSET_ENC_INT16 (sizeof(int16_t))   </span><span style=color:#75715e>//16位，2个字节
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define INTSET_ENC_INT32 (sizeof(int32_t))   </span><span style=color:#75715e>//32位，4个字节
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define INTSET_ENC_INT64 (sizeof(int64_t))   </span><span style=color:#75715e>//64位，8个字节
</span></span></span></code></pre></div><p>因为插入的数据的大小是不一样的，为了尽可能的<strong>节约内存</strong>，所以需要使用不同的类型来存储数据。</p><h3 id=整数集合的升级>整数集合的升级<a hidden class=anchor aria-hidden=true href=#整数集合的升级>#</a></h3><p><code>contents</code> 数组的长度始终是 <code>encoding * length</code>，初始<code>encoding</code>为 <code>int16</code>，存储 1、2、3、4。但若突然来了一个123456789，此时已超出 <code>int16</code>的编码范围，必须使用<code>int32</code>，因此要升级。</p><p>原始<code>contents</code> 数组的长度为 16 * 4 = 64，升级后的长度为 32 * 5 = 160。在 0~160的空间中从后往前依次将 123456789、4、3、2、1移动到正确位置。从后往前的目的是为了防止值覆盖。</p><p>只支持升级不支持降级，即若此时把123456789删了，encoding 还是 32 位。</p><h2 id=5跳表---zskiplist>5、跳表 - ZSkipList<a hidden class=anchor aria-hidden=true href=#5跳表---zskiplist>#</a></h2><p>跳表是一种可以进行二分查找的有序链表，采用空间换时间的设计思路，跳表在原有的有序链表上面增加了多级索引（例如每两个节点就提取一个节点到上一级），通过索引来实现快速查找。</p><h3 id=51查找数据>5.1、查找数据<a hidden class=anchor aria-hidden=true href=#51查找数据>#</a></h3><p>原始链表，查找复杂度为O(n)</p><p><img alt=跳表_原始链表 loading=lazy src=/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A8_%E5%8E%9F%E5%A7%8B%E9%93%BE%E8%A1%A8.jpeg></p><p>每隔两个节点抽取一个出来作为一级索引，查找复杂度为O(n/2) -> O(n)</p><p><img alt=跳表_一级索引 loading=lazy src=/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A8_%E4%B8%80%E7%BA%A7%E7%B4%A2%E5%BC%95.jpeg></p><p>继续从一级索引中抽取二级索引，查找复杂度为O(n/2/2)</p><p><img alt=跳表_二级索引 loading=lazy src=/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A8_%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.jpeg></p><p>最终，最高级索引有两个元素，次高级有4个元素&mldr;..一级索引有 n/2 个元素。从最高级索引开始，每级索引能过滤一半的值，因此查找复杂度为O(logN)</p><p><img alt=跳表_完整索引 loading=lazy src=/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A8_%E5%AE%8C%E6%95%B4%E7%B4%A2%E5%BC%95.png></p><p>跳表的总高度 h = log2n</p><p>假如原始链表包含 n 个元素，则一级索引元素个数为 n/2、二级索引元素个数为 n/4、三级索引元素个数为 n/8 以此类推。所以，索引节点的总和是：n/2 + n/4 + n/8 + … + 8 + 4 + 2 = n-2，<strong>空间复杂度是 O(n)</strong>。</p><p>可以每 3 个节点或更多节点抽取一个作为索引，这样能节省空间。</p><h3 id=52插入数据>5.2、插入数据<a hidden class=anchor aria-hidden=true href=#52插入数据>#</a></h3><p>实际索引不是绝对均匀地每两个节点抽取一个索引，而是每层随机选取 n/2 个节点作为索引，当数据量很大时接近均匀。</p><p>插入数据时，先按查找的方法找到数据应该在的位置，然后插入。再通过 <code>randomLevel()</code>函数确定该节点应该建立几级索引，该函数会确保有 1/2 概率创建一级索引，1/4概率创建二级索引，1/8概率创建三级索引&mldr;..等，创建二级索引时同时会创建一级索引，创建三级索引时同时会创建一级和二级索引&mldr;.等。插入的时间复杂度是 O(logn)</p><h3 id=53删除数据>5.3、删除数据<a hidden class=anchor aria-hidden=true href=#53删除数据>#</a></h3><p>找到，删掉，若该元素有索引则将其所有索引也删掉。删除元素的时间复杂度为 O(logn)。</p><h3 id=54总结>5.4、总结<a hidden class=anchor aria-hidden=true href=#54总结>#</a></h3><ul><li>跳表是可以实现二分查找的有序链表；</li><li>每个元素插入时随机生成它的level；</li><li>最底层包含所有的元素；</li><li>如果一个元素出现在level(x)，那么它肯定出现在x以下的level中；</li><li>跳表查询、插入、删除的时间复杂度为O(log n)，与平衡二叉树接近</li></ul><p><strong>为什么Redis选择使用跳表而不是红黑树来实现有序集合？</strong></p><p>Redis 中的有序集合(zset) 支持的操作：</p><ol><li>插入一个元素</li><li>删除一个元素</li><li>查找一个元素</li><li>有序输出所有元素</li><li>按照范围区间查找元素（比如查找值在 [100, 356] 之间的数据）</li></ol><p>其中，前四个操作红黑树也可以完成，且时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。按照区间查找数据时，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了，非常高效。</p><p>本节摘自<a href=https://www.jianshu.com/p/9d8296562806>Skip List&ndash;跳表（全网最详细的跳表文章没有之一）</a></p><h2 id=6简单动态字符串---sds>6、简单动态字符串 - sds<a hidden class=anchor aria-hidden=true href=#6简单动态字符串---sds>#</a></h2><p>sds 中用<code>len</code> 保存了字符串的长度，用一个数组保存了字符串的每个元素。</p><p>与 c 语言的字符串相比有以下好处：</p><ul><li>常数复杂度获取字符串长度：由于保存了 len，复杂度为O(1)，而c语言遍历为O(n)</li><li>杜绝缓冲区溢出：sds 在进行字符修改时会根据len判断是否需要扩容，若需要会在扩容后操作，不出现缓冲区溢出问题。</li><li>二进制安全：C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而 sds 根据len判断是否结束。</li></ul><h2 id=7redisobject>7、redisObject<a hidden class=anchor aria-hidden=true href=#7redisobject>#</a></h2><p>redis 就是 key-value 类型的 nosql 数据库，redis 内部使用一个 dict 来表示这种 key-value 的映射，其中 key 固定使用 sds 存储，但是值却有多种类型，为了在同一个dict内能够存储不同类型的value，这就需要一个通用的数据结构，这个通用的数据结构就是redisObject。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> redisObject {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> type:<span style=color:#ae81ff>4</span>;           <span style=color:#75715e>// 类型：五大基本类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>unsigned</span> encoding:<span style=color:#ae81ff>4</span>;       <span style=color:#75715e>// 编码：integer、hash table、ziplist、skiplist、sds等
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>unsigned</span> lru:LRU_BITS;     <span style=color:#75715e>// 不重要--- // 当 redis 打开 maxmemory 选项后，会根据 LRU 回收内存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> refcount;              <span style=color:#75715e>// 不重要--- // 引用计数：计数为 0 则回收对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr;                 <span style=color:#75715e>// 数据指针。指向真正的数据结构，如快表、跳表等。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} robj;
</span></span></code></pre></div><p>对于同一个type，还可能对应不同的encoding，这说明同样的一个数据类型，可能存在不同的内部表示方式。而不同的内部表示，在内存占用和查找性能上会有所不同。</p><p>如：当type = OBJ_STRING的时候，表示这个robj存储的是一个string，这时encoding可以是下面3种中的一种：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>OBJ_ENCODING_RAW: string采用原生的表示方式<span style=color:#960050;background-color:#1e0010>，即用</span>sds来表示<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>OBJ_ENCODING_INT: string采用数字的表示方式<span style=color:#960050;background-color:#1e0010>，实际上是一个</span>long型<span style=color:#960050;background-color:#1e0010>。</span>
</span></span><span style=display:flex><span>OBJ_ENCODING_EMBSTR: string采用一种特殊的嵌入式的sds来表示<span style=color:#960050;background-color:#1e0010>。</span>
</span></span></code></pre></div><h3 id=redisobject-作用>redisObject 作用<a hidden class=anchor aria-hidden=true href=#redisobject-作用>#</a></h3><ul><li>五大基本数据类型（string, list, hash, set, sorted set）每个在内部可以有不同的实现方式（dict, sds, ziplist, quicklist, skiplist等），redisObject 将这两者对应起来，是联结两个层面数据结构的桥梁。</li><li>为多种数据类型提供一种统一的表示方式。</li><li>允许同一类型的数据采用不同的内部表示，从而在某些情况下尽量节省内存。</li></ul><h2 id=8基本类型底层>8、基本类型底层<a hidden class=anchor aria-hidden=true href=#8基本类型底层>#</a></h2><h3 id=81string>8.1、String<a hidden class=anchor aria-hidden=true href=#81string>#</a></h3><p>sds 或 long。</p><p>String的内部存储结构一般是sds（Simple Dynamic String，可以动态扩展内存），但是如果一个String类型的value的值是数字，那么Redis内部会把它转成long类型来存储，从而减少内存的使用。</p><ul><li>在对string进行incr, decr等操作的时候，如果它内部是OBJ_ENCODING_INT编码，那么可以直接进行加减操作；如果它内部是OBJ_ENCODING_RAW或OBJ_ENCODING_EMBSTR编码，那么Redis会先试图把sds存储的字符串转成long型，如果能转成功，再进行加减操作。</li><li>对一个内部表示成long型的string执行append, setbit, getrange这些命令，针对的仍然是string的值（即十进制表示的字符串），而不是针对内部表示的long型进行操作。</li></ul><p><strong>String robj的编码与解码过程</strong></p><p>OBJ_STRING类型的字符串对象的编码和解码过程在Redis里非常重要，应用广泛。</p><p>当我们执行Redis的set命令的时候，Redis首先将接收到的value值（string类型）表示成一个<code>type = OBJ_STRING</code>并且<code>encoding = OBJ_ENCODING_RAW</code>的robj对象，然后在存入内部存储之前先执行一个编码过程，试图将它表示成另一种更节省内存的encoding方式。</p><p>当我们需要获取字符串的值，比如执行get命令的时候，我们需要执行与前面讲的编码过程相反的操作——解码。</p><h3 id=82hash>8.2、Hash<a hidden class=anchor aria-hidden=true href=#82hash>#</a></h3><p>压缩列表ziplist 或者 字典dict。</p><p>当Hash中数据项比较少的情况下，Hash底层才用压缩列表ziplist进行存储数据，随着数据的增加，底层的ziplist就可能会转成dict。</p><h3 id=83list>8.3、List<a hidden class=anchor aria-hidden=true href=#83list>#</a></h3><p>quicklist</p><h3 id=84set>8.4、Set<a hidden class=anchor aria-hidden=true href=#84set>#</a></h3><p>有序整数集合intset 或者 字典dict</p><p>当存储的数据同时满足下面这样两个条件的时候，Redis 就采用整数集合intset来实现set这种数据类型：</p><ul><li>存储的数据都是整数</li><li>存储的数据元素个数小于512个</li></ul><p>当不能同时满足这两个条件的时候，Redis 就使用dict来存储集合中的数据</p><h3 id=85sorted-set>8.5、Sorted Set<a hidden class=anchor aria-hidden=true href=#85sorted-set>#</a></h3><p>压缩列表ziplist 或者 zset</p><p>当存储的数据同时满足下面这两个条件的时候，Redis就使用压缩列表 ziplist</p><ul><li>集合中每个数据的大小都要小于 64 字节</li><li>元素个数要小于 128 个</li></ul><p>当不能同时满足这两个条件的时候，Redis 就使用zset来实现sorted set，这个zset包含一个dict + 一个skiplist。skiplist用来查询分数，dict用来查询数据到分数(score)的对应关系。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6/><span class=title>« Prev</span><br><span>Redis哨兵机制</span>
</a><a class=next href=https://ethereal-lu.github.io/posts/linux/linux%E5%9F%BA%E7%A1%80/><span class=title>Next »</span><br><span>Linux基础</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>