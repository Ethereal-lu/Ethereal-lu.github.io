<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>事务实现原理 | lu</title>
<meta name=keywords content><meta name=description content="MySQL 默认开启事务自动提交模式，即除非显式的开启事务（BEGIN 或 START TRANSACTION），否则每条 SOL 语句都会被当做一个单独的事务自动执行。
在 MySQL 中，可以使用 SET autocommit 语句设置事务的自动提交模式，语法格式如下：
SET autocommit = 0|1|ON|OFF;
对取值的说明：

值为 0 和值为 OFF：关闭事务自动提交。如果关闭自动提交，用户将会一直处于某个事务中，只有提交或回滚后才会结束当前事务，重新开始一个新事务。
值为 1 和值为 ON：开启事务自动提交。如果开启自动提交，则每执行一条 SQL 语句，事务都会提交一次。

事务想要做到可靠性以及并发处理。
1、redo log 与 undo log
1.1、redo log
mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Boffer Pool(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做缓冲池和磁盘之间的同步。
那么问题来了，如果还没来的同步的时候宕机或断电了怎么办？还没来得及执行上面图中红色的操作。这样会导致丢部分已提交事务的修改信息！
所以引入了redo log来记录已成功提交事务的修改信息，并且会把redo log持久化到磁盘，系统重启之后在读取redo log恢复最新数据。
redo log在事务提交时就写入磁盘，不会等待后台程序执行。
总结： redo log是用来恢复数据的 用于保障，已提交事务的持久化特性。
既然redo log也需要存储，也涉及磁盘IO为啥还用它？
（1）redo log 的存储是顺序存储，而缓存同步是随机操作。
（2）缓存同步是以数据页为单位的，每次传输的数据大小大于redo log。
1.2、undo log
undo log 叫做回滚日志，用于记录数据被修改前的信息。会记录执行的操作以及修改前的信息，这样根据操作记录做相反的操作即可恢复到事务执行前的状态。
undo log 记录事务修改之前版本的数据信息，因此假如由于系统错误或者rollback操作而回滚的话可以根据undo log的信息来进行回滚到没被修改前的状态。
总结： undo log是用来回滚数据的用于保障 未提交事务的原子性
2、事务的实现

事务的原子性是通过 undo log 来实现的
事务的持久性性是通过 redo log 来实现的
事务的隔离性是通过 (读写锁+MVCC)来实现的
一致性是通过原子性，持久性，隔离性来实现的！！

2.1、原子性的实现
一个事务必须被视为不可分割的最小工作单位，一个事务中的所有操作要么全部成功提交，要么全部失败回滚，对于一个事务来说不可能只执行其中的部分操作，这就是事务的原子性。"><meta name=author content="lu"><link rel=canonical href=http://localhost:1313/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity="sha256-1yREUm1+y9sAFUOKf6iQVKZYv3WdBULi5d+BzpS0k+4=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"><meta property="og:site_name" content="lu"><meta property="og:title" content="事务实现原理"><meta property="og:description" content="MySQL 默认开启事务自动提交模式，即除非显式的开启事务（BEGIN 或 START TRANSACTION），否则每条 SOL 语句都会被当做一个单独的事务自动执行。
在 MySQL 中，可以使用 SET autocommit 语句设置事务的自动提交模式，语法格式如下：
SET autocommit = 0|1|ON|OFF; 对取值的说明：
值为 0 和值为 OFF：关闭事务自动提交。如果关闭自动提交，用户将会一直处于某个事务中，只有提交或回滚后才会结束当前事务，重新开始一个新事务。 值为 1 和值为 ON：开启事务自动提交。如果开启自动提交，则每执行一条 SQL 语句，事务都会提交一次。 事务想要做到可靠性以及并发处理。
1、redo log 与 undo log 1.1、redo log mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Boffer Pool(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做缓冲池和磁盘之间的同步。
那么问题来了，如果还没来的同步的时候宕机或断电了怎么办？还没来得及执行上面图中红色的操作。这样会导致丢部分已提交事务的修改信息！
所以引入了redo log来记录已成功提交事务的修改信息，并且会把redo log持久化到磁盘，系统重启之后在读取redo log恢复最新数据。
redo log在事务提交时就写入磁盘，不会等待后台程序执行。
总结： redo log是用来恢复数据的 用于保障，已提交事务的持久化特性。
既然redo log也需要存储，也涉及磁盘IO为啥还用它？
（1）redo log 的存储是顺序存储，而缓存同步是随机操作。
（2）缓存同步是以数据页为单位的，每次传输的数据大小大于redo log。
1.2、undo log undo log 叫做回滚日志，用于记录数据被修改前的信息。会记录执行的操作以及修改前的信息，这样根据操作记录做相反的操作即可恢复到事务执行前的状态。
undo log 记录事务修改之前版本的数据信息，因此假如由于系统错误或者rollback操作而回滚的话可以根据undo log的信息来进行回滚到没被修改前的状态。
总结： undo log是用来回滚数据的用于保障 未提交事务的原子性
2、事务的实现 事务的原子性是通过 undo log 来实现的 事务的持久性性是通过 redo log 来实现的 事务的隔离性是通过 (读写锁+MVCC)来实现的 一致性是通过原子性，持久性，隔离性来实现的！！ 2.1、原子性的实现 一个事务必须被视为不可分割的最小工作单位，一个事务中的所有操作要么全部成功提交，要么全部失败回滚，对于一个事务来说不可能只执行其中的部分操作，这就是事务的原子性。"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-27T17:39:41+00:00"><meta property="article:modified_time" content="2022-03-27T17:39:41+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="事务实现原理"><meta name=twitter:description content="MySQL 默认开启事务自动提交模式，即除非显式的开启事务（BEGIN 或 START TRANSACTION），否则每条 SOL 语句都会被当做一个单独的事务自动执行。
在 MySQL 中，可以使用 SET autocommit 语句设置事务的自动提交模式，语法格式如下：
SET autocommit = 0|1|ON|OFF;
对取值的说明：

值为 0 和值为 OFF：关闭事务自动提交。如果关闭自动提交，用户将会一直处于某个事务中，只有提交或回滚后才会结束当前事务，重新开始一个新事务。
值为 1 和值为 ON：开启事务自动提交。如果开启自动提交，则每执行一条 SQL 语句，事务都会提交一次。

事务想要做到可靠性以及并发处理。
1、redo log 与 undo log
1.1、redo log
mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Boffer Pool(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做缓冲池和磁盘之间的同步。
那么问题来了，如果还没来的同步的时候宕机或断电了怎么办？还没来得及执行上面图中红色的操作。这样会导致丢部分已提交事务的修改信息！
所以引入了redo log来记录已成功提交事务的修改信息，并且会把redo log持久化到磁盘，系统重启之后在读取redo log恢复最新数据。
redo log在事务提交时就写入磁盘，不会等待后台程序执行。
总结： redo log是用来恢复数据的 用于保障，已提交事务的持久化特性。
既然redo log也需要存储，也涉及磁盘IO为啥还用它？
（1）redo log 的存储是顺序存储，而缓存同步是随机操作。
（2）缓存同步是以数据页为单位的，每次传输的数据大小大于redo log。
1.2、undo log
undo log 叫做回滚日志，用于记录数据被修改前的信息。会记录执行的操作以及修改前的信息，这样根据操作记录做相反的操作即可恢复到事务执行前的状态。
undo log 记录事务修改之前版本的数据信息，因此假如由于系统错误或者rollback操作而回滚的话可以根据undo log的信息来进行回滚到没被修改前的状态。
总结： undo log是用来回滚数据的用于保障 未提交事务的原子性
2、事务的实现

事务的原子性是通过 undo log 来实现的
事务的持久性性是通过 redo log 来实现的
事务的隔离性是通过 (读写锁+MVCC)来实现的
一致性是通过原子性，持久性，隔离性来实现的！！

2.1、原子性的实现
一个事务必须被视为不可分割的最小工作单位，一个事务中的所有操作要么全部成功提交，要么全部失败回滚，对于一个事务来说不可能只执行其中的部分操作，这就是事务的原子性。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"事务实现原理","item":"http://localhost:1313/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"事务实现原理","name":"事务实现原理","description":"MySQL 默认开启事务自动提交模式，即除非显式的开启事务（BEGIN 或 START TRANSACTION），否则每条 SOL 语句都会被当做一个单独的事务自动执行。\n在 MySQL 中，可以使用 SET autocommit 语句设置事务的自动提交模式，语法格式如下：\nSET autocommit = 0|1|ON|OFF; 对取值的说明：\n值为 0 和值为 OFF：关闭事务自动提交。如果关闭自动提交，用户将会一直处于某个事务中，只有提交或回滚后才会结束当前事务，重新开始一个新事务。 值为 1 和值为 ON：开启事务自动提交。如果开启自动提交，则每执行一条 SQL 语句，事务都会提交一次。 事务想要做到可靠性以及并发处理。\n1、redo log 与 undo log 1.1、redo log mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Boffer Pool(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做缓冲池和磁盘之间的同步。\n那么问题来了，如果还没来的同步的时候宕机或断电了怎么办？还没来得及执行上面图中红色的操作。这样会导致丢部分已提交事务的修改信息！\n所以引入了redo log来记录已成功提交事务的修改信息，并且会把redo log持久化到磁盘，系统重启之后在读取redo log恢复最新数据。\nredo log在事务提交时就写入磁盘，不会等待后台程序执行。\n总结： redo log是用来恢复数据的 用于保障，已提交事务的持久化特性。\n既然redo log也需要存储，也涉及磁盘IO为啥还用它？\n（1）redo log 的存储是顺序存储，而缓存同步是随机操作。\n（2）缓存同步是以数据页为单位的，每次传输的数据大小大于redo log。\n1.2、undo log undo log 叫做回滚日志，用于记录数据被修改前的信息。会记录执行的操作以及修改前的信息，这样根据操作记录做相反的操作即可恢复到事务执行前的状态。\nundo log 记录事务修改之前版本的数据信息，因此假如由于系统错误或者rollback操作而回滚的话可以根据undo log的信息来进行回滚到没被修改前的状态。\n总结： undo log是用来回滚数据的用于保障 未提交事务的原子性\n2、事务的实现 事务的原子性是通过 undo log 来实现的 事务的持久性性是通过 redo log 来实现的 事务的隔离性是通过 (读写锁+MVCC)来实现的 一致性是通过原子性，持久性，隔离性来实现的！！ 2.1、原子性的实现 一个事务必须被视为不可分割的最小工作单位，一个事务中的所有操作要么全部成功提交，要么全部失败回滚，对于一个事务来说不可能只执行其中的部分操作，这就是事务的原子性。\n","keywords":[],"articleBody":"MySQL 默认开启事务自动提交模式，即除非显式的开启事务（BEGIN 或 START TRANSACTION），否则每条 SOL 语句都会被当做一个单独的事务自动执行。\n在 MySQL 中，可以使用 SET autocommit 语句设置事务的自动提交模式，语法格式如下：\nSET autocommit = 0|1|ON|OFF; 对取值的说明：\n值为 0 和值为 OFF：关闭事务自动提交。如果关闭自动提交，用户将会一直处于某个事务中，只有提交或回滚后才会结束当前事务，重新开始一个新事务。 值为 1 和值为 ON：开启事务自动提交。如果开启自动提交，则每执行一条 SQL 语句，事务都会提交一次。 事务想要做到可靠性以及并发处理。\n1、redo log 与 undo log 1.1、redo log mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Boffer Pool(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做缓冲池和磁盘之间的同步。\n那么问题来了，如果还没来的同步的时候宕机或断电了怎么办？还没来得及执行上面图中红色的操作。这样会导致丢部分已提交事务的修改信息！\n所以引入了redo log来记录已成功提交事务的修改信息，并且会把redo log持久化到磁盘，系统重启之后在读取redo log恢复最新数据。\nredo log在事务提交时就写入磁盘，不会等待后台程序执行。\n总结： redo log是用来恢复数据的 用于保障，已提交事务的持久化特性。\n既然redo log也需要存储，也涉及磁盘IO为啥还用它？\n（1）redo log 的存储是顺序存储，而缓存同步是随机操作。\n（2）缓存同步是以数据页为单位的，每次传输的数据大小大于redo log。\n1.2、undo log undo log 叫做回滚日志，用于记录数据被修改前的信息。会记录执行的操作以及修改前的信息，这样根据操作记录做相反的操作即可恢复到事务执行前的状态。\nundo log 记录事务修改之前版本的数据信息，因此假如由于系统错误或者rollback操作而回滚的话可以根据undo log的信息来进行回滚到没被修改前的状态。\n总结： undo log是用来回滚数据的用于保障 未提交事务的原子性\n2、事务的实现 事务的原子性是通过 undo log 来实现的 事务的持久性性是通过 redo log 来实现的 事务的隔离性是通过 (读写锁+MVCC)来实现的 一致性是通过原子性，持久性，隔离性来实现的！！ 2.1、原子性的实现 一个事务必须被视为不可分割的最小工作单位，一个事务中的所有操作要么全部成功提交，要么全部失败回滚，对于一个事务来说不可能只执行其中的部分操作，这就是事务的原子性。\n1.每条数据变更(insert/update/delete)操作都伴随一条undo log的生成,并且回滚日志必须先于数据持久化到磁盘上\n2.所谓的回滚就是根据回滚日志做逆向操作，比如delete的逆向操作为insert，insert的逆向操作为delete，update的逆向为update等。\n2.2、持久性的实现 事务一旦提交，其所作做的修改会永久保存到数据库中，此时即使系统崩溃修改的数据也不会丢失。\n既然redo log也需要存储，也涉及磁盘IO为啥还用它？\n（1）redo log 的存储是顺序存储，而缓存同步是随机操作。\n（2）缓存同步是以数据页为单位的，每次传输的数据大小大于redo log。\n2.3、隔离性实现 隔离性是要管理多个并发读写请求的访问顺序。 这种顺序包括串行或者是并行。\n并发问题：\n脏读：事务1读到了事务2未提交的数据。若事务2回滚，则事务1读到的就是脏数据。 不可重复读：事务2在事务1执行的过程中提交了数据。导致事务1前后两次读取的数据不一致。 幻读：事务 1 对所有行执行了某操作，在提交之前，事务2添加了一行并提交，此时事务1发现还有一行没有执行相应操作，感觉出现了幻觉。 级别越低的隔离级别可以执行越高的并发，但同时实现复杂度以及开销也越大。\nMysql 隔离级别有以下四种（级别由低到高）：\nREAD UNCOMMITED (未提交读) READ COMMITED (提交读) REPEATABLE READ (可重复读) 【innodb 默认】 SERIALIZABLE (可重复读) 2.4、一致性的实现 数据库总是从一个一致性的状态转移到另一个一致性的状态.\n3、客户端失联的事务问题 客户端和服务端失联可以分为以下两种：\n客户端机器用kill或kill -9命令关闭，这时候tcp协议会发送四次握手协议，服务端能感知到客户端断开连接了，这时候它会把事务回滚； 客户端断网了，不能给服务器端发送信号了，服务端不知道客户端断开了，但是它有超时时间，到了就会把连接断开，但是这时服务端不会将事务回滚。这种情况会造成数据库锁表，后续的SQL语句也无法执行，是死锁的主要原因。 4、Mysql 如何选择合适的隔离级别 SqlServer 默认隔离级别为读已提交，而 Mysql 默认的隔离级别为可重复读，原因如下：Mysql在5.0这个版本以前，binlog只支持STATEMENT这种格式！而这种格式在读已提交(Read Commited)这个隔离级别下主从复制是有bug的，因此Mysql将可重复读(Repeatable Read)作为默认的隔离级别！该 bug 如下：\n时间 事务A 事务B 1 create table; insert age 3; 2 begin begin 3 delete where age \u003c 6 4 insert age 5 5 commit 6 commit 此时在主库中查询，会得到一条数据 5，但是从库中没有数据。因为 binlog 是按照事务提交的先后顺序到达从库的，所以从库执行时是先执行insert age 5，后执行 delete where age \u003c 6，故主从不一致了。可重复读的间隙锁和 binlog 的 row 格式都可以避免这个问题。\n对比\n项目中不用读未提交(Read UnCommitted)和串行化(Serializable)两个隔离级别，原因有二\n读未提交：一个事务读到另一个事务未提交读数据，会引发逻辑错误 串行化：每个次读操作都会加锁，快照读失效，性能不佳。一般是使用mysql自带分布式事务功能时才使用该隔离级别！(是强一致性事务，性能不佳！互联网的分布式方案，多采用最终一致性的事务解决方案！) 在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大：间隙锁与插入意向锁冲突\n在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行\n在RC隔离级别下，半一致性读(semi-consistent)特性增加了update操作的并发性！\n所谓半一致性读就是，一个update语句，如果读到一行已经加锁的记录，此时InnoDB会返回记录最近提交的版本，由MySQL服务层判断此版本是否满足update的where条件，若满足，MySQL会重新发起一次当前读，若不满足即可直接过滤。\n","wordCount":"188","inLanguage":"en","datePublished":"2022-03-27T17:39:41Z","dateModified":"2022-03-27T17:39:41Z","author":{"@type":"Person","name":"lu"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},"publisher":{"@type":"Organization","name":"lu","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/categories/ title=categories><span>categories</span></a></li><li><a href=http://localhost:1313/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">事务实现原理</h1><div class=post-meta><span title='2022-03-27 17:39:41 +0000 UTC'>2022-03-27</span>&nbsp;·&nbsp;188 words&nbsp;·&nbsp;lu</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1redo-log-与-undo-log>1、redo log 与 undo log</a><ul><li><a href=#11redo-log>1.1、redo log</a></li><li><a href=#12undo-log>1.2、undo log</a></li></ul></li><li><a href=#2事务的实现>2、事务的实现</a><ul><li><a href=#21原子性的实现>2.1、原子性的实现</a></li><li><a href=#22持久性的实现>2.2、持久性的实现</a></li><li><a href=#23隔离性实现>2.3、隔离性实现</a></li><li><a href=#24一致性的实现>2.4、一致性的实现</a></li></ul></li><li><a href=#3客户端失联的事务问题>3、客户端失联的事务问题</a></li><li><a href=#4mysql-如何选择合适的隔离级别>4、Mysql 如何选择合适的隔离级别</a></li></ul></nav></div></details></div><div class=post-content><p>MySQL 默认开启事务自动提交模式，即除非显式的开启事务（BEGIN 或 START TRANSACTION），否则每条 SOL 语句都会被当做一个单独的事务自动执行。</p><p>在 MySQL 中，可以使用 SET autocommit 语句设置事务的自动提交模式，语法格式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SET</span> autocommit <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>|</span><span style=color:#ae81ff>1</span><span style=color:#f92672>|</span><span style=color:#66d9ef>ON</span><span style=color:#f92672>|</span><span style=color:#66d9ef>OFF</span>;
</span></span></code></pre></div><p>对取值的说明：</p><ul><li>值为 0 和值为 OFF：关闭事务自动提交。如果关闭自动提交，用户将会一直处于某个事务中，只有提交或回滚后才会结束当前事务，重新开始一个新事务。</li><li>值为 1 和值为 ON：开启事务自动提交。如果开启自动提交，则每执行一条 SQL 语句，事务都会提交一次。</li></ul><p>事务想要做到可靠性以及并发处理。</p><h2 id=1redo-log-与-undo-log>1、redo log 与 undo log<a hidden class=anchor aria-hidden=true href=#1redo-log-与-undo-log>#</a></h2><h3 id=11redo-log>1.1、redo log<a hidden class=anchor aria-hidden=true href=#11redo-log>#</a></h3><p>mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Boffer Pool(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做<strong>缓冲池和磁盘之间的同步</strong>。</p><p>那么问题来了，如果还没来的同步的时候宕机或断电了怎么办？还没来得及执行上面图中红色的操作。这样会导致丢部分已提交事务的修改信息！</p><p>所以引入了redo log来记录已成功提交事务的修改信息，并且会把redo log持久化到磁盘，系统重启之后在读取redo log恢复最新数据。</p><p>redo log在事务提交时就写入磁盘，不会等待后台程序执行。</p><p><strong>总结：</strong> redo log是用来恢复数据的 用于保障，已提交事务的持久化特性。</p><p>既然redo log也需要存储，也涉及磁盘IO为啥还用它？</p><p>（1）redo log 的存储是顺序存储，而缓存同步是随机操作。</p><p>（2）缓存同步是以数据页为单位的，每次传输的数据大小大于redo log。</p><h3 id=12undo-log>1.2、undo log<a hidden class=anchor aria-hidden=true href=#12undo-log>#</a></h3><p>undo log 叫做回滚日志，用于记录数据<strong>被修改前</strong>的信息。会记录执行的操作以及修改前的信息，这样根据操作记录做相反的操作即可恢复到事务执行前的状态。</p><p>undo log 记录事务修改之前版本的数据信息，因此假如由于系统错误或者rollback操作而回滚的话可以根据undo log的信息来进行回滚到没被修改前的状态。</p><p><strong>总结：</strong> undo log是用来回滚数据的用于保障 未提交事务的原子性</p><h2 id=2事务的实现>2、事务的实现<a hidden class=anchor aria-hidden=true href=#2事务的实现>#</a></h2><ul><li>事务的原子性是通过 undo log 来实现的</li><li>事务的持久性性是通过 redo log 来实现的</li><li>事务的隔离性是通过 (读写锁+MVCC)来实现的</li><li><strong>一致性</strong>是通过原子性，持久性，隔离性来实现的！！</li></ul><h3 id=21原子性的实现>2.1、原子性的实现<a hidden class=anchor aria-hidden=true href=#21原子性的实现>#</a></h3><p>一个事务必须被视为不可分割的最小工作单位，一个事务中的所有操作要么全部成功提交，要么全部失败回滚，对于一个事务来说不可能只执行其中的部分操作，这就是事务的原子性。</p><p>1.每条数据变更(insert/update/delete)操作都伴随一条undo log的生成,并且回滚日志必须先于数据持久化到磁盘上</p><p>2.所谓的回滚就是根据回滚日志做逆向操作，比如delete的逆向操作为insert，insert的逆向操作为delete，update的逆向为update等。</p><h3 id=22持久性的实现>2.2、持久性的实现<a hidden class=anchor aria-hidden=true href=#22持久性的实现>#</a></h3><p>事务一旦提交，其所作做的修改会永久保存到数据库中，此时即使系统崩溃修改的数据也不会丢失。</p><p>既然redo log也需要存储，也涉及磁盘IO为啥还用它？</p><p>（1）redo log 的存储是顺序存储，而缓存同步是随机操作。</p><p>（2）缓存同步是以数据页为单位的，每次传输的数据大小大于redo log。</p><h3 id=23隔离性实现>2.3、隔离性实现<a hidden class=anchor aria-hidden=true href=#23隔离性实现>#</a></h3><p><strong>隔离性是要管理多个并发读写请求的访问顺序。</strong> 这种顺序包括<strong>串行</strong>或者是<strong>并行</strong>。</p><p>并发问题：</p><ul><li>脏读：事务1读到了事务2未提交的数据。若事务2回滚，则事务1读到的就是脏数据。</li><li>不可重复读：事务2在事务1执行的过程中提交了数据。导致事务1前后两次读取的数据不一致。</li><li>幻读：事务 1 对所有行执行了某操作，在提交之前，事务2添加了一行并提交，此时事务1发现还有一行没有执行相应操作，感觉出现了幻觉。</li></ul><p>级别越低的隔离级别可以执行越高的并发，但同时实现复杂度以及开销也越大。</p><p>Mysql 隔离级别有以下四种（级别由低到高）：</p><ul><li><strong>READ UNCOMMITED</strong> (未提交读)</li><li><strong>READ COMMITED</strong> (提交读)</li><li><strong>REPEATABLE READ</strong> (可重复读) 【innodb 默认】</li><li><strong>SERIALIZABLE</strong> (可重复读)</li></ul><h3 id=24一致性的实现>2.4、一致性的实现<a hidden class=anchor aria-hidden=true href=#24一致性的实现>#</a></h3><p>数据库总是从一个一致性的状态转移到另一个一致性的状态.</p><h2 id=3客户端失联的事务问题>3、客户端失联的事务问题<a hidden class=anchor aria-hidden=true href=#3客户端失联的事务问题>#</a></h2><p>客户端和服务端失联可以分为以下两种：</p><ol><li>客户端机器用kill或kill -9命令关闭，这时候tcp协议会发送四次握手协议，服务端能感知到客户端断开连接了，这时候它会把事务回滚；</li><li>客户端断网了，不能给服务器端发送信号了，服务端不知道客户端断开了，但是它有超时时间，到了就会把连接断开，但是这时服务端不会将事务回滚。这种情况会造成数据库锁表，后续的SQL语句也无法执行，是死锁的主要原因。</li></ol><h2 id=4mysql-如何选择合适的隔离级别>4、Mysql 如何选择合适的隔离级别<a hidden class=anchor aria-hidden=true href=#4mysql-如何选择合适的隔离级别>#</a></h2><p>SqlServer 默认隔离级别为读已提交，而 Mysql 默认的隔离级别为可重复读，原因如下：Mysql在5.0这个版本以前，binlog只支持<code>STATEMENT</code>这种格式！而这种格式在<code>读已提交(Read Commited)</code>这个隔离级别下主从复制是有bug的，因此Mysql将<code>可重复读(Repeatable Read)</code>作为默认的隔离级别！该 bug 如下：</p><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td><code>create table</code>; <code>insert age 3</code>;</td><td></td></tr><tr><td>2</td><td><code>begin</code></td><td><code>begin</code></td></tr><tr><td>3</td><td><code>delete where age &lt; 6</code></td><td></td></tr><tr><td>4</td><td></td><td><code>insert age 5</code></td></tr><tr><td>5</td><td></td><td><code>commit</code></td></tr><tr><td>6</td><td><code>commit</code></td><td></td></tr></tbody></table><p>此时在主库中查询，会得到一条数据 5，但是从库中没有数据。因为 binlog 是按照事务提交的先后顺序到达从库的，所以从库执行时是先执行<code>insert age 5</code>，后执行 <code>delete where age &lt; 6</code>，故主从不一致了。可重复读的间隙锁和 binlog 的 row 格式都可以避免这个问题。</p><p><strong>对比</strong></p><p>项目中不用读未提交(Read UnCommitted)和串行化(Serializable)两个隔离级别，原因有二</p><ul><li>读未提交：一个事务读到另一个事务未提交读数据，会引发逻辑错误</li><li>串行化：每个次读操作都会加锁，快照读失效，性能不佳。一般是使用mysql自带分布式事务功能时才使用该隔离级别！(是强一致性事务，性能不佳！互联网的分布式方案，多采用最终一致性的事务解决方案！)</li></ul><ol><li><p>在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大：间隙锁与插入意向锁冲突</p></li><li><p>在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行</p></li><li><p>在RC隔离级别下，半一致性读(semi-consistent)特性增加了update操作的并发性！</p><p>所谓半一致性读就是，一个update语句，如果读到一行已经加锁的记录，此时InnoDB会返回记录最近提交的版本，由MySQL服务层判断此版本是否满足update的where条件，若满足，MySQL会重新发起一次当前读，若不满足即可直接过滤。</p></li></ol></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E7%B4%A2%E5%BC%95/><span class=title>« Prev</span><br><span>MySQL索引</span>
</a><a class=next href=http://localhost:1313/posts/java/java-%E8%BF%9B%E9%98%B6/concurrenthashmap/><span class=title>Next »</span><br><span>ConcurrentHashMap</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>