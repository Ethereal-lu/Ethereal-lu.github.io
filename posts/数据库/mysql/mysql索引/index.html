<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MySQL索引 | lu</title>
<meta name=keywords content><meta name=description content='索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组。
1、索引类型

普通索引：最基本的索引，可以在任意一列或多列的组合上加普通索引。允许存在重复值以及空值。
唯一索引：与普通索引不同的是，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
主键索引：与唯一索引不同的是，不允许有空值。
组合索引：组合索引与单列索引相对应，只包含一个字段的索引叫做单列索引，包含两个或以上字段的索引叫做复合索引（或组合索引）。上述三种索引既可以是单列索引也可以是组合索引。

2、聚集索引
聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。
怎么理解呢？
聚簇索引的顺序，就是数据在硬盘上的物理顺序。一般情况下主键就是默认的聚簇索引。
一张表只允许存在一个聚簇索引，因为真实数据的物理顺序只能有一种。如果一张表上还没有聚簇索引，为它新创建聚簇索引时，就需要对已有数据重新进行排序，所以对表进行修改速度较慢是聚簇索引的缺点，对于经常更新的列不宜建立聚簇索引。
聚簇索引性能最好，因为一旦具有第一个索引值的记录被找到，具有连续索引值的记录也一定物理地紧跟其后。一张表只能有一个聚簇索引，所以非常珍贵，必须慎重设置，一般要根据这个表最常用的SQL查询方式选择某个（或多个）字段作为聚簇索引（或复合聚簇索引）。

InnoDB对主键建立聚簇索引。
如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。
如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引。

3、索引的最左匹配
最左前缀匹配原则，非常重要的原则，建立一个索引，对于索引中的字段，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。
mysql创建复合索引的规则是首先会对复合索引的最左边的，也就是第一个name字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的cid字段进行排序。其实就相当于实现了类似 order by name cid这样一种排序规则。
所以：第一个name字段是绝对有序的，而第二字段就是无序的了。所以通常情况下，直接使用第二个cid字段进行条件判断是用不到索引的。
在第一个值等值匹配的前提下，第二个值是有序的，因此mysql索引规则中要求复合索引要想使用第二个索引，必须先使用第一个索引的原因。（而且第一个索引必须是等值匹配）。
order by也会用到索引，但前提是 where子句必须用到索引；如果 where子句的字段没有索引，即使order by的字段有索引也不会用到。where和order by使用的索引可以是同一个组合索引，同样符合最左匹配原则，比如 select * from tb_user where name = "lu" and age < 21 order by score，如果有 (name, age, score) 的组合索引，由于 age 使用了范围搜索，score 索引就会失效。'><meta name=author content="lu"><link rel=canonical href=http://localhost:1313/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E7%B4%A2%E5%BC%95/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity="sha256-1yREUm1+y9sAFUOKf6iQVKZYv3WdBULi5d+BzpS0k+4=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E7%B4%A2%E5%BC%95/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E7%B4%A2%E5%BC%95/"><meta property="og:site_name" content="lu"><meta property="og:title" content="MySQL索引"><meta property="og:description" content='索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组。
1、索引类型 普通索引：最基本的索引，可以在任意一列或多列的组合上加普通索引。允许存在重复值以及空值。 唯一索引：与普通索引不同的是，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。 主键索引：与唯一索引不同的是，不允许有空值。 组合索引：组合索引与单列索引相对应，只包含一个字段的索引叫做单列索引，包含两个或以上字段的索引叫做复合索引（或组合索引）。上述三种索引既可以是单列索引也可以是组合索引。 2、聚集索引 聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。
怎么理解呢？
聚簇索引的顺序，就是数据在硬盘上的物理顺序。一般情况下主键就是默认的聚簇索引。
一张表只允许存在一个聚簇索引，因为真实数据的物理顺序只能有一种。如果一张表上还没有聚簇索引，为它新创建聚簇索引时，就需要对已有数据重新进行排序，所以对表进行修改速度较慢是聚簇索引的缺点，对于经常更新的列不宜建立聚簇索引。
聚簇索引性能最好，因为一旦具有第一个索引值的记录被找到，具有连续索引值的记录也一定物理地紧跟其后。一张表只能有一个聚簇索引，所以非常珍贵，必须慎重设置，一般要根据这个表最常用的SQL查询方式选择某个（或多个）字段作为聚簇索引（或复合聚簇索引）。
InnoDB对主键建立聚簇索引。 如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。 如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引。 3、索引的最左匹配 最左前缀匹配原则，非常重要的原则，建立一个索引，对于索引中的字段，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。
mysql创建复合索引的规则是首先会对复合索引的最左边的，也就是第一个name字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的cid字段进行排序。其实就相当于实现了类似 order by name cid这样一种排序规则。 所以：第一个name字段是绝对有序的，而第二字段就是无序的了。所以通常情况下，直接使用第二个cid字段进行条件判断是用不到索引的。
在第一个值等值匹配的前提下，第二个值是有序的，因此mysql索引规则中要求复合索引要想使用第二个索引，必须先使用第一个索引的原因。（而且第一个索引必须是等值匹配）。
order by也会用到索引，但前提是 where子句必须用到索引；如果 where子句的字段没有索引，即使order by的字段有索引也不会用到。where和order by使用的索引可以是同一个组合索引，同样符合最左匹配原则，比如 select * from tb_user where name = "lu" and age < 21 order by score，如果有 (name, age, score) 的组合索引，由于 age 使用了范围搜索，score 索引就会失效。'><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-27T17:39:41+00:00"><meta property="article:modified_time" content="2022-03-27T17:39:41+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="MySQL索引"><meta name=twitter:description content='索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组。
1、索引类型

普通索引：最基本的索引，可以在任意一列或多列的组合上加普通索引。允许存在重复值以及空值。
唯一索引：与普通索引不同的是，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
主键索引：与唯一索引不同的是，不允许有空值。
组合索引：组合索引与单列索引相对应，只包含一个字段的索引叫做单列索引，包含两个或以上字段的索引叫做复合索引（或组合索引）。上述三种索引既可以是单列索引也可以是组合索引。

2、聚集索引
聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。
怎么理解呢？
聚簇索引的顺序，就是数据在硬盘上的物理顺序。一般情况下主键就是默认的聚簇索引。
一张表只允许存在一个聚簇索引，因为真实数据的物理顺序只能有一种。如果一张表上还没有聚簇索引，为它新创建聚簇索引时，就需要对已有数据重新进行排序，所以对表进行修改速度较慢是聚簇索引的缺点，对于经常更新的列不宜建立聚簇索引。
聚簇索引性能最好，因为一旦具有第一个索引值的记录被找到，具有连续索引值的记录也一定物理地紧跟其后。一张表只能有一个聚簇索引，所以非常珍贵，必须慎重设置，一般要根据这个表最常用的SQL查询方式选择某个（或多个）字段作为聚簇索引（或复合聚簇索引）。

InnoDB对主键建立聚簇索引。
如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。
如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引。

3、索引的最左匹配
最左前缀匹配原则，非常重要的原则，建立一个索引，对于索引中的字段，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。
mysql创建复合索引的规则是首先会对复合索引的最左边的，也就是第一个name字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的cid字段进行排序。其实就相当于实现了类似 order by name cid这样一种排序规则。
所以：第一个name字段是绝对有序的，而第二字段就是无序的了。所以通常情况下，直接使用第二个cid字段进行条件判断是用不到索引的。
在第一个值等值匹配的前提下，第二个值是有序的，因此mysql索引规则中要求复合索引要想使用第二个索引，必须先使用第一个索引的原因。（而且第一个索引必须是等值匹配）。
order by也会用到索引，但前提是 where子句必须用到索引；如果 where子句的字段没有索引，即使order by的字段有索引也不会用到。where和order by使用的索引可以是同一个组合索引，同样符合最左匹配原则，比如 select * from tb_user where name = "lu" and age < 21 order by score，如果有 (name, age, score) 的组合索引，由于 age 使用了范围搜索，score 索引就会失效。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"MySQL索引","item":"http://localhost:1313/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E7%B4%A2%E5%BC%95/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySQL索引","name":"MySQL索引","description":"索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组。\n1、索引类型 普通索引：最基本的索引，可以在任意一列或多列的组合上加普通索引。允许存在重复值以及空值。 唯一索引：与普通索引不同的是，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。 主键索引：与唯一索引不同的是，不允许有空值。 组合索引：组合索引与单列索引相对应，只包含一个字段的索引叫做单列索引，包含两个或以上字段的索引叫做复合索引（或组合索引）。上述三种索引既可以是单列索引也可以是组合索引。 2、聚集索引 聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。\n怎么理解呢？\n聚簇索引的顺序，就是数据在硬盘上的物理顺序。一般情况下主键就是默认的聚簇索引。\n一张表只允许存在一个聚簇索引，因为真实数据的物理顺序只能有一种。如果一张表上还没有聚簇索引，为它新创建聚簇索引时，就需要对已有数据重新进行排序，所以对表进行修改速度较慢是聚簇索引的缺点，对于经常更新的列不宜建立聚簇索引。\n聚簇索引性能最好，因为一旦具有第一个索引值的记录被找到，具有连续索引值的记录也一定物理地紧跟其后。一张表只能有一个聚簇索引，所以非常珍贵，必须慎重设置，一般要根据这个表最常用的SQL查询方式选择某个（或多个）字段作为聚簇索引（或复合聚簇索引）。\nInnoDB对主键建立聚簇索引。 如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。 如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引。 3、索引的最左匹配 最左前缀匹配原则，非常重要的原则，建立一个索引，对于索引中的字段，mysql会一直向右匹配直到遇到范围查询(\u0026gt;、\u0026lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c \u0026gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。\nmysql创建复合索引的规则是首先会对复合索引的最左边的，也就是第一个name字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的cid字段进行排序。其实就相当于实现了类似 order by name cid这样一种排序规则。 所以：第一个name字段是绝对有序的，而第二字段就是无序的了。所以通常情况下，直接使用第二个cid字段进行条件判断是用不到索引的。\n在第一个值等值匹配的前提下，第二个值是有序的，因此mysql索引规则中要求复合索引要想使用第二个索引，必须先使用第一个索引的原因。（而且第一个索引必须是等值匹配）。\norder by也会用到索引，但前提是 where子句必须用到索引；如果 where子句的字段没有索引，即使order by的字段有索引也不会用到。where和order by使用的索引可以是同一个组合索引，同样符合最左匹配原则，比如 select * from tb_user where name = \u0026quot;lu\u0026quot; and age \u0026lt; 21 order by score，如果有 (name, age, score) 的组合索引，由于 age 使用了范围搜索，score 索引就会失效。\n","keywords":[],"articleBody":"索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组。\n1、索引类型 普通索引：最基本的索引，可以在任意一列或多列的组合上加普通索引。允许存在重复值以及空值。 唯一索引：与普通索引不同的是，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。 主键索引：与唯一索引不同的是，不允许有空值。 组合索引：组合索引与单列索引相对应，只包含一个字段的索引叫做单列索引，包含两个或以上字段的索引叫做复合索引（或组合索引）。上述三种索引既可以是单列索引也可以是组合索引。 2、聚集索引 聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。\n怎么理解呢？\n聚簇索引的顺序，就是数据在硬盘上的物理顺序。一般情况下主键就是默认的聚簇索引。\n一张表只允许存在一个聚簇索引，因为真实数据的物理顺序只能有一种。如果一张表上还没有聚簇索引，为它新创建聚簇索引时，就需要对已有数据重新进行排序，所以对表进行修改速度较慢是聚簇索引的缺点，对于经常更新的列不宜建立聚簇索引。\n聚簇索引性能最好，因为一旦具有第一个索引值的记录被找到，具有连续索引值的记录也一定物理地紧跟其后。一张表只能有一个聚簇索引，所以非常珍贵，必须慎重设置，一般要根据这个表最常用的SQL查询方式选择某个（或多个）字段作为聚簇索引（或复合聚簇索引）。\nInnoDB对主键建立聚簇索引。 如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。 如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引。 3、索引的最左匹配 最左前缀匹配原则，非常重要的原则，建立一个索引，对于索引中的字段，mysql会一直向右匹配直到遇到范围查询(\u003e、\u003c、between、like)就停止匹配，比如a = 1 and b = 2 and c \u003e 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。\nmysql创建复合索引的规则是首先会对复合索引的最左边的，也就是第一个name字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的cid字段进行排序。其实就相当于实现了类似 order by name cid这样一种排序规则。 所以：第一个name字段是绝对有序的，而第二字段就是无序的了。所以通常情况下，直接使用第二个cid字段进行条件判断是用不到索引的。\n在第一个值等值匹配的前提下，第二个值是有序的，因此mysql索引规则中要求复合索引要想使用第二个索引，必须先使用第一个索引的原因。（而且第一个索引必须是等值匹配）。\norder by也会用到索引，但前提是 where子句必须用到索引；如果 where子句的字段没有索引，即使order by的字段有索引也不会用到。where和order by使用的索引可以是同一个组合索引，同样符合最左匹配原则，比如 select * from tb_user where name = \"lu\" and age \u003c 21 order by score，如果有 (name, age, score) 的组合索引，由于 age 使用了范围搜索，score 索引就会失效。\n4、InnoDB 的 B+Tree B-Tree 和 B+Tree 的区别在于：\nB-Tree 中，所有节点都会带有指向具体记录的指针；B+Tree 中只有叶子结点会带有指向具体记录的指针。 B-Tree 中不同的叶子之间没有连在一起；B+Tree 中所有的叶子结点通过指针连接在一起。 B-Tree 中可能在非叶子结点就拿到了指向具体记录的指针，搜索效率不稳定；B+Tree 中，一定要到叶子结点中才可以获取到具体记录的指针，搜索效率稳定。 基于上面分析，可以得出如下结论：\nB+Tree 中，由于非叶子结点不带有指向具体记录的指针，所以非叶子结点中可以存储更多的索引项，这样就可以有效降低树的高度，进而提高搜索的效率。 B+Tree 中，叶子结点通过指针连接在一起，这样如果有范围扫描的需求，那么实现起来将非常容易，而对于 B-Tree，范围扫描则需要不停的在叶子结点和非叶子结点之间移动。 计算机在存储数据的时候，最小存储单元是扇区，一个扇区的大小是 512 字节，而文件系统（例如 XFS/EXT4）最小单元是块，一个块的大小是 4KB。InnoDB 引擎存储数据的时候，是以页为单位的，每个数据页的大小默认是 16KB，即四个块。 非叶子结点存储的是主键值+指针\n由于一页存储一个非叶子节点，主键值为 4 或 8 字节，InnoDB 的指针为 6 字节，因此，一个非叶子节点约可以指向 1000+ 个页。若按一条数据 1 KB 计算，则一个三层的b+树约可以存储 2100 万条数据。\n在 InnoDB 存储引擎中，B+Tree 的高度一般为 2-4 层，这就可以满足千万级的数据的存储，查找数据的时候，一次页的查找代表一次 IO，那我们通过主键索引查询的时候，其实最多只需要 2-4 次 IO 操作就可以了。\n5、回表 5.1、回表 如果是通过主键索引来查询数据，只需要搜索主键索引的 B+Tree 就可以找到数据。 如果是通过非主键索引来查询数据，例如 select * from user where username='javaboy'，那么此时需要先搜索 username 这一列索引的 B+Tree，搜索完成后得到主键的值，然后再去搜索主键索引的 B+Tree，就可以获取到一行完整的数据。 对于第二种查询方式而言，一共搜索了两棵 B+Tree，第一次搜索 B+Tree 拿到主键值后再去搜索主键索引的 B+Tree，这个过程就是所谓的回表。\n5.2、覆盖索引 但不使用主键索引不一定需要回表：覆盖索引\n如果辅助索引上已经存在我们需要的数据,那么引擎就不会去主键上去搜索数据了。 —- 这个就是所谓的\"覆盖索引\"\n普通索引、唯一索引、组合索引都可以是覆盖索引，只要满足所查询的字段全部都在辅助索引就行，这样就无需回表。\n5.3、索引下推 索引下推(Index Condition Pushdown，简称ICP)，是MySQL5.6版本的新特性，它能减少回表查询次数，提高查询效率。\nMySQL服务层负责SQL语法解析、生成执行计划等，并调用存储引擎层去执行数据的存储和检索。\n索引下推的下推其实就是指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理。\n我们来具体看一下，在没有使用ICP的情况下，MySQL的查询：\n存储引擎读取索引记录； 根据索引中的主键值，定位并读取完整的行记录； 存储引擎把记录交给Server层去检测该记录是否满足WHERE条件。 使用ICP的情况下，查询过程：\n存储引擎读取索引记录（不是完整的行记录）； 判断WHERE条件中的一部分能否用索引中的列来做检查，条件不满足，则处理下一行索引记录； 条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）； 存储引擎把记录交给Server层，Server层检测该记录是否满足WHERE条件的其余部分。 6、为什么数据库中建议使用自增主键 自增主键往往占用空间比较小，int 占 4 个字节，bigint 占 8 个字节。由于辅助索引的叶子节点存储的就是主键，所以如果主键占用空间小，则辅助索引的叶子节点占用的空间就小；同时主键索引的非叶子节点存储的就是主键值，如果主键占用空间小那么一个非叶子节点能指向的子节点更多，从而降低 B+Tree 的高度，提高搜索效率。 自增主键插入的时候比较快，直接插入即可，即使最右侧的节点分裂也不需要挪动其他记录；而其他非自增主键插入的时候，可能要插入到两个已有的数据中间，就有可能导致节点分裂等问题，插入效率低，需要挪动其他记录。 7、索引创建 7.1、创建索引 建表时创建：\nCREATE TABLE 表名( 字段名 数据类型 [完整性约束条件], ……， [UNIQUE | PRIMARY] INDEX | KEY [索引名](字段名1 [(长度)] [ASC | DESC]) [USING 索引方法] ); UNIQUE：唯一索引；PRIMARY：主键索引；什么都不加就是普通索引。INDEX和KEY作用一样，可以相互替换\nCREATE TABLE projectfile ( id INT AUTO_INCREMENT COMMENT '附件id', projectid INT COMMENT '项目id;此列受project表中的id列约束', filename VARCHAR (512) COMMENT '附件名', filesize BIGINT COMMENT '附件大小，单位Byte', -- 主键索引 PRIMARY KEY (id), -- 唯一索引 UNIQUE KEY (projectid), -- 普通索引 KEY (filename) -- 组合索引 KEY (filename, filesize) ) ENGINE = INNODB DEFAULT CHARSET = utf8 COMMENT '项目附件表'; 建表后创建：\nALTER TABLE 表名 ADD [UNIQUE | PRIMARY] INDEX | KEY [索引名] (字段名1 [(长度)] [ASC | DESC]) [USING 索引方法]； 字段名后的长度用于创建前缀索引，只能用于字符串类型，上方一样。\nALTER TABLE projectfile ADD KEY (filename, filesize); 7.2、查看已创建的索引 show index from 表名; 7.3、删除索引 ALTER TABLE 表名 DROP INDEX 索引名 7.4、查看SQL语句对索引的使用情况 在select语句前加上EXPLAIN即可。\nEXPLAIN SELECT * FROM `projectfile` pf WHERE pf.filename = 'Jane'; 8、在枚举字段上创建索引 如性别的列，只有男、女两种属性，在该列上建索引。在所有数据中可能男很多，女很少；或相反；或相等相差不多。\n如果where 只查索引字段，查询会使用索引，且效率提升明显！\n原理：只查索引字段意味着每个索引命中产生的回表操作都能得到一条有效数据，这样可以过滤掉一半的数据提升效率 如果where 查询索引字段+非索引字段，如果查询索引枚举值较少的这部分数据，效率有提升；\n原理：枚举值较少时，能过滤掉大部分数据行，即使存在浪费的回表操作，也能提升效率 如果where 查询索引字段+非索引字段，如果查询枚举值相差不大或者查询较多的这部分数据时，索引大大降低了查询效率！可怕的是，比全表索引效率还要低的多！\n原理：由于只有枚举字段有索引，无法利用到索引下推，故每命中一条索引都需要回表。但由于其他检索条件的限制，这其中的大量回表操作得不到有效的数据，这些IO是浪费的。而全表扫描虽然需要扫描更多数据行，但相比大量IO操作，要更高效。 9、索引失效情况 使用组合索引时，需要遵循“最左前缀”原则; 不在索引列上做任何操作，例如计算、函数、类型转换，会导致索引失效而转向全表扫描; 尽量使用覆盖索引(之访问索引列的查询)，减少 select * 覆盖索引能减少回表次数; MySQL在使用不等于(!=或者\u003c\u003e)的时候无法使用索引会导致全表扫描; LIKE以通配符开头(%abc)MySQL索引会失效变成全表扫描的操作; 字符串不加单引号会导致索引失效(可能发生了索引列的隐式转换); 少用or，用它来连接时只有一个索引生效，另一个会索引失效。 10、重建索引 什么时候需要重建索引？\n表上频繁发生update,delete操作; 表上发生了alter table ..move操作(move操作会使索引失效)。 怎么判断索引是否应该重建？\n对索引结构进行分析，如果索引高度超过 4 或者 B+树倾斜严重时需要重建索引\n如何重建索引？\n1. 先 drop 索引，再 create 2. alter index indexname rebuild online； rebuild是快速重建索引的一种有效的办法，因为它是一种使用现有索引项来重建新索引的方法。由于新旧索引在建立时同时存在，因此，使用这种重建方法需要有额外的磁盘空间可供 临时使用，当索引建完后把老索引删除，如果没有成功，也不会影响原来的索引。利用这种办法可以用 来将一个索引移到新的表空间。\nRebuild会阻塞DML操作，rebuild online不会阻塞DML操作；rebuild online时系统会生成一个系统临时日志表，所有rebuild online时索引的变化都记录在这个表中，当新的索引创建完成后，把这个表的记录维护到新的索引 中去，然后drop掉旧的索引，rebuild online就完成了。\nRebuild操作会产生大量Redo Log;\n","wordCount":"371","inLanguage":"en","datePublished":"2022-03-27T17:39:41Z","dateModified":"2022-03-27T17:39:41Z","author":{"@type":"Person","name":"lu"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E7%B4%A2%E5%BC%95/"},"publisher":{"@type":"Organization","name":"lu","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/categories/ title=categories><span>categories</span></a></li><li><a href=http://localhost:1313/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">MySQL索引</h1><div class=post-meta><span title='2022-03-27 17:39:41 +0000 UTC'>2022-03-27</span>&nbsp;·&nbsp;371 words&nbsp;·&nbsp;lu</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1索引类型>1、索引类型</a></li><li><a href=#2聚集索引>2、聚集索引</a></li><li><a href=#3索引的最左匹配>3、索引的最左匹配</a></li><li><a href=#4innodb-的-btree>4、InnoDB 的 B+Tree</a></li><li><a href=#5回表>5、回表</a><ul><li><a href=#51回表>5.1、回表</a></li><li><a href=#52覆盖索引>5.2、覆盖索引</a></li><li><a href=#53索引下推>5.3、索引下推</a></li></ul></li><li><a href=#6为什么数据库中建议使用自增主键>6、为什么数据库中建议使用自增主键</a></li><li><a href=#7索引创建>7、索引创建</a><ul><li><a href=#71创建索引>7.1、创建索引</a></li><li><a href=#72查看已创建的索引>7.2、查看已创建的索引</a></li><li><a href=#73删除索引>7.3、删除索引</a></li><li><a href=#74查看sql语句对索引的使用情况>7.4、查看SQL语句对索引的使用情况</a></li></ul></li><li><a href=#8在枚举字段上创建索引>8、在枚举字段上创建索引</a></li><li><a href=#9索引失效情况>9、索引失效情况</a></li><li><a href=#10重建索引>10、重建索引</a></li></ul></nav></div></details></div><div class=post-content><p>索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组。</p><h2 id=1索引类型>1、索引类型<a hidden class=anchor aria-hidden=true href=#1索引类型>#</a></h2><ul><li>普通索引：最基本的索引，可以在任意一列或多列的组合上加普通索引。允许存在重复值以及空值。</li><li>唯一索引：与普通索引不同的是，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</li><li>主键索引：与唯一索引不同的是，不允许有空值。</li><li>组合索引：组合索引与单列索引相对应，只包含一个字段的索引叫做单列索引，包含两个或以上字段的索引叫做复合索引（或组合索引）。上述三种索引既可以是单列索引也可以是组合索引。</li></ul><h2 id=2聚集索引>2、聚集索引<a hidden class=anchor aria-hidden=true href=#2聚集索引>#</a></h2><p><strong>聚簇索引</strong>的叶子节点就是数据节点，而<strong>非聚簇索引</strong>的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。</p><p>怎么理解呢？</p><p><strong>聚簇索引的顺序，就是数据在硬盘上的物理顺序。一般情况下主键就是默认的聚簇索引。</strong></p><p>一张表<strong>只允许存在一个</strong>聚簇索引，因为真实数据的物理顺序只能有一种。如果一张表上还没有聚簇索引，为它新创建聚簇索引时，就需要对已有数据重新进行排序，所以对表进行修改速度较慢是聚簇索引的缺点，对于<strong>经常更新的列不宜建立聚簇索引</strong>。</p><p>聚簇索引性能最好，因为一旦具有第一个索引值的记录被找到，具有连续索引值的记录也一定物理地紧跟其后。一张表只能有一个聚簇索引，所以非常珍贵，必须慎重设置，一般要根据这个表最常用的SQL查询方式选择某个（或多个）字段作为聚簇索引（<strong>或复合聚簇索引</strong>）。</p><ol><li>InnoDB对主键建立聚簇索引。</li><li>如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。</li><li>如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引。</li></ol><h2 id=3索引的最左匹配>3、索引的最左匹配<a hidden class=anchor aria-hidden=true href=#3索引的最左匹配>#</a></h2><p>最左前缀匹配原则，非常重要的原则，建立一个索引，对于索引中的字段，mysql会一直向右匹配直到遇到范围查询(>、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p><p>mysql创建复合索引的规则是首先会对复合索引的最左边的，也就是第一个name字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的cid字段进行排序。其实就相当于实现了类似 order by name cid这样一种排序规则。
所以：第一个name字段是绝对有序的，而第二字段就是无序的了。所以通常情况下，直接使用第二个cid字段进行条件判断是用不到索引的。</p><p>在第一个值等值匹配的前提下，第二个值是有序的，因此mysql索引规则中要求复合索引要想使用第二个索引，必须先使用第一个索引的原因。（而且第一个索引必须是<strong>等值匹配</strong>）。</p><p><code>order by</code>也会用到索引，但前提是 <code>where</code>子句必须用到索引；如果 <code>where</code>子句的字段没有索引，即使<code>order by</code>的字段有索引也不会用到。<code>where</code>和<code>order by</code>使用的索引可以是同一个组合索引，同样符合最左匹配原则，比如 <code>select * from tb_user where name = "lu" and age &lt; 21 order by score</code>，如果有 <code>(name, age, score)</code> 的组合索引，由于 <code>age</code> 使用了范围搜索，<code>score</code> 索引就会失效。</p><h2 id=4innodb-的-btree>4、InnoDB 的 B+Tree<a hidden class=anchor aria-hidden=true href=#4innodb-的-btree>#</a></h2><p>B-Tree 和 B+Tree 的区别在于：</p><ol><li>B-Tree 中，所有节点都会带有指向具体记录的指针；B+Tree 中只有叶子结点会带有指向具体记录的指针。</li><li>B-Tree 中不同的叶子之间没有连在一起；B+Tree 中所有的叶子结点通过指针连接在一起。</li><li>B-Tree 中可能在非叶子结点就拿到了指向具体记录的指针，搜索效率不稳定；B+Tree 中，一定要到叶子结点中才可以获取到具体记录的指针，搜索效率稳定。</li></ol><p>基于上面分析，可以得出如下结论：</p><ol><li>B+Tree 中，由于非叶子结点不带有指向具体记录的指针，所以非叶子结点中可以存储更多的索引项，这样就可以有效降低树的高度，进而提高搜索的效率。</li><li>B+Tree 中，叶子结点通过指针连接在一起，这样如果有范围扫描的需求，那么实现起来将非常容易，而对于 B-Tree，范围扫描则需要不停的在叶子结点和非叶子结点之间移动。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tex data-lang=tex><span style=display:flex><span>计算机在存储数据的时候，最小存储单元是扇区，一个扇区的大小是 512 字节，而文件系统（例如 XFS/EXT4）最小单元是块，一个块的大小是 4KB。InnoDB 引擎存储数据的时候，是以页为单位的，每个数据页的大小默认是 16KB，即四个块。
</span></span></code></pre></div><p><strong>非叶子结点存储的是主键值+指针</strong></p><p>由于一页存储一个非叶子节点，主键值为 4 或 8 字节，InnoDB 的指针为 6 字节，因此，一个非叶子节点约可以指向 1000+ 个页。若按一条数据 1 KB 计算，则一个三层的b+树约可以存储 2100 万条数据。</p><p>在 InnoDB 存储引擎中，B+Tree 的高度一般为 2-4 层，这就可以满足千万级的数据的存储，查找数据的时候，一次页的查找代表一次 IO，那我们通过主键索引查询的时候，其实最多只需要 2-4 次 IO 操作就可以了。</p><h2 id=5回表>5、回表<a hidden class=anchor aria-hidden=true href=#5回表>#</a></h2><h3 id=51回表>5.1、回表<a hidden class=anchor aria-hidden=true href=#51回表>#</a></h3><ol><li>如果是通过主键索引来查询数据，只需要搜索主键索引的 B+Tree 就可以找到数据。</li><li>如果是通过非主键索引来查询数据，例如 <code>select * from user where username='javaboy'</code>，那么此时需要先搜索 username 这一列索引的 B+Tree，搜索完成后得到主键的值，然后再去搜索主键索引的 B+Tree，就可以获取到一行完整的数据。</li></ol><p>对于第二种查询方式而言，一共搜索了两棵 B+Tree，<strong>第一次搜索 B+Tree 拿到主键值后再去搜索主键索引的 B+Tree，这个过程就是所谓的回表。</strong></p><h3 id=52覆盖索引>5.2、覆盖索引<a hidden class=anchor aria-hidden=true href=#52覆盖索引>#</a></h3><p><strong>但不使用主键索引不一定需要回表</strong>：覆盖索引</p><p>如果辅助索引上已经存在我们需要的数据,那么引擎就不会去主键上去搜索数据了。 &mdash;- 这个就是所谓的"<strong>覆盖索引</strong>"</p><p>普通索引、唯一索引、组合索引都可以是覆盖索引，只要满足所查询的字段全部都在辅助索引就行，这样就无需回表。</p><h3 id=53索引下推>5.3、索引下推<a hidden class=anchor aria-hidden=true href=#53索引下推>#</a></h3><p>索引下推(Index Condition Pushdown，简称ICP)，是MySQL5.6版本的新特性，它能减少回表查询次数，提高查询效率。</p><p>MySQL服务层负责SQL语法解析、生成执行计划等，并调用存储引擎层去执行数据的存储和检索。</p><p><code>索引下推</code>的<strong>下推</strong>其实就是指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理。</p><p>我们来具体看一下，在没有使用ICP的情况下，MySQL的查询：</p><ul><li>存储引擎读取索引记录；</li><li>根据索引中的主键值，定位并读取完整的行记录；</li><li>存储引擎把记录交给<code>Server</code>层去检测该记录是否满足<code>WHERE</code>条件。</li></ul><p>使用ICP的情况下，查询过程：</p><ul><li>存储引擎读取索引记录（不是完整的行记录）；</li><li>判断<code>WHERE</code>条件中的一部分能否用索引中的列来做检查，条件不满足，则处理下一行索引记录；</li><li>条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）；</li><li>存储引擎把记录交给<code>Server</code>层，<code>Server</code>层检测该记录是否满足<code>WHERE</code>条件的其余部分。</li></ul><h2 id=6为什么数据库中建议使用自增主键>6、为什么数据库中建议使用自增主键<a hidden class=anchor aria-hidden=true href=#6为什么数据库中建议使用自增主键>#</a></h2><ol><li>自增主键往往占用空间比较小，int 占 4 个字节，bigint 占 8 个字节。由于辅助索引的叶子节点存储的就是主键，所以如果主键占用空间小，则辅助索引的叶子节点占用的空间就小；同时主键索引的非叶子节点存储的就是主键值，如果主键占用空间小那么一个非叶子节点能指向的子节点更多，从而降低 B+Tree 的高度，提高搜索效率。</li><li>自增主键插入的时候比较快，直接插入即可，即使最右侧的节点分裂也不需要挪动其他记录；而其他非自增主键插入的时候，可能要插入到两个已有的数据中间，就有可能导致节点分裂等问题，插入效率低，需要挪动其他记录。</li></ol><h2 id=7索引创建>7、索引创建<a hidden class=anchor aria-hidden=true href=#7索引创建>#</a></h2><h3 id=71创建索引>7.1、创建索引<a hidden class=anchor aria-hidden=true href=#71创建索引>#</a></h3><p><strong>建表时创建</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#960050;background-color:#1e0010>表名</span>(
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>字段名</span> <span style=color:#960050;background-color:#1e0010>数据类型</span> [<span style=color:#960050;background-color:#1e0010>完整性约束条件</span>],
</span></span><span style=display:flex><span>       <span style=color:#960050;background-color:#1e0010>……，</span>
</span></span><span style=display:flex><span>[<span style=color:#66d9ef>UNIQUE</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>PRIMARY</span>] <span style=color:#66d9ef>INDEX</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>KEY</span>
</span></span><span style=display:flex><span>[<span style=color:#960050;background-color:#1e0010>索引名</span>](<span style=color:#960050;background-color:#1e0010>字段名</span><span style=color:#ae81ff>1</span> [(<span style=color:#960050;background-color:#1e0010>长度</span>)] [<span style=color:#66d9ef>ASC</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>DESC</span>]) [<span style=color:#66d9ef>USING</span> <span style=color:#960050;background-color:#1e0010>索引方法</span>]
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>UNIQUE：唯一索引；PRIMARY：主键索引；什么都不加就是普通索引。INDEX和KEY作用一样，可以相互替换</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#a6e22e>projectfile</span> (
</span></span><span style=display:flex><span>	id <span style=color:#66d9ef>INT</span> <span style=color:#66d9ef>AUTO_INCREMENT</span> COMMENT <span style=color:#e6db74>&#39;附件id&#39;</span>,
</span></span><span style=display:flex><span>	projectid <span style=color:#66d9ef>INT</span> COMMENT <span style=color:#e6db74>&#39;项目id;此列受project表中的id列约束&#39;</span>,
</span></span><span style=display:flex><span>	filename <span style=color:#66d9ef>VARCHAR</span> (<span style=color:#ae81ff>512</span>) COMMENT <span style=color:#e6db74>&#39;附件名&#39;</span>,
</span></span><span style=display:flex><span>	filesize <span style=color:#66d9ef>BIGINT</span> COMMENT <span style=color:#e6db74>&#39;附件大小，单位Byte&#39;</span>,
</span></span><span style=display:flex><span>	<span style=color:#75715e>-- 主键索引
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> (id),
</span></span><span style=display:flex><span>	<span style=color:#75715e>-- 唯一索引
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>UNIQUE</span> <span style=color:#66d9ef>KEY</span> (projectid),
</span></span><span style=display:flex><span>	<span style=color:#75715e>-- 普通索引
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>KEY</span> (filename)
</span></span><span style=display:flex><span>    <span style=color:#75715e>-- 组合索引
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>KEY</span> (filename, filesize)
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>ENGINE</span> <span style=color:#f92672>=</span> INNODB <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>CHARSET</span> <span style=color:#f92672>=</span> utf8 COMMENT <span style=color:#e6db74>&#39;项目附件表&#39;</span>;
</span></span></code></pre></div><p><strong>建表后创建：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#960050;background-color:#1e0010>表名</span> <span style=color:#66d9ef>ADD</span> [<span style=color:#66d9ef>UNIQUE</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>PRIMARY</span>]  <span style=color:#66d9ef>INDEX</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>KEY</span>  
</span></span><span style=display:flex><span>[<span style=color:#960050;background-color:#1e0010>索引名</span>] (<span style=color:#960050;background-color:#1e0010>字段名</span><span style=color:#ae81ff>1</span> [(<span style=color:#960050;background-color:#1e0010>长度</span>)] [<span style=color:#66d9ef>ASC</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>DESC</span>]) [<span style=color:#66d9ef>USING</span> <span style=color:#960050;background-color:#1e0010>索引方法</span>]<span style=color:#960050;background-color:#1e0010>；</span>
</span></span></code></pre></div><p>字段名后的长度用于创建前缀索引，只能用于字符串类型，上方一样。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> projectfile <span style=color:#66d9ef>ADD</span> <span style=color:#66d9ef>KEY</span> (filename, filesize);
</span></span></code></pre></div><h3 id=72查看已创建的索引>7.2、查看已创建的索引<a hidden class=anchor aria-hidden=true href=#72查看已创建的索引>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#66d9ef>show</span> <span style=color:#66d9ef>index</span> <span style=color:#66d9ef>from</span> <span style=color:#960050;background-color:#1e0010>表名</span>;
</span></span></code></pre></div><h3 id=73删除索引>7.3、删除索引<a hidden class=anchor aria-hidden=true href=#73删除索引>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#960050;background-color:#1e0010>表名</span> <span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>INDEX</span> <span style=color:#960050;background-color:#1e0010>索引名</span>
</span></span></code></pre></div><h3 id=74查看sql语句对索引的使用情况>7.4、查看SQL语句对索引的使用情况<a hidden class=anchor aria-hidden=true href=#74查看sql语句对索引的使用情况>#</a></h3><p>在select语句前加上EXPLAIN即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#66d9ef>EXPLAIN</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> <span style=color:#f92672>`</span>projectfile<span style=color:#f92672>`</span> pf <span style=color:#66d9ef>WHERE</span> pf.filename <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Jane&#39;</span>;
</span></span></code></pre></div><h2 id=8在枚举字段上创建索引>8、在枚举字段上创建索引<a hidden class=anchor aria-hidden=true href=#8在枚举字段上创建索引>#</a></h2><p>如性别的列，只有男、女两种属性，在该列上建索引。在所有数据中可能男很多，女很少；或相反；或相等相差不多。</p><ul><li><p>如果where 只查索引字段，查询会使用索引，且效率提升明显！</p><ul><li>原理：只查索引字段意味着每个索引命中产生的回表操作都能得到一条有效数据，这样可以过滤掉一半的数据提升效率</li></ul></li><li><p>如果where 查询索引字段+非索引字段，如果查询索引枚举值较少的这部分数据，效率有提升；</p><ul><li>原理：枚举值较少时，能过滤掉大部分数据行，即使存在浪费的回表操作，也能提升效率</li></ul></li><li><p>如果where 查询索引字段+非索引字段，如果查询枚举值相差不大或者查询较多的这部分数据时，索引大大降低了查询效率！可怕的是，比全表索引效率还要低的多！</p><ul><li>原理：由于只有枚举字段有索引，无法利用到索引下推，故每命中一条索引都需要回表。但由于其他检索条件的限制，这其中的大量回表操作得不到有效的数据，这些IO是浪费的。而全表扫描虽然需要扫描更多数据行，但相比大量IO操作，要更高效。</li></ul></li></ul><h2 id=9索引失效情况>9、索引失效情况<a hidden class=anchor aria-hidden=true href=#9索引失效情况>#</a></h2><ol><li>使用组合索引时，需要遵循“最左前缀”原则;</li><li>不在索引列上做任何操作，例如计算、函数、类型转换，会导致索引失效而转向全表扫描;</li><li>尽量使用覆盖索引(之访问索引列的查询)，减少 select * 覆盖索引能减少回表次数;</li><li>MySQL在使用不等于(!=或者&lt;>)的时候无法使用索引会导致全表扫描;</li><li>LIKE以通配符开头(%abc)MySQL索引会失效变成全表扫描的操作;</li><li>字符串不加单引号会导致索引失效(可能发生了索引列的隐式转换);</li><li>少用or，用它来连接时只有一个索引生效，另一个会索引失效。</li></ol><h2 id=10重建索引>10、重建索引<a hidden class=anchor aria-hidden=true href=#10重建索引>#</a></h2><p>什么时候需要重建索引？</p><ol><li>表上频繁发生update,delete操作;</li><li>表上发生了alter table ..move操作(move操作会使索引失效)。</li></ol><p>怎么判断索引是否应该重建？</p><p>对索引结构进行分析，如果索引高度超过 4 或者 B+树倾斜严重时需要重建索引</p><p>如何重建索引？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#ae81ff>1</span>. <span style=color:#960050;background-color:#1e0010>先</span> <span style=color:#66d9ef>drop</span> <span style=color:#960050;background-color:#1e0010>索引，再</span> <span style=color:#66d9ef>create</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>. <span style=color:#66d9ef>alter</span> <span style=color:#66d9ef>index</span> indexname rebuild online<span style=color:#960050;background-color:#1e0010>；</span>
</span></span></code></pre></div><p>rebuild是快速重建索引的一种有效的办法，因为它是一种使用现有索引项来重建新索引的方法。由于新旧索引在建立时同时存在，因此，使用这种重建方法需要有额外的磁盘空间可供 临时使用，当索引建完后把老索引删除，如果没有成功，也不会影响原来的索引。利用这种办法可以用 来将一个索引移到新的表空间。</p><p>Rebuild会阻塞DML操作，rebuild online不会阻塞DML操作；rebuild online时系统会生成一个系统临时日志表，所有rebuild online时索引的变化都记录在这个表中，当新的索引创建完成后，把这个表的记录维护到新的索引 中去，然后drop掉旧的索引，rebuild online就完成了。</p><p>Rebuild操作会产生大量Redo Log;</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%B0%8F%E7%9F%A5%E8%AF%86/><span class=title>« Prev</span><br><span>MySQL小知识</span>
</a><a class=next href=http://localhost:1313/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/><span class=title>Next »</span><br><span>事务实现原理</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>