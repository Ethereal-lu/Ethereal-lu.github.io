<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>IO 多路复用 | lu</title>
<meta name=keywords content><meta name=description content="1、概念
IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件描述符；一旦某个文件描述符就绪，就能够通知应用程序进行相应的读写操作；没有文件描述符就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程。
文件描述符：Linux 中一切都可以看作文件，包括普通文件、链接文件、Socket  以及设备驱动等，对其进行相关操作时，都可能会创建对应的文件描述符。文件描述符（file  descriptor）是内核为了高效管理已被打开的文件所创建的索引，用于指代被打开的文件，对文件所有 I/O  操作相关的系统调用都需要通过文件描述符。
Socket：在Linux 中，Socket 也是文件，发送端将数据写进发送方的 Socket ，再通过网卡、路由到接收方的 Socket ，接收方程序将数据从接收方 Socket 中读出来使用。一个 Socket 由<协议、发送方 IP、发送方 Port、接收方 IP、接收方 Port> 五元组描述。总之，Socket 就是一个文件，同样可以进行读写。
2、Linux IO模型
目前Linux系统中提供了5种IO处理模型

阻塞IO
非阻塞IO
IO多路复用
信号驱动IO
异步IO

阻塞IO
阻塞IO意味着当我们发起一次IO操作后一直等待成功或失败之后才返回，在这期间程序不能做其它的事情。阻塞IO操作只能对单个文件描述符进行操作，如果文件描述符不就绪就阻塞。

服务端采用单线程，当accept一个请求后，在recv或send调用阻塞时，将无法accept其他请求（必须等上一个请求处recv或send完），无法处理并发。
服务器端采用多线程，当accept一个请求后，开启线程进行recv，可以完成并发处理，但随着请求数增加需要增加系统线程，大量的线程占用很大的内存空间，并且线程切换会带来很大的开销。

非阻塞IO
服务器端当accept一个请求后，加入fds集合，每次轮询一遍fds，若IO失败则返回错误，每次轮询所有fd（包括没有发生读写事件的fd）会很浪费cpu
IO多路复用
个人认为IO多路复用是吸收了阻塞IO和非阻塞IO的优点的一种IO方式，即同时可以对多个请求进行处理，但当所有请求不就绪时会阻塞，不占用CPU资源。
服务器端采用单线程通过select/epoll等系统调用获取fd列表，遍历活跃（即有读写事件）的fd进行accept/recv/send，使其能支持更多的并发连接请求。
3、IO多路复用的实现
3.1、select


select 每个进程可同时监听的文件描述符数量最大为 1024，虽然可以设置，但是会降低网络效率。


每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大


对socket扫描时是线性扫描，采用轮询的方法，效率较低（高并发时）


后面的不重要
数据结构：fd_set简单地理解为一个长度是1024的比特位，每个比特位表示一个需要处理的FD，如果是1，那么表示这个FD有需要处理的I/O事件，否则没有。
select 在调用期间会一直阻塞。
select将监听的文件描述符分为三组，分别是：read_fds是需要进行读操作的文件描述符，write_fds是需要进行写操作的文件描述符，except_fds是需要进行异常事件处理的文件描述符。
3.2、poll
poll 仅仅时取消了 1024 的限制，其他和 select 一样，不分为三组。poll 是 fd 数组。
3.3、epoll
epoll 底层是红黑树 + 链表。红黑树存储所有需要监听的 fd（文件描述符），链表存储活跃（有读写事件）的fd。"><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/posts/linux/io/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/posts/linux/io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/posts/linux/io/"><meta property="og:site_name" content="lu"><meta property="og:title" content="IO 多路复用"><meta property="og:description" content="1、概念 IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件描述符；一旦某个文件描述符就绪，就能够通知应用程序进行相应的读写操作；没有文件描述符就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程。
文件描述符：Linux 中一切都可以看作文件，包括普通文件、链接文件、Socket 以及设备驱动等，对其进行相关操作时，都可能会创建对应的文件描述符。文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，用于指代被打开的文件，对文件所有 I/O 操作相关的系统调用都需要通过文件描述符。
Socket：在Linux 中，Socket 也是文件，发送端将数据写进发送方的 Socket ，再通过网卡、路由到接收方的 Socket ，接收方程序将数据从接收方 Socket 中读出来使用。一个 Socket 由<协议、发送方 IP、发送方 Port、接收方 IP、接收方 Port> 五元组描述。总之，Socket 就是一个文件，同样可以进行读写。
2、Linux IO模型 目前Linux系统中提供了5种IO处理模型
阻塞IO 非阻塞IO IO多路复用 信号驱动IO 异步IO 阻塞IO 阻塞IO意味着当我们发起一次IO操作后一直等待成功或失败之后才返回，在这期间程序不能做其它的事情。阻塞IO操作只能对单个文件描述符进行操作，如果文件描述符不就绪就阻塞。
服务端采用单线程，当accept一个请求后，在recv或send调用阻塞时，将无法accept其他请求（必须等上一个请求处recv或send完），无法处理并发。 服务器端采用多线程，当accept一个请求后，开启线程进行recv，可以完成并发处理，但随着请求数增加需要增加系统线程，大量的线程占用很大的内存空间，并且线程切换会带来很大的开销。 非阻塞IO 服务器端当accept一个请求后，加入fds集合，每次轮询一遍fds，若IO失败则返回错误，每次轮询所有fd（包括没有发生读写事件的fd）会很浪费cpu
IO多路复用 个人认为IO多路复用是吸收了阻塞IO和非阻塞IO的优点的一种IO方式，即同时可以对多个请求进行处理，但当所有请求不就绪时会阻塞，不占用CPU资源。
服务器端采用单线程通过select/epoll等系统调用获取fd列表，遍历活跃（即有读写事件）的fd进行accept/recv/send，使其能支持更多的并发连接请求。
3、IO多路复用的实现 3.1、select select 每个进程可同时监听的文件描述符数量最大为 1024，虽然可以设置，但是会降低网络效率。
每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大
对socket扫描时是线性扫描，采用轮询的方法，效率较低（高并发时）
后面的不重要
数据结构：fd_set简单地理解为一个长度是1024的比特位，每个比特位表示一个需要处理的FD，如果是1，那么表示这个FD有需要处理的I/O事件，否则没有。
select 在调用期间会一直阻塞。
select将监听的文件描述符分为三组，分别是：read_fds是需要进行读操作的文件描述符，write_fds是需要进行写操作的文件描述符，except_fds是需要进行异常事件处理的文件描述符。
3.2、poll poll 仅仅时取消了 1024 的限制，其他和 select 一样，不分为三组。poll 是 fd 数组。
3.3、epoll epoll 底层是红黑树 + 链表。红黑树存储所有需要监听的 fd（文件描述符），链表存储活跃（有读写事件）的fd。"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-09T19:42:15+00:00"><meta property="article:modified_time" content="2022-04-09T19:42:15+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="IO 多路复用"><meta name=twitter:description content="1、概念
IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件描述符；一旦某个文件描述符就绪，就能够通知应用程序进行相应的读写操作；没有文件描述符就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程。
文件描述符：Linux 中一切都可以看作文件，包括普通文件、链接文件、Socket  以及设备驱动等，对其进行相关操作时，都可能会创建对应的文件描述符。文件描述符（file  descriptor）是内核为了高效管理已被打开的文件所创建的索引，用于指代被打开的文件，对文件所有 I/O  操作相关的系统调用都需要通过文件描述符。
Socket：在Linux 中，Socket 也是文件，发送端将数据写进发送方的 Socket ，再通过网卡、路由到接收方的 Socket ，接收方程序将数据从接收方 Socket 中读出来使用。一个 Socket 由<协议、发送方 IP、发送方 Port、接收方 IP、接收方 Port> 五元组描述。总之，Socket 就是一个文件，同样可以进行读写。
2、Linux IO模型
目前Linux系统中提供了5种IO处理模型

阻塞IO
非阻塞IO
IO多路复用
信号驱动IO
异步IO

阻塞IO
阻塞IO意味着当我们发起一次IO操作后一直等待成功或失败之后才返回，在这期间程序不能做其它的事情。阻塞IO操作只能对单个文件描述符进行操作，如果文件描述符不就绪就阻塞。

服务端采用单线程，当accept一个请求后，在recv或send调用阻塞时，将无法accept其他请求（必须等上一个请求处recv或send完），无法处理并发。
服务器端采用多线程，当accept一个请求后，开启线程进行recv，可以完成并发处理，但随着请求数增加需要增加系统线程，大量的线程占用很大的内存空间，并且线程切换会带来很大的开销。

非阻塞IO
服务器端当accept一个请求后，加入fds集合，每次轮询一遍fds，若IO失败则返回错误，每次轮询所有fd（包括没有发生读写事件的fd）会很浪费cpu
IO多路复用
个人认为IO多路复用是吸收了阻塞IO和非阻塞IO的优点的一种IO方式，即同时可以对多个请求进行处理，但当所有请求不就绪时会阻塞，不占用CPU资源。
服务器端采用单线程通过select/epoll等系统调用获取fd列表，遍历活跃（即有读写事件）的fd进行accept/recv/send，使其能支持更多的并发连接请求。
3、IO多路复用的实现
3.1、select


select 每个进程可同时监听的文件描述符数量最大为 1024，虽然可以设置，但是会降低网络效率。


每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大


对socket扫描时是线性扫描，采用轮询的方法，效率较低（高并发时）


后面的不重要
数据结构：fd_set简单地理解为一个长度是1024的比特位，每个比特位表示一个需要处理的FD，如果是1，那么表示这个FD有需要处理的I/O事件，否则没有。
select 在调用期间会一直阻塞。
select将监听的文件描述符分为三组，分别是：read_fds是需要进行读操作的文件描述符，write_fds是需要进行写操作的文件描述符，except_fds是需要进行异常事件处理的文件描述符。
3.2、poll
poll 仅仅时取消了 1024 的限制，其他和 select 一样，不分为三组。poll 是 fd 数组。
3.3、epoll
epoll 底层是红黑树 + 链表。红黑树存储所有需要监听的 fd（文件描述符），链表存储活跃（有读写事件）的fd。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ethereal-lu.github.io/posts/"},{"@type":"ListItem","position":2,"name":"IO 多路复用","item":"https://ethereal-lu.github.io/posts/linux/io/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"IO 多路复用","name":"IO 多路复用","description":"1、概念 IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件描述符；一旦某个文件描述符就绪，就能够通知应用程序进行相应的读写操作；没有文件描述符就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程。\n文件描述符：Linux 中一切都可以看作文件，包括普通文件、链接文件、Socket 以及设备驱动等，对其进行相关操作时，都可能会创建对应的文件描述符。文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，用于指代被打开的文件，对文件所有 I/O 操作相关的系统调用都需要通过文件描述符。\nSocket：在Linux 中，Socket 也是文件，发送端将数据写进发送方的 Socket ，再通过网卡、路由到接收方的 Socket ，接收方程序将数据从接收方 Socket 中读出来使用。一个 Socket 由\u0026lt;协议、发送方 IP、发送方 Port、接收方 IP、接收方 Port\u0026gt; 五元组描述。总之，Socket 就是一个文件，同样可以进行读写。\n2、Linux IO模型 目前Linux系统中提供了5种IO处理模型\n阻塞IO 非阻塞IO IO多路复用 信号驱动IO 异步IO 阻塞IO 阻塞IO意味着当我们发起一次IO操作后一直等待成功或失败之后才返回，在这期间程序不能做其它的事情。阻塞IO操作只能对单个文件描述符进行操作，如果文件描述符不就绪就阻塞。\n服务端采用单线程，当accept一个请求后，在recv或send调用阻塞时，将无法accept其他请求（必须等上一个请求处recv或send完），无法处理并发。 服务器端采用多线程，当accept一个请求后，开启线程进行recv，可以完成并发处理，但随着请求数增加需要增加系统线程，大量的线程占用很大的内存空间，并且线程切换会带来很大的开销。 非阻塞IO 服务器端当accept一个请求后，加入fds集合，每次轮询一遍fds，若IO失败则返回错误，每次轮询所有fd（包括没有发生读写事件的fd）会很浪费cpu\nIO多路复用 个人认为IO多路复用是吸收了阻塞IO和非阻塞IO的优点的一种IO方式，即同时可以对多个请求进行处理，但当所有请求不就绪时会阻塞，不占用CPU资源。\n服务器端采用单线程通过select/epoll等系统调用获取fd列表，遍历活跃（即有读写事件）的fd进行accept/recv/send，使其能支持更多的并发连接请求。\n3、IO多路复用的实现 3.1、select select 每个进程可同时监听的文件描述符数量最大为 1024，虽然可以设置，但是会降低网络效率。\n每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大\n对socket扫描时是线性扫描，采用轮询的方法，效率较低（高并发时）\n后面的不重要\n数据结构：fd_set简单地理解为一个长度是1024的比特位，每个比特位表示一个需要处理的FD，如果是1，那么表示这个FD有需要处理的I/O事件，否则没有。\nselect 在调用期间会一直阻塞。\nselect将监听的文件描述符分为三组，分别是：read_fds是需要进行读操作的文件描述符，write_fds是需要进行写操作的文件描述符，except_fds是需要进行异常事件处理的文件描述符。\n3.2、poll poll 仅仅时取消了 1024 的限制，其他和 select 一样，不分为三组。poll 是 fd 数组。\n3.3、epoll epoll 底层是红黑树 + 链表。红黑树存储所有需要监听的 fd（文件描述符），链表存储活跃（有读写事件）的fd。\n","keywords":[],"articleBody":"1、概念 IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件描述符；一旦某个文件描述符就绪，就能够通知应用程序进行相应的读写操作；没有文件描述符就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程。\n文件描述符：Linux 中一切都可以看作文件，包括普通文件、链接文件、Socket 以及设备驱动等，对其进行相关操作时，都可能会创建对应的文件描述符。文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，用于指代被打开的文件，对文件所有 I/O 操作相关的系统调用都需要通过文件描述符。\nSocket：在Linux 中，Socket 也是文件，发送端将数据写进发送方的 Socket ，再通过网卡、路由到接收方的 Socket ，接收方程序将数据从接收方 Socket 中读出来使用。一个 Socket 由\u003c协议、发送方 IP、发送方 Port、接收方 IP、接收方 Port\u003e 五元组描述。总之，Socket 就是一个文件，同样可以进行读写。\n2、Linux IO模型 目前Linux系统中提供了5种IO处理模型\n阻塞IO 非阻塞IO IO多路复用 信号驱动IO 异步IO 阻塞IO 阻塞IO意味着当我们发起一次IO操作后一直等待成功或失败之后才返回，在这期间程序不能做其它的事情。阻塞IO操作只能对单个文件描述符进行操作，如果文件描述符不就绪就阻塞。\n服务端采用单线程，当accept一个请求后，在recv或send调用阻塞时，将无法accept其他请求（必须等上一个请求处recv或send完），无法处理并发。 服务器端采用多线程，当accept一个请求后，开启线程进行recv，可以完成并发处理，但随着请求数增加需要增加系统线程，大量的线程占用很大的内存空间，并且线程切换会带来很大的开销。 非阻塞IO 服务器端当accept一个请求后，加入fds集合，每次轮询一遍fds，若IO失败则返回错误，每次轮询所有fd（包括没有发生读写事件的fd）会很浪费cpu\nIO多路复用 个人认为IO多路复用是吸收了阻塞IO和非阻塞IO的优点的一种IO方式，即同时可以对多个请求进行处理，但当所有请求不就绪时会阻塞，不占用CPU资源。\n服务器端采用单线程通过select/epoll等系统调用获取fd列表，遍历活跃（即有读写事件）的fd进行accept/recv/send，使其能支持更多的并发连接请求。\n3、IO多路复用的实现 3.1、select select 每个进程可同时监听的文件描述符数量最大为 1024，虽然可以设置，但是会降低网络效率。\n每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大\n对socket扫描时是线性扫描，采用轮询的方法，效率较低（高并发时）\n后面的不重要\n数据结构：fd_set简单地理解为一个长度是1024的比特位，每个比特位表示一个需要处理的FD，如果是1，那么表示这个FD有需要处理的I/O事件，否则没有。\nselect 在调用期间会一直阻塞。\nselect将监听的文件描述符分为三组，分别是：read_fds是需要进行读操作的文件描述符，write_fds是需要进行写操作的文件描述符，except_fds是需要进行异常事件处理的文件描述符。\n3.2、poll poll 仅仅时取消了 1024 的限制，其他和 select 一样，不分为三组。poll 是 fd 数组。\n3.3、epoll epoll 底层是红黑树 + 链表。红黑树存储所有需要监听的 fd（文件描述符），链表存储活跃（有读写事件）的fd。\n使用 epoll 主要是使用如下三个系统调用\n// 创建一个 epoll 实例 int epoll_create(int size); // epoll_ctl 负责把 fd 增加、删除到内核红黑树 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); // epoll_wait 负责检测可读链表，没有可读 fd 则阻塞进程 int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); 不同于select和poll 的线性扫描，epoll 每次查询只需要看可读链表中是否有元素即可，是 O(1) 的时间复杂度。\n事件：\n可读事件，当文件描述符关联的内核读缓冲区可读，则触发可读事件。 (可读：内核缓冲区非空，有数据可以读取)\n可写事件，当文件描述符关联的内核写缓冲区可写，则触发可写事件。 (可写：内核缓冲区不满，有空闲空间可以写入）\n边沿触发vs水平触发 epoll事件有两种模型，边沿触发：edge-triggered (ET)， 水平触发：level-triggered (LT)\n水平触发(level-triggered)\nsocket接收缓冲区不为空 有数据可读 读事件一直触发 socket发送缓冲区不满 可以继续写入数据 写事件一直触发 边沿触发(edge-triggered)\nsocket的接收缓冲区状态变化时触发读事件，即空的接收缓冲区刚接收到数据时触发读事件 socket的发送缓冲区状态变化时触发写事件，即满的缓冲区刚空出空间时触发读事件 边沿触发仅触发一次，水平触发会一直触发。\nlibevent 采用水平触发， nginx 采用边沿触发\nJDK在Linux已经默认使用epoll方式，但是JDK的epoll采用的是水平触发，而Netty重新实现了epoll机制，采用边缘触发方式。\n4、redis 使用的IO模型 下面这篇文章可以对 非阻塞IO 与 IO多路复用 的作用解释的更通透。\nredis专题11 线程IO模型\n5、进程间通信方式 5.1、管道 操作系统分为内核态和用户态，管道就是在内核中开辟一块缓冲区，不同的进程通过对这个缓冲取进行读写操作实现IPC。管道具有半双工通信，同步与互斥，提供字节流服务，生命周期随进程的特点。\n匿名管道：父进程调用 pipe 函数在内核中开辟一块缓冲区作为管道，同时得到该管道的文件描述符。然后通过 fork 创建子进程，根据读时共享子进程也会有管道的文件描述符，故父子进程可以通过文件描述符指向的管道通信。由于该管道只是给父进程返回文件描述符，但其自身并没有标识符，因此匿名管道只能用于父子进程。 文件描述符：指向内核为每一个进程所维护的该进程打开文件的记录表。 文件标识符：与特定进程无关，是系统定义的一个结构，包含文件名、文件状态和文件位置等信息。 命名管道：命名管道也是内核中的一块缓冲区，但是这块缓冲区有具体的标识符，不同进程可以通过标识符来对管道进行操作，从而达到通信的目的。 5.2、共享内存 共享内存是最快的进程间通信方式。\n共享内存的本质是直接在内核中开辟一块物理内存，多个进程可以将自己的虚拟地址映射到这块内存上面从而达到通信的目的，相比于其他方式，这种方式有效的降低了输入输出数据的拷贝次数，从而提高了效率。\n5.3、Socket Socket 即通过 tcp 建立连接的双方使用收发缓冲区进行通信。\n5.4、信号 如 kill -9 等。\n","wordCount":"175","inLanguage":"en","datePublished":"2022-04-09T19:42:15Z","dateModified":"2022-04-09T19:42:15Z","author":{"@type":"Person","name":"lu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ethereal-lu.github.io/posts/linux/io/"},"publisher":{"@type":"Organization","name":"lu","logo":{"@type":"ImageObject","url":"https://ethereal-lu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="lu (Alt + H)">lu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethereal-lu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ethereal-lu.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">IO 多路复用</h1><div class=post-meta><span title='2022-04-09 19:42:15 +0000 UTC'>2022-04-09</span>&nbsp;·&nbsp;175 words&nbsp;·&nbsp;lu</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1概念>1、概念</a></li><li><a href=#2linux-io模型>2、Linux IO模型</a><ul><li></li></ul></li><li><a href=#3io多路复用的实现>3、IO多路复用的实现</a><ul><li><a href=#31select>3.1、select</a></li><li><a href=#32poll>3.2、poll</a></li><li><a href=#33epoll>3.3、epoll</a></li></ul></li><li><a href=#4redis-使用的io模型>4、redis 使用的IO模型</a></li><li><a href=#5进程间通信方式>5、进程间通信方式</a><ul><li><a href=#51管道>5.1、管道</a></li><li><a href=#52共享内存>5.2、共享内存</a></li><li><a href=#53socket>5.3、Socket</a></li><li><a href=#54信号>5.4、信号</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=1概念>1、概念<a hidden class=anchor aria-hidden=true href=#1概念>#</a></h2><p><strong>IO多路复用</strong>是一种同步IO模型，实现一个线程可以监视多个文件描述符；一旦某个文件描述符就绪，就能够通知应用程序进行相应的读写操作；没有文件描述符就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程。</p><p><strong><a href=https://zhuanlan.zhihu.com/p/143847169>文件描述符</a></strong>：Linux 中一切都可以看作文件，包括普通文件、链接文件、Socket 以及设备驱动等，对其进行相关操作时，都可能会创建对应的文件描述符。文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，用于指代被打开的文件，对文件所有 I/O 操作相关的系统调用都需要通过文件描述符。</p><p><strong><a href=https://zhuanlan.zhihu.com/p/234806787>Socket</a></strong>：在Linux 中，Socket 也是文件，发送端将数据写进发送方的 Socket ，再通过网卡、路由到接收方的 Socket ，接收方程序将数据从接收方 Socket 中读出来使用。一个 Socket 由&lt;协议、发送方 IP、发送方 Port、接收方 IP、接收方 Port> 五元组描述。总之，Socket 就是一个文件，同样可以进行读写。</p><h2 id=2linux-io模型>2、Linux IO模型<a hidden class=anchor aria-hidden=true href=#2linux-io模型>#</a></h2><p>目前Linux系统中提供了5种IO处理模型</p><ol><li>阻塞IO</li><li>非阻塞IO</li><li>IO多路复用</li><li>信号驱动IO</li><li>异步IO</li></ol><h4 id=阻塞io>阻塞IO<a hidden class=anchor aria-hidden=true href=#阻塞io>#</a></h4><p>阻塞IO意味着当我们发起一次IO操作后一直等待成功或失败之后才返回，在这期间程序不能做其它的事情。阻塞IO操作只能对单个文件描述符进行操作，如果文件描述符不就绪就阻塞。</p><ul><li>服务端采用单线程，当accept一个请求后，在recv或send调用阻塞时，将无法accept其他请求（必须等上一个请求处recv或send完），无法处理并发。</li><li>服务器端采用多线程，当accept一个请求后，开启线程进行recv，可以完成并发处理，但随着请求数增加需要增加系统线程，大量的线程占用很大的内存空间，并且线程切换会带来很大的开销。</li></ul><h4 id=非阻塞io>非阻塞IO<a hidden class=anchor aria-hidden=true href=#非阻塞io>#</a></h4><p>服务器端当accept一个请求后，加入fds集合，每次轮询一遍fds，若IO失败则返回错误，每次轮询所有fd（包括没有发生读写事件的fd）会很浪费cpu</p><h4 id=io多路复用>IO多路复用<a hidden class=anchor aria-hidden=true href=#io多路复用>#</a></h4><p>个人认为IO多路复用是吸收了阻塞IO和非阻塞IO的优点的一种IO方式，即同时可以对多个请求进行处理，但当所有请求不就绪时会阻塞，不占用CPU资源。</p><p>服务器端采用单线程通过select/epoll等系统调用获取fd列表，遍历活跃（即有读写事件）的fd进行accept/recv/send，使其能支持更多的并发连接请求。</p><h2 id=3io多路复用的实现>3、IO多路复用的实现<a hidden class=anchor aria-hidden=true href=#3io多路复用的实现>#</a></h2><h3 id=31select>3.1、select<a hidden class=anchor aria-hidden=true href=#31select>#</a></h3><ul><li><p>select 每个进程可同时监听的文件描述符数量最大为 1024，虽然可以设置，但是会降低网络效率。</p></li><li><p>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</p></li><li><p>对socket扫描时是线性扫描，采用轮询的方法，效率较低（高并发时）</p></li></ul><p>后面的不重要</p><p>数据结构：<code>fd_set</code>简单地理解为一个长度是1024的比特位，每个比特位表示一个需要处理的FD，如果是1，那么表示这个FD有需要处理的I/O事件，否则没有。</p><p>select 在调用期间会一直阻塞。</p><p>select将监听的文件描述符分为三组，分别是：read_fds是需要进行读操作的文件描述符，write_fds是需要进行写操作的文件描述符，except_fds是需要进行异常事件处理的文件描述符。</p><h3 id=32poll>3.2、poll<a hidden class=anchor aria-hidden=true href=#32poll>#</a></h3><p>poll 仅仅时取消了 1024 的限制，其他和 select 一样，不分为三组。poll 是 fd 数组。</p><h3 id=33epoll>3.3、epoll<a hidden class=anchor aria-hidden=true href=#33epoll>#</a></h3><p>epoll 底层是红黑树 + 链表。红黑树存储所有需要监听的 fd（文件描述符），链表存储活跃（有读写事件）的fd。</p><p>使用 epoll 主要是使用如下三个系统调用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// 创建一个 epoll 实例
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_create</span>(<span style=color:#66d9ef>int</span> size); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// epoll_ctl 负责把 fd 增加、删除到内核红黑树
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_ctl</span>(<span style=color:#66d9ef>int</span> epfd, <span style=color:#66d9ef>int</span> op, <span style=color:#66d9ef>int</span> fd, <span style=color:#66d9ef>struct</span> epoll_event <span style=color:#f92672>*</span>event); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// epoll_wait 负责检测可读链表，没有可读 fd 则阻塞进程
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_wait</span>(<span style=color:#66d9ef>int</span> epfd, <span style=color:#66d9ef>struct</span> epoll_event <span style=color:#f92672>*</span> events, <span style=color:#66d9ef>int</span> maxevents, <span style=color:#66d9ef>int</span> timeout);
</span></span></code></pre></div><p>不同于select和poll 的线性扫描，epoll 每次查询只需要看可读链表中是否有元素即可，是 O(1) 的时间复杂度。</p><p><img alt=io复用区别 loading=lazy src=/posts/linux/io/io%E5%A4%8D%E7%94%A8%E5%8C%BA%E5%88%AB.png></p><p><strong>事件</strong>：</p><p>可读事件，当文件描述符关联的内核读缓冲区可读，则触发可读事件。 (可读：内核缓冲区非空，有数据可以读取)</p><p>可写事件，当文件描述符关联的内核写缓冲区可写，则触发可写事件。 (可写：内核缓冲区不满，有空闲空间可以写入）</p><h4 id=边沿触发vs水平触发>边沿触发vs水平触发<a hidden class=anchor aria-hidden=true href=#边沿触发vs水平触发>#</a></h4><p><code>epoll</code>事件有两种模型，边沿触发：edge-triggered (ET)， 水平触发：level-triggered (LT)</p><p><strong>水平触发(level-triggered)</strong></p><ul><li>socket接收缓冲区不为空 有数据可读 读事件一直触发</li><li>socket发送缓冲区不满 可以继续写入数据 写事件一直触发</li></ul><p><strong>边沿触发(edge-triggered)</strong></p><ul><li>socket的接收缓冲区状态变化时触发读事件，即空的接收缓冲区刚接收到数据时触发读事件</li><li>socket的发送缓冲区状态变化时触发写事件，即满的缓冲区刚空出空间时触发读事件</li></ul><p>边沿触发仅触发一次，水平触发会一直触发。</p><p><code>libevent</code> 采用水平触发， <code>nginx</code> 采用边沿触发</p><p>JDK在Linux已经默认使用epoll方式，但是JDK的epoll采用的是水平触发，而Netty重新实现了epoll机制，采用边缘触发方式。</p><h2 id=4redis-使用的io模型>4、redis 使用的IO模型<a hidden class=anchor aria-hidden=true href=#4redis-使用的io模型>#</a></h2><p>下面这篇文章可以对 非阻塞IO 与 IO多路复用 的作用解释的更通透。</p><p><a href=https://researchlab.github.io/2018/10/08/redis-11-redisio/>redis专题11 线程IO模型</a></p><h2 id=5进程间通信方式>5、进程间通信方式<a hidden class=anchor aria-hidden=true href=#5进程间通信方式>#</a></h2><h3 id=51管道>5.1、管道<a hidden class=anchor aria-hidden=true href=#51管道>#</a></h3><p>操作系统分为内核态和用户态，管道就是在内核中开辟一块缓冲区，不同的进程通过对这个缓冲取进行读写操作实现IPC。管道具有半双工通信，同步与互斥，提供字节流服务，生命周期随进程的特点。</p><ul><li>匿名管道：父进程调用 pipe 函数在内核中开辟一块缓冲区作为管道，同时得到该管道的文件描述符。然后通过 fork 创建子进程，根据读时共享子进程也会有管道的文件描述符，故父子进程可以通过文件描述符指向的管道通信。由于该管道只是给父进程返回文件描述符，但其自身并没有标识符，因此匿名管道只能用于父子进程。<ul><li>文件描述符：指向内核为每一个进程所维护的该进程打开文件的记录表。</li><li>文件标识符：与特定进程无关，是系统定义的一个结构，包含文件名、文件状态和文件位置等信息。</li></ul></li><li>命名管道：命名管道也是内核中的一块缓冲区，但是这块缓冲区有具体的标识符，不同进程可以通过标识符来对管道进行操作，从而达到通信的目的。</li></ul><h3 id=52共享内存>5.2、共享内存<a hidden class=anchor aria-hidden=true href=#52共享内存>#</a></h3><p>共享内存是最快的进程间通信方式。</p><p>共享内存的本质是直接在内核中开辟一块物理内存，多个进程可以将自己的虚拟地址映射到这块内存上面从而达到通信的目的，相比于其他方式，这种方式有效的降低了输入输出数据的拷贝次数，从而提高了效率。</p><h3 id=53socket>5.3、Socket<a hidden class=anchor aria-hidden=true href=#53socket>#</a></h3><p>Socket 即通过 tcp 建立连接的双方使用收发缓冲区进行通信。</p><h3 id=54信号>5.4、信号<a hidden class=anchor aria-hidden=true href=#54信号>#</a></h3><p>如 kill -9 等。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/><span class=title>« Prev</span><br><span>Redis持久化</span>
</a><a class=next href=https://ethereal-lu.github.io/posts/linux/linux%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B--fork%E6%96%B9%E6%B3%95/><span class=title>Next »</span><br><span>linux创建子进程--fork()方法</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>