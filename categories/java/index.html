<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java | lu</title>
<meta name=keywords content><meta name=description content><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/categories/java/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity="sha256-1yREUm1+y9sAFUOKf6iQVKZYv3WdBULi5d+BzpS0k+4=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://ethereal-lu.github.io/categories/java/index.xml><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/categories/java/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/categories/java/"><meta property="og:site_name" content="lu"><meta property="og:title" content="Java"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="lu (Alt + H)">lu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://ethereal-lu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ethereal-lu.github.io/categories/>Categories</a></div><h1>Java
<a href=/categories/java/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Netty</h2></header><div class=entry-content><p>1 NIO基础 non-blocking io 非阻塞IO
1.1 三大组件 1.1.1 Channel & Buffer Buffer是内存中的数据缓冲区，Channel 是内存与磁盘之间的数据通道。不同于InputStream、OutputStream等BIO中的流都是单向数据通道，Channel 是双向数据通道，可以从 Channel 将数据读入 Buffer，也可以将Buffer 中的数据写入Channel 。
常见的 Channel 有：
FileChannel ：文件通道 DatagramChannel ：udp SocketChannel ：tcp；客户端服务端都可以 ServerSocketChannel ：tcp；专用于服务端 Buffer 使用最多的就是 ByteBuffer，其他的也是每种基础数据类型有一个对应的Buffer，但用的不多。
1.1.2 Selector 在使用传统BIO开发时，要么对每个连接都新建一个线程处理（线程太多撑爆内存、线程切换成本高），要么使用线程池（阻塞IO，同时只能处理一个连接，线程利用率不高）—> 正因为此，原始的HTTP1.0才使用短连接，一个请求处理完立刻释放连接，让线程可以处理其他请求。
Selector 的作用就是配合一个线程来管理多个Channel ，获取这些Channel 上发生的事件，将有事件发生的Channel 交给线程处理。适合连接数多但流量低的场景，流量大意味着一个Channel 要处理大量数据，会使其他Channel 饥饿。
1.2 ByteBuffer 1.2.1 基本使用 public class TestByteBuffer { public static void main(String[] args) { // 获取 FileChannel try (FileChannel channel = new FileInputStream("data.txt").getChannel()) { // 申请 10 个字节的缓冲区 ByteBuffer buffer = ByteBuffer.allocate(10); // 读取channel中的数据到buffer。read 方法返回读取到的字节数，-1表示读完了 while (channel.read(buffer) != -1) { buffer.flip(); // 切换为读模式 while (buffer.hasRemaining()) { System.out.println(buffer.get()); // get 每次读一个字节 } buffer.clear(); // 切换为写模式 } } catch (IOException e) { e.printStackTrace(); } } } 1.2.2 内部结构 ByteBuffer有以下几个重要属性
...</p></div><footer class=entry-footer><span title='2022-07-09 19:12:41 +0000 UTC'>2022-07-09</span>&nbsp;·&nbsp;1470 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Netty" href=https://ethereal-lu.github.io/posts/java/netty/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>设计模式</h2></header><div class=entry-content><p>1、设计模式分类 创建型模式
用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。
结构型模式
用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。
行为型模式
用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。
2、UML图 统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。
2.1、类的表示方式 在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。
属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：
+：表示public
-：表示private
#：表示protected
属性的完整表示方式是： 可见性 名称 ：类型 [ = 缺省值]
方法的完整表示方式是： 可见性 名称(参数列表) [ ： 返回类型]
2.2、类与类之间关系的表示方式 感觉没必要记，用到时再查吧。
3、软件设计原则 在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。
3.1 开闭原则 对扩展开放，对修改关闭。即使用接口和抽象类，扩展时实现新的派生类而不修改子类。增加新功能时添加新的代码，而不要修改原有代码。
3.2 里氏代换原则 里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。
3.3 依赖倒转原则 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。
简单说就是尽量让接口作为成员变量，而不要让实现类作为成员变量。
3.4 接口隔离原则 客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。
被迫依赖：类 B 为了定义一个已经在类 A 中定义了的方法而去继承类 A，此时类 B 被迫依赖于类 A 中其他它并不需要的方法。
应该将该方法单独抽象为接口，若所有实现类的方法体都一样，可以用 default 修饰并实现。
继承接口时也一样，不要使类被迫依赖于接口中其他不适用的方法。应该将接口拆分为多个接口。
...</p></div><footer class=entry-footer><span title='2021-09-25 17:12:41 +0000 UTC'>2021-09-25</span>&nbsp;·&nbsp;6688 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 设计模式" href=https://ethereal-lu.github.io/posts/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>JUC 并发编程</h2></header><div class=entry-content><p>线程基础知识 概述 每个线程拥有一个自己独立的栈，但是共享进程的堆空间。
Thread 中的 run 方法是一个回调函数，与普通函数没什么区别，所以以如下方式调用run时，就是一个普通的方法执行。而 start 方法会在本地创建一个线程，然后在本地代码中通过 jvm 回调 run 方法来执行任务。
Thread thread = new Thread(() -> {...}); thread.run(); 线程实现方法 Thread类是描述线程的类，要实现多线程，必须继承Thread类
方法一、创建Thread类的子类 1、创建Thread类的子类，并重写run方法，其中设置线程的任务
2、创建子类对象，并执行start方法
​ （执行start方法会创建一个新的栈空间，并在该栈空间中执行run方法。每执行一次步骤2，就开启一个新的线程）
方法二、实现Runnable接口 推荐使用这种 —> 使用该方法时，Thread 类是咱们自定义类的静态代理类
1、创建一个Runnable接口的实现类，并重写run方法，其中设置线程的任务
2、创建对象，并将其作为参数传递给Thread类的构造方法，再调用start方法。
​ new Thread(new MyRunnable()).start(); ​ 匿名内部类实现： new Thread(new Runnable(){重写run方法}).start();
方法三、实现Callable接口 Callable接口类似于Runnable，但Runnable不会返回结果，也不会抛出检查异常，Callable可以，Runnable 效率比 Callable 低。
1、创建一个Callable接口的实现类，并重写call方法，其中设置线程的任务 2、在使用的地方创建该类对象 obj 。 3、ExecutorService executorService = Executors.newFixedThreadPool(5); // 创建执行服务 4、Future future = executorService.submit(obj); // 提交执行 5、V result = future.get(); // 获取结果 6、executorService.shutdownNow(); // 关闭服务
...</p></div><footer class=entry-footer><span title='2021-08-16 17:12:41 +0000 UTC'>2021-08-16</span>&nbsp;·&nbsp;2357 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to JUC 并发编程" href=https://ethereal-lu.github.io/posts/java/juc%E7%AC%94%E8%AE%B0/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Shrio学习笔记</h2></header><div class=entry-content><p>作者 小陈
微信 chenxu521600
B站 编程不良人 | 百知教育
资料 http://www.baizhiedu.xin
1.权限的管理 1.1 什么是权限管理 基本上涉及到用户参与的系统都要进行权限管理，权限管理属于系统安全的范畴，权限管理实现对用户访问系统的控制，按照安全规则或者安全策略控制用户可以访问而且只能访问自己被授权的资源。
权限管理包括用户身份认证和授权两部分，简称认证授权。对于需要访问控制的资源用户首先经过身份认证，认证通过后用户具有该资源的访问权限方可访问。
1.2 什么是身份认证 身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确。对于采用指纹等系统，则出示指纹；对于硬件Key等刷卡系统，则需要刷卡。
1.3 什么是授权 授权，即访问控制，控制谁能访问哪些资源。主体进行身份认证后需要分配权限方可访问系统的资源，对于某些资源没有权限是无法访问的
2.什么是shiro Apache Shiro™ is a powerful and easy-to-use Java security framework that performs authentication, authorization, cryptography, and session management. With Shiro’s easy-to-understand API, you can quickly and easily secure any application – from the smallest mobile applications to the largest web and enterprise applications.
Shiro 是一个功能强大且易于使用的Java安全框架，它执行身份验证、授权、加密和会话管理。使用Shiro易于理解的API，您可以快速轻松地保护任何应用程序—从最小的移动应用程序到最大的web和企业应用程序。
Shiro是apache旗下一个开源框架，它将软件系统的安全认证相关的功能抽取出来，实现用户身份认证，权限授权、加密、会话管理等功能，组成了一个通用的安全认证框架。
3.shiro的核心架构 ...</p></div><footer class=entry-footer><span title='2021-07-27 18:48:13 +0000 UTC'>2021-07-27</span>&nbsp;·&nbsp;2810 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Shrio学习笔记" href=https://ethereal-lu.github.io/posts/java/shiro%E7%AC%94%E8%AE%B0/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MyBatisPlus学习笔记</h2></header><div class=entry-content><p>1、快速开始 1.1、导入依赖 mybatis 和 mybatis-plus 的依赖不要同时导入。
&lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;scope>runtime&lt;/scope> &lt;/dependency> &lt;dependency> &lt;groupId>com.baomidou&lt;/groupId> &lt;artifactId>mybatis-plus-boot-starter&lt;/artifactId> &lt;version>3.4.3&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>com.baomidou&lt;/groupId> &lt;artifactId>mybatis-plus-core&lt;/artifactId> &lt;version>3.4.3&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.projectlombok&lt;/groupId> &lt;artifactId>lombok&lt;/artifactId> &lt;optional>true&lt;/optional> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;/dependencies> 1.2、配置 在主yaml中配置和 mybatis 的完全一样，没其他配置。
1.3、使用 @Repository public interface UserMapper extends BaseMapper&lt;User> { } UserMapper 接口只需继承 BaseMapper ，其中泛型填入被操作的实体类。BaseMapper 中已经实现许多的方法，直接使用即可。
2、配置日志 使用 mybatis-plus 的方法时，具体 sql 代码是不可见的，我们希望知道它是怎么执行的，就需要看日志。
# 配置日志 mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 这里使用 mybatis 自带的控制台输出 3、CRUD扩展 数据库的 user 表如下：
...</p></div><footer class=entry-footer><span title='2021-07-18 19:42:15 +0000 UTC'>2021-07-18</span>&nbsp;·&nbsp;1232 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to MyBatisPlus学习笔记" href=https://ethereal-lu.github.io/posts/java/mybatisplus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>JVM学习笔记</h2></header><div class=entry-content><p>JVM有几大模块组成：
类加载的子系统 内存模型 执行引擎 垃圾收集器（GC） JIT(热点代码缓存) 自动内存管理 1、内存区域划分 Java虚拟机所管理的内存包括方法区、虚拟机栈、本地方法栈、堆、程序计数器。
1.1、程序计数器 字节码解释器工作时就是通过改变这个计数器 的值来选取下一条需要执行的字节码指令，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地 址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。
1.2、虚拟机栈 Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、 float、long、double）、对象引用和returnAddress 类型。操作数栈主要用于保存方法执行过程中变量的临时结果，方法执行过程中会根据字节码指令向操作数栈压入和弹出数据，返回值也是存储在操作数栈中。
1.3、本地方法栈 本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机 栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native） 方法服务。
1.4、堆 Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java 世界里“几乎”所有的对象实例都在这里分配内存。
Class 对象也存储在堆中。以 Person 类为例，类加载时会创建 instanceKlass （jvm 的一种数据结构）用来存储 Person 类的元数据，包括常量池、字段、方法等，存放在方法区，若是第一次加载 Person 类，会同时生成这个类对应的Class对象， instanceKlass 中包含指向该 Class 对象的指针；之后每次创建 person 实例时都是通过Class对象作为模板创建的（即不是根据 instanceKlass 创建对象），person 实例中包含指向方法区 instanceKlass 的指针。
Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该 被视为连续的。
1.5、方法区 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
运行时常量池（Runtime Constant Pool）是方法区的一部分。用于存放编译期生成的各种字面量与符号引用。
2、HotSpot虚拟机对象探秘 2.1、对象的创建 1、先检查类是否已经被加载、解析和初始化过，如果没有，那必须先执行相应的类加载过程。
2、为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。当使用带压缩整理过程的收集器时，内存的分配算法是指针碰撞，既简单又高效；而当使用基于清除算法的收集器时，采用较为复杂的空闲列表来分配内存。
3、虚拟机将分配到的内存空间（但不包括对象头）都初始化为零值。
4、设置对象头中的信息。
5、执行构造函数，按照程序员的意愿对对象进行初始化。
2.2、对象的内存布局 对象在堆内存中的存储布局可以划分为三个部分：对象头、实例数据和对齐填充。
...</p></div><footer class=entry-footer><span title='2021-07-10 19:42:15 +0000 UTC'>2021-07-10</span>&nbsp;·&nbsp;563 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to JVM学习笔记" href=https://ethereal-lu.github.io/posts/java/jvm%E7%AC%94%E8%AE%B0/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java学习笔记</h2></header><div class=entry-content><p>数组： 数组的初始化方式： 1、动态初始化（指定长度） 数据类型[] 数组名 = new 数据类型[数组长度]； 2、静态初始化（指定内容） 数据类型[] 数组名 = new 数据类型[] {元素1， 元素2， 元素3， ... }； 元素值可以是变量 省略的静态初始化 数据类型[] 数组名 = {元素1， 元素2， 元素3， ... }； 该方式不允许拆分为2步，即先定义数组名，再经行赋值。 直接打印数组名，打印的是数组的内存地址。 支持下标索引。 未初始化的默认初始值： 整数类型： 0 浮点类型： 0.0 字符类型： '\u0000' 布尔类型： false 引用类型： null 获取数组长度： 数组名.length; 获取数组副本： 数组名.clone(); 成员变量与局部变量： 成员变量定义在类内，方法外。局部变量定义在方法内。 成员变量不要写static关键字。??? 成员变量有默认值，而局部变量没有默认值。 当成员变量与局部变量的命名冲突时，按照就近原则，优先使用局部变量。若想使用全局变量，使用this.成员变量名。 可变参数: 使用前提：当方法的参数类型确定，但是参数个数不确定时，使用可变参数。 使用格式：修饰符 返回值类型 方法名(数据类型...变量名) {} 例如: public void func (int... num) {} 原理： 可变参数底层是一个数组，根据传递参数个数的不同，会创建不同长度的数组，来存储这些参数。参数个数可以是0个或多个。 因此，方法中的变量名其实就是数组的名字，可以作为数组使用。 注意： 一个方法的参数列表中只能有一个可变参数。 如果方法有多个参数，则可变参数必须放在参数末尾。 类的使用: 1、导包：import 包路径.类名称 当类与当前文件处于同一个包中时，可以不用导包。只有java.lang下的包不需要导包，其他都需要导包。 但实际使用中，可以不用手动导包，当你使用某个类时，系统会自动帮你导包。 2、实例化： 类名称 对象名 = new 类名称(); 3、使用: 对象名.成员变量名 对象名.成员方法名(参数) Private: Getter: 函数格式必须是 getXXX 如果变量是布尔类型，则使用isXXX Setter: 函数格式必须是 setXXX Private修饰构造函数时，外部不能再构造该类的实例，故只能在类内构造好全部实例并赋给static类型的变量。叫构造函数私有化 this: this是当前对象的引用，即this和对象是同一个东西。 this.成员变量 调用本类成员变量 可以将类内的成员变量与方法中的同名局部变量区分。 this.成员方法 调用本类成员方法 this(...) 调用本类构造函数 --> 写在第一行，只能调用一个。 若子类使用了this(...)，则不再默认赠送super()。 super: super.成员变量 调用父类成员变量 可以将父类中的成员变量和子类中的同名成员变量区分。 super.成员方法 调用父类成员变量 super(...) 调用父类类构造函数 --> 写在第一行，只能调用一个。 构造函数： 格式： public 类名（参数类型 参数名称 ， ...）{...} 注意事项： 构造方法的名称和类名要严格相等，大小写敏感。 构造方法没有返回值类型。 若不明确定义构造函数，则会自动生成默认构造函数，若手动定义了任意形式的构造函数，编译器将不会再生成默认构造函数。 构造函数支持重载 继承中的构造函数: 构造链：同C++一样--> 祖宗 > 父类 > 子类 子类构造方法中若不显式调用super，则默认隐含一个 "super()" 调用。 子类构造函数可以显式地写 super([参数1，...]) 来调用父类的重载构造函数。且必须在方法体的第一行，即只能调用一个。 标准类：也叫做 Java Bean 通常包含以下4部分内容： 所有的成员变量都要使用private关键字。 为每一个成员变量编写一对儿Getter/Setter方法 编写一个无参构造函数 编写一个全参构造函数 点击 Code->Generate 或者 快捷键 alt + insert 可以自动生成上述内容 ==： 对于基本类型， == 比较的是值 对于引用类型， == 比较的是地址 基本类型与字符串之间的转换： 基本类型 --> 字符串 1、基本数据类型的值+"" 最简单的方式（工作中常用） 2、使用包装类的静态方法 static String toString(int i) 将i变为字符串形式 如 Integer.toString(100); 3、使用String类的静态方法 static String valueOf(int i) 将i变为字符串形式 如 String.valueOf(100); 字符串 --> 基本类型 使用包装类的静态方法 parseXX("字符串") Integer static int parseInt(String s) 如 Integer.parseInt("100"); ... ... 泛型: 泛型名字不一定是E，可以是任意大写字母。 类: public class ClassName&lt;E> { ... 在类内将需要的地方都用E代替} 实例化对象时确定类型 方法: 修饰符 &lt;E> 返回值类型 方法名(参数列表){ ... } 调用方法时确定类型 接口: 含有泛型的接口定义与类相同。 确定类型的方法：1、在实现类中确定类型 2、实现类依然沿用接口的泛型E，实现类创建对象时确定类型 通配符: &lt;?> 代表任意数据类型， 使用: 例如当多个不同类型的ArrayList集合要作为参数调用同一个方法时，可以将参数设置为ArrayList&lt;?> list方便接受任意类型。 高级使用: ? extends E 表示 ? 只能是E的子类/本身 ? super E 表示 ? 只能是E的父类/本身 static: 带上static的成员变量或函数，不属于对象，而是属于类，所有对象共享。 类名.静态变量 类名.静态方法() 注意事项：静态不能直接访问非静态 --> 在内存中，先有静态，后有非静态 静态不能使用this 静态代码块：static{ ... } 首次用到类时，静态代码块唯一执行一次。 典型用途：一次性地对静态成员变量赋值。 override: 在子类的覆盖重写方法前面加上 @override 可以检验该方法是否为重写方法（建议写上） 子类方法的返回值的范围必须 小于等于 父类方法的返回值的范围。 子类方法的权限必须 大于等于 父类方法的权限 权限： public > protected > (default) > private (default) 表示什么也不写，留空。 同一个类 YES YES YES YES (我自己) 同一个包 YES YES YES NO (我领居) 不同包子类 YES YES NO NO (我儿子) 不同包不同类 YES NO NO NO (陌生人) abstract: 抽象方法：只定义，不实现。加上abstract关键字，去掉大括号，直接分号结束。 抽象类： 抽象方法所在的类，必须是抽象类。在class前加上abstract即可。但抽象类中不一定包含抽象方法（通常是有的）。 使用步骤： 抽象类不能直接创建对象。 必须用一个子类继承抽象父类。 子类必须覆盖重写抽象父类中的所有抽象方法。-->此处覆盖重写即实现：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。 创建子类对象，并使用。 interface： 概念：接口就是多个类的公共规范。是一种引用数据类型，最重要的就是其中的抽象方法。 定义：public interface 接口名称 { ... } 包含：常量、抽象方法、默认方法、静态方法、私有方法。 常量：可以理解为成员变量，但是必须使用 public static final 三个关键字修饰，故相当于常量。 public static final 数据类型 常量名称 = 值 （三个关键字可省略，但不能换为别的） 注意：1、接口中的常量可以省略public static final，但写不写效果一样。 2、接口中的常量必须手动赋值，不能不赋值。赋值之后无法改变。 3、常量名称全部大写，由下划线连接。 使用：接口名称.常量 抽象方法：1、接口中的抽象方法，修饰符固定为 public abstract (可省略，但不能换为别的) 2、方法的三要素可随意定义。 默认方法：public default 返回值类型 方法名(参数列表) {方法体} (public可省略，default不能省略) 可以解决接口升级的问题。（不想改变实现类，但是接口中又想要添加新方法，则接口就可以用默认方法自己实现）（实现类可以覆盖重写默认方法） 默认方法会被实现类继承，故可以通过实现类的对象访问默认方法。 静态方法：public static 返回值类型 方法名(参数列表) {方法体} (public可省略，static不能省略) 使用：接口名称.静态方法(参数); 不能通过对象访问。 私有方法：1、普通私有方法：解决多个默认方法之间的重复代码问题 private 返回值类型 方法名(参数列表) {方法体} 只有接口中的默认方法能访问。 2、静态私有方法：解决多个静态方法之间的重复代码问题 private static 返回值类型 方法名(参数列表) {方法体} 只有接口中的默认方法和静态方法能访问。 使用：1、接口不能直接使用，必须有一个“实现类”来“实现”该接口。 public class 实现类名称 implements 接口名称 {...} 2、接口的实现类必须实现接口中的全部抽象方法。去掉abstract关键字，加上大括号实现体。 3、创建实现类对象，使用。 注意事项：1、接口没有静态代码块和构造方法。 2、如果实现类没有覆盖重写所有接口中的所有方法，则该实现类自己就必须是抽象类。 3、一个实现类可以实现多个接口 public class 类名 implements interface1, interface2 {}。 4、若一个类实现的多个接口中有重名的抽象方法，则只需实现一个即可。 5、若一个类实现的多个接口中有重名的默认方法，则该实现类必须对重名默认方法覆盖重写。 6、若一个类的直接父类中的方法和它实现的接口中的默认方法重名，则优先使用直接父类的方法。 在java中【继承 优先于 接口】 7、接口是多继承的。多个父接口当中的抽象方法如果重名，没关系。 多个父接口当中的默认方法如果重名，则子接口必须对重名的默认方法覆盖重写，【而且带着default关键字】 多态：（一个子类对象既有子类形态，又有父类形态）一个对象拥有多种形态，即【对象】的多态性。【多态性指的是对象，而不是类】 代码中体现多态性： 父类引用指向子类对象。 格式 父类名称 对象名 = new 子类名称(); 或 接口名称 对象名 = new 实现类名称(); 【初步理解: 定义了一个指向子类对象的父类引用，这个引用指向的是子类的对象，但是只能访问父类大小的内存空间，所以它只能访问父类继承到子类当中的成员 （包括成员变量和成员函数）的那部分内存空间，而不能访问子类独有的多出来的那部分内存空间，而对于被子类重写了的方法，该引用依然可以访问 这部分内存，只是内存中的内容已经被改写了，所以访问到的是子类重写之后的方法。综上所述，该引用能访问的范围是所有从父类继承下来的变量和 父类独有方法，以及被子类重写之后的方法。】 多态对象访问成员变量： 对象名.成员变量 访问的是父类的成员变量，若没有则向上找，不会向下找。 不能用这种方法访问子类特有成员变量。 多态对象访问成员函数： 若子类重写了父类的成员函数，则访问子类的成员函数。 若子类没有重写，则访问父类的成员函数，没有则向上找。 同样不能访问子类特有成员函数。 记忆口诀；对于成员变量，等号左边是谁就优先用谁。对于成员方法，new的是谁就优先用谁。 使用多态的好处：比如将父类的引用作为参数传入方法中，则该引用可以指向不同的子类对象使方法实现不同的功能，却不需要改变方法中的任何代码。 对象的向上转型： 在特定场合会自动向上转型，如方法参数要求为父类，但是传入一个子类对象也正确，这时就发生了自动向上转型。与int double发生自动类型转换原理一样。 格式：与多态相同：父类名称 对象名 = new 子类名称(); 含义：创建一个子类对象，把它当作父类来看待使用。 【向上转型一定是安全的】从小范围转向了大范围，如将小范围的猫向上转型为更大范围的动物。 类似于将short转换为int。 弊端：不能访问子类特有方法。 对象的向下转型：其实是一个【还原】的动作。 格式： 子类名称 对象名 = (子类名称) 父类对象; (子类名称)必须有，不能省略。 含义： 将向上转型之后的父类对象还原为本来的子类对象。 注意： 只有本来是猫，向上转型为动物后，再向下转型为猫才是正确的。 若本来不是猫，却硬要向下转型为猫就会出错(编译不会报错，但运行会出现异常ClassCastException)。 instanceof: 格式： 对象名 instanceof 类名 作用： 返回一个布尔值，判断前面的对象能不能当作后面类的实例。 应用： 在向下转型之前，判断需要转型的对象是不是目标类的对象，是则向下转型，不是则不转型。 final: 该关键字表示最终的，不可再改变的。 用法: 修饰一个类、方法、局部变量、成员变量。 修饰一个类： public final class 类名 {...} 不能有子类。 修饰一个方法： 该方法不能被重写。 对于类和方法，abstract 和 final 不能同时使用，会矛盾。 修饰一个局部变量： 一次赋值，终生不变。（可以先定义，再赋值。分两步）--对于基本类型，值不可变。对于引用类型，地址值不可变。 修饰一个成员变量： 由于成员变量有默认值，所以不能分两步，必须当场手动赋值或通过构造函数赋值。 修饰一个数组或集合： 该数组或集合不能再被赋值，但内部的数据还可以改变。 内部类： 一个类内部包含另一个类，即一个事物内部包含另一个事物。 例如 身体和心脏的关系 分类： 成员内部类 局部内部类（包含匿名内部类） 成员内部类：修饰符 class 外部类名称 { 修饰符 class 内部类名称 {...} ... } 内用外，随意访问。外用内，需要内部类对象。 在main方法中使用：1、间接方式： 在外部类的方法中调用内部类，然后main通过访问外部类的方法调用内部类。 2、直接方式： 外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称(); 当局部变量、内部类的成员变量、外部类的成员变量重名时： 内部类的成员方法调用内部类的成员变量用this.内部成员变量。 内部类的成员方法调用外部类的成员变量用Outer.this.外部成员变量。 局部内部类：如果一个类定义在方法内部，就是局部内部类。---只有当前所属的方法才能使用它，出了这个方法就不能使用了。 格式：修饰符 class 外部类名称 {... 修饰符 返回值类型 外部类方法名称(参数列表) { class 内部局部类名称 {...} ... } ...} 注意：若局部内部类要访问所在方法的局部变量，则该局部变量必须是【有效final的】（即可以不写final关键字，但是不能变） 因为局部内部类在堆中，生命周期长，而局部变量在栈中，生命周期短，所以不能变。 【匿名内部类】：【用的最多】 如果接口的实现类（或者父类的子类）只需使用唯一的一次，则可以省略该类的定义，而改为使用匿名内部类。 格式：接口名称 对象名 = new 接口名称() { 重写所有抽象方法 }; 注意：1、匿名内部类只能唯一【创建一次对象】。若想多次创建对象，就要单独定义实现类。 2、匿名对象只能唯一【调用一次方法】。若想多次调用方法，就要给对象起个名字。 3、匿名内部类是省略了实现类/子类名称。而匿名对象是省略了对象名称。他俩不是一回事。 new 接口名() { 重写所有抽象方法 }.方法(参数); 即匿名内部类又匿名对象的使用方法。 异常: throw : 用于抛出异常， 例如: throw new NullPointerException("异常产生的原因") 若抛出运行时异常，可不理会，默认由JVM处理 若抛出编译器异常，则必须处理。throws或try-catch throws: 声明异常。 (用于甩锅) 格式: 修饰符 返回值类型 方法名(参数列表) throws AAAException, BBBException... {throw new AAAException("原因")...} 注意: 1、throws必须写在方法声明处 2、throws后面必须是Exception或者是其子类 3、throws后面必须声明方法内部抛出的所有异常 4、若调用了一个声明抛出异常的方法，则必须处理这些异常。可以继续抛出，也可以自己处理。 try-catch: 自己处理异常 try可以抛出多个异常，这时需要使用多个catch来捕获异常。 try中若产生异常，则try代码块中产生异常之后的代码不会执行，而跳转到catch。 try中若没有产生异常，则执行完try中的代码继续执行try-catch之后的代码。 finally: 不论是否发生异常，finally代码块中的代码一定会执行。 格式 : try{} catch{} finally{} 注意 : finally必须与try一起使用，一般用于资源释放。 正是由于其有一定会执行到，所以若finally代码块中有return语句，则一定会返回finally中的结果。（要避免） 注意 : 子类异常一定要与父类异常一致。 Thread : Thread类是描述线程的类，要实现多线程，必须继承Thread类 每个线程拥有一个自己独立的栈，但是共享进程的堆空间。 Thread.sleep(毫秒) // 静态方法 睡眠 Thread thread = Thread.currentThread(); // 获取当前线程 第一种方法： 创建Thread类的子类 1、创建Thread类的子类，并重写run方法，其中设置线程的任务 2、创建子类对象，并执行start方法 (执行start方法会创建一个新的栈空间，并在该栈空间中执行run方法)(每执行一次步骤2，就开启一个新的线程) 第二种方法： 实现Runnable接口 (推荐使用这种) ---> 使用该方法时，Thread 类是咱们自定义类的静态代理类 1、创建一个Runnable接口的实现类，并重写run方法，其中设置线程的任务 2、创建对象，并将其作为参数传递给Thread类的构造方法，再调用start方法。 new Thread(new MyRunnable()).start(); 匿名内部类实现： new Thread(new Runnable(){重写run方法}).start(); 第三种方法： 实现Callable&lt;V>接口 （面试可能会问到） Callable接口类似于Runnable，【Runnable不会返回结果，也不会抛出检查异常，Callable可以】 1、创建一个Callable&lt;V>接口的实现类，并重写call方法，其中设置线程的任务 2、在使用的地方创建该类对象 obj 。 3、ExecutorService executorService = Executors.newFixedThreadPool(5); // 创建执行服务 4、Future&lt;V> future = executorService.submit(obj); // 提交执行 5、V result = future.get(); // 获取结果 6、executorService.shutdownNow(); // 关闭服务 同步： 多个对象访问同一个资源，可以并发读取，但当其中某一个对象要修改时，就必须实现同步 所有的对象都拥有一把锁。 锁对象选取总结为一句话就是 在同步代码中要改变谁就锁谁。 方法一： 同步代码块： synchronized (锁对象) {访问共享数据的代码} 线程不仅要抢夺CUP，还要占用锁对象。同时拥有才能执行代码 锁对象可以是任意对象，但必须是同一个对象，推荐将共享资源作为锁对象。线程占用锁对象后直到执行完毕才释放。 方法二： 同步方法 修饰符 synchronized 返回值类型 方法名 (参数列表) {访问共享数据的代码} // 该方法即为同步方法 首先将 访问共享数据的代码块 抽取出来，作为上述方法。 同步方法的锁对象默认为 this ，即同步方法所在类的对象；创建该类的对象后，该对象调用同步方法时就会锁住对象自己。 当同步方法同时也是静态方法时，锁对象为同步方法所在类的 Class 对象。 方法三： Lock锁 Lock是一个接口，有两个方法 void lock() 获取锁 和 void unlock() 释放锁 它有一个实现类ReentrantLock（可重入锁）， 先实例化一个ReentrantLock对象。 在出现安全问题代码之前用该对象调用 lock() 方法。在出现安全问题代码之后用该对象调用 unlock() 方法。 lock() 和 unlock() 方法建议放在 try --- finally 代码块中 线程状态： 线程停止：不推荐使用 Thread 类提供的 stop() 等方法。推荐自己通过一个标志位控制停止 public class MyRunnable implements Runnable { private boolean flag = true; @Override public void run() { while (flag) { TODO... } } public void stop() { flag = false; } } 通过调用自己实现的 stop 方法来停止线程 下方所有方法都是 Thread 类中的方法！ 线程休眠：Thread.sleep(毫秒) // sleep 不会释放锁、 wait 会释放锁。 线程礼让： Thread.yield(); 使当前线程从运行状态变为就绪状态，让 cpu 从所有就绪的线程中挑一个运行。 礼让有可能不成功，因为 cpu 可能再挑选一次还是让当前线程继续执行。 线程强制执行： join() ，相当于插队，停止现在执行的线程，立刻执行自己的线程，且本线程执行结束才能执行其他线程 public class MyRunnable implements Runnable { @Override public void run() { for (int i = 0; i &lt; 1000; i++) { System.out.println("Runnable " + i); } } public static void main(String[] args) throws InterruptedException { MyRunnable myRunnable = new MyRunnable(); Thread thread = new Thread(myRunnable); thread.start(); for (int i = 0; i &lt; 500; i++) { if (i == 200) { thread.join(); } System.out.println("主线程" + i); } } } 在上方举例代码中，主线程执行到200之前，主线程和Runnable线程交替执行，当主线程执行到200次时， Runnable 线程插队接着执行，之后Runnable线程全部执行完毕后才由主线程继续执行。 查看线程状态：Thread.State state = thread.getState(); // Thread.State 是一个枚举类型 线程优先级：1 最小；10 最大；默认为5。优先级越高在就绪状态很大可能越早执行，但也不是一定。 守护（daemon）线程： 线程分为用户线程和守护线程。 虚拟机必须保证用户线程执行完毕，但不用等待守护线程执行完毕。 守护线程有：后台记录日志、监控内存、垃圾回收等 private boolean daemon = false; // 默认 daemon 属性是关闭的，即默认为用户线程 thread.setDaemon(true); // 可通过这样将线程设置为 守护线程。 // 将线程设置为守护线程之后，虚拟机将不再保证该线程是否执行结束， // 即只要当用户线程执行结束后就将整个程序关闭，而不考虑守护线程此时是否已经执行完毕。 线程池 : 底层原理 ： 线程池就是一个容纳多个线程的容器，可由集合实现 使用步骤: 1、使用线程池工厂类Executors里面的静态方法newFixedThreadPool生产一个指定线程数量的线程池，由ExecutorService接口接收。 2、创建Runnable接口的实现类，重写run方法，设置线程任务。 3、调用ExecutorService中的execute方法，传递线程任务，开启线程，执行run方法。 例: ExecutorService executorService = Executors.newFixedThreadPool(5); // 创建服务 Runnable runnable = new Runnable() { //此处虽然new 的是Runnable接口，但是立即重写了run方法，故相当于其实现类。 @Override public void run() { //线程任务 } }; executorService.execute(runnable); // 执行服务 executorService.shutdownNow(); // 关闭服务 ExecutorService 中的 submit()方法和 execute()方法作用相同，只是适用于不同场景 void execute(Runnable command) // 执行任务，没有返回值，一般用于执行 Runnable &lt;T> Future&lt;T> submit(Callable&lt;T> task); // 执行任务，有返回值，一般用于执行 Callable Lambda表达式 : 可推导，可省略 格式： () -> {} 使用前提： 必须是接口，且接口中有且只有一个抽象方法 (有且只有一个抽象方法的接口，称为"函数式接口") 可以省略的内容： 1、(参数列表) 参数列表中的数据类型可以省略， 如果参数只有一个，则括号()也可以省略 2、{方法体} 如果{}中的代码只有一行，无论是否有返回值，都可以省略 {}， return， 分号 （要省一起省） 注解: @override 检测是否为覆盖重写 @FunctionalInterface 检测是否为函数式接口 ------------------------------------------------------------------------------------------------------------------ API使用： Scanner： 功能：从键盘输入数据到程序。 包路径：java.util.Scanner 实例化：Scanner sc = new Scanner(System.in); System.in 表示从键盘输入数据。 方法：---其实键盘输入的一切东西都是字符串，使用不同的函数会将字符串转换为相应的类型。-->故若记不住也可以一直使用sc.next();之后再转换类型 获取键盘输入的一个int数字： int num = sc.nextInt(); 获取键盘输入的一个字符串： String str = sc.next(); 读取文件内容：Scanner in = new Scanner(Paths.get("\u202AC:\\Users\\Lenovo\\Desktop\\1.txt"), StandardCharsets.UTF_8); 之后再用in的各种方法。nextLine(); next(); nextInt(); 等 Random: 功能: 获取随机数。 实例化：Random rand = new Random(); 方法：int rand_num = rand.nextInt(n) 在[0, n)中随机取一个数字。----> m + rand.nextInt(n)取到[m, m + n）中的随机数。 ArrayList: [元素1， 元素2， 元素3， ...] 功能：可变长的数组。 泛型：装在集合中的元素必须是同一个类型，只能是引用类型，不能是基本类型。 实例化：ArrayList&lt;String> list = new ArrayList&lt;>(); 注意事项：直接打印list输出的不是一个地址值，而是空的中括号。 不支持下标索引，只能用get()方法获取。 常用方法：list.add("李沁") 添加元素，返回一个boolean值，表示添加的动作是否成功。一定成功，可以不接受返回值。 list.get(index) 根据索引获取元素，返回获取的元素。 list.remove(index) 根据索引删除元素，返回被删除的元素。 list.size() 获取集合长度。 若想在ArrayList中存储基本类型，需要使用其包装类(引用类型)： 基本类型 包装类 byte Byte short Short ... ... （与上方一样，只需首字母大写） int Integer 【特殊】 char Character 【特殊】 ArrayList&lt;Integer> list_int = ArrayList&lt;>(); // 自动装箱：int --> Integer 自动拆箱：integer --> int String: 功能：字符串（常量） --> Java中所有的双引号字符串都是String类的实例。 实例化：直接创建： String str1 = "李沁"; 在字符串常量池中， 其他实例化方式都在堆中，不在池里。 使用空构造函数： String str2 = new String(); 根据字符数组创建： char[] charArray = { 'a', 'b', 'c' }; String str3 = new String(charArray) // abc 根据字节数组创建： byte[] byteArray = { 97, 98, 99 }; String str3 = new String(byteArray) // abc 方法：str1.equals(str2) 比较str1和str2的值是否相等，返回boolean。 常变量比较时推荐 常量.equals(变量) str1.equalsIgnoreCase(str2) 忽略大小写。 str.length() 长度 str.concat(str1) 拼接 str.charAt(index) 根据索引返回字符 str.indexOf(str1) 在str中查找str1，返回首次找到的索引值；若没有，返回-1 str.substring(index) 截取，从index到末尾 str.substring(int begin, int end) 截取，[begin, end) str.toCharArray() 转换为字符数组 str.getBytes() 转换为字节数组 用于遍历字符串 str.replace(old, new) 用new替换str中的old str.split(regex) 切割，返回数组 Arrays: 功能：与数组相关的类，提供大量静态方法，用来实现数组常见的操作。 方法： Arrays.toString(数组) 将参数变成字符串 [元素1， 元素2，元素3，...] Arrays.deepToString(多维数组) 将参数变成字符串 [元素1， 元素2，元素3，...] Arrays.sort(数组) 排序。默认从小到大，自定义类型的排序需要Comparable或Comparator接口 Arrays.equals(数组1， 数组2) 两个数组完全相等是返回ture Math: 功能：数学相关的类，提供大量静态方法，用来实现数学运算相关的操作。 方法： Math.abs() 绝对值 Math.ceil() 向上取整 Math.floor() 向下取整 Math.round() 四舍五入 Collection接口: 所有单列集合的顶层接口 List接口: 1、有序（存入和取出的顺序一致） 2、允许元素重复 3、有索引 Vector:(了解) Arraylist:(重点) 底层由数组实现，查询快，增删慢。 LinkedList:(次之) 底层由链表实现，查询慢，增删快。 特有方法: addFirst() == push() addLast() == add() getFirst() getLast() removeFirst() == pop() removeLast() 这两种方法都会删除并返回 共有方法： void add(int index, E element) 将元素添加到索引位置 E get(int index) 返回索引处的元素 E remove(int index) 删除索引位置元素,并返回被删除的元素 E set(int index, E element) 替换索引位置元素,并返回被替换前的元素 Set接口: 1、不允许元素重复 2、没有索引 TreeSet: (无序) (了解) 底层由二叉树实现，一般用于排序。 HashSet: (无序) (重点) 底层由哈希表实现。(查询速度很快) 注意: 使用HashCode存储自定义类型时，需要重写HashCode()和equals()。可通过alt + insert直接添加。才能保证元素不重复。 LinkedHashSet: (有序) (次之) 底层由哈希表+链表实现。 extends HashSet 比HashSet多了一条链表，用来记录元素的顺序 共有方法： boolean add(E e) 添加， 无需接收 boolean remove(E e) 删除， 若有e，删除并返回true。若没有e，无动作并返回false void clear() 清空。 但不删除集合。 boolean contains(E e) 是否包含。 boolean isEmpty() 是否为空。 int size() 元素个数。 Object[] toArray() 转为数组。 哈希值: 是一个十进制的整数，由操作系统随机给出的对象的逻辑地址值。 哈希表: 拉链法。由哈希值为元素组成数组（初始长度为16）。若哈希值相等，则以链表方式挂在该哈希值后面。当链表长度超过8时，变为红黑树。检索速度加快。 Collections : 是Collection的工具类，提供大量静态方法，用于操作集合。 以ArrayList为例: ArrayList&lt;String> list = new ArrayList&lt;>(); addAll(Collection&lt;T> c, T... elements) : 往集合中添加多个元素。 Collections.addAll(list, "a", "b", "c"); shuffle(List&lt;T> list) : 打乱顺序。 Collections.shuffle(list); sort(List&lt;T> list) : 排序， 默认升序。 Collections.sort(list); 注意：若要对自定义类型排序，则被排序的类必须实现Comparable接口，重写compareTo方法来定义排序规则。 this - 参数 ： 升序 (了解)另一种sort()： Collections.sort(arr, new Comparator&lt;Integer>() { @Override public int compare(Integer o1, Integer o2) { return o1 - o2; } }); 这种方法List接口中的方法类似-> arr.sort(new Comparator&lt;Integer>() {...}) Iterator: 迭代器 是接口 也有泛型 --> Collection&lt;String> array = new ArrayList&lt;>(); Iterator&lt;String> it = array.iterator(); 常用方法: boolean hasNext() 是否有下一个元素。 E next() 返回下一个元素。 使用： Collection中的实现类为 iterator() 1、实例化iterator 2、用hasNext() 3、用next() 增强for循环: 专门用来遍历数组与集合，由Iterator迭代器实现，遍历时不能做增删操作。 for (元素数据类型 变量 : 集合或数组名) { ... } Map: --> 字典 键值对 key是唯一的 HashMap: (无序) 底层为哈希表 LinkedHashMap : (有序) 底层为哈希表+链表(保证顺序) 方法: V put(K key, V value) : 添加，若key值不存在，则添加并返回null。若key值已存在，则更新value值，并返回被替换掉的value值。一般不接收返回值。 V remove(K key) : 删除，若key值存在，返回被删除的value。若key不存在，则返回null。 V get(K key) : 获取，若key值存在，返回对应的value。若key不存在，则返回null。 boolean containsKey(k key) : 判断是否包含指定的键。 Set&lt;K> keySet() 返回由键组成的Set，之后可以通过遍历Set来遍历Map。 for (K key : map.keySet()) { sout(key + map.get(key)) } Set&lt;Map.Entry&lt;K, V>> entrySet() --> for (Map.Entry&lt;K, V> entry : map.entrySet()) { 也是遍历，看起来不好用的样子 System.out.println(entry.getKey() + ' ' + entry.getValue());} 用Map存储自定义类型时，若自定义类型作为键，则必须将该类重写HashCode和equals方法，保证键是唯一的。 of方法： static &lt;E> List&lt;E> of (E... elements) 1、of方法只适用于List, Set, Map 接口。而不适用于他们的实现类 2、of方法返回一个不能被操作的集合。因此适合初始化，且初始化后不能改变。 3、Set 和 Map 调用of方法时不能有重复元素。 ------------------------------------------------------------------------------------------------------------------ ------------------------------------------------------------------------------------------------------------------ ------------------------------------------------------------------------------------------------------------------ ------------------------------------------------------------------------------------------------------------------ Object： 以下方法所有类都有，只是重写之后功能有所不同。 toString() 直接打印对象的名字，就是调用对象的toString方法->得到对象的地址值。 没有意义。 重写：可以和构造方法与Getter/Setter方法一样的步骤添加（重写）toString方法->打印出属性值。 equals() boolean equals(Object obj) 判断两个对象是否"相等"，返回布尔值。 比较两个对象的地址值，同上方的==作用一样。 没有意义。 重写： 原理 --> 由于equals方法的参数类型为Object,所以默认向上转型了。若想比较两个对象的属性值，需要先向下转型。 同样可以 alt + insert 直接生成equals方法。 判断两对象的属性值是否都一样。 hashCode() 返回对象的哈希码值 // synchronized 能实现线程同步、但无法实现线程间通信、用如下 4 个方法可以实现线程间通信。 wait() 等待。在被唤醒之前，放弃CPU的使用权 wait(毫秒值) 在被唤醒或到时间之前，放弃CPU的使用权 notify() 唤醒。随机唤醒锁对象中的一个进程 notifyAll() 唤醒锁对象(对象监视器)中的所有进程 这两种常搭配同步机制使用 objects: 该工具类提供的方法是容忍空指针的。 若 a=null，则a.equals(b) 报错。而Objects.equals(a, b) 正常运行。 Objects.requireNonNull(T obj) 查看obj是否为空，用来判断参数的合法性。 旧API : Date: 1970年1月1日 00:00:00 作为0时刻 Date() 无参构造--> 获取当前时间。 Date(long date) 有参构造 --> 输入毫秒值，输出相对于0时刻的日期。 getTime() 把日期转换为毫秒 DateFormat: 格式化日期。 抽象类。 String format(Date date) 把日期格式化为字符串。 Date parse(String source) 把符合的字符串解析为日期。 SimpleDateFormat: DateFormat的实现类 SimpleDateFormat(String pattern) 有参构造 参数一般为 "yyyy-MM-dd HH:mm:ss" 使用上方两个方法。 注意：用parse时，参数的模式必须与构造SimpleDateFormat对象时的模式完全一样，否则报错。 Calendar: 日历类 抽象类 getInstance() 静态方法 返回Calendar类的子类对象 Calendar instance = Calendar.getInstance(); 功能：使用默认时区和语言环境获得一个日历 get(field) 返回给定字段的值。 字段值有YEAR MONTH DATE HOUR MINTER SECOND 年月日时分秒 都是静态变量 set(field, value) 将给定的日历字段设置为给定值 add(field, amount) 修改指定的字段，通过amount的正负实现加减。 Date getTime() 将Calendar转为Date对象 原理：实际上该类中有一个fields数组，上述的方法都是在对该数组操作。字段值YEAR等固定为0，1，2等，作用是对该数组的索引。 新API LocalDate, LocalTime, LocalDateTime : 之前的Date类和Calendar类都有缺陷。JDK8 新引入日期时间类 由于LocalDateTime类使用较多，故以他为例，其余两种用法相同。 构造方法： 1、LocalDateTime now = LocalDateTime.now(); 获取当前时间 2、LocalDateTime localDateTime = LocalDateTime.of(2020, 1, 20, 12, 20, 34); 获取指定时间 常用方法： now.getDayOfMonth() 获取对象是这个月的第几天。类似的方法获取其他属性。 LocalDateTime time = now.withDayOfMonth(12); 使用类似方法设置属性。但是该语句执行后，time为修改后的值，而now的值不变。体现了时间的不可变性。 LocalDateTime plusDays = now.plusDays(3); 使用类似方法修改属性，在原有基础上加3天。不可变性同上。 LocalDateTime months = now.minusMonths(2); 使用类似方法修改属性，在原有基础上减2月。不可变性同上。 Instant 替换 Date 类 DateTimeFormatter : 类似于SimpleDateFormat 日期时间的格式化与解析 DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"); 构造 String format = formatter.format(LocalDateTime.now()); 格式化 TemporalAccessor parse = formatter.parse("2021-01-21 22:00:25"); 解析 System: 提供大量静态方法， 可以获取与系统相关的信息即服务 static currentTimeMillis() 返回以毫秒为单位的当前时间, 用来测试程序的效率。 static arraycopy(原数组， int 原数组起始位置， 目标数组， int 目标数组起始位置， int 要复制的数组元素的数量) 复制数组 StringBuilder: 在String类中，字符串是常量，底层是被final修饰的数组。字符串相加时，占用内存多，效率低下。 StringBuilder类是字符串缓冲区，可以提高字符串的操作效率（看成是一个长度可以变化的字符串） 底层也是一个数组，但是没有被final修饰，可以改变长度。 在内存中始终是一个数组，初始容量为16个字节，超出会自动扩容，占用空间少，效率高。 构造函数： StringBuilder() 无参构造，空字符串。 StringBuilder("abc") 有参构造，即参数的字符串。 成员函数： append(任意类型) 添加到字符串，并返回自身。所以无需接收。 toString() 将StringBuilder对象，转换为String对象。 通过StringBuilder的构造方法可以将String转换为StringBuilder. reverser() 翻转 File: 文件类，主要用于文件和目录的创建，查找和删除等操作 File类已被Path取代 静态方法: static String pathSeparator 路径分隔符 windows ; 分号 linux : 冒号 static String separator 文件名称分隔符 Windows \ 反斜杠 Linux / 正斜杠 构造方法: File(String pathname) 路径名 ==> 文件/文件夹 相对/绝对 存在/不存在 File(String parent, String child) 父路径，子路径 File(File parent, String child) 父路径，子路径。父路径是File型，故可以使用其方法做调整 常用方法: 获取方法: String getAbsolutePath() 返回绝对路径名 String getPath() 返回路径名 String getName() 返回末尾文件/文件夹 名字 long length() 返回文件大小（以字节为单位） 不能是文件夹，若路径不存在，返回0 判断方法: boolean exists() 文件或文件夹是否真实存在 boolean isDirectory() 路径是否以文件夹结尾 前提：真实存在 boolean isFile() 路径是否以文件结尾 前提：真实存在 创建删除: boolean creatNewFile() 不存在时创建文件 不能创建文件夹，路径必须存在 boolean delete() 删除文件/文件夹 boolean mkdir() 创建单级空文件夹 boolean mkdirs() 创建单级/多级空文件夹 多级文件夹：父文件夹中包含子文件夹 遍历文件夹: String[] list() 返回由所有文件或子目录组成的字符串数组 File[] listFiles() 返回由所有文件或子目录封装而成的文件数组 过滤器: File[] files = dir.listFiles(new FileFilter(){重写accept()方法，该方法中写入过滤规则，留下的返回ture，不要的返回false}) 可以写为Lambda表达式。 读取文件的方法： Scanner in = new Scanner(Paths.get("C:\\Users\\Lenovo\\Desktop\\1.txt"), StandardCharsets.UTF_8); String num = in.nextLine(); BufferedReader reader = Files.newBufferedReader(Paths.get("C:\\Users\\Lenovo\\Desktop\\1.txt"), StandardCharsets.UTF_8); String str = reader.readLine(); （不好用）BufferedReader bufferedReader = new BufferedReader(new FileReader("C:\\Users\\Lenovo\\Desktop\\1.txt")); String s = bufferedReader.readLine(); Properties: 用来加载配置文件, 示例如下： Properties properties = new Properties(); // ClassLoader classLoader = Person.class.getClassLoader(); 注释掉的两句作用与下一句一样 // InputStream is = classLoader.getResourceAsStream("jdbc.properties"); // 路径相对于src FileInputStream fis = new FileInputStream("src\\jdbc.properties"); // 路径相对于Module而不是src properties.load(fis); String user = properties.getProperty("user"); String passwd = properties.getProperty("passwd"); System.out.println(user + " " + passwd); IO流: （默认相对路径在Module下） 基本流: OutputStream: 字节输出流 (一切都以字节为单位) (一次读写一个字节) 接口 共有方法: write(byte[] bytes) 写入多个字节 close() FileOutputStream: 文件字节输出流 构造方法: FileOutputStream(String name[, boolean append = false]) 参数为路径，即写入的目标文件路径，如果没有该文件，会先创建该文件。若append为ture，则为追加写，否则会覆盖原文件 FileOutputStream(File file[, boolean append = false]) 参数为文件，即写入的目标文件，append同上。 InputStream: 字节输入流 接口 共有方法: read() 读取一个字节,返回读到的内容，读到文件末尾返回-1 int read(byte[] bytes) 读取多个字节，将读取到的内容存入字节数组中，并返回读取的有效字节个数，读到文件末尾返回-1 close() FileInputStream: 文件字节输入流 构造方法: FileInputStream(String name) FileInputStream(File file) Reader: 字符输入流 抽象 共有方法: read() read(char[] c) close() 作用和上述相同,包括返回-1等等都相同，只是读取单位变为字符。 FileReader: 文件字符输入流 ---> 只能读取IDEA默认编码格式文件(即UTF-8) 构造方法: FileReader(String filename) FileReader(File file) Writer: 字符输出流 抽象 共有方法: write() 参数可以为单个字符，字符数组或字符串 close() FileWriter: 文件字符输出流 构造方法: FileWriter(String filename[, boolean append = false]) FileWriter(File file[, boolean append = false]) 注意: 这里的write方法是将数据写入内存缓冲区(字符转为字节)，flash方法或close方法会数据刷新到文件。因此必须调用close()方法。 Properties集合: 实现了Map&lt;K, V> 唯一和IO流结合的集合 该集合的默认键和值都是字符串类型。store方法能把集合中的数据存入硬盘，load方法会加载到该集合中。 缓冲流: 创建一个缓冲区，减少系统IO次数，提高读写效率。 BufferedInputStream: 字节缓冲输入流 extends InputStream 用read写入，close关闭。只需要关闭缓冲流，基本流会随之关闭。 构造方法: BufferedInputStream(InputStream in[, int size]) read和write方法与基本流完全相同。 BufferedOutputStream: 字节缓冲输出流 extends OutputStream 用write写入，close关闭 构造方法: BufferedOutputStream(OutputStream out[, int size]) 参数可以传递FileOutputStream对象，可选参数size用于指定缓冲区大小 BufferedWriter: 字符缓冲输出流 extends Writer 构造方法: BufferedWriter(Writer out[, int size]) 可传入FileWriter 特有方法: void newLine() 无视系统差异，换行 BufferedReader: 字符缓冲输入流 extends Reader 构造方法: BufferedReader(Reader in[, int size]) 可传入FileReader 特有方法: String readLine() 读取一行数据，但不读取行末换行符。读到文件末尾返回null 转换流: 可以指定编码/解码的码表 OutputStreamWriter extends Writer: 步骤: 1、new对象 2、write() 3、close() 构造方法: OutputStreamWriter(OutputStream out[, String charsetName]) 参数一般传递为FileOutputStream。可选字段为编码表名称，不区分大小写，默认为UTF-8 InputStreamReader extends Reader: 步骤: 1、new对象 2、read() 3、close() 构造方法: OutputStreamWriter(InputStream in[, String charsetName]) (反)序列化流: 把对象以流的方式写入/读出到文件中 使用字节流 ObjectOutputStream: extends OutputStream 对象的序列化流 把对象以流的方式写入到文件中保存，叫写对象，也叫对象的序列化。 构造方法: ObjectOutputStream(OutputStream out) 参数一般传递为FileOutputStream。 特有方法: void writeObject(Object obj) 此处参数也可以是由obj组成的集合，如ArrayList&lt;Person> list 被序列化的对象(即参数obj)必须实现Serializable接口，以激活(反)序列化功能。其为标记型接口，内部没有任何抽象方法。 ObjectInputStream: extends InputStream 对象的反序列化流 把文件中保存的对象以流的方式读出来，叫读对象，也叫对象的反序列化。 构造方法: ObjectInputStream(InputStream in) 参数一般传递为FileInputStream。 特有方法: Object readObject() transient关键字: 瞬态关键字，被其修饰的成员变量不能被序列化，没有替他功能。static关键字也有这个功能。 注意：为了避免InvalidClassException,在每个被序列化的对象中都显示声明一个序列号-> private static final long serialVersionUID = 42L 打印流: PrintStream System.out.println(); enum : 枚举类 类的对象只有确定的有限个，我们称之为枚举类 当需要定义一组常量时，强烈建议使用枚举类 默认继承java.lang.Enum 定义： 类似于接口的定义，创建Class包时，选项中就有Enum的选项。 public enum Season { SPRING("春天", "warm"), 默认由public static final 修饰 SUMMER("夏天", "sun"), 实例写在类的最前面 AUTUMN("秋天", "cool"), 实例之间用逗号分隔，最后一个结尾为分号 WINTER("冬天", "cold"); 为什么不需要显示声明成员变量(由局部变量代替)，暂时不清楚 Season(String seasonName, String seasonDec){} } 构造函数默认由private修饰，可省略不写。 静态方法： values() 返回枚举类型的对象数组，方便用于遍历枚举值 valueOf(String objName) 返回枚举类中对象名为objName的对象 如: Season winter = Season.valueOf("WINTER"); toString() 返回当前枚举类对象常量的名字 反射: java.lang.Class 程序由javac.exe编译后，会生成一个或多个字节码文件(.class结尾)。 接着使用java.exe对某个字节码文件解释运行，就相当于将某个字节码文件加载到内存中，这个过程就叫类的加载， 加载到内存中的类就叫运行时类，这个运行时类就是Class的一个实例。 加载到内存中的运行时类会缓存一段时间，在此时间内以不同方式获取到的该运行时类的Class实例都是同一个。 获取Class实例的方法： 1、 Class clazz = Person.class; 2、 Person person = new Person(); Class clazz = person.getClass(); 3、 Class clazz = Class.forName(类相对于src的全路径); // 用的较多 ClassLoader：引导类加载器--》加载java核心类库 引导类加载器无法获取到 扩展类加载器--》加载jar包 通过Class实例.getClassLoader()即可获得类加载器，如 系统类加载器--》加载自定义类 Person.class.getClassLoader()获取的即为系统类加载器 无法创建实例的类型用 Class c = int.class; double.class; Math.class; 等 ArrayList&lt;Integer> list = new ArrayList&lt;>(); Class l1 = list.getClass(); 得到ArrayList&lt;Integer>类的Class实例 l1.getDeclaredConstructors(); 获取所有构造函数，去掉Declared为只获取public的构造函数 l1.getDeclaredMethods(); 获取所有函数，去掉Declared为只获取public的函数 l1.getDeclaredFields(); 获取所有属性，去掉Declared为只获取public的属性 l1.getSuperclass(); 获取父类 l1.getGenericSuperclass(); 获取带泛型的父类 li.getInterfaces(); 获取接口 li.getPackage(); 获取包 li.getAnnotations(); 获取注解 for (Method method: l1.getDeclaredMethods()) { System.out.println(Modifier.toString(method.getModifiers()) + " " + method.getReturnType() + " " + method.getName() + "(" + Arrays.toString(method.getParameterTypes()) + ");"); } Field f = l1.getDeclaredField("size"); 根据属性名称获取特定的Field对象。 f.setAccessible(true); 使其变为可访问的 Object v = f.get(list); Person person = new Person("alice", 21); 方法对象调用invoke方法来执行方法。 Class p = person.getClass(); public Object invoke(Object obj, Object... args) Method m = p.getMethod("getName"); 第一个参数为对象名，之后的参数为方法的参数。 String s = (String) m.invoke(person); 调用的是静态方法时，第一个参数为null。 代理的作用就是在不修改源码的情况下，对目标对象的方法增强。 静态代理：接口 + 代理类 + 被代理类 --》 一个代理类只能对应一个被代理类 代理类与被代理类实现同样的接口 动态代理：接口 + 代理类 + 多个被代理类 --》 一个代理类可以对应多个被代理类 代理类与被代理类实现同样的接口 结合src/proxy/annotationProxy包下的例子理解 1、根据自己需求创建一个被代理类对象（想象在项目中，要增强功能时，一定在之前已经使用过这个对象） 2、根据这个被代理类对象，动态获取一个代理类对象（因此，没有显示的代理类，是被动态获取到的） 3、使用代理类对象调用被代理类的方法。（具体原理看包中例子的注释）</p></div><footer class=entry-footer><span title='2021-05-20 17:39:41 +0000 UTC'>2021-05-20</span>&nbsp;·&nbsp;2258 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Java学习笔记" href=https://ethereal-lu.github.io/posts/java/java%E7%AC%94%E8%AE%B0/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Annotation学习笔记</h2></header><div class=entry-content><p>元注解 元注解用于修饰注解 元注解有6中，如下： @Target 规定所修饰的注解只能用于指定的区域 @Documented 将注解生成在javadoc中 @Inherited 所修饰的注解作用于某类后，该类的子类会默认继承父类的注解 @Retention 所修饰的注解的作用时间，RUNTIME>CLASS>SOURCE @Native 使用本地方法 @Repeatable 可重复 注解接口格式 注解接口必须为public @interface Target {....}，其中public可以不写，@interface表示默认继承了 java.lang.annotation.Annotation接口 属性格式：属性类型 + 属性名 + ()；还可以使用default给属性赋予默认值 当属性只有一个且属性名为value()时，在使用的时候可以不指定属性名直接赋值 一个自定义的注解接口如下： @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnnotation { String name() default "hello"; // 使用时可以不赋值 int age(); // 使用时必须赋值 } 通过反射解析注解 Class类中有getAnnotation​()等获取注解的相关方法，通过调用这些方法获取我们填入的参数，从而做出相应的操作</p></div><footer class=entry-footer><span title='2021-05-12 18:48:13 +0000 UTC'>2021-05-12</span>&nbsp;·&nbsp;47 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Annotation学习笔记" href=https://ethereal-lu.github.io/posts/java/annotation%E7%AC%94%E8%AE%B0/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>SpringBoot学习笔记</h2></header><div class=entry-content><p>Spring Boot 是 Spring 的子项目，正如其名字，提供 Spring 的引导( Boot )的功能。
通过 Spring Boot ，开发者可以快速配置 Spring 项目，引入各种 Spring MVC、Spring Transaction、Spring AOP、等等框架，而无需不断重复编写繁重的 Spring 配置，降低了 Spring 的使用成本。
项目创建 新建 spring initializr 项目，在新建过程中引入 spring web 依赖 将所有的controller、pojo、dao等包创建在Application类的同名目录下（约定大于配置），创建在其他目录下会报错 在resources目录下创建banner.txt文件，可以在里面粘贴一些图片用于启动时展示 自动装配原理 父工程 spring-boot-dependencies 对springboot的所有依赖进行管理，其中就有依赖的版本控制，因此我们在pom.xml中引入依赖时，不需要指定版本
启动器：启动器都以spring-boot-starter打头，就是springboot的启动场景，如spring-boot-starter-web，就会帮我们自动导入web环境所有的依赖。springboot会将所有的功能场景变为一个个的启动器。我们要使用什么功能，只需要找到相对应的启动器并导入即可
主程序：
// @SpringBootApplication ：标注这个类是springboot的应用 @SpringBootApplication public class Springboot01HelloworldApplication { public static void main(String[] args) { // 启动springboot SpringApplication.run(Springboot01HelloworldApplication.class, args); } } @SpringBootApplication 是复合注解，主要包括 **@ComponentScan, @EnableAutoConfiguration, @SpringBootConfiguration**三个注解。
@SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) public @interface SpringBootApplication @ComponentScan 注解：组件扫描。 spring里有四大注解：@Service,@Repository,@Component,@Controller用来定义一个bean.@ComponentScan注解就是用来自动扫描被这些注解标识的类，最终生成ioc容器里的bean． @SpringBootConfiguration 注解：@SpringBootConfiguration继承自@Configuration，二者功能也一致，标注当前类是配置类， 并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。 @EnableAutoConfiguration 注解：从 classpath 中搜索所有的 META-INF/spring.factories 配置文件，然后将其中key为org.springframework.boot.autoconfigure.EnableAutoConfiguration 的 value 加载到spring容器中。 注解：
...</p></div><footer class=entry-footer><span title='2021-05-10 17:39:41 +0000 UTC'>2021-05-10</span>&nbsp;·&nbsp;1219 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to SpringBoot学习笔记" href=https://ethereal-lu.github.io/posts/java/springboot%E7%AC%94%E8%AE%B0/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>mybatis学习笔记</h2></header><div class=entry-content><p>第一个MyBatis项目 先进入mysql创建mybatis数据库，并在其中创建user表，其中有字段值如实体类User中的属性 新建一个Maven项目，作为父项目，在其pom.xml配置文件中引入依赖（mysql驱动、junit、mybatis）。则其子模块中都继承了这些依赖。 在父项目下新建一个Maven子模块，在其main目录的resources下新建文件mybatis-config.xml作为配置文件，内容如下： &lt;?xml version="1.0" encoding="UTF-8" ?> &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"> &lt;!--核心配置文件--> &lt;configuration> &lt;!--下方这一句为引入外部属性文件，需在resources下创建jdbc.properties文件 也可以不引入外部属性文件而直接对4个value赋值--> &lt;properties resource="jdbc.properties"/> &lt;environments default="development"> &lt;environment id="development"> &lt;transactionManager type="JDBC"/> &lt;dataSource type="POOLED"> &lt;!--只需为下面四项赋值即可--> &lt;property name="driver" value="${jdbc.driveClass}"/> &lt;property name="url" value="${jdbc.url}"/> &lt;property name="username" value="${jdbc.username}"/> &lt;property name="password" value="${jdbc.password}"/> &lt;/dataSource> &lt;/environment> &lt;/environments> &lt;!--每一个sql映射文件Mapper.xml都需要在Mybatis的核心配置文件中的&lt;mappers>标签下注册， 否则就会报错Type interface com.lu.dao.UserDao is not known to the MapperRegistry.--> &lt;mappers> &lt;!--如果Mapper.xml在resources目录下，则直接写文件名即可，若在其他路径，则要写全路径，用/分割目录--> &lt;mapper resource="UserMapper.xml"/> &lt;/mappers> &lt;/configuration> jdbc.properties文件如下：其中jdbc.url字段特别容易引发错误
jdbc.driveClass=com.mysql.cj.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai jdbc.userName=root jdbc.password=gaolu666 创建获取sqlSession对象的工具类（类中代码如下）。 // sqlSessionFactory --> SqlSession public class MybatisUtils { private static final SqlSessionFactory sqlSessionFactory; // 用Mybatis的配置文件获取sqlSessionFactory对象 static { String resource = "mybatis-config.xml"; InputStream inputStream = null; try { inputStream = Resources.getResourceAsStream(resource); } catch (IOException e) { e.printStackTrace(); } sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } // 用sqlSessionFactory对象获取SqlSession对象 public static SqlSession getSqlSession() { return sqlSessionFactory.openSession(); } } 实现。创建实体类、UserDao接口以及Mapper配置文件UserMapper.xml（该文件代替JDBC中的UserDaoImpl实现类，但是仍然可以将该文件理解为UserDao的实现类），分别如下：【实体类要实现序列化接口】 // 实体类 public class User implements Serializable { private int id; private String name; private String passwd; ... // 省略部分为有参无参构造，getter、setter方法 } // UserDao接口 public interface UserDao { List&lt;User> getUserList(); // 根据ID查询用户 User getUserById(int id); // 添加用户 void addUser(User user); // 修改用户 void updateUser(User user); // 删除用户 void deleteUser(int id); } &lt;!--sql映射文件UserMapper.xml--> &lt;?xml version="1.0" encoding="UTF-8" ?> &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"> &lt;mapper namespace="com.lu.dao.UserDao"> &lt;!--namespace绑定一个Mapper（Dao）接口--> &lt;!--id对应绑定的接口中的一个方法名，resultType为返回值， 当该方法的返回值为集合时resultType对应集合泛型中的类的全路径--> &lt;select id="getUserList" resultType="com.lu.pojo.User"> select * from user &lt;/select> &lt;!--parameterType对应参数类型，当方法的参数只有一个，且参数类型为基本类型时，可以不写parameterType这一项， 方法参数有多个时，用map或注解--> &lt;select id="getUserById" parameterType="int" resultType="com.lu.pojo.User"> select * from user where id = #{id} /*此处#{id}接收getUserById方法的参数，因此名称与参数名一致*/ &lt;/select> &lt;insert id="addUser" parameterType="com.lu.pojo.User"> /*此处#{id}, #{name}, #{passwd}自动接收User类中的属性，因此名字与三个属性名一致*/ insert into user (id, name, passwd) values (#{id}, #{name}, #{passwd}) &lt;/insert> &lt;update id="updateUser" parameterType="com.lu.pojo.User"> update user set name = #{name}, passwd = #{passwd} where id = #{id} /*修改多个参数中间用逗号隔开不要忘*/ &lt;/update> &lt;delete id="deleteUser" parameterType="int"> delete from user where id = #{id} &lt;/delete> &lt;/mapper> 测试，代码如下： public class UserDaoTest { @Test public void getUserListTest() { // 第一步：获取sqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); // 第二部：getMapper UserDao mapper = sqlSession.getMapper(UserDao.class); // 第三步：执行sql for (User user: mapper.getUserList()) System.out.println(user); // 第四步：关闭连接 sqlSession.close(); // 注意事项：增删改操作必须要提交事务 --> sqlSession.commit(); } } map的使用（野路子，增加灵活性但不利于维护） 使用场景：当表中的字段过多，而只需要更新少量字段时，不需要像上方一样，传入一个带全部字段的新对象，而只需要利用map传递需要的字段即可。同样在添加操作时，也可以在map中只存放notnull的字段，对于允许null的字段，可以不添加。示例如下： &lt;update id="updateUser2" parameterType="map"> /*上方参数类型map即表示Map类型，下方的#{key_name}和#{key_id}接收map中的值，故名称与map中的键名一致*/ update user set name = #{key_name} where id = #{key_id} &lt;/update> 配置解析 核心配置文件mybatis-config.xml environments environments标签下可以有多套环境，但同时最多只能使用一套（即互斥使用），修改default的值即可切换环境 transactionManager标签即事务管理器，只需知道除了JDBC还有一个MANAGED即可 dataSource即数据源，type的值默认为POOLED即使用连接池，只需知道type不止这一个值即可 properties properties标签即引入外部属性文件 properties标签必须位于configuration标签下的第一行 properties标签下也可以添加propertie标签，并优先读取propertie标签内的值，然后读取外部文件，并覆盖同名键 typeAliases typeAliases即类型别名，为java类型设置一个短的名字，用于减少类完全限定名（类的全路径）的冗余 类型别名有两种实现方式，一种为typeAlias，即为每一个类自定义一个别名，另一种为package，它指定一个包，将包下所有类的别名设定为类名的首字母小写（其实大写也可以用，但建议小写），如下：（当实体类少时用第一种，实体类多时用第二种） &lt;typeAliases> &lt;typeAlias type="com.lu.pojo.User" alias="User"/> &lt;package name="com.lu.pojo"/> &lt;/typeAliases> settings logImpl：设置日志 cacheEnabled：缓存 lazyLoadingEnabled：懒加载 mappers 一般会将操作数据库的接口与其同名sql映射文件mapper.xml放在同一个包下，但这样还需另外设置过滤操作。也可以在resources目录下创建与接口所在目录的同名目录，然后将sql映射文件放入该目录中，这样在编译后接口与映射文件就在同一个包下了。 生命周期与作用域 错误的使用可能会导致严重的并发问题
...</p></div><footer class=entry-footer><span title='2021-04-26 19:42:15 +0000 UTC'>2021-04-26</span>&nbsp;·&nbsp;976 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to mybatis学习笔记" href=https://ethereal-lu.github.io/posts/java/mybatis%E7%AC%94%E8%AE%B0/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://ethereal-lu.github.io/categories/java/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>