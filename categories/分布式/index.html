<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>分布式 | lu</title>
<meta name=keywords content><meta name=description content><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://ethereal-lu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/index.xml><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"><meta property="og:site_name" content="lu"><meta property="og:title" content="分布式"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="分布式"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="lu (Alt + H)">lu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://ethereal-lu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ethereal-lu.github.io/categories/>Categories</a></div><h1>分布式
<a href=/categories/%E5%88%86%E5%B8%83%E5%BC%8F/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Dubbo</h2></header><div class=entry-content><p>1 RPC RPC 即进程A中的方法A通过网络调用进程B中的方法B，是一种进程间通信方式。
为了实现RPC远程调用，请求时在网络中传输的数据应该包括类名、方法名、参数类型列表、参数值列表，前三项可以唯一确定一个方法。除了上述4项，企业内部使用时还可以自定义需要传输的数据以便于业务开发。确定好要传什么数据后还需要确定怎么传数据，如 Tomcat + HttpClient 、 Netty 、Socket等都可以选择。
2 Dubbo 优势 分布式系统中，Dubbo 相较于 HTTP 的优势：
负载均衡 服务调用链路生成：服务间依赖关系错踪复杂，Dubbo 可以解决服务之间互相是如何调用的。 资源调度：基于访问压力实时管理集群容量，提高集群利用率。 3 Dubbo 架构 Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。
Monitor： 统计服务的调用次数和调用时间的监控中心 Container： 运行服务的容器 调用关系说明：
服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 重要知识点总结：
注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小 监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示 注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外 注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者 注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表 注册中心和监控中心都是可选的，服务消费者可以直连服务提供者 服务提供者无状态，任意一台宕掉后，不影响使用 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复 4 核心要点 Dubbo作为一个分布式服务框架，主要具有如下几个核心的要点：
服务定义：服务提供方实现服务，而服务消费方调用服务。 服务注册：随着系统扩展，提供者需要暴露的服务和消费者需要调用的服务都不断膨胀，而一个服务既可以是提供者又可以是调用者，会使服务任务繁重，且管理混乱。将服务管理抽离进行统一管理可以进行优化。Dubbo提供多种注册中心以选择，包括Redis和Zookeeper。 服务监控：无论是服务提供方，还是服务消费方，他们都需要对服务调用的实际状态进行有效的监控，从而改进服务质量。 远程通信与信息交换：支持Triple 协议和 Netty 框架 服务调用：下图展示 RPC 层的服务调用 详细调用流程如下图
服务提供者启动，开启Netty服务，创建Zookeeper客户端，向注册中心注册服务。 服务消费者启动，从Zookeeper注册中心获取服务提供者列表，与服务提供者通过Netty建立长连接。 服务消费者通过接口开始远程调用服务，ProxyFactory初始化Proxy对象，Proxy创建动态代理对象。 动态代理对象调用invoke方法，层层包装生成一个Invoker对象，该对象包含了代理对象。 Invoker通过负载均衡选择一个合适的服务提供者，再加入各种过滤器，协议层包装成一个新的DubboInvoker对象。 交换层将DubboInvoker对象包装成一个Reuqest对象，该对象序列化后通过NettyClient传输到服务提供者的NettyServer端。 到了服务提供者这边，再通过反序列化、协议解密等操作生成一个DubboExporter对象,再层层传递处理,会生成一个服务提供端的Invoker对象. 这个Invoker对象会调用本地服务，获得结果再通过层层回调返回到服务消费者，服务消费者拿到结果后，再解析获得最终结果。 5 负载均衡 Dubbo 提供了多种均衡策略，默认为 random 随机负载均衡。
...</p></div><footer class=entry-footer><span title='2022-08-17 23:42:15 +0000 UTC'>2022-08-17</span>&nbsp;·&nbsp;249 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Dubbo" href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/dubbo/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Raft算法</h2></header><div class=entry-content><p>一、 概述 分布式一致性算法Raft将一致性分解为多个子问题：Leader选举、日志同步、安全性、日志压缩、成员变更等。
Raft将系统中的角色分为领导者（Leader）、跟从者（Follower）和候选人（Candidate）：
Leader：接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志。 Follower：接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。 Candidate：Leader选举过程中的临时角色。 Raft要求系统在任意时刻最多只有一个Leader，正常工作期间只有Leader和Followers。
只有 Leader 节点能够处理客户端的一切请求（如果客户端的请求发到了 Follower，Follower 将会把请求重定向到 Leader）。Raft算法将时间分为一个个的任期（term），每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束。
二、Leader选举 Raft 使用心跳（heartbeat）触发Leader选举。Leader向所有Followers周期性发送heartbeat。如果Follower在超时时间内没有收到Leader的heartbeat（也许此时还没有选出Leader，大家都在等；也许Leader挂了；也许只是Leader与该Follower之间网络故障），就会随机睡眠一段时间后发起Leader选举。
当服务器启动时，初始化为Follower，此时可能是集群刚启动，那么所有节点全部等待leader的心跳，当某个或某些节点超时后变为Candidate发起选举；也可能是新节点加入集群，那它会直接收到leader的心跳。
不论外部环境如何，只要一个节点在超时时间内没有收到Leader的心跳，那它就会发起选举。也即选举时只有一个或几个节点会成为Candidate，并不是所有节点都成为Candidate。
Follower按如下规则投票：
每个 term 只能投一票 只能给 term 和 logindex 不低于自己的 Candidate 投票 注意：只有Candidate会给自己投票，Follower不能给自己投票，Follower按上方规则给自己收到的第一个投票请求投票。醒的最早的Candidate最有可能成为Leader。
Follower将其当前term加一然后转换为Candidate。它首先给自己投票并且给集群中的其他服务器发送 RequestVote RPC。结果有以下三种情况：
赢得了多数的选票，成功选举为Leader； 收到了Leader的消息，表示有其它服务器已经抢先当选了Leader； 没有服务器赢得多数的选票，Leader选举失败，等待选举时间超时后发起下一次选举。 选举出Leader后，Leader通过定期向所有Followers发送心跳信息维持其统治。若Follower一段时间未收到Leader的心跳则认为Leader可能已经挂了，再次发起Leader选举过程。
Raft保证选举出的Leader上一定具有最新的已提交的日志，这一点将在四、安全性中说明。
三、日志同步 Leader选出后，就开始接收客户端的请求。Leader把请求作为日志条目（Log entries）加入到它的日志中，然后并行的向其他服务器发起 AppendEntries RPC 复制日志条目。当这条日志被复制到大多数服务器上，Leader将这条日志应用到它的状态机并向客户端返回执行结果。
某些Followers可能没有成功的复制日志，Leader会无限的重试 AppendEntries RPC直到所有的Followers最终存储了所有的日志条目。
日志由有序编号（log index，索引）的日志条目组成。每个日志条目包含它被创建时的任期号（term），和用于状态机执行的命令。如果一个日志条目被复制到大多数服务器上，就被认为可以提交（commit）了。log index 与 term 无关，Leader 每生成一条日志条目都会消耗一个 log index ，log index 只会一直递增。
Raft日志同步保证如下两点：
如果不同日志中的两个条目有着相同的索引和任期号，则它们所存储的命令是相同的。 如果不同日志中的两个条目有着相同的索引和任期号，则它们之前的所有条目都是完全一样的。 第一条特性源于Leader在一个term内在给定的一个log index最多创建一条日志条目，同时该条目在日志中的位置也从来不会改变。
第二条特性源于 AppendEntries 的一个简单的一致性检查。当发送一个 AppendEntries RPC 时，Leader会把新日志条目紧接着之前的条目的log index和term都包含在里面。如果Follower没有在它的日志中找到log index和term都相同的日志，它就会拒绝新的日志条目。
...</p></div><footer class=entry-footer><span title='2022-08-11 13:42:15 +0000 UTC'>2022-08-11</span>&nbsp;·&nbsp;190 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Raft算法" href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/raft%E7%AE%97%E6%B3%95/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>分布式基础</h2></header><div class=entry-content><p>1、分布式Session 解决分布式Session有两种方案：
将所有Session存放在Redis服务器中，所有请求过来后先到Redis服务器中获取Session token：用户首次登录后，将用户信息加密为token下发给客户端，之后每次请求都携带该token，token验证通过即承认其合法身份。多个服务器都使用相同的密钥和算法对 token 进行验证。</p></div><footer class=entry-footer><span title='2022-06-02 19:42:15 +0000 UTC'>2022-06-02</span>&nbsp;·&nbsp;6 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 分布式基础" href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>分布式锁</h2></header><div class=entry-content><p>1、前言 单纯的Java Api并不能提供分布式锁的能力。目前比较常用的分布式锁的实现方案有如下三种：
基于数据库实现分布式锁 基于缓存实现分布式锁 基于Zookeeper实现分布式锁 分布式锁应该实现如下功能：
互斥性：在任何时刻，对于同一条数据，只有一台应用可以获取到分布式锁； 高可用性：在分布式场景下，一小部分服务器宕机不影响正常使用，这种情况就需要将提供分布式锁的服务以集群的方式部署； 防止锁超时：如果客户端没有主动释放锁，服务器会在一段时间之后自动释放锁，防止客户端宕机或者网络不可达时产生死锁； 独占性：加锁解锁必须由同一台服务器进行，也就是锁的持有者才可以释放锁，不能出现你加的锁，别人给你解锁了； 2、基于数据库实现分布式锁 2.1、实现方式 在数据库中存储方法名，将数据库的自动提交关闭，然后在查询语句后面增加for update来查询需要上锁的方法名，数据库会在查询过程中给数据库表增加排他锁。值得注意的是：只有通过索引进行检索的时候才会使用行级锁，所以应该给方法名加上唯一锁，同时为了避免重载方法也被锁住，应该在方法名上将参数类型也加上。等临界资源使用完毕后再手动提交事务。
2.2、缺点 数据在磁盘中，查询开销很大 事务提交之前客户端失联，会导致死锁 如果表中数据量不大，查询优化器可能会通过全表扫描执行，此时会使用表锁，而非行锁。 3、基于缓存实现分布式锁 3.1、实现方式 以 redis 为例来说明基于缓存实现分布式锁。
Redis分布式锁主要是通过在 set 命令中添加 nx 和 ex 这两个参数实现的。
核心思想就是每次想要获取锁的时候，就对一个固定的 key 值以 SET NX EX的方式存放，如果成功，就说明获取锁成功，否则以自旋的方式持续获取锁，直到超时获取失败。解锁通过 LUA 代码实现，LUA是原子性的。
3.2、优缺点 优点：性能好，redis 是 NoSQL，数据在内存中，支持高性能，高并发。
缺点：过期时间需要手动提前设置，若设置太长当线程阻塞后需要较长时间才锁过期，会影响性能，若设置太短会导致提前释放产生并发问题。所以可靠性稍低。
关于 redis 实现分布式锁更多内容查看 redis 目录中的分布式锁篇章
4、基于Zookeeper实现分布式锁 4.1、实现方式 在与方法对应的永久节点下创建一个临时序号节点 获取当前永久节点下的所有子节点 判断自己是否是最小节点 如果是，上锁成功 如果不是，说明前面还有锁，上锁失败，监听比自己小的节点，形成链式监听，当触发监听时，再次执行步骤 2 惊群效应（羊群效应）：如果在上锁时，每个节点监听的是最小的节点，那么每次最小节点发生改变都会触发大量的监听事件，对于 zk 压力非常大，这就是惊群效应。故应该使用上述的链式监听，因为如果前一个结点没有获取到锁，自然也轮不到自己获取。这样只能实现公平锁。
客户端突然失联，会自动释放锁 可以在临时序号节点的值中保存当前主机和线程的信息，实现可重入锁 4.2、优缺点 优点：可靠性高；断开连接自动释放锁，无需手动设置过期时间
缺点：
性能没有 reids 高。因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同不到所有的Follower机器上。 可能产生并发问题：如果由于网络抖动，服务端没有收到客户端的心跳包，服务端就会删除临时节点让其他节点获取锁，从而使多个客户端获取到锁。但是 zk 有重试机制，如果检测不到客户端的心跳，就会重试连接，所以这种情况并不常见。</p></div><footer class=entry-footer><span title='2022-05-30 10:42:15 +0000 UTC'>2022-05-30</span>&nbsp;·&nbsp;71 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 分布式锁" href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>分布式事务</h2></header><div class=entry-content><p>1 事务 事务可以看做是一次大的活动，它由不同的小活动组成，这些活动要么全部成功，要么全部失败。
1.1 本地事务 在计算机系统中，更多的是通过关系型数据库来控制事务，这是利用数据库本身的事务特性来实现的，因此叫数据库事务，由于应用主要靠关系数据库来控制事务，而数据库通常和应用在同一个服务器，所以基于关系型数据库的事务又被称为本地事务。
1.2 分布式事务 随着互联网的快速发展，软件系统由原来的单体应用转变为分布式应用。分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操作，这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务，例如用户注册送积分事务、创建订单减库存事务，银行转账事务等都是分布式事务。
1.3 BASE 理论 由于 CAP 理论，大型互联网应用为达到良好的响应性能来提高用户体验，一般会保证 P 和 A ，舍弃 C 强一致，保证最终一致性。
BASE 是 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent （最终一致性）三个短语的缩写。BASE 理论通过牺牲强一致性来获得可用性，当出现故障允许部分不可用但要保证核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。满足BASE理论的事务，我们称之为“柔性事务”。
基本可用：分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。如电商网站交易付款出现问题了，商品依然可以正常浏览。
软状态：由于不要求强一致性，所以BASE允许系统中存在中间状态（也叫软状态），这个状态不影响系统可用性，如订单的"支付中"、“数据同步中”等状态，待数据最终一致后状态改为“成功”状态。
最终一致：最终一致是指经过一段时间后，所有节点数据都将会达到一致。如订单的"支付中"状态，最终会变 为“支付成功”或者"支付失败"，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待。
2 分布式事务解决方案 2.1 2PC 2PC 即两阶段提交协议，是将整个事务流程分为两个阶段，准备阶段（Prepare phase）、提交阶段（commit phase），2 是指两个阶段，P 是指准备阶段，C 是指提交阶段。
整个事务过程由事务管理器和参与者组成，事务管理器负责决策整个分布式事务的提交和回滚，事务参与者负责自己本地事务的提交和回滚。
在准备阶段 事务管理器给每个参与者发送 Prepare 消息，每个数据库参与者在本地执行事务（此时本地事务不提交），并将自己的执行结果发送给事务管理器。 在提交阶段 事务管理器只要发现有任意一个数据库参与者执行失败，就会直接给每个参与者发送回滚（Rollback）消息；否则，发送提交（Commit）消息；参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的锁资源。注意：必须在最后阶段释放锁资源。 tips：Mysql 中，事务执行是指在内存中修改值；事务提交是指将 undolog 和 redolog 存储在磁盘中。事务已经提交，仍然可以回滚。
2.2 TCC TCC 是 Try、Conﬁrm、Cancel 三个词语的缩写，TCC 要求每个分支事务实现三个操作：预处理、确认 、撤销 。
Try 阶段是做完业务检查（一致性）及资源预留（隔离），此阶段仅是一个初步操作，它和后续的 Conﬁrm 一起才能真正构成一个完整的业务逻辑。 Confirm 阶段是做确认提交，Try 阶段所有分支事务执行成功后开始执行 Conﬁrm。通常情况下，采用 TCC 则认为 Conﬁrm 阶段是不会出错的。即：只要 Try 成功，Conﬁrm 一定成功。若 Conﬁrm 阶段真的出错了，需引入重试机制或人工处理。 Cancel 阶段是在业务执行错误需要回滚的状态下执行分支事务的业务取消，预留资源释放。通常情况下，采用 TCC 则认为 Cancel 阶段也是一定成功的。若 Cancel 阶段真的出错了，需引入重试机制或人工处理。 事务管理器首先发起所有的分支事务的 Try 操作，任何一个分支事务的Try操作执行失败，事务管理器将会发起所有分支事务的 Cancel 操作，若 Try 操作全部成功，事务管理器将会发起所有分支事务的 Conﬁrm 操作，其中 Conﬁrm/Cancel 操作若执行失败，事务管理器会进行重试。
...</p></div><footer class=entry-footer><span title='2022-05-19 17:42:15 +0000 UTC'>2022-05-19</span>&nbsp;·&nbsp;130 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 分布式事务" href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>微服务学习笔记</h2></header><div class=entry-content><p>1、微服务架构介绍 1.1、微服务概念 微服务就是将一个单体架构的应用按业务划分为一个个独立运行的程序即服务，他们之间通过 HTTP 协议进行通信（也可以采用消息队列来通信，如 RabbotMQ、Kafaka 等），可以采用不同的编程语言，使用不同的存储技术，自动化部署（如Jenkins）减少人为控制，降低出错概率。服务数量越多，管理起来越复杂，因此采用集中化管理。例如 Eureka，Zookeeper 等都是比较常见的服务集中化管理框架。
微服务是一种架构风格。有两个特点：
职责单一：一个微服务解决一个业务问题（注意是一个业务问题而不是一个接口）。 面向服务：将自己的业务能力封装并对外提供服务，这是继承SOA的核心思想，一个微服务本身也可能调用其它的微服务。 1.2、微服务设计原则 AKF 拆分原则
前后端分离原则
无状态服务
状态：如果一个数据需要被多个服务共享，才能完成一笔交易，那么这个数据被称为状态。进而依赖这个状态数据的服务被称为有状态服务，反之称为无状态服务。
例如对空调的设置：1、若空调遥控器发送加一或减一的指令，空调根据现在的温度计算并调整温度，则空调提供的是有状态服务，状态是空调当前温度。2、若空调遥控器发送的是加一或减一之后的温度数值，空调根据接收到的温度数值设置温度，则空调提供的是无状态服务。
Restful 通信风格
2、Eureka 注册中心 应用微服务化之后，首先遇到的第一个问题就是服务发现问题，一个微服务如何发现其他微服务呢？最简单的方式就是每个微服务里面配置其他微服务的地址，但是当微服务数量众多的时候，这样做明显不现实。所以需要使用到微服务架构中的一个最重要的组件：服务注册中心，所有服务都注册到服务注册中心，同时也可以从服务注册中心获取当前可用的服务清单。
2.1、注册中心概念 注册中心可以理解为微服务架构中的“通讯录”。它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其他服务时，就到这里找到服务的地址，进行调用。
张三办了张新的电话卡并将号码告诉我，我将其名字和号码的映射保存进通讯录。 -- 服务注册 我想给张三打电话，于是在通讯录中根据其名字找到张三，然后根据映射到的电话号码拨打 -- 服务发现 --------------------------------------------------------- 上例中我和张三分别代表一个微服务，通讯录是独立于我和张三的服务注册中心 总结：服务注册中心的作用就是服务的注册和服务的发现。
2.2、Eureka 入门案例 1、创建一个 SpringBoot 项目并引入web、test和下方两个依赖 。
&lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-dependencies&lt;/artifactId> &lt;version>2020.0.4&lt;/version> &lt;type>pom&lt;/type> &lt;scope>runtime&lt;/scope> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-eureka-server&lt;/artifactId> &lt;version>3.0.4&lt;/version> &lt;/dependency> 2、application.yaml 如下
server: port: 8761 # 官方文档使用的端口 spring: application: name: eureka-server # 应用名称 # 配置 eureka-server 注册中心 eureka: instance: hostname: localhost # 主机名，默认根据操作系统的主机名获取 client: # 下方值为 false 的两项，只有当自身为单节点的注册中心时才需要设置为 false 。 # 单节点指的是只有一个注册中心，不是只有一个微服务。 # 当自身是微服务或者是集群中的注册中心之一时无需设置，使用默认 true。 register-with-eureka: false # 是否将自己注册到注册中心，默认为 true fetch-registry: false # 是否从注册中心获取服务注册信息，默认 true service-url: # 注册中心对外暴露的注册地址 defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ 3、启动类前添加 @EnableEurekaServer 注解
...</p></div><footer class=entry-footer><span title='2021-10-25 17:42:15 +0000 UTC'>2021-10-25</span>&nbsp;·&nbsp;2164 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 微服务学习笔记" href=https://ethereal-lu.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AC%94%E8%AE%B0/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>