<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MySQL | lu</title>
<meta name=keywords content><meta name=description content><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/categories/mysql/><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://ethereal-lu.github.io/categories/mysql/index.xml><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/categories/mysql/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/categories/mysql/"><meta property="og:site_name" content="lu"><meta property="og:title" content="MySQL"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="MySQL"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="lu (Alt + H)">lu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://ethereal-lu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ethereal-lu.github.io/categories/>Categories</a></div><h1>MySQL
<a href=/categories/mysql/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>慢查询优化</h2></header><div class=entry-content><p>1、开启慢查询 慢查询的时间定义：可设置为超过 1 秒就是慢查询（MySql 默认是 10 秒）
mysql> show variables like 'long_query_time'; 设置方法一：全局变量设置
mysql> set global slow_query_log='ON'; mysql> set global slow_query_log_file='/usr/local/mysql/data/slow.log'; mysql> set global long_query_time=1; 设置方法二：配置文件设置
slow_query_log = ON slow_query_log_file = /usr/local/mysql/data/slow.log long_query_time = 1 2、分析慢查询日志 explain 关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句
EXPLAIN SELECT * FROM `user`; table type possible_keys key key_len ref rows Extra 表名 const、eq_reg、ref、range、index、all 可选择的索引 实际使用的索引 需要扫描的行数 3、常见的慢查询优化 没建索引或索引没起作用 模糊查询以 % 开头 未遵守最左匹配 索引列进行计算 … 优化数据库结构 分库分表：字段很多时垂直分表；数据很多时水平分表 增加中间表： 对于需要经常联合查询的表，可将需要联合的字段合成一张中间表，这样每次只需要查询中间表一张表即可 分解复杂查询： 将一个大的查询分解为多个小查询，在应用层进行逻辑处理 优化LIMIT分页：select id,title from collect limit 10000,20;这样的查询，需要查询10020条然后只返回最后20条。 为 id,title建立组合索引，用于覆盖索引查询 用主键索引过滤掉前 10000 行无效的查询 子查询select id,title from collect where id>=(select id from collect limit 10000,1) limit 10; 关联查询select id,title from collect inner join (select id from collect limit 10000,20) as midTable using(id);</p></div><footer class=entry-footer><span title='2022-09-24 23:39:41 +0000 UTC'>2022-09-24</span>&nbsp;·&nbsp;109 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 慢查询优化" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MySQL默认数据库</h2></header><div class=entry-content><p>Mysql系统默认数据库 information_schema performance_schema mysql sys 一、information_schema（信息概要） 保存了MySQl服务所有数据库的信息。 具体MySQL服务有多少个数据库，各个数据库有哪些表，各个表中的字段是什么数据类型，各个表中有哪些索引，各个数据库要什么权限才能访问。 二、performance_schema（性能概要） 主要用于收集数据库服务器性能参数。5.7后默认开启。 提供进程等待的详细信息，包括锁、互斥变量、文件信息； 保存历史的事件汇总信息，为提供MySQL服务器性能做出详细的判断； 三、mysql（核心数据库） 保存MySQL的用户、权限设置、关键字等 如哪些user可以访问这个数据、DB参数、插件、主从 四、Sys（系统表） Sys库所有的数据源来自：performance_schema。目标是把performance_schema的把复杂度降低，让DBA能更好的阅读这个库里的内容。让DBA更快的了解DB的运行情况。</p></div><footer class=entry-footer><span title='2022-05-17 17:39:41 +0000 UTC'>2022-05-17</span>&nbsp;·&nbsp;17 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to MySQL默认数据库" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E5%BA%93/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>分库分表</h2></header><div class=entry-content><p>当一张表的字段数过多或数据量过大时，即使添加从库、优化索引，做很多操作时性能仍下降严重。此时就要考虑对其进行切分了，切分的目的就在于减少数据库的负担，缩短查询时间。
数据库分布式核心内容就是数据切分（Sharding），以及切分后对数据的定位、整合。数据切分就是将数据分散存储到多个数据库中，使得单一数据库中的数据量变小，通过扩充主机的数量缓解单一数据库的性能问题，从而达到提升数据库操作性能的目的。
数据切分根据其切分类型，可以分为两种方式：垂直（纵向）切分和水平（横向）切分
1、垂直分库 垂直分库就是根据业务耦合性，将关联度低的不同表存储在不同的数据库。减轻数据库的压力。
2、垂直分表 垂直分表是基于数据库中的"列"进行，某个表字段较多，可以新建一张扩展表，将不经常用或字段长度较大的字段拆分出去到扩展表中。在字段很多的情况下（例如一个大表有100多个字段），通过"大表拆小表"，更便于开发与维护，也能避免跨页问题，MySQL底层是通过数据页存储的，一条记录占用空间过大会导致跨页，造成额外的性能开销。另外数据库以行为单位将数据加载到内存中，这样表中字段长度较短且访问频率较高，内存能加载更多的数据，命中率更高，减少了磁盘IO，从而提升了数据库性能。
垂直分表虽然使表的复杂度降低了，但是数据量大的问题依然存在；另外，只有部分字段的表无法 join ，只能通过接口聚合方式解决，提升了开发的复杂度
3、水平分表 将一个表中的数据按照一定的规则划分到同一个库中的不同表中，每张表存储一部分数据。库内分表只解决了单一表数据量过大的问题，但没有减轻MySQL数据库的压力，大家还是竞争同一个物理机的硬件资源。
4、分库分表 将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。
5、数据分片规则 数据分片规则指的是水平分表时的规则
1、根据数值范围
按照时间区间或ID区间来切分。例如：按日期将不同月甚至是日的数据分散到不同的库中；将userId为19999的记录分到第一个库，1000020000的分到第二个库，以此类推。某种意义上，某些系统中使用的"冷热数据分离"，将一些使用较少的历史数据迁移到其他库中，业务功能上只提供热点数据的查询，也是类似的实践。
优点：1、易于扩展；2、若查询条件是时间或id则可以很快地知道在哪个表
2、哈希
将 id 或某个字段根据哈希函数划分数据
3、使用单独的一个数据库来存储映射关系</p></div><footer class=entry-footer><span title='2022-05-06 17:39:41 +0000 UTC'>2022-05-06</span>&nbsp;·&nbsp;25 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 分库分表" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MySQL数据类型</h2></header><div class=entry-content><p>1、整型 int(11)：括号中的 11 表示字符的显示宽度，它不影响存储，即它所能存储的数据还是在上图 int 的范围内。
那它什么时候起作用：
只有 int 字段类型设置为无符号且填充零（UNSIGNED ZEROFILL）时，当数值位数未达到设置的显示宽度时，会在数值前面补充零直到满足设定的显示宽度，为什么会有无符号的限制呢，是因为 ZEROFILL 属性会隐式地将数值转为无符号型，因此不能存储负的数值。
详见https://www.cnblogs.com/chenmingjun/p/10556206.html
2、浮点类型 MySQL中使用浮点数和定点数来表示小数。
浮点类型有两种，分别是单精度浮点数（FLOAT）和双精度浮点数（DOUBLE）；定点类型只有一种，就是 DECIMAL。
浮点类型和定点类型都可以用(M, D)来表示，其中M称为精度，表示总共的位数；D称为标度，表示小数的位数。
CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。
3、字符串 主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。因此，当char类型的长度不够时，会以空格填充。当插入的字符串长度超过括号中设置的长度时报错。
3.1、varchar(n) varchar是动态字符串（跟上面的int不一样）长度是在括号里面指定的，即只能存储小于等于指定长度的字符串，以 varchar(255)举例，该字段最多只能存储255个字符。
3.2、varchar(255) 那为什么会经常性设置成varchar(255)呢？
首先我们要知道一个概念：InnoDB存储引擎的表索引的前缀长度最长是767字节(bytes)，前缀长度意思就是索引中数据的长度，即若给一个varchar类型的字段建索引，则该varchar中最长的字符长度不能超过767字节。
utf8编码时 255*3=765bytes ,恰恰是能建索引情况下的最大值。（255是字符的长度，3是utf8一个字符占用3个字节）
如果使用的是utf8mb4编码，默认字符长度则应该是 767除以4向下取整，也就是191。
3.3、字符集 varchar(n)占用几个字节跟字符集有关系：
字符类型若为gbk，每个字符占用2个字节， 字符类型若为utf8，每个字符最多占用3个字节 字符类型若为utf8mb4，每个字符最多占用4个字节 3.4、前缀索引 如果要为三个 varchar 字段建立联合索引，但是三个字段的长度之和加起来超过了767字节，该怎么办？
UNIQUE KEY `uniq_code` (`nick_name`(20),`account`(20),`city`(20)) 每个字段取前20字符建立索引，这样的话就是长度就不会超出，这个就是前缀索引
3.5、varchar（20） 和varchar（255）的开销 如果要存储'hello12345'这个字符串，使用varchar(10)和varchar(100)存储，占用的磁盘空间是一样的，但是内存消耗不一样。
MySQL建立索引时如果没有限制索引的大小，索引长度会默认采用的该字段的长度。因此，加载索引信息时用varchar(255)类型会占用更多的内存。 由于MySQL通常会分配固定大小的内存块来保存内部值，因此当使用临时表进行排序等操作时会消耗更多的内存。 3.6、varchar 与 char VARCHAR 会保留字符串末尾的空格，而 CHAR 会删除。即对于 “a ”，varchar 存储的是 “a ”，而char存储的是“a”
...</p></div><footer class=entry-footer><span title='2022-05-04 12:39:41 +0000 UTC'>2022-05-04</span>&nbsp;·&nbsp;117 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to MySQL数据类型" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MySQL主从复制</h2></header><div class=entry-content><p>复制原理 主从复制的原理其实就是把主服务器上的 binlog 日志复制到从服务器上执行一遍，这样从服务器上的数据就和主服务器上的数据相同了。
复制过程 主节点开启bin-log功能，记录任何修改了数据库数据的事件。 从节点每隔一定时间探测 master 的 binlog 是否发生改变，如果发生改变，则开启一个线程（I/O Thread)把自己扮演成 mysql 的客户端，请求主节点的binlog，请求时携带参数 position 表示请求该位置之后的内容；如果不携带表示从头开始复制（用于首次复制）。 主节点启动一个线程（dump Thread）与从节点的 I/O Thread建立连接，将 binlog 中 position 之后的内容返回给从节点 IO 线程。 从节点接收到主节点发送过来的数据把它放置到中继日志（Relay log）文件中。 从节点启动另外一个线程（sql Thread ），把 Relay log 中的事件读取出来，并在本地再执行一次。 复制策略 「同步策略」：Master会等待所有的Slave都回应后才会提交，用于强一致性场景但会严重影响性能 「半同步策略」：Master至少会等待一个Slave回应后提交。 「异步策略」：Master不用等待Slave回应就可以提交。 「延迟策略」：Slave要落后于Master指定的时间。 Binlog 格式 statement：记录的是修改SQL语句 row：记录的是每行实际数据的变更 mixed：statement和row模式的混合 面试题 主从复制功能
负载均衡、读写分离 备份容灾 高可用和故障切换 主从复制，达到了写性能的瓶颈如何解决
分库分表
主从复制的过程有数据延迟怎么办
数据延迟会导致Slave被读取到的数据并不是最新数据。
如果业务场景需要强一致性，使用复制策略中的同步策略。</p></div><footer class=entry-footer><span title='2022-03-27 21:39:41 +0000 UTC'>2022-03-27</span>&nbsp;·&nbsp;54 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to MySQL主从复制" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>InnoDB锁</h2></header><div class=entry-content><p>锁机制用于管理对共享资源的并发访问。
1、锁粒度 表锁是MySQL中最大粒度的锁定机制，会锁定整张表，可以很好的避免死锁，是 MySQL 中最大颗粒度的锁定机制。表锁由 MySQL Server 实现，一般在执行 DDL 语句时会对整个表进行加锁，比如说ALTER TABLE等操作。在执行 DML 语句时，也可以通过LOCK TABLES显式指定对某个表进行加锁。
页级锁锁定一页，主要应用于 BDB 存储引擎。
行级锁的锁定颗粒度在 MySQL 中是最小的，只针对操作的当前行进行加锁，所以行级锁发生锁定资源争用的概率也最小。只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。InnoDB 默认使用行级锁。
2、行锁详解 InnoDB默认使用行锁，实现了两种标准的行锁——共享锁与排他锁；
1、除了显式加锁的情况，其他情况下的加锁与解锁都无需人工干预。 2、InnoDB所有的行锁算法都是基于索引实现的，锁定的也都是索引或索引区间
lock in share mode与for update的区别：
lock in share mode 是共享锁；for update 是排他锁 没有覆盖索引时，两种锁都需要即锁辅助索引又锁主键索引；当有覆盖索引时，lock in share mode 只锁辅助索引，而 for update 即锁辅助索引又锁主键索引。 3、当前读与快照读 **1、当前读：**即加锁读，读取记录的最新版本，会加锁保证其他并发事务不能修改当前记录，直至获取锁的事务释放锁；使用当前读的操作主要包括：显式加锁的读操作与插入/更新/删除等写操作。
2、快照读：即不加锁读，读取记录的快照版本而非最新版本，通过MVCC实现；
InnoDB默认的RR事务隔离级别下，不显式加『lock in share mode』与『for update』的『select』操作都属于快照读，保证事务执行过程中只有第一次读之前提交的修改和自己的修改可见，其他的均不可见；
4、MVCC MVCC『多版本并发控制』，与之对应的是『基于锁的并发控制』；
MVCC的最大好处：读不加任何锁，读写不冲突，对于读操作多于写操作的应用，极大的增加了系统的并发性能；
5、锁算法 InnoDB主要实现了三种行锁算法：
5.1、记录锁 记录锁(Record Locks)也称为行锁，顾名思义，表示对某一行记录加锁。
5.2、间隙锁 Gap锁，锁定的是索引记录之间的间隙，是防止幻读的关键；并发事务插入新数据前会先检测间隙中是否已被加锁，防止幻读的出现；间隙锁与间隙锁不互斥。
注意！间隙锁锁住的是一个区间，而不仅仅是这个区间中目前仅存在的数据行。
插入意向锁名字里虽然有意向锁这三个字，但是它并不是意向锁，它属于行级锁，是一种特殊的间隙锁，该锁只用于并发插入操作。是在插入一条记录行前，由 INSERT 操作产生的一种间隙锁。该锁用以表示插入意向，由于插入意向锁只是锁住一个点，当多个事务在同一区间插入位置不同的多条数据时，事务之间不需要互相等待。 间隙锁的意义只在于阻止区间被插入，因此是可以共存的。一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁，共享和排他的间隙锁是没有区别的，他们相互不冲突，且功能相同。
...</p></div><footer class=entry-footer><span title='2022-03-27 17:39:41 +0000 UTC'>2022-03-27</span>&nbsp;·&nbsp;100 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to InnoDB锁" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/innodb%E9%94%81/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MySQL小知识</h2></header><div class=entry-content><p>1、or和union的区别 对于单列来说，用or是没有任何问题的，但是or涉及到多个列的时候，每次select只能选取一个index，另一列需要进行table-scan，即全部扫描一遍，但是使用union就可以解决这个问题，分别使用各自列的index进行查询。 但是这里还会有一个问题就是，UNION会对结果进行排序去重，可能会降低一些performance。
2、having和where的区别 where是在分组前对数据进行过滤；where后面不可以使用聚合函数 having是在分组后对数据进行过滤；having后面可以使用聚合函数 having 的作用就是弥补 where 的粗粒度，实现在组内更细粒度的筛选。
在查询过程中执行顺序：from>where>group（含聚合）>having>order>select。</p></div><footer class=entry-footer><span title='2022-03-27 17:39:41 +0000 UTC'>2022-03-27</span>&nbsp;·&nbsp;11 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to MySQL小知识" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E5%B0%8F%E7%9F%A5%E8%AF%86/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MySQL索引</h2></header><div class=entry-content><p>索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组。
1、索引类型 普通索引：最基本的索引，可以在任意一列或多列的组合上加普通索引。允许存在重复值以及空值。 唯一索引：与普通索引不同的是，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。 主键索引：与唯一索引不同的是，不允许有空值。 组合索引：组合索引与单列索引相对应，只包含一个字段的索引叫做单列索引，包含两个或以上字段的索引叫做复合索引（或组合索引）。上述三种索引既可以是单列索引也可以是组合索引。 2、聚集索引 聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。
怎么理解呢？
聚簇索引的顺序，就是数据在硬盘上的物理顺序。一般情况下主键就是默认的聚簇索引。
一张表只允许存在一个聚簇索引，因为真实数据的物理顺序只能有一种。如果一张表上还没有聚簇索引，为它新创建聚簇索引时，就需要对已有数据重新进行排序，所以对表进行修改速度较慢是聚簇索引的缺点，对于经常更新的列不宜建立聚簇索引。
聚簇索引性能最好，因为一旦具有第一个索引值的记录被找到，具有连续索引值的记录也一定物理地紧跟其后。一张表只能有一个聚簇索引，所以非常珍贵，必须慎重设置，一般要根据这个表最常用的SQL查询方式选择某个（或多个）字段作为聚簇索引（或复合聚簇索引）。
InnoDB对主键建立聚簇索引。 如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。 如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引。 3、索引的最左匹配 最左前缀匹配原则，非常重要的原则，建立一个索引，对于索引中的字段，mysql会一直向右匹配直到遇到范围查询(>、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。
mysql创建复合索引的规则是首先会对复合索引的最左边的，也就是第一个name字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的cid字段进行排序。其实就相当于实现了类似 order by name cid这样一种排序规则。 所以：第一个name字段是绝对有序的，而第二字段就是无序的了。所以通常情况下，直接使用第二个cid字段进行条件判断是用不到索引的。
在第一个值等值匹配的前提下，第二个值是有序的，因此mysql索引规则中要求复合索引要想使用第二个索引，必须先使用第一个索引的原因。（而且第一个索引必须是等值匹配）。
order by也会用到索引，但前提是 where子句必须用到索引；如果 where子句的字段没有索引，即使order by的字段有索引也不会用到。where和order by使用的索引可以是同一个组合索引，同样符合最左匹配原则，比如 select * from tb_user where name = "lu" and age &lt; 21 order by score，如果有 (name, age, score) 的组合索引，由于 age 使用了范围搜索，score 索引就会失效。
...</p></div><footer class=entry-footer><span title='2022-03-27 17:39:41 +0000 UTC'>2022-03-27</span>&nbsp;·&nbsp;371 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to MySQL索引" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E7%B4%A2%E5%BC%95/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>事务实现原理</h2></header><div class=entry-content><p>MySQL 默认开启事务自动提交模式，即除非显式的开启事务（BEGIN 或 START TRANSACTION），否则每条 SOL 语句都会被当做一个单独的事务自动执行。
在 MySQL 中，可以使用 SET autocommit 语句设置事务的自动提交模式，语法格式如下：
SET autocommit = 0|1|ON|OFF; 对取值的说明：
值为 0 和值为 OFF：关闭事务自动提交。如果关闭自动提交，用户将会一直处于某个事务中，只有提交或回滚后才会结束当前事务，重新开始一个新事务。 值为 1 和值为 ON：开启事务自动提交。如果开启自动提交，则每执行一条 SQL 语句，事务都会提交一次。 事务想要做到可靠性以及并发处理。
1、redo log 与 undo log 1.1、redo log mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Boffer Pool(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做缓冲池和磁盘之间的同步。
那么问题来了，如果还没来的同步的时候宕机或断电了怎么办？还没来得及执行上面图中红色的操作。这样会导致丢部分已提交事务的修改信息！
所以引入了redo log来记录已成功提交事务的修改信息，并且会把redo log持久化到磁盘，系统重启之后在读取redo log恢复最新数据。
redo log在事务提交时就写入磁盘，不会等待后台程序执行。
总结： redo log是用来恢复数据的 用于保障，已提交事务的持久化特性。
既然redo log也需要存储，也涉及磁盘IO为啥还用它？
（1）redo log 的存储是顺序存储，而缓存同步是随机操作。
（2）缓存同步是以数据页为单位的，每次传输的数据大小大于redo log。
1.2、undo log undo log 叫做回滚日志，用于记录数据被修改前的信息。会记录执行的操作以及修改前的信息，这样根据操作记录做相反的操作即可恢复到事务执行前的状态。
undo log 记录事务修改之前版本的数据信息，因此假如由于系统错误或者rollback操作而回滚的话可以根据undo log的信息来进行回滚到没被修改前的状态。
总结： undo log是用来回滚数据的用于保障 未提交事务的原子性
2、事务的实现 事务的原子性是通过 undo log 来实现的 事务的持久性性是通过 redo log 来实现的 事务的隔离性是通过 (读写锁+MVCC)来实现的 一致性是通过原子性，持久性，隔离性来实现的！！ 2.1、原子性的实现 一个事务必须被视为不可分割的最小工作单位，一个事务中的所有操作要么全部成功提交，要么全部失败回滚，对于一个事务来说不可能只执行其中的部分操作，这就是事务的原子性。
...</p></div><footer class=entry-footer><span title='2022-03-27 17:39:41 +0000 UTC'>2022-03-27</span>&nbsp;·&nbsp;188 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 事务实现原理" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>MyISAM与InnoDB 的区别</h2></header><div class=entry-content><p>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务
InnoDB支持外键，而MyISAM不支持。
InnoDB是聚集索引，InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。
InnoDB不保存表的具体行数，而MyISAM用一个变量保存了整个表的行数。（因为事务）
InnoDB支持行级锁，MyISAM不支持。
InnoDB表必须有主键索引（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有。</p></div><footer class=entry-footer><span title='2021-05-22 17:39:41 +0000 UTC'>2021-05-22</span>&nbsp;·&nbsp;6 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to MyISAM与InnoDB 的区别" href=https://ethereal-lu.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/myisam%E4%B8%8Einnodb%E7%9A%84%E5%8C%BA%E5%88%AB/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://ethereal-lu.github.io/categories/mysql/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>