<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>小碎片知识 | lu</title>
<meta name=keywords content><meta name=description content><meta name=author content="lu"><link rel=canonical href=https://ethereal-lu.github.io/categories/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://ethereal-lu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethereal-lu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethereal-lu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ethereal-lu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ethereal-lu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://ethereal-lu.github.io/categories/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/index.xml><link rel=alternate hreflang=en href=https://ethereal-lu.github.io/categories/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethereal-lu.github.io/categories/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/"><meta property="og:site_name" content="lu"><meta property="og:title" content="小碎片知识"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="小碎片知识"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethereal-lu.github.io/ accesskey=h title="lu (Alt + H)">lu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethereal-lu.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://ethereal-lu.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://ethereal-lu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ethereal-lu.github.io/categories/>Categories</a></div><h1>小碎片知识
<a href=/categories/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Hugo + GithubPages 实现博客自动部署</h2></header><div class=entry-content><p>1 安装Hugo 下载 Hugo 最新版本并安装 将 Hugo 安装目录添加到环境变量 hugo version查看安装情况 2 安装Git 在安装过程中选择下方图片红框中的选项。在 windows 上安装 git 都推荐选择该选项。 如果已经安装完成，执行git config --global core.autocrlf false 因为Windows和Linux的回车符不一样，在git add时，回车符会进行转换，导致网站发布后文件的一致性检查不通过，进而致使网站的 css 文件无法加载，显示为网站无样式。
3 创建网站 在任意位置通过hugo new site my-site创建名称为my-site的博客根目录 my-site/
├── archetypes/ &lt;-- 模板
│ └── default.md
├── assets/
├── content/ &lt;-- 存放 笔记.md
├── data/
├── i18n/
├── layouts/
├── static/
├── themes/ &lt;-- 主题
└── hugo.toml &lt;-- site configuration 进入 content 文件夹，创建 post 目录，并把所有笔记拷贝到该目录下。
...</p></div><footer class=entry-footer><span title='2025-01-09 00:00:00 +0000 UTC'>2025-01-09</span>&nbsp;·&nbsp;425 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Hugo + GithubPages 实现博客自动部署" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/hugo-+-githubpages-%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>编码</h2></header><div class=entry-content><p>1、为什么使用编码 人类的语言并不适合计算机使用，所以就需要发明一种适合计算机的语言，这就是二进制。电脑读不懂人类语言，所以需要将人类语言转换为二进制语言，这就是编码；人类读不懂电脑的二进制语言，所以需要转换为人类语言，这就是解码。
2、为什么会乱码 编码与解码使用的规则不一样，就会乱码。即解码的时候，解码器不知道如何将当前的二进制转换为人类语言，就会乱码。
3、字符集的历史 3.1、百花齐放 ASCII 码占用了 0~127，即一个字节中的后 7 位。
IOS-8859-n 编码家族占用了 128~255，即利用了 ASCII 码未使用的第 1 位，因此IOS-8859-n 编码家族兼容ASCII 码。
至此一个字节的 8 位已全部占用，后来的编码必须使用多个字节。
GB2312：GB2312 并不兼容 ISO-8859-n 编码集，但是兼容 ASCII 编码。因为 ASCII 编码中的单字节字符一定是小于 128 的，所以最后我们就决定，中文的双字节字符都从 128 之后开始，也就是当发现字符连续两位都大于 128 时，就说明这是一个中文，指定了之后我们就把这种编码方式称之为 GB2312 编码。
GB2312 中收录的中文汉字都是简体字和常用字，对于一些生僻字以及繁体字没有收录，于是乎 GBK 出现了。
GBK： GBK 只要求第一位是大于 128，第二位可以小于 128，只要发现一个字节大于 128，那么紧随其后的一个字节就是和其作为一个整体作为中文字符。GBK兼容GB2312、ASCII，不兼容IOS-8859-n 。
3.2、Unicode Unicode 不兼容以上任何编码。Unicode 字符最开始采用的是 UCS-2 标准，UCS-2 标准规定一个字符至少使用 2 个字节来表示。由于无法攘括全世界所有字符，后来又有了 UCS-4 标准，可以用 4 个字节来存储一个字符。
Unicode 编码只是定义了字符集，对于字符集具体应该如何存储并没有做要求。
UTF 系列编码就是对 Unicode 字符集的实现，只不过实现的方式有所区别，其中主要有：UTF-8，UTF-16，UTF-32 等类型。
3.2.1、UTF-32 编码 UTF-32 编码基本按照 Unicode字符集标准来实现，任何一个符号都占用 4 个字节。浪费严重。
...</p></div><footer class=entry-footer><span title='2022-04-08 23:08:18 +0000 UTC'>2022-04-08</span>&nbsp;·&nbsp;369 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 编码" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A0%81/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>C# 学习笔记</h2></header><div class=entry-content><p>1、基础概念 1.1、.Net 概念 通常所说的 .Net 包括 .Net 平台和 .Net FrameWork 框架。它们两者的关系即 jvm 和 jre 的关系。
.Net FrameWork 框架由两部分组成，分别是 .Net 类库和 CLR（公共语言运行时）。
1.2、C# 语言 C# 是一种编程语言，可以开发基于 .Net 平台 的应用。
1.3、.Net 作用 Winform 开发桌面应用程序 ASP.NET 开发 web 网站 Unity3D 开发游戏和虚拟现实 1.4、.Net 两种交互模式 C/S：客户机（Client）/服务器模式。客户端需要安装专用的客户端软件，如 微信。 B/S：浏览器（Browser）/服务器模式。客户端只需要安装浏览器即可。 2、语法规则 C# 的基础语法规则几乎与 java 一样。
2.1、基本类型 与 java 一样，包括 byte、short、int、long、float、double、bool等，u开头表示无符号。
如果一个小数是浮点类型，则其后需加个 f ，否则默认为 double 型。
2.2、字符串 类名为 string ，小写。它的使用和 java 几乎一样，注意方法名为大写开头。
字符串格式化：string str = $"{name}的年龄为{age}"，其中name和age为之前声明的变量。
2.3、函数 C# 的函数名要大写开头。
...</p></div><footer class=entry-footer><span title='2021-12-01 21:39:41 +0000 UTC'>2021-12-01</span>&nbsp;·&nbsp;349 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to C# 学习笔记" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/c%23-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>VMware + Ubuntu18.04设置静态 IP</h2></header><div class=entry-content><p>进入VMware 的虚拟网络编辑器；
选择 VMnet8，点击 DHCP 设置，记住子网 IP，子网掩码和起始终止 IP，关闭。
点击右下方的更改设置，取消勾选 DHCP 分配 IP。再输入刚才记住的子网 IP 和子网掩码。
点击 NET 设置，记住网关并点击左下方的 DNS 设置，取消勾选自动检测并设置首选DNS为 8.8.8.8，备用为 114.114.114.114。确定、确定、应用。
打开主机的网络适配器中的 VMnet8 ，进入它的 IPV4 设置，将 IP 设置为之前记住的起始终止 IP 之间的任意一个，子网掩码和 DNS 都与之前设置的VMware一致。
一路确定并禁用再启用 VMnet8。
打开虚拟机，bash 输入 vim /etc/network/interfaces，内容如下：
source /etc/network/interfaces.d/* auto lo iface lo inet loopback auto ens32 iface ens32 inet static # 下方设置与之前步骤设置的一致 address 192.168.40.130 # 主机中设置的 IP，以后虚拟机 IP 固定为它 netmask 255.255.255.0 # 子网掩码 gateway 192.168.40.2 # 网关 dns-nameservers 8.8.8.8 # dns 输入vim /etc/systemd/resolved.conf，使其内容如下：
...</p></div><footer class=entry-footer><span title='2021-11-14 22:08:18 +0000 UTC'>2021-11-14</span>&nbsp;·&nbsp;122 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to VMware + Ubuntu18.04设置静态 IP" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81-ip/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>feign发起https请求</h2></header><div class=entry-content><p>1、安装 openssl 2、bash 进入任意目录执行以下命令
mkdir certs # 证书目录 mkdir private # 密钥目录 openssl rand -out private/.rand 1000 # 在构建根证书之前需要构建随机数文件(.rand) openssl genrsa -aes256 -out private/ca.key.pem 2048 # 构建根证书私钥 openssl req -new -key private/ca.key.pem -out private/ca.csr -subj "/C=CN/ST=BJ/L=BJ/O=FATE/OU=fate/CN=*.FATE.ORG" # 生成根证书签发申请 openssl x509 -req -days 10000 -sha1 -extensions v3_ca -signkey private/ca.key.pem -in private/ca.csr -out certs/ca.cer # 签发根证书 openssl pkcs12 -export -cacerts -inkey private/ca.key.pem -in certs/ca.cer -out certs/ca.p12 # 根证书转换为PKCS12格式密钥库 openssl genrsa -aes256 -out private/server.key.pem 2048 # 构建服务器证书私钥 openssl req -new -key private/server.key.pem -out private/server.csr -subj "/C=CN/ST=BJ/L=BJ/0=fate/OU=fate/CN=www.fate.org" # 生成服务器证书签发申请 openssl x509 -req -days 3650 -sha1 -extensions v3_req -CA certs/ca.cer -CAkey private/ca.key.pem -CAserial ca.srl -CAcreateserial -in private/server.csr -out certs/server.cer # 签发服务器证书 openssl pkcs12 -export -clcerts -inkey private/server.key.pem -in certs/server.cer -out certs/server.p12 # 服务器证书转换为PKCS12格式密钥库 3、将 server.p12 复制到微服务端的 resources 目录下
...</p></div><footer class=entry-footer><span title='2021-11-02 11:08:18 +0000 UTC'>2021-11-02</span>&nbsp;·&nbsp;187 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to feign发起https请求" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/feign%E5%8F%91%E8%B5%B7https%E8%AF%B7%E6%B1%82/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>指令重排与内存屏障</h2></header><div class=entry-content><p>指令重排 有两种发生指令重排的情况：一个是编译的时候，由编译原理的知识知道，编译器会对代码进行优化，这一步就涉及到指令重排，当然，编译完成之后的目标代码中指令的顺序就是确定的，不同线程执行该代码的顺序是一样的；另一个就是CPU在执行具体的指令的时候，也会因为计算机当前的状态（比如寄存器的占用情况、ALU的使用情况，cup缓存层的存在等原因）的不同导致指令最终的执行顺序发生变化(实际上，cpu本身并不会对指令进行重排，它本身是按照编译后的顺序来执行指令的，只是由于执行不同的指令需要的时间长短不同，以及缓存层的存在，再加上CPU执行指令的流水线并不是串行化等因素，那么就有可能出现排在靠前位置的指令还没执行完，而排在靠后的指令已经执行完了的情况，这一情况就是所谓的CPU执行指令的乱序）
编译器指令重排 如果两条有依赖关系 (像 a++; b=f(a); ) 的指令挨得很近，后一条指令必定会因为等待前一条执行的结果，而在流水线中阻塞很久(这个“很久”是对计算机而言哈)。而编译器的乱序，作为编译优化的一种手段，则试图通过指令重排，在这两条指令之间插入其他指令，将这两条指令拉开一定的距离，以保证后一条指令执行的时候前一条指令结果已经得到了，那么也就不需要阻塞等待了。所以相比于CPU的乱序，编译器的乱序才是真正对指令顺序做了调整，但是编译器所进行的调整也必须保证上下文的依赖逻辑，即存在依赖关系的指令顺序不能调整。
CPU 指令重排 现在的CPU一般采用流水线来执行指令。一个指令的执行被分成：取址，译码，访存，执行，写回等若干个阶段。流水线中的多个指令是可以同时处于同一个阶段的，只要CPU内部相应的处理部件未被占满。这样一来，乱序就可能产生了。比如一条加法指令出现在一条除法指令的后面，但由于除法的执行时间很长，在它执行完之前，加法可能就先执行完了。再比如两条访存指令，可能由于第二条指令中了cache(或其它原因)而导致它先于第一条指令完成。指令流水线除了在资源不足的情况下会卡住之外(如一个加法器应付两条加法指令)，指令之间存在的相互依赖才是导致流水线阻塞的主要原因。当然，CPU的乱序执行并不是任意地乱序，而必须保证上下文依赖逻辑的正确性。
内存屏障 不存在依赖关系的内存操作会被按随机顺序有效得到执行，但这在CPU与CPU(多核)交互时或CPU与IO设备交互(一般IO比较耗时)时，这可能成为问题。我们需要一些手段来干预编译器和CPU对指令顺序的影响，而内存屏障就是这样的干预手段。它们能保证处于屏障两边的内存操作满足部分有序(“部分有序”的意思是，内存屏障之前的操作必须都先于屏障之后的操作，但是如果几个操作出现在屏障的一边，则不保证它们有序)。这样的强制措施是非常重要的，因为系统中的CPU和其它设备可以使用各种各样的策略来提高性能，包括对内存操作的乱序、延迟和合并执行、预取、投机性的分支预测和各种缓存……内存屏障就是用于禁用或者抑制这些策略，使代码能够清楚地控制多个CPU和/或设备的交互。操心系统中存在各式各样的内存屏障，不同的内存屏障涉及到了各种复杂的实现，这里不过多地讲了，但关于内存屏障还要记住的一点就是：在内存屏障之前出现的内存访问不保证在内存屏障指令完成之前完成，内存屏障相当于在该CPU的访问队列中画了一条线，使得相关访存类型的请求不能相互跨越(用于实现内存屏障的指令，其本身并不作为参考对象，其两边的访存操作才被当作参考对象，所以屏障指令执行完成并不表示出现在屏障之前的所有访存操作都已经完成，但如果屏障之后的某一个访存操作已经完成，则屏障指令之前的所有访存操作必定都已经完成了)。
要想并发程序正确地执行，必须要保证程序的原子性、可见性以及有序性。只要有一个没有被保证，就可能会导致程序运行不正确。</p></div><footer class=entry-footer><span title='2021-08-26 23:08:18 +0000 UTC'>2021-08-26</span>&nbsp;·&nbsp;15 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 指令重排与内存屏障" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E4%B8%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>lambda 表达式中使用的变量为什么必须是 final</h2></header><div class=entry-content><p>Java 规范中规定：Lambda 表达式中要用到的，但又未在 Lambda 表达式中声明的变量，必须声明为 final 或者是 effectively final，否则就会出现编译错误。
有效 final 即不用显示声明为 final，由 JVM 添加 final。
个人理解 由于 lambda 表达式相当于生成一个对象，存储在堆中（生命周期长），而方法的局部变量存储在栈中（生命周期短）。如果 lambda 表达式在使用了外部方法中的局部变量后，该局部变量又发生变化，且方法执行完毕内存被释放，此 lambda 表达式生成的对象可能依然存活（未被GC回收），但是却无法得知局部变量改变后的值，造成数据一致性破坏。
// 报错 public class Test { public void func() { int a = 5; Runnable runnable = () -> { a++; }; } } 上方在方法中报错而下方在类中不报错，因此推断与栈和堆的生存周期有关系。
// 不报错 public class Test { private int a = 3; Runnable runnable = () -> { a++; }; } **存在问题：**作为方法中的内部类，既然方法被释放后，该类绝不可能再被使用，矛盾！
其他理解 lambda是对接口中的方法的一种简写方式，当方法想要使用外部的变量的时候，需要把值给传过去，但是方法中无论怎么改变量的值，都不会改变这个变量在外部的值（值传递和引用传递的区别），所以加上final就是为了方便开发者，以免误以为可以更改这个变量的值。final的目的就是告诉开发人员不能改变外面的变量值。
**存在问题：**外部变量什么时候传递给 lambda 的。难道隐式的传了？
悬而未决，先睡觉
...</p></div><footer class=entry-footer><span title='2021-08-18 23:08:18 +0000 UTC'>2021-08-18</span>&nbsp;·&nbsp;76 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to lambda 表达式中使用的变量为什么必须是 final" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/lambda/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>文件的 MD5 值</h2></header><div class=entry-content><p>是什么 文件的 MD5 值不是文件的属性也不是文件存储的内容，而是由分析程序根据文件的信息分析得到的一串独一无二的字符值。当两个文件的 MD5 值相同时说明这两个文件的内容完全一样。任何数据计算得到的 MD5 值长度都相等。
作用 由于同一个分析程序对于内容一样的文件分析得到的 MD5 值始终是一样的，因此可以通过对传输前后的文件进行 MD5 值的对比来检验传输途中文件是否被他人篡改。
MD5 值何时改变 1、不同的分析程序对同一份文件分析得到的 MD5 值可能不同。
2、对文件的内容进行增删改后，文件的 MD5 值会发生改变。
3、修改文件的名称和后缀都不会改变文件的 MD5 值。
查看文件 MD5 值的方法 1、Windows
certutil -hashfile 文件路径 md5 # 示例 certutil -hashfile E:\资料\作业资料\abc.py md5 2、Linux
md5sum 文件路径</p></div><footer class=entry-footer><span title='2021-08-18 23:08:18 +0000 UTC'>2021-08-18</span>&nbsp;·&nbsp;42 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to 文件的 MD5 值" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E6%96%87%E4%BB%B6md5/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Enum 向注解赋值问题</h2></header><div class=entry-content><p>问题 Enum 如下
@Getter @AllArgsConstructor(access = AccessLevel.PRIVATE) public enum RoleEnum { ADMIN (0, "admin"), ANALYST (1, "analyst"); private final Integer intValue; private final String strValue; } 将该 enum 对象的属性赋值给注解时报错：
@RequiresRoles(RoleEnum.ADMIN.getStrValue()) // error: "attribute value must be constant" 报错显示注解所需值必须是常量
这是因为 ADMIN 作为 RoleEnum 的对象，只有当 RoleEnum 被类加载器所加载之后才会生成，而在编译期 strValue 属性还是变量，所以会报错。
解决 在 enum 中添加内部类存储常量
@Getter @AllArgsConstructor(access = AccessLevel.PRIVATE) public enum RoleEnum { ADMIN (0, Names.ADMIN), ANALYST (1, Names.ANALYST); public static class Names { public static final String ADMIN = "admin"; public static final String ANALYST = "analyst"; } private final Integer intValue; private final String strValue; } 向注解中赋值时使用内部类的常量
...</p></div><footer class=entry-footer><span title='2021-08-11 16:39:41 +0000 UTC'>2021-08-11</span>&nbsp;·&nbsp;97 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to Enum 向注解赋值问题" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/enum%E8%B5%8B%E5%80%BC/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>c语言数组赋值问题</h2></header><div class=entry-content><p>数组正常初始化是没问题的
char ch[50] = "Reindeer"; 但是分步赋值，或重新赋值就会报错
// 分步赋值 char ch[50]; ch = "Reindeer"; // 重新赋值 char ch[50] = "Reindeer"; ch = "Ethereal"; // 报错 Array type 'char [50]' is not assignable 原因： ch 就是字符数组的首地址，是一个常量，不能作为左值。
解决：可以使用 strcpy 函数赋值
char ch[50]; strcpy(ch, "Ethereal");</p></div><footer class=entry-footer><span title='2021-06-06 20:57:45 +0000 UTC'>2021-06-06</span>&nbsp;·&nbsp;41 words&nbsp;·&nbsp;lu</footer><a class=entry-link aria-label="post link to c语言数组赋值问题" href=https://ethereal-lu.github.io/posts/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://ethereal-lu.github.io/categories/%E5%B0%8F%E7%A2%8E%E7%89%87%E7%9F%A5%E8%AF%86/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://ethereal-lu.github.io/>lu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>